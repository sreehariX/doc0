url,content,token_count,char_count,techStackName
https://docs.astro.build/en/getting-started/,"""""""Want to try Astro 5 beta? Read our v5 upgrade guide!
Astro Docs
Guides, resources, and API references to help you build with Astro.
Install Astro
Learn about Astro‚Äôs features
Powered by Astro and our open-source contributors. Join us!
What will you build with Astro?
Explore Astro starter themes for blogs, portfolios, docs, landing pages, SaaS, marketing, ecommerce sites, and more!
Take a guided tour
Complete our introductory Build a Blog Tutorial to learn the basics and create your first Astro site.
Start a new project
Terminal window
# create a new project with npm
npm create astro@latest
Our installation guide has step-by-step instructions for installing Astro using our CLI wizard, creating a new project from an existing Astro GitHub repository, and for installing Astro manually.
Learn
Astro‚Äôs main features
Island architecture
Astro components
The Astro template syntax
Extend
Add integrations like React, and Tailwind
Create type safe content collections
Enhance navigation with view transitions
Connect a headless CMS to your project
Have a question or want to get involved?
Join our Discord
Contribute
Give us feedback
Community""""""",241,1145,astro
https://docs.astro.build/en/install-and-setup/,"""""""On this page
Overview
Prerequisites
Browser compatibility
Start a new project
Install from the CLI wizard
Use a theme or starter template
Edit your project
Start the Astro dev server
Work in development mode
Configure your dev environment
TypeScript in Astro
Build and preview your site
Deploy your new site
Next Steps
Explore Astro‚Äôs Features
Take the introductory tutorial
Manual Setup
Want to build your own Docs?
Grab this template to get started.‚Üí
Install and set up Astro
The create astro CLI command is the fastest way to start a new Astro project from scratch. It will walk you through every step of setting up your new Astro project and allow you to choose from a few different official starter templates.
Or, you can begin your project using any existing theme or starter template.
To install Astro manually instead, see our step-by-step manual installation guide.
Online previews
Prefer to try Astro in your browser? Visit astro.new to browse our starter templates and spin up a new Astro project without ever leaving your browser.
Prerequisites
Node.js - v18.17.1 or v20.3.0 or higher. ( v19 is not supported.)
Text editor - We recommend VS Code with our Official Astro extension.
Terminal - Astro is accessed through its command-line interface (CLI).
Browser compatibility
Astro is built with Vite which targets browsers with modern JavaScript support by default. For a complete reference, you can see the list of currently supported browser versions in Vite.
Start a new project
Install from the CLI wizard
Run the following command in your terminal to start our handy install wizard:
npm
pnpm
Yarn
Terminal window
# create a new project with npm
npm create astro@latest
You can run create astro anywhere on your machine, so there‚Äôs no need to create a new empty directory for your project before you begin. If you don‚Äôt have an empty directory yet for your new project, the wizard will help create one for you automatically.
If all goes well, you will see a success message followed by some recommended next steps. Now that your project has been created, you can cd into your new project directory to begin using Astro.
If you skipped the ‚ÄúInstall dependencies?‚Äù step during the CLI wizard, then be sure to install your dependencies before continuing.
You can now start the Astro dev server and see a live preview of your project while you build!
Use a theme or starter template
You can also start a new astro project based on an official example or the main branch of any GitHub repository by passing a --template argument to the create astro command.
Explore our themes and starters showcase where you can browse themes for blogs, portfolios, documentation sites, landing pages, and more! Or, search on GitHub for even more starter projects.
Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use:
npm
pnpm
Yarn
Terminal window
# create a new project with an official example
npm create astro@latest -- --template <example-name>
# create a new project based on a GitHub repository‚Äôs main branch
npm create astro@latest -- --template <github-username>/<github-repo>
By default, this command will use the template repository‚Äôs main branch. To use a different branch name, pass it as part of the --template argument: <github-username>/<github-repo>#<branch>.
Answer the questions and follow the instructions of the CLI wizard.
You can now start the Astro dev server and see a live preview of your project while you make it your own!
Edit your project
To make changes to your project, open your project folder in your code editor. Working in development mode with the dev server running allows you to see updates to your site as you edit the code.
You can also customize aspects of your development environment such as configuring TypeScript or installing the official Astro editor extensions.
Start the Astro dev server
Astro comes with a built-in development server that has everything you need for project development. The astro dev CLI command will start the local development server so that you can see your new website in action for the very first time.
Every starter template comes with a pre-configured script that will run astro dev for you. After navigating into your project directory, use your favorite package manager to run this command and start the Astro development server.
npm
pnpm
Yarn
Terminal window
npm run dev
If all goes well, Astro will now be serving your project on http://localhost:4321/. Visit that link in your browser and see your new site!
Work in development mode
Astro will listen for live file changes in your src/ directory and update your site preview as you build, so you will not need to restart the server as you make changes during development. You will always be able to see an up-to-date version of your site in your browser when the dev server is running.
When viewing your site in the browser, you‚Äôll have access to the Astro dev toolbar. As you build, it will help you inspect your islands, spot accessibility issues, and more.
If you aren‚Äôt able to open your project in the browser after starting the dev server, go back to the terminal where you ran the dev command and check the message displayed. It should tell you if an error occurred, or if your project is being served at a different URL than http://localhost:4321/.
Configure your dev environment
Explore the guides below to customize your development experience.
Editor Setup
Customize your code editor to improve the Astro developer experience and unlock new features.
Dev Toolbar
Explore the helpful features of the dev toolbar.
TypeScript in Astro
Astro ships with built-in support for TypeScript, which can help prevent errors at runtime by defining the shapes of objects and components in your code.
You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the Astro VSCode Extension will infer as much as it can to provide autocompletion, hints, and errors in your editor.
Read more about using and configuring TypeScript in Astro
Build and preview your site
To check the version of your site that will be created at build time, quit the dev server (Ctrl + C) and run the appropriate build command for your package manager in your terminal:
npm
pnpm
Yarn
Terminal window
npm run build
Astro will build a deploy-ready version of your site in a separate folder (dist/ by default) and you can watch its progress in the terminal. This will alert you to any build errors in your project before you deploy to production. If TypeScript is configured to strict or strictest, the build script will also check your project for type errors.
When the build is finished, run the appropriate preview command (e.g. npm run preview) in your terminal and you can view the built version of your site locally in the same browser preview window.
Note that this previews your code as it existed when the build command was last run. This is meant to give you a preview of how your site will look when it is deployed to the web. Any later changes you make to your code after building will not be reflected while you preview your site until you run the build command again.
Use (Ctrl + C) to quit the preview and run another terminal command, such as restarting the dev server to go back to working in development mode which does update as you edit to show a live preview of your code changes.
Read more about the Astro CLI and the terminal commands you will use as you build with Astro.
Deploy your new site
You may wish to deploy your new site right away, before you begin to add or change too much code. This is helpful to get a minimal, working version of your site published and can save you extra time and effort troubleshooting your deployment later.
Next Steps
Success! You are now ready to start building with Astro! ü•≥
Here are a few things that we recommend exploring next. You can read them in any order. You can even leave our documentation for a bit and go play in your new Astro project codebase, coming back here whenever you run into trouble or have a question.
Explore Astro‚Äôs Features
Understand your codebase
Learn about Astro‚Äôs file structure in our Project Structure guide.
Create content collections
Add content to your new site with frontmatter validation and automatic type-safety.
Add view transitions
Create seamless page transitions and animations.
Learn about Islands
Read about Astro's island architecture.
Take the introductory tutorial
Build a fully functional Astro blog starting from a single blank page in our introductory tutorial.
This is a great way to see how Astro works and walks you through the basics of pages, layouts, components, routing, islands, and more. It also includes an optional, beginner-friendly unit for those newer to web development concepts in general, which will guide you through installing the necessary applications on your computer, creating a GitHub account, and deploying your site.
Manual Setup
This guide will walk you through the steps to manually install and configure a new Astro project.
If you prefer not to use our automatic create astro CLI tool, you can set up your project yourself by following the guide below.
Create your directory
Create an empty directory with the name of your project, and then navigate into it.
Terminal window
mkdir my-astro-project
cd my-astro-project
Once you are in your new directory, create your project package.json file. This is how you will manage your project dependencies, including Astro. If you aren‚Äôt familiar with this file format, run the following command to create one.
npm
pnpm
Yarn
Terminal window
npm init --yes
Install Astro
First, install the Astro project dependencies inside your project.
Important
Astro must be installed locally, not globally. Make sure you are not running npm install -g astro pnpm add -g astro or yarn add global astro.
npm
pnpm
Yarn
Terminal window
npm install astro
Then, replace any placeholder ‚Äúscripts‚Äù section of your package.json with the following:
package.json
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1"",
    ""dev"": ""astro dev"",
    ""start"": ""astro dev"",
    ""build"": ""astro build"",
    ""preview"": ""astro preview""
  },
You‚Äôll use these scripts later in the guide to start Astro and run its different commands.
Create your first page
In your text editor, create a new file in your directory at src/pages/index.astro. This will be your first Astro page in the project.
For this guide, copy and paste the following code snippet (including --- dashes) into your new file:
src/pages/index.astro
---
// Welcome to Astro! Everything between these triple-dash code fences
// is your ""component frontmatter"". It never runs in the browser.
console.log('This runs in your terminal, not the browser!');
---
<!-- Below is your ""component template."" It's just HTML, but with
    some magic sprinkled in to help you build great templates. -->
<html>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
<style>
  h1 {
    color: orange;
  }
</style>
Create your first static asset
You will also want to create a public/ directory to store your static assets. Astro will always include these assets in your final build, so you can safely reference them from inside your component templates.
In your text editor, create a new file in your directory at public/robots.txt. robots.txt is a simple file that most sites will include to tell search bots like Google how to treat your site.
For this guide, copy and paste the following code snippet into your new file:
public/robots.txt
# Example: Allow all bots to scan and index your site.
# Full syntax: https://developers.google.com/search/docs/advanced/robots/create-robots-txt
User-agent: *
Allow: /
Create astro.config.mjs
Astro is configured using astro.config.mjs. This file is optional if you do not need to configure Astro, but you may wish to create it now.
Create astro.config.mjs at the root of your project, and copy the code below into it:
astro.config.mjs
import { defineConfig } from 'astro/config';
// https://astro.build/config
export default defineConfig({});
If you want to include UI framework components such as React, Svelte, etc. or use other tools such as Tailwind or Partytown in your project, here is where you will manually import and configure integrations.
Read Astro‚Äôs API configuration reference for more information.
Add TypeScript support
TypeScript is configured using tsconfig.json. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file.
If you do intend to write TypeScript code, using Astro‚Äôs strict or strictest template is recommended. You can view and compare the three template configurations at astro/tsconfigs/.
Create tsconfig.json at the root of your project, and copy the code below into it. (You can use base, strict, or strictest for your TypeScript template):
tsconfig.json
{
  ""extends"": ""astro/tsconfigs/base""
}
Read Astro‚Äôs TypeScript setup guide for more information.
Next Steps
If you have followed the steps above, your project directory should now look like this:
Directory
node_modules/
Directory
public/
robots.txt
Directory
src/
Directory
pages/
index.astro
astro.config.mjs
package-lock.json
or yarn.lock, pnpm-lock.yaml, etc.
package.json
tsconfig.json
You can now start the Astro dev server and see a live preview of your project while you build!
Edit page
Translate this page
Previous
Getting Started
Next
Deploy Your Site
Contribute
Give us feedback
Community

On this page
Overview
Prerequisites
Browser compatibility
Start a new project
Install from the CLI wizard
Use a theme or starter template
Edit your project
Start the Astro dev server
Work in development mode
Configure your dev environment
TypeScript in Astro
Build and preview your site
Deploy your new site
Next Steps
Explore Astro‚Äôs Features
Take the introductory tutorial
Manual Setup
Want to build your own Docs?
Grab this template to get started.‚Üí
Install and set up Astro
The create astro CLI command is the fastest way to start a new Astro project from scratch. It will walk you through every step of setting up your new Astro project and allow you to choose from a few different official starter templates.
Or, you can begin your project using any existing theme or starter template.
To install Astro manually instead, see our step-by-step manual installation guide.
Online previews
Prefer to try Astro in your browser? Visit astro.new to browse our starter templates and spin up a new Astro project without ever leaving your browser.
Prerequisites
Node.js - v18.17.1 or v20.3.0 or higher. ( v19 is not supported.)
Text editor - We recommend VS Code with our Official Astro extension.
Terminal - Astro is accessed through its command-line interface (CLI).
Browser compatibility
Astro is built with Vite which targets browsers with modern JavaScript support by default. For a complete reference, you can see the list of currently supported browser versions in Vite.
Start a new project
Install from the CLI wizard
Run the following command in your terminal to start our handy install wizard:
npm
pnpm
Yarn
Terminal window
# create a new project with pnpm
pnpm create astro@latest
You can run create astro anywhere on your machine, so there‚Äôs no need to create a new empty directory for your project before you begin. If you don‚Äôt have an empty directory yet for your new project, the wizard will help create one for you automatically.
If all goes well, you will see a success message followed by some recommended next steps. Now that your project has been created, you can cd into your new project directory to begin using Astro.
If you skipped the ‚ÄúInstall dependencies?‚Äù step during the CLI wizard, then be sure to install your dependencies before continuing.
You can now start the Astro dev server and see a live preview of your project while you build!
Use a theme or starter template
You can also start a new astro project based on an official example or the main branch of any GitHub repository by passing a --template argument to the create astro command.
Explore our themes and starters showcase where you can browse themes for blogs, portfolios, documentation sites, landing pages, and more! Or, search on GitHub for even more starter projects.
Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use:
npm
pnpm
Yarn
Terminal window
# create a new project with an official example
pnpm create astro@latest --template <example-name>
# create a new project based on a GitHub repository‚Äôs main branch
pnpm create astro@latest --template <github-username>/<github-repo>
By default, this command will use the template repository‚Äôs main branch. To use a different branch name, pass it as part of the --template argument: <github-username>/<github-repo>#<branch>.
Answer the questions and follow the instructions of the CLI wizard.
You can now start the Astro dev server and see a live preview of your project while you make it your own!
Edit your project
To make changes to your project, open your project folder in your code editor. Working in development mode with the dev server running allows you to see updates to your site as you edit the code.
You can also customize aspects of your development environment such as configuring TypeScript or installing the official Astro editor extensions.
Start the Astro dev server
Astro comes with a built-in development server that has everything you need for project development. The astro dev CLI command will start the local development server so that you can see your new website in action for the very first time.
Every starter template comes with a pre-configured script that will run astro dev for you. After navigating into your project directory, use your favorite package manager to run this command and start the Astro development server.
npm
pnpm
Yarn
Terminal window
pnpm run dev
If all goes well, Astro will now be serving your project on http://localhost:4321/. Visit that link in your browser and see your new site!
Work in development mode
Astro will listen for live file changes in your src/ directory and update your site preview as you build, so you will not need to restart the server as you make changes during development. You will always be able to see an up-to-date version of your site in your browser when the dev server is running.
When viewing your site in the browser, you‚Äôll have access to the Astro dev toolbar. As you build, it will help you inspect your islands, spot accessibility issues, and more.
If you aren‚Äôt able to open your project in the browser after starting the dev server, go back to the terminal where you ran the dev command and check the message displayed. It should tell you if an error occurred, or if your project is being served at a different URL than http://localhost:4321/.
Configure your dev environment
Explore the guides below to customize your development experience.
Editor Setup
Customize your code editor to improve the Astro developer experience and unlock new features.
Dev Toolbar
Explore the helpful features of the dev toolbar.
TypeScript in Astro
Astro ships with built-in support for TypeScript, which can help prevent errors at runtime by defining the shapes of objects and components in your code.
You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the Astro VSCode Extension will infer as much as it can to provide autocompletion, hints, and errors in your editor.
Read more about using and configuring TypeScript in Astro
Build and preview your site
To check the version of your site that will be created at build time, quit the dev server (Ctrl + C) and run the appropriate build command for your package manager in your terminal:
npm
pnpm
Yarn
Terminal window
pnpm build
Astro will build a deploy-ready version of your site in a separate folder (dist/ by default) and you can watch its progress in the terminal. This will alert you to any build errors in your project before you deploy to production. If TypeScript is configured to strict or strictest, the build script will also check your project for type errors.
When the build is finished, run the appropriate preview command (e.g. npm run preview) in your terminal and you can view the built version of your site locally in the same browser preview window.
Note that this previews your code as it existed when the build command was last run. This is meant to give you a preview of how your site will look when it is deployed to the web. Any later changes you make to your code after building will not be reflected while you preview your site until you run the build command again.
Use (Ctrl + C) to quit the preview and run another terminal command, such as restarting the dev server to go back to working in development mode which does update as you edit to show a live preview of your code changes.
Read more about the Astro CLI and the terminal commands you will use as you build with Astro.
Deploy your new site
You may wish to deploy your new site right away, before you begin to add or change too much code. This is helpful to get a minimal, working version of your site published and can save you extra time and effort troubleshooting your deployment later.
Next Steps
Success! You are now ready to start building with Astro! ü•≥
Here are a few things that we recommend exploring next. You can read them in any order. You can even leave our documentation for a bit and go play in your new Astro project codebase, coming back here whenever you run into trouble or have a question.
Explore Astro‚Äôs Features
Understand your codebase
Learn about Astro‚Äôs file structure in our Project Structure guide.
Create content collections
Add content to your new site with frontmatter validation and automatic type-safety.
Add view transitions
Create seamless page transitions and animations.
Learn about Islands
Read about Astro's island architecture.
Take the introductory tutorial
Build a fully functional Astro blog starting from a single blank page in our introductory tutorial.
This is a great way to see how Astro works and walks you through the basics of pages, layouts, components, routing, islands, and more. It also includes an optional, beginner-friendly unit for those newer to web development concepts in general, which will guide you through installing the necessary applications on your computer, creating a GitHub account, and deploying your site.
Manual Setup
This guide will walk you through the steps to manually install and configure a new Astro project.
If you prefer not to use our automatic create astro CLI tool, you can set up your project yourself by following the guide below.
Create your directory
Create an empty directory with the name of your project, and then navigate into it.
Terminal window
mkdir my-astro-project
cd my-astro-project
Once you are in your new directory, create your project package.json file. This is how you will manage your project dependencies, including Astro. If you aren‚Äôt familiar with this file format, run the following command to create one.
npm
pnpm
Yarn
Terminal window
pnpm init
Install Astro
First, install the Astro project dependencies inside your project.
Important
Astro must be installed locally, not globally. Make sure you are not running npm install -g astro pnpm add -g astro or yarn add global astro.
npm
pnpm
Yarn
Terminal window
pnpm add astro
Then, replace any placeholder ‚Äúscripts‚Äù section of your package.json with the following:
package.json
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1"",
    ""dev"": ""astro dev"",
    ""start"": ""astro dev"",
    ""build"": ""astro build"",
    ""preview"": ""astro preview""
  },
You‚Äôll use these scripts later in the guide to start Astro and run its different commands.
Create your first page
In your text editor, create a new file in your directory at src/pages/index.astro. This will be your first Astro page in the project.
For this guide, copy and paste the following code snippet (including --- dashes) into your new file:
src/pages/index.astro
---
// Welcome to Astro! Everything between these triple-dash code fences
// is your ""component frontmatter"". It never runs in the browser.
console.log('This runs in your terminal, not the browser!');
---
<!-- Below is your ""component template."" It's just HTML, but with
    some magic sprinkled in to help you build great templates. -->
<html>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
<style>
  h1 {
    color: orange;
  }
</style>
Create your first static asset
You will also want to create a public/ directory to store your static assets. Astro will always include these assets in your final build, so you can safely reference them from inside your component templates.
In your text editor, create a new file in your directory at public/robots.txt. robots.txt is a simple file that most sites will include to tell search bots like Google how to treat your site.
For this guide, copy and paste the following code snippet into your new file:
public/robots.txt
# Example: Allow all bots to scan and index your site.
# Full syntax: https://developers.google.com/search/docs/advanced/robots/create-robots-txt
User-agent: *
Allow: /
Create astro.config.mjs
Astro is configured using astro.config.mjs. This file is optional if you do not need to configure Astro, but you may wish to create it now.
Create astro.config.mjs at the root of your project, and copy the code below into it:
astro.config.mjs
import { defineConfig } from 'astro/config';
// https://astro.build/config
export default defineConfig({});
If you want to include UI framework components such as React, Svelte, etc. or use other tools such as Tailwind or Partytown in your project, here is where you will manually import and configure integrations.
Read Astro‚Äôs API configuration reference for more information.
Add TypeScript support
TypeScript is configured using tsconfig.json. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file.
If you do intend to write TypeScript code, using Astro‚Äôs strict or strictest template is recommended. You can view and compare the three template configurations at astro/tsconfigs/.
Create tsconfig.json at the root of your project, and copy the code below into it. (You can use base, strict, or strictest for your TypeScript template):
tsconfig.json
{
  ""extends"": ""astro/tsconfigs/base""
}
Read Astro‚Äôs TypeScript setup guide for more information.
Next Steps
If you have followed the steps above, your project directory should now look like this:
Directory
node_modules/
Directory
public/
robots.txt
Directory
src/
Directory
pages/
index.astro
astro.config.mjs
package-lock.json
or yarn.lock, pnpm-lock.yaml, etc.
package.json
tsconfig.json
You can now start the Astro dev server and see a live preview of your project while you build!
Edit page
Translate this page
Previous
Getting Started
Next
Deploy Your Site
Contribute
Give us feedback
Community

On this page
Overview
Prerequisites
Browser compatibility
Start a new project
Install from the CLI wizard
Use a theme or starter template
Edit your project
Start the Astro dev server
Work in development mode
Configure your dev environment
TypeScript in Astro
Build and preview your site
Deploy your new site
Next Steps
Explore Astro‚Äôs Features
Take the introductory tutorial
Manual Setup
Want to build your own Docs?
Grab this template to get started.‚Üí
Install and set up Astro
The create astro CLI command is the fastest way to start a new Astro project from scratch. It will walk you through every step of setting up your new Astro project and allow you to choose from a few different official starter templates.
Or, you can begin your project using any existing theme or starter template.
To install Astro manually instead, see our step-by-step manual installation guide.
Online previews
Prefer to try Astro in your browser? Visit astro.new to browse our starter templates and spin up a new Astro project without ever leaving your browser.
Prerequisites
Node.js - v18.17.1 or v20.3.0 or higher. ( v19 is not supported.)
Text editor - We recommend VS Code with our Official Astro extension.
Terminal - Astro is accessed through its command-line interface (CLI).
Browser compatibility
Astro is built with Vite which targets browsers with modern JavaScript support by default. For a complete reference, you can see the list of currently supported browser versions in Vite.
Start a new project
Install from the CLI wizard
Run the following command in your terminal to start our handy install wizard:
npm
pnpm
Yarn
Terminal window
# create a new project with yarn
yarn create astro
You can run create astro anywhere on your machine, so there‚Äôs no need to create a new empty directory for your project before you begin. If you don‚Äôt have an empty directory yet for your new project, the wizard will help create one for you automatically.
If all goes well, you will see a success message followed by some recommended next steps. Now that your project has been created, you can cd into your new project directory to begin using Astro.
If you skipped the ‚ÄúInstall dependencies?‚Äù step during the CLI wizard, then be sure to install your dependencies before continuing.
You can now start the Astro dev server and see a live preview of your project while you build!
Use a theme or starter template
You can also start a new astro project based on an official example or the main branch of any GitHub repository by passing a --template argument to the create astro command.
Explore our themes and starters showcase where you can browse themes for blogs, portfolios, documentation sites, landing pages, and more! Or, search on GitHub for even more starter projects.
Run the following command in your terminal, substituting the official Astro starter template name, or the GitHub username and repository of the theme you want to use:
npm
pnpm
Yarn
Terminal window
# create a new project with an official example
yarn create astro --template <example-name>
# create a new project based on a GitHub repository‚Äôs main branch
yarn create astro --template <github-username>/<github-repo>
By default, this command will use the template repository‚Äôs main branch. To use a different branch name, pass it as part of the --template argument: <github-username>/<github-repo>#<branch>.
Answer the questions and follow the instructions of the CLI wizard.
You can now start the Astro dev server and see a live preview of your project while you make it your own!
Edit your project
To make changes to your project, open your project folder in your code editor. Working in development mode with the dev server running allows you to see updates to your site as you edit the code.
You can also customize aspects of your development environment such as configuring TypeScript or installing the official Astro editor extensions.
Start the Astro dev server
Astro comes with a built-in development server that has everything you need for project development. The astro dev CLI command will start the local development server so that you can see your new website in action for the very first time.
Every starter template comes with a pre-configured script that will run astro dev for you. After navigating into your project directory, use your favorite package manager to run this command and start the Astro development server.
npm
pnpm
Yarn
Terminal window
yarn run dev
If all goes well, Astro will now be serving your project on http://localhost:4321/. Visit that link in your browser and see your new site!
Work in development mode
Astro will listen for live file changes in your src/ directory and update your site preview as you build, so you will not need to restart the server as you make changes during development. You will always be able to see an up-to-date version of your site in your browser when the dev server is running.
When viewing your site in the browser, you‚Äôll have access to the Astro dev toolbar. As you build, it will help you inspect your islands, spot accessibility issues, and more.
If you aren‚Äôt able to open your project in the browser after starting the dev server, go back to the terminal where you ran the dev command and check the message displayed. It should tell you if an error occurred, or if your project is being served at a different URL than http://localhost:4321/.
Configure your dev environment
Explore the guides below to customize your development experience.
Editor Setup
Customize your code editor to improve the Astro developer experience and unlock new features.
Dev Toolbar
Explore the helpful features of the dev toolbar.
TypeScript in Astro
Astro ships with built-in support for TypeScript, which can help prevent errors at runtime by defining the shapes of objects and components in your code.
You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the Astro VSCode Extension will infer as much as it can to provide autocompletion, hints, and errors in your editor.
Read more about using and configuring TypeScript in Astro
Build and preview your site
To check the version of your site that will be created at build time, quit the dev server (Ctrl + C) and run the appropriate build command for your package manager in your terminal:
npm
pnpm
Yarn
Terminal window
yarn run build
Astro will build a deploy-ready version of your site in a separate folder (dist/ by default) and you can watch its progress in the terminal. This will alert you to any build errors in your project before you deploy to production. If TypeScript is configured to strict or strictest, the build script will also check your project for type errors.
When the build is finished, run the appropriate preview command (e.g. npm run preview) in your terminal and you can view the built version of your site locally in the same browser preview window.
Note that this previews your code as it existed when the build command was last run. This is meant to give you a preview of how your site will look when it is deployed to the web. Any later changes you make to your code after building will not be reflected while you preview your site until you run the build command again.
Use (Ctrl + C) to quit the preview and run another terminal command, such as restarting the dev server to go back to working in development mode which does update as you edit to show a live preview of your code changes.
Read more about the Astro CLI and the terminal commands you will use as you build with Astro.
Deploy your new site
You may wish to deploy your new site right away, before you begin to add or change too much code. This is helpful to get a minimal, working version of your site published and can save you extra time and effort troubleshooting your deployment later.
Next Steps
Success! You are now ready to start building with Astro! ü•≥
Here are a few things that we recommend exploring next. You can read them in any order. You can even leave our documentation for a bit and go play in your new Astro project codebase, coming back here whenever you run into trouble or have a question.
Explore Astro‚Äôs Features
Understand your codebase
Learn about Astro‚Äôs file structure in our Project Structure guide.
Create content collections
Add content to your new site with frontmatter validation and automatic type-safety.
Add view transitions
Create seamless page transitions and animations.
Learn about Islands
Read about Astro's island architecture.
Take the introductory tutorial
Build a fully functional Astro blog starting from a single blank page in our introductory tutorial.
This is a great way to see how Astro works and walks you through the basics of pages, layouts, components, routing, islands, and more. It also includes an optional, beginner-friendly unit for those newer to web development concepts in general, which will guide you through installing the necessary applications on your computer, creating a GitHub account, and deploying your site.
Manual Setup
This guide will walk you through the steps to manually install and configure a new Astro project.
If you prefer not to use our automatic create astro CLI tool, you can set up your project yourself by following the guide below.
Create your directory
Create an empty directory with the name of your project, and then navigate into it.
Terminal window
mkdir my-astro-project
cd my-astro-project
Once you are in your new directory, create your project package.json file. This is how you will manage your project dependencies, including Astro. If you aren‚Äôt familiar with this file format, run the following command to create one.
npm
pnpm
Yarn
Terminal window
yarn init --yes
Install Astro
First, install the Astro project dependencies inside your project.
Important
Astro must be installed locally, not globally. Make sure you are not running npm install -g astro pnpm add -g astro or yarn add global astro.
npm
pnpm
Yarn
Terminal window
yarn add astro
Then, replace any placeholder ‚Äúscripts‚Äù section of your package.json with the following:
package.json
  ""scripts"": {
    ""test"": ""echo \""Error: no test specified\"" && exit 1"",
    ""dev"": ""astro dev"",
    ""start"": ""astro dev"",
    ""build"": ""astro build"",
    ""preview"": ""astro preview""
  },
You‚Äôll use these scripts later in the guide to start Astro and run its different commands.
Create your first page
In your text editor, create a new file in your directory at src/pages/index.astro. This will be your first Astro page in the project.
For this guide, copy and paste the following code snippet (including --- dashes) into your new file:
src/pages/index.astro
---
// Welcome to Astro! Everything between these triple-dash code fences
// is your ""component frontmatter"". It never runs in the browser.
console.log('This runs in your terminal, not the browser!');
---
<!-- Below is your ""component template."" It's just HTML, but with
    some magic sprinkled in to help you build great templates. -->
<html>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
<style>
  h1 {
    color: orange;
  }
</style>
Create your first static asset
You will also want to create a public/ directory to store your static assets. Astro will always include these assets in your final build, so you can safely reference them from inside your component templates.
In your text editor, create a new file in your directory at public/robots.txt. robots.txt is a simple file that most sites will include to tell search bots like Google how to treat your site.
For this guide, copy and paste the following code snippet into your new file:
public/robots.txt
# Example: Allow all bots to scan and index your site.
# Full syntax: https://developers.google.com/search/docs/advanced/robots/create-robots-txt
User-agent: *
Allow: /
Create astro.config.mjs
Astro is configured using astro.config.mjs. This file is optional if you do not need to configure Astro, but you may wish to create it now.
Create astro.config.mjs at the root of your project, and copy the code below into it:
astro.config.mjs
import { defineConfig } from 'astro/config';
// https://astro.build/config
export default defineConfig({});
If you want to include UI framework components such as React, Svelte, etc. or use other tools such as Tailwind or Partytown in your project, here is where you will manually import and configure integrations.
Read Astro‚Äôs API configuration reference for more information.
Add TypeScript support
TypeScript is configured using tsconfig.json. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file.
If you do intend to write TypeScript code, using Astro‚Äôs strict or strictest template is recommended. You can view and compare the three template configurations at astro/tsconfigs/.
Create tsconfig.json at the root of your project, and copy the code below into it. (You can use base, strict, or strictest for your TypeScript template):
tsconfig.json
{
  ""extends"": ""astro/tsconfigs/base""
}
Read Astro‚Äôs TypeScript setup guide for more information.
Next Steps
If you have followed the steps above, your project directory should now look like this:
Directory
node_modules/
Directory
public/
robots.txt
Directory
src/
Directory
pages/
index.astro
astro.config.mjs
package-lock.json
or yarn.lock, pnpm-lock.yaml, etc.
package.json
tsconfig.json
You can now start the Astro dev server and see a live preview of your project while you build!
Edit page
Translate this page
Previous
Getting Started
Next
Deploy Your Site
Contribute
Give us feedback
Community""""""",8641,41144,astro
https://docs.astro.build/en/guides/deploy/,"""""""On this page
Overview
Deployment Guides
Quick Deploy Options
Website UI
CLI Deployment
Building Your Site Locally
Adding an Adapter for SSR
Want to build your own Docs?
Grab this template to get started.‚Üí
Deploy your Astro Site
Ready to build and deploy your Astro site? Follow one of our guides to different deployment services or scroll down for general guidance about deploying an Astro site.
Deployment Guides
Netlify
SSR
Static
Vercel
SSR
Static
Deno Deploy
SSR
Static
GitHub Pages
Static
GitLab Pages
Static
Cloudflare Pages
SSR
Static
AWS
Static
AWS via Flightcontrol
SSR
Static
AWS via SST
SSR
Static
Clever Cloud
SSR
Static
Azion
SSR
Static
Google Cloud
SSR
Static
Firebase Hosting
SSR
Static
Heroku
Static
Microsoft Azure
Static
Buddy
Static
Edgio
SSR
Static
Fleek
Static
Fly.io
SSR
Static
Render
Static
Stormkit
Static
Surge
Static
Cleavr
SSR
Static
Kinsta
SSR
Static
Zeabur
SSR
Static
Zerops
SSR
Static
Quick Deploy Options
You can build and deploy an Astro site to a number of hosts quickly using either their website‚Äôs dashboard UI or a CLI.
Website UI
A quick way to deploy your website is to connect your Astro project‚Äôs online Git repository (e.g. GitHub, GitLab, Bitbucket) to a host provider and take advantage of continuous deployment using Git.
These host platforms automatically detect pushes to your Astro project‚Äôs source repository, build your site and deploy it to the web at a custom URL or your personal domain. Often, setting up a deployment on these platforms will follow steps something like the following:
Add your repository to an online Git provider (e.g. in GitHub, GitLab, Bitbucket)
Choose a host that supports continuous deployment (e.g. Netlify or Vercel) and import your Git repository as a new site/project.
Many common hosts will recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy your site as shown below. (If not, these settings can be changed.)
Deploy settings
Build Command: astro build or npm run build
Publish directory: dist
Click ‚ÄúDeploy‚Äù and your new website will be created at a unique URL for that host (e.g. new-astro-site.netlify.app).
The host will be automatically configured to watch your Git provider‚Äôs main branch for changes, and to rebuild and republish your site at each new commit. These settings can typically be configured in your host provider‚Äôs dashboard UI.
CLI Deployment
Some hosts will have their own command line interface (CLI) you can install globally to your machine using npm. Often, using a CLI to deploy looks something like the following:
Install your host‚Äôs CLI globally, for example:
npm
pnpm
Yarn
Terminal window
yarn global add netlify-cli
Run the CLI and follow any instructions for authorization, setup etc.
Build your site and deploy to your host
Many common hosts will build and deploy your site for you. They will usually recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy as shown below. (If not, these settings can be changed.)
Deploy settings
Build Command: astro build or npm run build
Publish directory: dist
Other hosts will require you to build your site locally and deploy using the command line.
Building Your Site Locally
Many hosts like Netlify and Vercel will build your site for you and then publish that build output to the web. But, some sites will require you to build locally and then run a deploy command or upload your build output.
You may also wish to build locally to preview your site, or to catch any potential errors and warnings in your own environment.
Run the command npm run build to build your Astro site.
npm
pnpm
Yarn
Terminal window
yarn run build
By default, the build output will be placed at dist/. This location can be changed using the outDir configuration option.
Adding an Adapter for SSR
Note
Before deploying your Astro site with SSR (server-side rendering) enabled, make sure you have:
Installed the appropriate adapter to your project dependencies (either manually, or using the adapter‚Äôs astro add command, e.g. npx astro add netlify).
Added the adapter to your astro.config.mjs file‚Äôs import and default export when installing manually. (The astro add command will take care of this step for you!)
Edit page
Translate this page
Previous
Installation and Setup
Next
Migrate to Astro
Contribute
Give us feedback
Community

On this page
Overview
Deployment Guides
Quick Deploy Options
Website UI
CLI Deployment
Building Your Site Locally
Adding an Adapter for SSR
Want to build your own Docs?
Grab this template to get started.‚Üí
Deploy your Astro Site
Ready to build and deploy your Astro site? Follow one of our guides to different deployment services or scroll down for general guidance about deploying an Astro site.
Deployment Guides
Netlify
SSR
Static
Vercel
SSR
Static
Deno Deploy
SSR
Static
GitHub Pages
Static
GitLab Pages
Static
Cloudflare Pages
SSR
Static
AWS
Static
AWS via Flightcontrol
SSR
Static
AWS via SST
SSR
Static
Clever Cloud
SSR
Static
Azion
SSR
Static
Google Cloud
SSR
Static
Firebase Hosting
SSR
Static
Heroku
Static
Microsoft Azure
Static
Buddy
Static
Edgio
SSR
Static
Fleek
Static
Fly.io
SSR
Static
Render
Static
Stormkit
Static
Surge
Static
Cleavr
SSR
Static
Kinsta
SSR
Static
Zeabur
SSR
Static
Zerops
SSR
Static
Quick Deploy Options
You can build and deploy an Astro site to a number of hosts quickly using either their website‚Äôs dashboard UI or a CLI.
Website UI
A quick way to deploy your website is to connect your Astro project‚Äôs online Git repository (e.g. GitHub, GitLab, Bitbucket) to a host provider and take advantage of continuous deployment using Git.
These host platforms automatically detect pushes to your Astro project‚Äôs source repository, build your site and deploy it to the web at a custom URL or your personal domain. Often, setting up a deployment on these platforms will follow steps something like the following:
Add your repository to an online Git provider (e.g. in GitHub, GitLab, Bitbucket)
Choose a host that supports continuous deployment (e.g. Netlify or Vercel) and import your Git repository as a new site/project.
Many common hosts will recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy your site as shown below. (If not, these settings can be changed.)
Deploy settings
Build Command: astro build or npm run build
Publish directory: dist
Click ‚ÄúDeploy‚Äù and your new website will be created at a unique URL for that host (e.g. new-astro-site.netlify.app).
The host will be automatically configured to watch your Git provider‚Äôs main branch for changes, and to rebuild and republish your site at each new commit. These settings can typically be configured in your host provider‚Äôs dashboard UI.
CLI Deployment
Some hosts will have their own command line interface (CLI) you can install globally to your machine using npm. Often, using a CLI to deploy looks something like the following:
Install your host‚Äôs CLI globally, for example:
npm
pnpm
Yarn
Terminal window
npm install --global netlify-cli
Run the CLI and follow any instructions for authorization, setup etc.
Build your site and deploy to your host
Many common hosts will build and deploy your site for you. They will usually recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy as shown below. (If not, these settings can be changed.)
Deploy settings
Build Command: astro build or npm run build
Publish directory: dist
Other hosts will require you to build your site locally and deploy using the command line.
Building Your Site Locally
Many hosts like Netlify and Vercel will build your site for you and then publish that build output to the web. But, some sites will require you to build locally and then run a deploy command or upload your build output.
You may also wish to build locally to preview your site, or to catch any potential errors and warnings in your own environment.
Run the command npm run build to build your Astro site.
npm
pnpm
Yarn
Terminal window
npm run build
By default, the build output will be placed at dist/. This location can be changed using the outDir configuration option.
Adding an Adapter for SSR
Note
Before deploying your Astro site with SSR (server-side rendering) enabled, make sure you have:
Installed the appropriate adapter to your project dependencies (either manually, or using the adapter‚Äôs astro add command, e.g. npx astro add netlify).
Added the adapter to your astro.config.mjs file‚Äôs import and default export when installing manually. (The astro add command will take care of this step for you!)
Edit page
Translate this page
Previous
Installation and Setup
Next
Migrate to Astro
Contribute
Give us feedback
Community

On this page
Overview
Deployment Guides
Quick Deploy Options
Website UI
CLI Deployment
Building Your Site Locally
Adding an Adapter for SSR
Want to build your own Docs?
Grab this template to get started.‚Üí
Deploy your Astro Site
Ready to build and deploy your Astro site? Follow one of our guides to different deployment services or scroll down for general guidance about deploying an Astro site.
Deployment Guides
Netlify
SSR
Static
Vercel
SSR
Static
Deno Deploy
SSR
Static
GitHub Pages
Static
GitLab Pages
Static
Cloudflare Pages
SSR
Static
AWS
Static
AWS via Flightcontrol
SSR
Static
AWS via SST
SSR
Static
Clever Cloud
SSR
Static
Azion
SSR
Static
Google Cloud
SSR
Static
Firebase Hosting
SSR
Static
Heroku
Static
Microsoft Azure
Static
Buddy
Static
Edgio
SSR
Static
Fleek
Static
Fly.io
SSR
Static
Render
Static
Stormkit
Static
Surge
Static
Cleavr
SSR
Static
Kinsta
SSR
Static
Zeabur
SSR
Static
Zerops
SSR
Static
Quick Deploy Options
You can build and deploy an Astro site to a number of hosts quickly using either their website‚Äôs dashboard UI or a CLI.
Website UI
A quick way to deploy your website is to connect your Astro project‚Äôs online Git repository (e.g. GitHub, GitLab, Bitbucket) to a host provider and take advantage of continuous deployment using Git.
These host platforms automatically detect pushes to your Astro project‚Äôs source repository, build your site and deploy it to the web at a custom URL or your personal domain. Often, setting up a deployment on these platforms will follow steps something like the following:
Add your repository to an online Git provider (e.g. in GitHub, GitLab, Bitbucket)
Choose a host that supports continuous deployment (e.g. Netlify or Vercel) and import your Git repository as a new site/project.
Many common hosts will recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy your site as shown below. (If not, these settings can be changed.)
Deploy settings
Build Command: astro build or npm run build
Publish directory: dist
Click ‚ÄúDeploy‚Äù and your new website will be created at a unique URL for that host (e.g. new-astro-site.netlify.app).
The host will be automatically configured to watch your Git provider‚Äôs main branch for changes, and to rebuild and republish your site at each new commit. These settings can typically be configured in your host provider‚Äôs dashboard UI.
CLI Deployment
Some hosts will have their own command line interface (CLI) you can install globally to your machine using npm. Often, using a CLI to deploy looks something like the following:
Install your host‚Äôs CLI globally, for example:
npm
pnpm
Yarn
Terminal window
pnpm add --global netlify-cli
Run the CLI and follow any instructions for authorization, setup etc.
Build your site and deploy to your host
Many common hosts will build and deploy your site for you. They will usually recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy as shown below. (If not, these settings can be changed.)
Deploy settings
Build Command: astro build or npm run build
Publish directory: dist
Other hosts will require you to build your site locally and deploy using the command line.
Building Your Site Locally
Many hosts like Netlify and Vercel will build your site for you and then publish that build output to the web. But, some sites will require you to build locally and then run a deploy command or upload your build output.
You may also wish to build locally to preview your site, or to catch any potential errors and warnings in your own environment.
Run the command npm run build to build your Astro site.
npm
pnpm
Yarn
Terminal window
pnpm run build
By default, the build output will be placed at dist/. This location can be changed using the outDir configuration option.
Adding an Adapter for SSR
Note
Before deploying your Astro site with SSR (server-side rendering) enabled, make sure you have:
Installed the appropriate adapter to your project dependencies (either manually, or using the adapter‚Äôs astro add command, e.g. npx astro add netlify).
Added the adapter to your astro.config.mjs file‚Äôs import and default export when installing manually. (The astro add command will take care of this step for you!)
Edit page
Translate this page
Previous
Installation and Setup
Next
Migrate to Astro
Contribute
Give us feedback
Community""""""",2999,13174,astro
https://docs.astro.build/en/guides/migrate-to-astro/,"""""""On this page
Overview
Migration Guides
Why migrate your site to Astro?
Which projects can I convert to Astro?
How will my project design change?
Want to build your own Docs?
Grab this template to get started.‚Üí
Migrate an existing project to Astro
Ready to convert your site to Astro? See one of our guides for migration tips.
Migration Guides
Create React App
Docusaurus
Eleventy
Gatsby
GitBook
Gridsome
Hugo
Jekyll
Next.js
NuxtJS
Pelican
SvelteKit
VuePress
WordPress
Note that many of these pages are stubs: they‚Äôre collections of resources waiting for your contribution!
Why migrate your site to Astro?
Astro provides many benefits: performance, simplicity, and many of the features you want built right into the framework. When you do need to extend your site, Astro provides several official and 3rd-party community integrations.
Migrating may be less work than you think!
Depending on your existing project, you may be able to use your existing:
UI framework components directly in Astro.
CSS stylesheets or libraries including Tailwind.
Markdown/MDX files, configured using your existing remark and rehype plugins.
Content from a CMS through an integration or API.
Which projects can I convert to Astro?
Many existing sites can be built with Astro. Astro is ideally suited for your existing content-based sites like blogs, landing pages, marketing sites and portfolios. Astro integrates with several popular headless CMSs, and allows you to connect eCommerce shop carts.
Astro allows you to choose between a statically-generated site and server-side rendering (SSR), making it a great replacement for SSGs or for sites that need to fetch some page data on the fly.
How will my project design change?
Depending on your existing project, you may need to think differently about:
Designing in Astro Islands to avoid sending unnecessary JavaScript to the browser.
Providing client-side interactivity with client-side <script> tags or UI framework components.
Managing shared state with Nano Stores or local storage instead of app-wide hooks or wrappers.
Edit page
Translate this page
Previous
Deploy Your Site
Next
Tutorial: Build a Blog
Contribute
Give us feedback
Community""""""",460,2177,astro
https://docs.astro.build/en/tutorial/0-introduction/,"""""""Tutorial Tracker
Unit 0 (/2 Complete)
0
Unit 1 (/6 Complete)
1
Unit 2 (/6 Complete)
2
Unit 3 (/5 Complete)
3
Unit 4 (/4 Complete)
4
Unit 5 (/5 Complete)
5
Unit 6 (/4 Complete)
6
Welcome, world!
To-do
0 Build your first Astro Blog
Checklist
To-do
1 About this Tutorial
Want to build your own Docs?
Grab this template to get started.‚Üí
Build your first Astro Blog
In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ
Along the way, you‚Äôll:
Set up your development environment
Create pages and blog posts for your website
Build with Astro components
Query and work with local files
Add interactivity to your site
Deploy your site to the web
Want a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.
Note
If you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.
Checklist
Looks great! I‚Äôm ready to get started!
Edit page
Translate this page
Previous
Migrate to Astro
Next
About this Tutorial
Contribute
Give us feedback
Community

Tutorial Tracker
Unit 0 (/2 Complete)
0
Unit 1 (/6 Complete)
1
Unit 2 (/6 Complete)
2
Unit 3 (/5 Complete)
3
Unit 4 (/4 Complete)
4
Unit 5 (/5 Complete)
5
Unit 6 (/4 Complete)
6
Create and deploy your first Astro site
To-do
0 Check in: Unit 1 - Setup
To-do
1 Prepare your dev environment
To-do
2 Create your first Astro project
To-do
3 Write your first line of Astro
To-do
4 Store your repository online
To-do
5 Deploy your site to the web
Want to build your own Docs?
Grab this template to get started.‚Üí
Build your first Astro Blog
In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ
Along the way, you‚Äôll:
Set up your development environment
Create pages and blog posts for your website
Build with Astro components
Query and work with local files
Add interactivity to your site
Deploy your site to the web
Want a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.
Note
If you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.
Checklist
Looks great! I‚Äôm ready to get started!
Edit page
Translate this page
Previous
Migrate to Astro
Next
About this Tutorial
Contribute
Give us feedback
Community

Tutorial Tracker
Unit 0 (/2 Complete)
0
Unit 1 (/6 Complete)
1
Unit 2 (/6 Complete)
2
Unit 3 (/5 Complete)
3
Unit 4 (/4 Complete)
4
Unit 5 (/5 Complete)
5
Unit 6 (/4 Complete)
6
Add, style and link to pages on your site
To-do
0 Check in: Unit 2 - Pages
To-do
1 Create your first Astro page
To-do
2 Write your first Markdown blog post
To-do
3 Add dynamic content about you
To-do
4 Style your About page
To-do
5 Add site-wide styling
Want to build your own Docs?
Grab this template to get started.‚Üí
Build your first Astro Blog
In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ
Along the way, you‚Äôll:
Set up your development environment
Create pages and blog posts for your website
Build with Astro components
Query and work with local files
Add interactivity to your site
Deploy your site to the web
Want a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.
Note
If you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.
Checklist
Looks great! I‚Äôm ready to get started!
Edit page
Translate this page
Previous
Migrate to Astro
Next
About this Tutorial
Contribute
Give us feedback
Community

Tutorial Tracker
Unit 0 (/2 Complete)
0
Unit 1 (/6 Complete)
1
Unit 2 (/6 Complete)
2
Unit 3 (/5 Complete)
3
Unit 4 (/4 Complete)
4
Unit 5 (/5 Complete)
5
Unit 6 (/4 Complete)
6
Build and design with Astro UI components
To-do
0 Check in: Unit 3 - Components
To-do
1 Make a reusable Navigation component
To-do
2 Create a social media footer
To-do
3 Build it yourself - Header
To-do
4 Send your first script to the browser
Want to build your own Docs?
Grab this template to get started.‚Üí
Build your first Astro Blog
In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ
Along the way, you‚Äôll:
Set up your development environment
Create pages and blog posts for your website
Build with Astro components
Query and work with local files
Add interactivity to your site
Deploy your site to the web
Want a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.
Note
If you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.
Checklist
Looks great! I‚Äôm ready to get started!
Edit page
Translate this page
Previous
Migrate to Astro
Next
About this Tutorial
Contribute
Give us feedback
Community

Tutorial Tracker
Unit 0 (/2 Complete)
0
Unit 1 (/6 Complete)
1
Unit 2 (/6 Complete)
2
Unit 3 (/5 Complete)
3
Unit 4 (/4 Complete)
4
Unit 5 (/5 Complete)
5
Unit 6 (/4 Complete)
6
Save time and energy with reusable page layouts
To-do
0 Check in: Unit 4 - Layouts
To-do
1 Build your first layout
To-do
2 Create and pass data to a custom blog layout
To-do
3 Combine layouts to get the best of both worlds
Want to build your own Docs?
Grab this template to get started.‚Üí
Build your first Astro Blog
In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ
Along the way, you‚Äôll:
Set up your development environment
Create pages and blog posts for your website
Build with Astro components
Query and work with local files
Add interactivity to your site
Deploy your site to the web
Want a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.
Note
If you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.
Checklist
Looks great! I‚Äôm ready to get started!
Edit page
Translate this page
Previous
Migrate to Astro
Next
About this Tutorial
Contribute
Give us feedback
Community

Tutorial Tracker
Unit 0 (/2 Complete)
0
Unit 1 (/6 Complete)
1
Unit 2 (/6 Complete)
2
Unit 3 (/5 Complete)
3
Unit 4 (/4 Complete)
4
Unit 5 (/5 Complete)
5
Unit 6 (/4 Complete)
6
Beef up your blog
To-do
0 Check in: Unit 5 - Astro API
To-do
1 Create a blog post archive
To-do
2 Generate tag pages
To-do
3 Build a tag index page
To-do
4 Add an RSS feed
Want to build your own Docs?
Grab this template to get started.‚Üí
Build your first Astro Blog
In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ
Along the way, you‚Äôll:
Set up your development environment
Create pages and blog posts for your website
Build with Astro components
Query and work with local files
Add interactivity to your site
Deploy your site to the web
Want a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.
Note
If you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.
Checklist
Looks great! I‚Äôm ready to get started!
Edit page
Translate this page
Previous
Migrate to Astro
Next
About this Tutorial
Contribute
Give us feedback
Community

Tutorial Tracker
Unit 0 (/2 Complete)
0
Unit 1 (/6 Complete)
1
Unit 2 (/6 Complete)
2
Unit 3 (/5 Complete)
3
Unit 4 (/4 Complete)
4
Unit 5 (/5 Complete)
5
Unit 6 (/4 Complete)
6
Set sail for Astro islands
To-do
0 Check in: Unit 6 - Astro Islands
To-do
1 Build your first Astro island
To-do
2 Back on dry land. Take your blog from day to night, no island required!
To-do
3 Congratulations!
Want to build your own Docs?
Grab this template to get started.‚Üí
Build your first Astro Blog
In this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ
Along the way, you‚Äôll:
Set up your development environment
Create pages and blog posts for your website
Build with Astro components
Query and work with local files
Add interactivity to your site
Deploy your site to the web
Want a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.
Note
If you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.
Checklist
Looks great! I‚Äôm ready to get started!
Edit page
Translate this page
Previous
Migrate to Astro
Next
About this Tutorial
Contribute
Give us feedback
Community""""""",2281,8866,astro
https://docs.astro.build/en/concepts/why-astro/,"""""""On this page
Overview
Features
Design Principles
Content-driven
Server-first
Fast by default
Easy to use
Developer-focused
Want to build your own Docs?
Grab this template to get started.‚Üí
Why Astro?
Astro is the web framework for building content-driven websites like blogs, marketing, and e-commerce. Astro is best-known for pioneering a new frontend architecture to reduce JavaScript overhead and complexity compared to other frameworks. If you need a website that loads fast and has great SEO, then Astro is for you.
Features
Astro is an all-in-one web framework. It includes everything you need to create a website, built-in. There are also hundreds of different integrations and API hooks available to customize a project to your exact use case and needs.
Some highlights include:
Islands: A component-based web architecture optimized for content-driven websites.
UI-agnostic: Supports React, Preact, Svelte, Vue, Solid, Lit, HTMX, web components, and more.
Server-first: Moves expensive rendering off of your visitors‚Äô devices.
Zero JS, by default: Less client-side JavaScript to slow your site down.
Content collections: Organize, validate, and provide TypeScript type-safety for your Markdown content.
Customizable: Tailwind, MDX, and hundreds of integrations to choose from.
Design Principles
Here are five core design principles to help explain why we built Astro, the problems that it exists to solve, and why Astro may be the best choice for your project or team.
Astro is‚Ä¶
Content-driven: Astro was designed to showcase your content.
Server-first: Websites run faster when they render HTML on the server.
Fast by default: It should be impossible to build a slow website in Astro.
Easy to use: You don‚Äôt need to be an expert to build something with Astro.
Developer-focused: You should have the resources you need to be successful.
Content-driven
Astro was designed for building content-rich websites. This includes marketing sites, publishing sites, documentation sites, blogs, portfolios, landing pages, community sites, and e-commerce sites. If you have content to show, it needs to reach your reader quickly.
By contrast, most modern web frameworks were designed for building web applications. These frameworks excel at building more complex, application-like experiences in the browser: logged-in admin dashboards, inboxes, social networks, todo lists, and even native-like applications like Figma and Ping. However with that complexity, they can struggle to provide great performance when delivering your content.
Astro‚Äôs focus on content from its beginnings as a static site builder have allowed Astro to sensibly scale up to performant, powerful, dynamic web applications that still respect your content and your audience. Astro‚Äôs unique focus on content lets Astro make tradeoffs and deliver unmatched performance features that wouldn‚Äôt make sense for more application-focused web frameworks to implement.
Server-first
Astro leverages server-rendering over client-side rendering in the browser as much as possible. This is the same approach that traditional server-side frameworks -- PHP, WordPress, Laravel, Ruby on Rails, etc. -- have been using for decades. But you don‚Äôt need to learn a second server-side language to unlock it. With Astro, everything is still just HTML, CSS, and JavaScript (or TypeScript, if you prefer).
This approach stands in contrast to other modern JavaScript web frameworks like Next.js, SvelteKit, Nuxt, Remix, and others. These frameworks were built for client-side rendering of your entire website and include server-side rendering mainly to address performance concerns. This approach has been dubbed the Single-Page App (SPA), in contrast with Astro‚Äôs Multi-Page App (MPA) approach.
The SPA model has its benefits. However, these come at the expense of additional complexity and performance tradeoffs. These tradeoffs harm page performance -- critical metrics like Time to Interactive (TTI) -- which doesn‚Äôt make much sense for content-focused websites where first-load performance is essential.
Astro‚Äôs server-first approach allows you to opt in to client-side rendering only if, and exactly as, necessary. You can choose to add UI framework components that run on the client. You can take advantage of Astro‚Äôs view transitions router for finer control over select page transitions and animations. Astro‚Äôs server-first rendering, either pre-rendered or on-demand, provides performant defaults that you can enhance and extend.
Fast by default
Good performance is always important, but it is especially critical for websites whose success depends on displaying your content. It has been well-proven that poor performance loses you engagement, conversions, and money. For example:
Every 100ms faster ‚Üí 1% more conversions (Mobify, earning +$380,000/yr)
50% faster ‚Üí 12% more sales (AutoAnything)
20% faster ‚Üí 10% more conversions (Furniture Village)
40% faster ‚Üí 15% more sign-ups (Pinterest)
850ms faster ‚Üí 7% more conversions (COOK)
Every 1 second slower ‚Üí 10% fewer users (BBC)
In many web frameworks, it is easy to build a website that looks great during development only to load painfully slow once deployed. JavaScript is often the culprit, since many phones and lower-powered devices rarely match the speed of a developer‚Äôs laptop.
Astro‚Äôs magic is in how it combines the two values explained above -- a content focus with a server-first architecture -- to make tradeoffs and deliver features that other frameworks cannot. The result is amazing web performance for every website, out of the box. Our goal: It should be nearly impossible to build a slow website with Astro.
An Astro website can load 40% faster with 90% less JavaScript than the same site built with the most popular React web framework. But don‚Äôt take our word for it: watch Astro‚Äôs performance leave Ryan Carniato (creator of Solid.js and Marko) speechless.
Easy to use
Astro‚Äôs goal is to be accessible to every web developer. Astro was designed to feel familiar and approachable regardless of skill level or past experience with web development.
The .astro UI language is a superset of HTML: any valid HTML is valid Astro templating syntax! So, if you can write HTML, you can write Astro components! But, it also combines some of our favorite features borrowed from other component languages like JSX expressions (React) and CSS scoping by default (Svelte and Vue). This closeness to HTML also makes it easier to use progressive enhancement and common accessibility patterns without any overhead.
We then made sure that you could also use your favorite UI component languages that you already know, and even reuse components you might already have. React, Preact, Svelte, Vue, Solid, Lit, and others, including web components, are all supported for authoring UI components in an Astro project.
Astro was designed to be less complex than other UI frameworks and languages. One big reason for this is that Astro was designed to render on the server, not in the browser. That means that you don‚Äôt need to worry about: hooks (React), stale closures (also React), refs (Vue), observables (Svelte), atoms, selectors, reactions, or derivations. There is no reactivity on the server, so all of that complexity melts away.
One of our favorite sayings is: opt in to complexity. We designed Astro to remove as much ‚Äúrequired complexity‚Äù as possible from the developer experience, especially as you onboard for the first time. You can build a ‚ÄúHello World‚Äù example website in Astro with just HTML and CSS. Then, when you need to build something more powerful, you can incrementally reach for new features and APIs as you go.
Developer-focused
We strongly believe that Astro is only a successful project if people love using it. Astro has everything you need to support you as you build with Astro.
Astro invests in developer tools like a great CLI experience from the moment you open your terminal, an official VS Code extension for syntax highlighting, TypeScript and Intellisense, and documentation actively maintained by hundreds of community contributors and available in 14 languages.
Our welcoming, respectful, inclusive community on Discord is ready to provide support, motivation, and encouragement. Open a #support thread to get help with your project. Visit our dedicated #showcase channel for sharing your Astro sites, blog posts, videos, and even work-in-progress for safe feedback and constructive criticism. Participate in regular live events such as our weekly community call, ‚ÄúTalking and Doc‚Äôing,‚Äù and API/bug bashes.
As an open-source project, we welcome contributions of all types and sizes from community members of all experience levels. You are invited to join in roadmap discussions to shape the future of Astro, and we hope you‚Äôll contribute fixes and features to the core codebase, compiler, docs, language tools, websites, and other projects.
Edit page
Translate this page
Previous
Tutorial: Build a Blog
Next
Astro Islands
Contribute
Give us feedback
Community""""""",1831,9003,astro
https://docs.astro.build/en/concepts/islands/,"""""""On this page
Overview
A brief history
What is an island?
Creating an island
What are the benefits of Islands?
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro Islands
Astro pioneered and popularized a frontend architecture called Islands. Islands architecture results in better frontend performance by helping you avoid monolithic JavaScript patterns and stripping all non-essential JavaScript from the page automatically. Developers keep using their favorite UI components and frameworks with Astro and still get these benefits.
A brief history
The term ‚Äúcomponent island‚Äù was first coined by Etsy‚Äôs frontend architect Katie Sylor-Miller in 2019. This idea was then expanded on and documented in this post by Preact creator Jason Miller on August 11, 2020.
The general idea of an ‚ÄúIslands‚Äù architecture is deceptively simple: render HTML pages on the server, and inject placeholders or slots around highly dynamic regions [‚Ä¶] that can then be ‚Äúhydrated‚Äù on the client into small self-contained widgets, reusing their server-rendered initial HTML.
‚Äî Jason Miller, Creator of Preact
The technique that this architectural pattern builds on is also known as partial or selective hydration.
In contrast, most JavaScript-based web frameworks hydrate & render an entire website as one large JavaScript application (also known as a single-page application, or SPA). SPAs provide simplicity and power but suffer from page-load performance problems due to heavy client-side JavaScript usage.
SPAs have their place, even embedded inside an Astro page. But, SPAs lack the native ability to selectively and strategically hydrate, making them a heavy-handed choice for most projects on the web today.
Astro became popular as the first mainstream JavaScript web framework with selective hydration built-in, using that component islands pattern first coined by Sylor-Miller.
What is an island?
In Astro, an ‚Äúisland‚Äù refers to any interactive UI component on the page. Think of an island as an interactive widget floating in a sea of otherwise static, lightweight, server-rendered HTML.
Header (interactive island)
Sidebar (static HTML)
Static content like text, images, etc.
Image carousel (interactive island)
Footer (static HTML)
Source: Islands Architecture: Jason Miller
An island always runs in isolation from other islands on the page, and multiple islands can exist on a page. Islands can still share state and communicate with each other, even though they run in different component contexts.
This flexibility allows Astro to support multiple UI frameworks like React, Preact, Svelte, Vue, and SolidJS. Because they are independent, you can even mix several frameworks on each page.
Tip
Although most developers will stick to just one UI framework, Astro supports multiple frameworks in the same project. This allows you to:
Choose the framework that is best for each component.
Learn a new framework without needing to start a new project.
Collaborate with others even when working in different frameworks.
Incrementally convert an existing site to another framework with no downtime.
Creating an island
By default, Astro will automatically render every UI component to just HTML & CSS, stripping out all client-side JavaScript automatically.
src/pages/index.astro
<MyReactComponent />
This may sound strict, but this behavior is what keeps Astro websites fast by default and protects developers from accidentally sending unnecessary or unwanted JavaScript that might slow down their website.
Turning any static UI component into an interactive island requires only a client:* directive. Astro then automatically builds and bundles your client-side JavaScript for optimized performance.
src/pages/index.astro
<!-- This component is now interactive on the page!
     The rest of your website remains static. -->
<MyReactComponent client:load />
With islands, client-side JavaScript is only loaded for the explicit interactive components that you mark using client:* directives.
And because interaction is configured at the component-level, you can handle different loading priorities for each component based on its usage. For example, client:idle tells a component to load when the browser becomes idle, and client:visible tells a component to load only once it enters the viewport.
What are the benefits of Islands?
The most obvious benefit of building with Astro Islands is performance: the majority of your website is converted to fast, static HTML and JavaScript is only loaded for the individual components that need it. JavaScript is one of the slowest assets that you can load per-byte, so every byte counts.
Another benefit is parallel loading. In the example illustration above, the low-priority ‚Äúimage carousel‚Äù island doesn‚Äôt need to block the high-priority ‚Äúheader‚Äù island. The two load in parallel and hydrate in isolation, meaning that the header becomes interactive immediately without having to wait for the heavier carousel lower down the page.
Even better, you can tell Astro exactly how and when to render each component. If that image carousel is really expensive to load, you can attach a special client directive that tells Astro to only load the carousel when it becomes visible on the page. If the user never sees it, it never loads.
In Astro, it‚Äôs up to you as the developer to explicitly tell Astro which components on the page need to also run in the browser. Astro will only hydrate exactly what‚Äôs needed on the page and leave the rest of your site as static HTML.
Islands are the secret to Astro‚Äôs fast-by-default performance story!
Edit page
Translate this page
Previous
Why Astro?
Next
Project Structure
Contribute
Give us feedback
Community""""""",1100,5688,astro
https://docs.astro.build/en/basics/project-structure/,"""""""On this page
Overview
Directories and Files
Example Project Tree
src/
src/pages
src/components
src/content
src/layouts
src/styles
public/
package.json
astro.config.mjs
tsconfig.json
Want to build your own Docs?
Grab this template to get started.‚Üí
Project Structure
Your new Astro project generated from the create astro CLI wizard already includes some files and folders. Others, you will create yourself and add to Astro‚Äôs existing file structure.
Here‚Äôs how an Astro project is organized, and some files you will find in your new project.
Directories and Files
Astro leverages an opinionated folder layout for your project. Every Astro project root should include the following directories and files:
src/* - Your project source code (components, pages, styles, etc.)
public/* - Your non-code, unprocessed assets (fonts, icons, etc.)
package.json - A project manifest.
astro.config.mjs - An Astro configuration file. (recommended)
tsconfig.json - A TypeScript configuration file. (recommended)
Example Project Tree
A common Astro project directory might look like this:
Directory
public/
robots.txt
favicon.svg
social-image.png
Directory
src/
Directory
components/
Header.astro
Button.jsx
Directory
content/
config.ts
Directory
posts/
post1.md
post2.md
post3.md
Directory
layouts/
PostLayout.astro
Directory
pages/
Directory
posts/
[post].astro
about.astro
index.astro
rss.xml.js
Directory
styles/
global.css
astro.config.mjs
package.json
tsconfig.json
src/
The src/ folder is where most of your project source code lives. This includes:
Pages
Layouts
Astro components
UI framework components (React, etc.)
Styles (CSS, Sass)
Markdown
Astro processes, optimizes, and bundles your src/ files to create the final website that is shipped to the browser. Unlike the static public/ directory, your src/ files are built and handled for you by Astro.
Some files (like Astro components) are not even sent to the browser as written but are instead rendered to static HTML. Other files (like CSS) are sent to the browser but may be optimized or bundled with other CSS files for performance.
Tip
While this guide describes some popular conventions used in the Astro community, the only directories reserved by Astro are src/pages/ and src/content/. You are free to rename and reorganize any other directories in a way that works best for you.
src/pages
Pages routes are created for your site by adding supported file types to this directory.
Caution
src/pages is a required sub-directory in your Astro project. Without it, your site will have no pages or routes!
src/components
Components are reusable units of code for your HTML pages. These could be Astro components, or UI framework components like React or Vue. It is common to group and organize all of your project components together in this folder.
This is a common convention in Astro projects, but it is not required. Feel free to organize your components however you like!
src/content
The src/content/ directory is reserved to store content collections and a configuration file. No other files are allowed inside this folder.
src/layouts
Layouts are Astro components that define the UI structure shared by one or more pages.
Just like src/components, this directory is a common convention but not required.
src/styles
It is a common convention to store your CSS or Sass files in a src/styles directory, but this is not required. As long as your styles live somewhere in the src/ directory and are imported correctly, Astro will handle and optimize them.
public/
The public/ directory is for files and assets in your project that do not need to be processed during Astro‚Äôs build process. The files in this folder will be copied into the build folder untouched, and then your site will be built.
This behavior makes public/ ideal for common assets like images and fonts, or special files such as robots.txt and manifest.webmanifest.
You can place CSS and JavaScript in your public/ directory, but be aware that those files will not be bundled or optimized in your final build.
Tip
As a general rule, any CSS or JavaScript that you write yourself should live in your src/ directory.
package.json
This is a file used by JavaScript package managers to manage your dependencies. It also defines the scripts that are commonly used to run Astro (ex: npm start, npm run build).
There are two kinds of dependencies you can specify in a package.json: dependencies and devDependencies. In most cases, these work the same: Astro needs all dependencies at build time, and your package manager will install both. We recommend putting all of your dependencies in dependencies to start, and only use devDependencies if you find a specific need to do so.
For help creating a new package.json file for your project, check out the manual setup instructions.
astro.config.mjs
This file is generated in every starter template and includes configuration options for your Astro project. Here you can specify integrations to use, build options, server options, and more.
Astro supports several file formats for its JavaScript configuration file: astro.config.js, astro.config.mjs, astro.config.cjs and astro.config.ts. We recommend using .mjs in most cases or .ts if you want to write TypeScript in your config file.
TypeScript config file loading is handled using tsm and will respect your project‚Äôs tsconfig options.
See the Configuring Astro Guide for details on setting configurations.
tsconfig.json
This file is generated in every starter template and includes TypeScript configuration options for your Astro project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file.
See the TypeScript Guide for details on setting configurations.
Edit page
Translate this page
Previous
Astro Islands
Next
Components
Contribute
Give us feedback
Community""""""",1208,5828,astro
https://docs.astro.build/en/basics/astro-components/,"""""""On this page
Overview
Component Structure
The Component Script
The Component Template
Component-based design
Component Props
Slots
Named Slots
Fallback Content for Slots
Transferring slots
HTML Components
Next Steps
Want to build your own Docs?
Grab this template to get started.‚Üí
Components
Astro components are the basic building blocks of any Astro project. They are HTML-only templating components with no client-side runtime. You can spot an Astro component by its file extension: .astro.
Astro components are extremely flexible. Often, an Astro component will contain some reusable UI on the page, like a header or a profile card. At other times, an Astro component may contain a smaller snippet of HTML, like a collection of common <meta> tags that make SEO easy to work with. Astro components can even contain an entire page layout.
The most important thing to know about Astro components is that they don‚Äôt render on the client. They render to HTML either at build-time or on-demand using server-side rendering (SSR). You can include JavaScript code inside of your component frontmatter, and all of it will be stripped from the final page sent to your users‚Äô browsers. The result is a faster site, with zero JavaScript footprint added by default.
When your Astro component does need client-side interactivity, you can add standard HTML <script> tags or UI Framework components.
Component Structure
An Astro component is made up of two main parts: the Component Script and the Component Template. Each part performs a different job, but together they provide a framework that is both easy to use and expressive enough to handle whatever you might want to build.
src/components/EmptyComponent.astro
---
// Component Script (JavaScript)
---
<!-- Component Template (HTML + JS Expressions) -->
The Component Script
Astro uses a code fence (---) to identify the component script in your Astro component. If you‚Äôve ever written Markdown before, you may already be familiar with a similar concept called frontmatter. Astro‚Äôs idea of a component script was directly inspired by this concept.
You can use the component script to write any JavaScript code that you need to render your template. This can include:
importing other Astro components
importing other framework components, like React
importing data, like a JSON file
fetching content from an API or database
creating variables that you will reference in your template
src/components/MyComponent.astro
---
import SomeAstroComponent from '../components/SomeAstroComponent.astro';
import SomeReactComponent from '../components/SomeReactComponent.jsx';
import someData from '../data/pokemon.json';
// Access passed-in component props, like `<X title=""Hello, World"" />`
const { title } = Astro.props;
// Fetch external data, even from a private API or database
const data = await fetch('SOME_SECRET_API_URL/users').then(r => r.json());
---
<!-- Your template here! -->
The code fence is designed to guarantee that the JavaScript that you write in it is ‚Äúfenced in.‚Äù It won‚Äôt escape into your frontend application, or fall into your user‚Äôs hands. You can safely write code here that is expensive or sensitive (like a call to your private database) without worrying about it ever ending up in your user‚Äôs browser.
Tip
You can even write TypeScript in your component script!
The Component Template
The component template is below the code fence and determines the HTML output of your component.
If you write plain HTML here, your component will render that HTML in any Astro page it is imported and used.
However, Astro‚Äôs component template syntax also supports JavaScript expressions, Astro <style> and <script> tags, imported components, and special Astro directives. Data and values defined in the component script can be used in the component template to produce dynamically-created HTML.
src/components/MyFavoritePokemon.astro
---
// Your component script here!
import Banner from '../components/Banner.astro';
import ReactPokemonComponent from '../components/ReactPokemonComponent.jsx';
const myFavoritePokemon = [/* ... */];
const { title } = Astro.props;
---
<!-- HTML comments supported! -->
{/* JS comment syntax is also valid! */}
<Banner />
<h1>Hello, world!</h1>
<!-- Use props and other variables from the component script: -->
<p>{title}</p>
<!-- Include other UI framework components with a `client:` directive to hydrate: -->
<ReactPokemonComponent client:visible />
<!-- Mix HTML with JavaScript expressions, similar to JSX: -->
<ul>
  {myFavoritePokemon.map((data) => <li>{data.name}</li>)}
</ul>
<!-- Use a template directive to build class names from multiple strings or even objects! -->
<p class:list={[""add"", ""dynamic"", {classNames: true}]} />
Component-based design
Components are designed to be reusable and composable. You can use components inside of other components to build more and more advanced UI. For example, a Button component could be used to create a ButtonGroup component:
src/components/ButtonGroup.astro
---
import Button from './Button.astro';
---
<div>
  <Button title=""Button 1"" />
  <Button title=""Button 2"" />
  <Button title=""Button 3"" />
</div>
Component Props
An Astro component can define and accept props. These props then become available to the component template for rendering HTML. Props are available on the Astro.props global in your frontmatter script.
Here is an example of a component that receives a greeting prop and a name prop. Notice that the props to be received are destructured from the global Astro.props object.
src/components/GreetingHeadline.astro
---
// Usage: <GreetingHeadline greeting=""Howdy"" name=""Partner"" />
const { greeting, name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
This component, when imported and rendered in other Astro components, layouts or pages, can pass these props as attributes:
src/components/GreetingCard.astro
---
import GreetingHeadline from './GreetingHeadline.astro';
const name = 'Astro';
---
<h1>Greeting Card</h1>
<GreetingHeadline greeting=""Hi"" name={name} />
<p>I hope you have a wonderful day!</p>
You can also define your props with TypeScript with a Props type interface. Astro will automatically pick up the Props interface in your frontmatter and give type warnings/errors. These props can also be given default values when destructured from Astro.props.
src/components/GreetingHeadline.astro
---
interface Props {
  name: string;
  greeting?: string;
}
const { greeting = ""Hello"", name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
Component props can be given default values to use when none are provided.
src/components/GreetingHeadline.astro
---
const { greeting = ""Hello"", name = ""Astronaut"" } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
Slots
The <slot /> element is a placeholder for external HTML content, allowing you to inject (or ‚Äúslot‚Äù) child elements from other files into your component template.
By default, all child elements passed to a component will be rendered in its <slot />.
Note
Unlike props, which are attributes passed to an Astro component available for use throughout your component with Astro.props, slots render child HTML elements where they are written.
src/components/Wrapper.astro
---
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';
const { title } = Astro.props;
---
<div id=""content-wrapper"">
  <Header />
  <Logo />
  <h1>{title}</h1>
  <slot />  <!-- children will go here -->
  <Footer />
</div>
src/pages/fred.astro
---
import Wrapper from '../components/Wrapper.astro';
---
<Wrapper title=""Fred's Page"">
  <h2>All about Fred</h2>
  <p>Here is some stuff about Fred.</p>
</Wrapper>
This pattern is the basis of an Astro layout component: an entire page of HTML content can be ‚Äúwrapped‚Äù with <SomeLayoutComponent></SomeLayoutComponent> tags and sent to the component to render inside of common page elements defined there.
Named Slots
An Astro component can also have named slots. This allows you to pass only HTML elements with the corresponding slot name into a slot‚Äôs location.
Slots are named using the name attribute:
src/components/Wrapper.astro
---
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';
const { title } = Astro.props;
---
<div id=""content-wrapper"">
  <Header />
  <slot name=""after-header"" />  <!--  children with the `slot=""after-header""` attribute will go here -->
  <Logo />
  <h1>{title}</h1>
  <slot />  <!--  children without a `slot`, or with `slot=""default""` attribute will go here -->
  <Footer />
  <slot name=""after-footer"" />  <!--  children with the `slot=""after-footer""` attribute will go here -->
</div>
To inject HTML content into a particular slot, use the slot attribute on any child element to specify the name of the slot. All other child elements of the component will be injected into the default (unnamed) <slot />.
src/pages/fred.astro
---
import Wrapper from '../components/Wrapper.astro';
---
<Wrapper title=""Fred's Page"">
  <img src=""https://my.photo/fred.jpg"" slot=""after-header"" />
  <h2>All about Fred</h2>
  <p>Here is some stuff about Fred.</p>
  <p slot=""after-footer"">Copyright 2022</p>
</Wrapper>
Tip
Use a slot=""my-slot"" attribute on the child element that you want to pass through to a matching <slot name=""my-slot"" /> placeholder in your component.
To pass multiple HTML elements into a component‚Äôs <slot/> placeholder without a wrapping <div>, use the slot="""" attribute on Astro‚Äôs <Fragment/> component:
src/components/CustomTable.astro
---
// Create a custom table with named slot placeholders for head and body content
---
<table class=""bg-white"">
  <thead class=""sticky top-0 bg-white""><slot name=""header"" /></thead>
  <tbody class=""[&_tr:nth-child(odd)]:bg-gray-100""><slot name=""body"" /></tbody>
</table>
Inject multiple rows and columns of HTML content using a slot="""" attribute to specify the ""header"" and ""body"" content. Individual HTML elements can also be styled:
src/components/StockTable.astro
---
import CustomTable from './CustomTable.astro';
---
<CustomTable>
  <Fragment slot=""header""> <!-- pass table header -->
    <tr><th>Product name</th><th>Stock units</th></tr>
  </Fragment>
  <Fragment slot=""body""> <!-- pass table body -->
    <tr><td>Flip-flops</td><td>64</td></tr>
    <tr><td>Boots</td><td>32</td></tr>
    <tr><td>Sneakers</td><td class=""text-red-500"">0</td></tr>
  </Fragment>
</CustomTable>
Note that named slots must be an immediate child of the component. You cannot pass named slots through nested elements.
Tip
Named slots can also be passed to UI framework components!
Note
It is not possible to dynamically generate an Astro slot name, such as within a map function. If this feature is needed within UI framework components, it might be best to generate these dynamic slots within the framework itself.
Fallback Content for Slots
Slots can also render fallback content. When there are no matching children passed to a slot, a <slot /> element will render its own placeholder children.
src/components/Wrapper.astro
---
import Header from './Header.astro';
import Logo from './Logo.astro';
import Footer from './Footer.astro';
const { title } = Astro.props;
---
<div id=""content-wrapper"">
  <Header />
  <Logo />
  <h1>{title}</h1>
  <slot>
    <p>This is my fallback content, if there is no child passed into slot</p>
  </slot>
  <Footer />
</div>
Fallback content will only be displayed when there are no matching elements with the slot=‚Äúname‚Äù attribute being passed in to a named slot.
Astro will pass an empty slot when a slot element exists but has no content to pass. Fallback content cannot be used as a default when an empty slot is passed. Fallback content is only displayed when no slot element can be found.
Transferring slots
Slots can be transferred to other components. For example, when creating nested layouts:
src/layouts/BaseLayout.astro
---
---
<html lang=""en"">
  <head>
    <meta charset=""utf-8"" />
    <link rel=""icon"" type=""image/svg+xml"" href=""/favicon.svg"" />
    <meta name=""viewport"" content=""width=device-width"" />
    <meta name=""generator"" content={Astro.generator} />
    <slot name=""head"" />
  </head>
  <body>
    <slot />
  </body>
</html>
src/layouts/HomeLayout.astro
---
import BaseLayout from './BaseLayout.astro';
---
<BaseLayout>
  <slot name=""head"" slot=""head"" />
  <slot />
</BaseLayout>
Note
Named slots can be transferred to another component using both the name and slot attributes on a <slot /> tag
Now, the default and head slots passed to HomeLayout will be transferred to the BaseLayout parent
src/pages/index.astro
---
import HomeLayout from '../layouts/HomeLayout.astro';
---
<HomeLayout>
  <title slot=""head"">Astro</title>
  <h1>Astro</h1>
</HomeLayout>
HTML Components
Astro supports importing and using .html files as components or placing these files within the src/pages/ subdirectory as pages. You may want to use HTML components if you‚Äôre reusing code from an existing site built without a framework, or if you want to ensure that your component has no dynamic features.
HTML components must contain only valid HTML, and therefore lack key Astro component features:
They don‚Äôt support frontmatter, server-side imports, or dynamic expressions.
Any <script> tags are left unbundled, treated as if they had is:inline.
They can only reference assets that are in the public/ folder.
Note
A <slot /> element inside an HTML component will work as it would in an Astro component. In order to use the HTML Web Component Slot element instead, add is:inline to your <slot> element.
Next Steps
Read more about using UI framework components in your Astro project.
Edit page
Translate this page
Previous
Project Structure
Next
Pages
Contribute
Give us feedback
Community""""""",3117,13741,astro
https://docs.astro.build/en/basics/astro-pages/,"""""""On this page
Overview
Supported page files
File-based routing
Link between pages
Astro Pages
Markdown/MDX Pages
HTML Pages
Custom 404 Error Page
Custom 500 Error Page
error
Page Partials
Using with a library
Want to build your own Docs?
Grab this template to get started.‚Üí
Pages
Pages are files that live in the src/pages/ subdirectory of your Astro project. They are responsible for handling routing, data loading, and overall page layout for every page in your website.
Supported page files
Astro supports the following file types in the src/pages/ directory:
.astro
.md
.mdx (with the MDX Integration installed)
.html
.js/.ts (as endpoints)
File-based routing
Section titled File-based routing
Astro leverages a routing strategy called file-based routing. Each file in your src/pages/ directory becomes an endpoint on your site based on its file path.
A single file can also generate multiple pages using dynamic routing. This allows you to create pages even if your content lives outside of the special /pages/ directory, such as in a content collection or a CMS.
Read more about Routing in Astro.
Link between pages
Write standard HTML <a> elements in your Astro pages to link to other pages on your site. Use a URL path relative to your root domain as your link, not a relative file path.
For example, to link to https://example.com/authors/sonali/ from any other page on example.com:
src/pages/index.astro
Read more <a href=""/authors/sonali/"">about Sonali</a>.
Astro Pages
Astro pages use the .astro file extension and support the same features as Astro components.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>My Homepage</title>
  </head>
  <body>
    <h1>Welcome to my website!</h1>
  </body>
</html>
A page must produce a full HTML document. If not explicitly included, Astro will add the necessary <!DOCTYPE html> declaration and <head> content to any .astro component located within src/pages/ by default. You can opt-out of this behavior on a per-component basis by marking it as a partial page.
To avoid repeating the same HTML elements on every page, you can move common <head> and <body> elements into your own layout components. You can use as many or as few layout components as you‚Äôd like.
src/pages/index.astro
---
import MySiteLayout from '../layouts/MySiteLayout.astro';
---
<MySiteLayout>
  <p>My page content, wrapped in a layout!</p>
</MySiteLayout>
Read more about layout components in Astro.
Markdown/MDX Pages
Astro also treats any Markdown (.md) files inside of src/pages/ as pages in your final website. If you have the MDX Integration installed, it also treats MDX (.mdx) files the same way.
Tip
Consider creating content collections instead of pages for directories of related Markdown files that share a similar structure, such as blog posts or product items.
Markdown files can use the special layout frontmatter property to specify a layout component that will wrap their Markdown content in a full <html>...</html> page document.
src/pages/page.md
---
layout: '../layouts/MySiteLayout.astro'
title: 'My Markdown page'
---
# Title
This is my page, written in **Markdown.**
Read more about Markdown in Astro.
HTML Pages
Files with the .html file extension can be placed in the src/pages/ directory and used directly as pages on your site. Note that some key Astro features are not supported in HTML Components.
Custom 404 Error Page
For a custom 404 error page, you can create a 404.astro or 404.md file in src/pages.
This will build to a 404.html page. Most deploy services will find and use it.
Custom 500 Error Page
For a custom 500 error page to show for pages that are rendered on demand, create the file src/pages/500.astro. This custom page is not available for prerendered pages and can‚Äôt be prerendered.
If an error occurs rendering this page, your host‚Äôs default 500 error page will be shown to your visitor.
Added in: astro@4.10.3
During development, if you have a 500.astro, the error thrown at runtime is logged in your terminal, as opposed to being shown in the error overlay.
error
Added in: astro@4.11.0
src/pages/500.astro is a special page that is automatically passed an error prop for any error thrown during rendering. This allows you to use the details of an error (e.g. from a page, from middleware, etc.) to display information to your visitor.
The error prop‚Äôs data type can be anything, which may affect how you type or use the value in your code:
src/pages/500.astro
---
interface Props {
    error: unknown
}
const { error } = Astro.props
---
<div>{error instanceof Error ? error.message : 'Unknown error'}</div>
To avoid leaking sensitive information when displaying content from the error prop, consider evaluating the error first, and returning appropriate content based on the error thrown. For example, you should avoid displaying the error‚Äôs stack as it contains information about how your code is structured on the server
Page Partials
Added in: astro@3.4.0
Caution
Page partials are intended to be used in conjunction with a front-end library, such as htmx or Unpoly. You can also use them if you are comfortable writing low-level front-end JavaScript. For this reason they are an advanced feature.
Additionally, partials should not be used if the component contains scoped styles or scripts, as these elements will be stripped from the HTML output. If you need scoped styles, it is better to use regular, non-partial pages along with a frontend library that knows how to merge the contents into the head.
Partials are page components located within src/pages/ that are not intended to render as full pages.
Like components located outside of this folder, these files do not automatically include the <!DOCTYPE html> declaration, nor any <head> content such as scoped styles and scripts.
However, because they are located in the special src/pages/ directory, the generated HTML is available at a URL corresponding to its file path. This allows a rendering library (e.g. htmx, Stimulus, jQuery) to access it on the client and load sections of HTML dynamically on a page without a browser refresh or page navigation.
Partials, when combined with a rendering library, provide an alternative to Astro islands and <script> tags for building dynamic content in Astro.
Page files that can export a value (e.g. .astro , .mdx) can be marked as partials.
Configure a file within the src/pages/ directory to be a partial by adding the following export:
src/pages/partial.astro
---
export const partial = true;
---
<li>I'm a partial!</li>
The export const partial must be identifiable statically. It can have the value of:
The boolean true.
An environment variable using import.meta.env such as import.meta.env.USE_PARTIALS.
Using with a library
Partials are used to dynamically update a section of a page using a library such as htmx.
The following example shows an hx-post attribute set to a partial‚Äôs URL. The content from the partial page will be used to update the targeted HTML element on this page.
src/pages/index.astro
<html>
  <head>
    <title>My page</title>
    <script src=""https://unpkg.com/htmx.org@1.9.6""
      integrity=""sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni""
      crossorigin=""anonymous""></script>
  </head>
</html>
<section>
  <div id=""parent-div"">Target here</div>
  <button hx-post=""/partials/clicked/""
    hx-trigger=""click""
    hx-target=""#parent-div""
    hx-swap=""innerHTML""
  >
      Click Me!
  </button>
</section>
The .astro partial must exist at the corresponding file path, and include an export defining the page as a partial:
src/pages/partials/clicked.astro
---
export const partial = true;
---
<div>I was clicked!</div>
See the htmx documentation for more details on using htmx.
Edit page
Translate this page
Previous
Components
Next
Layouts
Contribute
Give us feedback
Community""""""",1825,7830,astro
https://docs.astro.build/en/basics/layouts/,"""""""On this page
Overview
Sample Layout
Using TypeScript with layouts
Markdown Layouts
Markdown Layout Props
Importing Layouts Manually (MDX)
Nesting Layouts
Want to build your own Docs?
Grab this template to get started.‚Üí
Layouts
Layouts are Astro components used to provide a reusable UI structure, such as a page template.
We conventionally use the term ‚Äúlayout‚Äù for Astro components that provide common UI elements shared across pages such as headers, navigation bars, and footers. A typical Astro layout component provides Astro, Markdown or MDX pages with:
a page shell (<html>, <head> and <body> tags)
a <slot /> to specify where individual page content should be injected.
But, there is nothing special about a layout component! They can accept props and import and use other components like any other Astro component. They can include UI frameworks components and client-side scripts. They do not even have to provide a full page shell, and can instead be used as partial UI templates.
However, if a layout component does contain a page shell, its <html> element must be the parent of all other elements in the component. All <style> or <script> elements must be enclosed by the <html> tags.
Layout components are commonly placed in a src/layouts directory in your project for organization, but this is not a requirement; you can choose to place them anywhere in your project. You can even colocate layout components alongside your pages by prefixing the layout names with _.
Sample Layout
src/layouts/MySiteLayout.astro
---
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
const { title } = Astro.props;
---
<html lang=""en"">
  <head>
    <meta charset=""utf-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
    <BaseHead title={title}/>
  </head>
  <body>
    <nav>
      <a href=""#"">Home</a>
      <a href=""#"">Posts</a>
      <a href=""#"">Contact</a>
    </nav>
    <h1>{title}</h1>
    <article>
      <slot /> <!-- your content is injected here -->
    </article>
    <Footer />
  </body>
  <style>
    h1 {
      font-size: 2rem;
    }
  </style>
</html>
src/pages/index.astro
---
import MySiteLayout from '../layouts/MySiteLayout.astro';
---
<MySiteLayout title=""Home Page"">
  <p>My page content, wrapped in a layout!</p>
</MySiteLayout>
Learn more about slots.
Using TypeScript with layouts
Any Astro layout can be modified to introduce typesafety & autocompletion by providing the types for your props:
src/components/MyLayout.astro
---
interface Props {
  title: string;
  description: string;
  publishDate: string;
  viewCount: number;
}
const { title, description, publishDate, viewCount } = Astro.props;
---
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"">
    <meta name=""description"" content={description}>
    <title>{title}</title>
  </head>
  <body>
    <header>
      <p>Published on {publishDate}</p>
      <p>Viewed by {viewCount} folks</p>
    </header>
    <main>
      <slot />
    </main>
  </body>
</html>
Markdown Layouts
Page layouts are especially useful for individual Markdown pages which otherwise would not have any page formatting.
Astro provides a special layout frontmatter property to specify which .astro component to use as the page layout. By default, this specified component can automatically access data from the Markdown file.
src/pages/page.md
---
layout: ../layouts/BlogPostLayout.astro
title: ""Hello, World!""
author: ""Matthew Phillips""
date: ""09 Aug 2022""
---
All frontmatter properties are available as props to an Astro layout component.
The `layout` property is the only special one provided by Astro.
You can use it in Markdown files located within `src/pages/`.
A typical layout for a Markdown page includes:
The frontmatter prop to access the Markdown page‚Äôs frontmatter and other data.
A default <slot /> to indicate where the page‚Äôs Markdown content should be rendered.
src/layouts/BlogPostLayout.astro
---
// 1. The frontmatter prop gives access to frontmatter and other data
const { frontmatter } = Astro.props;
---
<html>
  <head>
    <!-- Add other Head elements here, like styles and meta tags. -->
    <title>{frontmatter.title}</title>
  </head>
  <body>
    <!-- Add other UI components here, like common headers and footers. -->
    <h1>{frontmatter.title} by {frontmatter.author}</h1>
    <!-- 2. Rendered HTML will be passed into the default slot. -->
    <slot />
    <p>Written on: {frontmatter.date}</p>
  </body>
</html>
You can set a layout‚Äôs Props type with the MarkdownLayoutProps helper:
src/layouts/BlogPostLayout.astro
---
import type { MarkdownLayoutProps } from 'astro';
type Props = MarkdownLayoutProps<{
  // Define frontmatter props here
  title: string;
  author: string;
  date: string;
}>;
// Now, `frontmatter`, `url`, and other Markdown layout properties
// are accessible with type safety
const { frontmatter, url } = Astro.props;
---
<html>
  <head>
    <link rel=""canonical"" href={new URL(url, Astro.site).pathname}>
    <title>{frontmatter.title}</title>
  </head>
  <body>
    <h1>{frontmatter.title} by {frontmatter.author}</h1>
    <slot />
    <p>Written on: {frontmatter.date}</p>
  </body>
</html>
Markdown Layout Props
A Markdown layout will have access to the following information via Astro.props:
file - The absolute path of this file (e.g. /home/user/projects/.../file.md).
url - The URL of the page (e.g. /en/guides/markdown-content).
frontmatter - All frontmatter from the Markdown or MDX document.
frontmatter.file - The same as the top-level file property.
frontmatter.url - The same as the top-level url property.
headings - A list of headings (h1 -> h6) in the Markdown or MDX document with associated metadata. This list follows the type: { depth: number; slug: string; text: string }[].
rawContent() - A function that returns the raw Markdown document as a string.
compiledContent() - A function that returns the Markdown document compiled to an HTML string.
Note
A Markdown layout will have access to all the Markdown file‚Äôs available properties from Astro.props with two key differences:
Heading information (i.e. h1 -> h6 elements) is available via the headings array, rather than a getHeadings() function.
file and url are also available as nested frontmatter properties (i.e. frontmatter.url and frontmatter.file).
Importing Layouts Manually (MDX)
You can also use the special Markdown layout property in the frontmatter of MDX files to pass frontmatter and headings props directly to a specified layout component in the same way.
To pass information to your MDX layout that does not (or cannot) exist in your frontmatter, you can instead import and use a <Layout /> component. This works like any other Astro component, and will not receive any props automatically. Pass it any necessary props directly:
src/pages/posts/first-post.mdx
---
layout: ../../layouts/BaseLayout.astro
title: 'My first MDX post'
publishDate: '21 September 2022'
---
import BaseLayout from '../../layouts/BaseLayout.astro';
export function fancyJsHelper() {
  return ""Try doing that with YAML!"";
}
<BaseLayout title={frontmatter.title} fancyJsHelper={fancyJsHelper}>
  Welcome to my new Astro blog, using MDX!
</BaseLayout>
Then, your values are available to you through Astro.props in your layout, and your MDX content will be injected into the page where your <slot /> component is written:
src/layouts/BaseLayout.astro
---
const { title, fancyJsHelper } = Astro.props;
---
<!-- -->
<h1>{title}</h1>
<slot /> <!-- your content is injected here -->
<p>{fancyJsHelper()}</p>
<!-- -->
Learn more about Astro‚Äôs Markdown and MDX support in our Markdown guide.
Nesting Layouts
Layout components do not need to contain an entire page worth of HTML. You can break your layouts into smaller components, and combine layout components to create even more flexible, page templates. This pattern is useful when you want to share some code across multiple layouts.
For example, a BlogPostLayout.astro layout component could style a post‚Äôs title, date and author. Then, a site-wide BaseLayout.astro could handle the rest of your page template, like navigation, footers, SEO meta tags, global styles, and fonts. You can also pass props received from your post to another layout, just like any other nested component.
src/layouts/BlogPostLayout.astro
---
import BaseLayout from './BaseLayout.astro';
const { frontmatter } = Astro.props;
---
<BaseLayout url={frontmatter.url}>
  <h1>{frontmatter.title}</h1>
  <h2>Post author: {frontmatter.author}</h2>
  <slot />
</BaseLayout>
Edit page
Translate this page
Previous
Pages
Next
Astro Template Syntax
Contribute
Give us feedback
Community""""""",2048,8649,astro
https://docs.astro.build/en/basics/astro-syntax/,"""""""On this page
Overview
JSX-like Expressions
Variables
Dynamic Attributes
Dynamic HTML
Dynamic Tags
Fragments
Differences between Astro and JSX
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro Syntax
If you know HTML, you already know enough to write your first Astro component.
Astro component syntax is a superset of HTML. The syntax was designed to feel familiar to anyone with experience writing HTML or JSX, and adds support for including components and JavaScript expressions.
JSX-like Expressions
You can define local JavaScript variables inside of the frontmatter component script between the two code fences (---) of an Astro component. You can then inject these variables into the component‚Äôs HTML template using JSX-like expressions!
Dynamic vs reactive
Using this approach, you can include dynamic values that are calculated in the frontmatter. But once included, these values are not reactive and will never change. Astro components are templates that only run once, during the rendering step.
See below for more examples of differences between Astro and JSX.
Variables
Local variables can be added into the HTML using the curly braces syntax:
src/components/Variables.astro
---
const name = ""Astro"";
---
<div>
  <h1>Hello {name}!</h1>  <!-- Outputs <h1>Hello Astro!</h1> -->
</div>
Dynamic Attributes
Local variables can be used in curly braces to pass attribute values to both HTML elements and components:
src/components/DynamicAttributes.astro
---
const name = ""Astro"";
---
<h1 class={name}>Attribute expressions are supported</h1>
<MyComponent templateLiteralNameAttribute={`MyNameIs${name}`} />
Caution
HTML attributes will be converted to strings, so it is not possible to pass functions and objects to HTML elements. For example, you can‚Äôt assign an event handler to an HTML element in an Astro component:
dont-do-this.astro
---
function handleClick () {
    console.log(""button clicked!"");
}
---
<!-- ‚ùå This doesn't work! ‚ùå -->
<button onClick={handleClick}>Nothing will happen when you click me!</button>
Instead, use a client-side script to add the event handler, like you would in vanilla JavaScript:
do-this-instead.astro
---
---
<button id=""button"">Click Me</button>
<script>
  function handleClick () {
    console.log(""button clicked!"");
  }
  document.getElementById(""button"").addEventListener(""click"", handleClick);
</script>
Dynamic HTML
Local variables can be used in JSX-like functions to produce dynamically-generated HTML elements:
src/components/DynamicHtml.astro
---
const items = [""Dog"", ""Cat"", ""Platypus""];
---
<ul>
  {items.map((item) => (
    <li>{item}</li>
  ))}
</ul>
Astro can conditionally display HTML using JSX logical operators and ternary expressions.
src/components/ConditionalHtml.astro
---
const visible = true;
---
{visible && <p>Show me!</p>}
{visible ? <p>Show me!</p> : <p>Else show me!</p>}
Dynamic Tags
You can also use dynamic tags by assigning an HTML tag name to a variable or with a component import reassignment:
src/components/DynamicTags.astro
---
import MyComponent from ""./MyComponent.astro"";
const Element = 'div'
const Component = MyComponent;
---
<Element>Hello!</Element> <!-- renders as <div>Hello!</div> -->
<Component /> <!-- renders as <MyComponent /> -->
When using dynamic tags:
Variable names must be capitalized. For example, use Element, not element. Otherwise, Astro will try to render your variable name as a literal HTML tag.
Hydration directives are not supported. When using client:* hydration directives, Astro needs to know which components to bundle for production, and the dynamic tag pattern prevents this from working.
The define:vars directive is not supported. If you cannot wrap the children with an extra element (e.g <div>), then you can manually add a style={`--myVar:${value}`} to your Element.
Fragments
Astro supports <> </> notation and also provides a built-in <Fragment /> component. This component can be useful to avoid wrapper elements when adding set:* directives to inject an HTML string.
The following example renders paragraph text using the <Fragment /> component:
src/components/SetHtml.astro
---
const htmlString = '<p>Raw HTML content</p>';
---
<Fragment set:html={htmlString} />
Differences between Astro and JSX
Astro component syntax is a superset of HTML. It was designed to feel familiar to anyone with HTML or JSX experience, but there are a couple of key differences between .astro files and JSX.
Attributes
In Astro, you use the standard kebab-case format for all HTML attributes instead of the camelCase used in JSX. This even works for class, which is not supported by React.
example.astro
<div className=""box"" dataValue=""3"" />
<div class=""box"" data-value=""3"" />
Multiple Elements
An Astro component template can render multiple elements with no need to wrap everything in a single <div> or <>, unlike JavaScript or JSX.
src/components/RootElements.astro
---
// Template with multiple elements
---
<p>No need to wrap elements in a single containing element.</p>
<p>Astro supports multiple root elements in a template.</p>
Comments
In Astro, you can use standard HTML comments or JavaScript-style comments.
example.astro
---
---
<!-- HTML comment syntax is valid in .astro files -->
{/* JS comment syntax is also valid */}
Caution
HTML-style comments will be included in browser DOM, while JS ones will be skipped. To leave TODO messages or other development-only explanations, you may wish to use JavaScript-style comments instead.
Edit page
Translate this page
Previous
Layouts
Next
Rendering Modes
Contribute
Give us feedback
Community""""""",1211,5583,astro
https://docs.astro.build/en/basics/rendering-modes/,"""""""On this page
Overview
Server output modes
Pre-rendered
On-demand rendered
Want to build your own Docs?
Grab this template to get started.‚Üí
Rendering Modes
Your Astro project code must be rendered to HTML in order to be displayed on the web.
Astro pages, routes, and API endpoints can be either pre-rendered at build time or rendered on demand by a server when a route is requested. With Astro islands, you can also include some client-side rendering when necessary.
In Astro, most of the processing occurs on the server, instead of in the browser. This generally makes your site or app faster than client-side rendering when viewed on less-powerful devices or on slower internet connections. Server-rendered HTML is fast, SEO friendly, and accessible by default.
Server output modes
You can configure how your pages are rendered in your output configuration.
Pre-rendered
Section titled Pre-rendered
The default rendering mode is output: 'static', which creates the HTML for all your page routes at build time.
In this mode, your entire site will be pre-rendered and the server will have all pages built ahead of time and ready to send to the browser. The same HTML document is sent to the browser for every visitor, and a full-site rebuild is required to update the contents of the page. This method is also known as static site generation (SSG).
By default, all Astro projects are configured to be pre-rendered at build time (statically-generated) to provide the most lightweight browser experience. The browser does not need to wait for any HTML to build because the server does not need to generate any pages on demand. Your site is not dependent on the performance of a backend data source, and once built, will remain available to visitors as a static site as long as your server is functioning.
Static sites can include Astro islands for interactive UI components (or even entire embedded client-side rendered apps!) written in the UI framework of your choice in an otherwise static, pre-rendered page.
Astro‚Äôs View Transitions API are also available in static mode for animation and state persistence across page navigation. Static sites can also use middleware to intercept and transform response data from a request.
Tip
Astro‚Äôs default static mode is a powerful, modern-feeling choice for content-heavy sites that update infrequently, and display the same page content to all visitors.
On-demand rendered
With an SSR adapter, Astro‚Äôs other two output modes can be configured to enable on-demand rendering of some or all of your pages, routes or API endpoints:
output: 'server' for highly dynamic sites with most or all on-demand routes.
output: 'hybrid' for mostly static sites with some on-demand routes.
Since they are generated per visit, these routes can be customized for each viewer. For example, a page rendered on demand can show a logged-in user their account information or display freshly updated data without requiring a full-site rebuild. On-demand rendering on the server at request time is also known as server-side rendering (SSR).
Read more about features available to you with on-demand rendering and an adapter, such as cookies, Response and Request objects, HTML streaming, and more.
Consider enabling server or hybrid mode in your Astro project if you need the following:
API endpoints: Create specific pages that function as API endpoints for tasks like database access, authentication, and authorization while keeping sensitive data hidden from the client.
Protected pages: Restrict access to a page based on user privileges, by handling user access on the server.
Frequently changing content: Generate individual pages without requiring a static rebuild of your site. This is useful when the content of a page updates frequently, for example displaying data from an API called dynamically with fetch().
Both server and hybrid output modes allow you to include Astro islands for interactivity (or even entire embedded client-side rendered apps!) in your choice of UI frameworks. With middleware and Astro‚Äôs View Transitions API for animations and preserving state across route navigations, even highly interactive apps are possible.
Tip
On demand server-rendering in Astro, especially when combined with view transitions, provides a true app experience without the JavaScript overhead of a client-side, single-page application.
Edit page
Translate this page
Previous
Astro Template Syntax
Next
Imports
Contribute
Give us feedback
Community""""""",873,4473,astro
https://docs.astro.build/en/guides/imports/,"""""""On this page
Overview
Supported File Types
Files in public/
Import statements
JavaScript
TypeScript
NPM Packages
JSON
CSS
CSS Modules
Other Assets
Aliases
Astro.glob()
Glob Patterns
WASM
Node Builtins
Extending file type support
Want to build your own Docs?
Grab this template to get started.‚Üí
Imports
Astro supports most static assets with zero configuration required. You can use the import statement anywhere in your project JavaScript (including your Astro frontmatter) and Astro will include a built, optimized copy of that static asset in your final build. @import is also supported inside of CSS & <style> tags.
Supported File Types
The following file types are supported out-of-the-box by Astro:
Astro Components (.astro)
Markdown (.md, .markdown, etc.)
JavaScript (.js, .mjs)
TypeScript (.ts)
NPM Packages
JSON (.json)
CSS (.css)
CSS Modules (.module.css)
Images & Assets (.svg, .jpg, .png, etc.)
Additionally, you can extend Astro to add support for different UI Frameworks like React, Svelte and Vue components. You can also install the Astro MDX integration and use .mdx files in your project.
Files in public/
You can place any static asset in the public/ directory of your project, and Astro will copy it directly into your final build untouched. public/ files are not built or bundled by Astro, which means that any type of file is supported. You can reference a public/ file by a URL path directly in your HTML templates.
Import statements
Astro uses ESM, the same import and export syntax supported in the browser.
JavaScript
import { getUser } from './user.js';
JavaScript can be imported using normal ESM import & export syntax.
Importing JSX files
An appropriate UI framework (React, Preact, or Solid) is required to render JSX/TSX files. Use .jsx/.tsx extensions where appropriate, as Astro does not support JSX in .js/.ts files.
TypeScript
import { getUser } from './user';
import type { UserType } from './user';
Astro includes built-in support for TypeScript. You can import .ts and .tsx files directly in your Astro project, and even write TypeScript code directly inside your Astro component script and any hoisted script tags.
Astro doesn‚Äôt perform any type checking itself. Type checking should be taken care of outside of Astro, either by your IDE or through a separate script. For type checking Astro files, the astro check command is provided.
TypeScript and file extensions
Per TypeScript‚Äôs module resolution rules, .ts and .tsx file extensions should not be used when importing TypeScript files. Instead, either use .js/.jsx file extensions or completely omit the file extension.
import { getUser } from './user.js'; // user.ts
import MyComponent from ""./MyComponent""; // MyComponent.tsx
Read more about TypeScript support in Astro.
NPM Packages
If you‚Äôve installed an NPM package, you can import it in Astro.
---
import { Icon } from 'astro-icon';
---
If a package was published using a legacy format, Astro will try to convert the package to ESM so that import statements work. In some cases, you may need to adjust your vite config for it to work.
Caution
Some packages rely on a browser environment. Astro components runs on the server, so importing these packages in the frontmatter may lead to errors.
JSON
// Load the JSON object via the default export
import json from './data.json';
Astro supports importing JSON files directly into your application. Imported files return the full JSON object in the default import.
CSS
// Load and inject 'style.css' onto the page
import './style.css';
Astro supports importing CSS files directly into your application. Imported styles expose no exports, but importing one will automatically add those styles to the page. This works for all CSS files by default, and can support compile-to-CSS languages like Sass & Less via plugins.
Read more about advanced CSS import use cases such as a direct URL reference for a CSS file, or importing CSS as a string in the Styling guide.
CSS Modules
// 1. Converts './style.module.css' classnames to unique, scoped values.
// 2. Returns an object mapping the original classnames to their final, scoped value.
import styles from './style.module.css';
// This example uses JSX, but you can use CSS Modules with any framework.
return <div className={styles.error}>Your Error Message</div>;
Astro supports CSS Modules using the [name].module.css naming convention. Like any CSS file, importing one will automatically apply that CSS to the page. However, CSS Modules export a special default styles object that maps your original classnames to unique identifiers.
CSS Modules help you enforce component scoping & isolation on the frontend with uniquely-generated class names for your stylesheets.
Other Assets
import imgReference from './image.png'; // imgReference === '/src/image.png'
import svgReference from './image.svg'; // svgReference === '/src/image.svg'
import txtReference from './words.txt'; // txtReference === '/src/words.txt'
// This example uses JSX, but you can use import references with any framework.
<img src={imgReference.src} alt=""image description"" />;
All other assets not explicitly mentioned above can be imported via ESM import and will return a URL reference to the final built asset. This can be useful for referencing non-JS assets by URL, like creating an image element with a src attribute pointing to that image.
It can also be useful to place images in the public/ folder as explained on the project-structure page.
Read more about appending Vite import parameters (e.g. ?url, ?raw) in Vite‚Äôs static asset handling guide.
Note
Adding alt text to <img> tags is encouraged for accessibility! Don‚Äôt forget to add an alt=""a helpful description"" attribute to your image elements. You can just leave the attribute empty if the image is purely decorative.
Aliases
An alias is a way to create shortcuts for your imports.
Aliases can help improve the development experience in codebases with many directories or relative imports.
src/pages/about/company.astro
---
import Button from '../../components/controls/Button.astro';
import logoUrl from '../../assets/logo.png?url';
---
In this example, a developer would need to understand the tree relationship between src/pages/about/company.astro, src/components/controls/Button.astro, and src/assets/logo.png. And then, if the company.astro file were to be moved, these imports would also need to be updated.
You can add import aliases in tsconfig.json.
tsconfig.json
{
  ""compilerOptions"": {
    ""baseUrl"": ""."",
    ""paths"": {
      ""@components/*"": [""src/components/*""],
      ""@assets/*"": [""src/assets/*""]
    }
  }
}
Note
Make sure compilerOptions.baseUrl is set so the aliased paths can be resolved.
The development server will automatically restart after this configuration change. You can now import using the aliases anywhere in your project:
src/pages/about/company.astro
---
import Button from '@components/controls/Button.astro';
import logoUrl from '@assets/logo.png?url';
---
These aliases are also integrated automatically into VS Code and other editors.
Astro.glob()
Astro.glob() is a way to import many files at once.
Astro.glob() only takes one parameter: a relative glob pattern matching the local files you‚Äôd like to import. It‚Äôs asynchronous, and returns an array of each matching file‚Äôs exports.
src/components/my-component.astro
---
// imports all files that end with `.md` in `./src/pages/post/`
const posts = await Astro.glob('../pages/post/*.md');
---
<!-- Renders an <article> for the first 5 blog posts -->
<div>
{posts.slice(0, 4).map((post) => (
  <article>
    <h2>{post.frontmatter.title}</h2>
    <p>{post.frontmatter.description}</p>
    <a href={post.url}>Read more</a>
  </article>
))}
</div>
Astro components imported using Astro.glob are of type AstroInstance. You can render each component instance using its default property:
src/pages/component-library.astro
---
// imports all files that end with `.astro` in `./src/components/`
const components = await Astro.glob('../components/*.astro');
---
<!-- Display all of our components -->
{components.map((component) => (
  <div>
    <component.default size={24} />
  </div>
))}
Glob Patterns
A glob pattern is a file path that supports special wildcard characters. This is used to reference multiple files in your project at once.
For example, the glob pattern ./pages/**/*.{md,mdx} starts within the pages subdirectory, looks through all of its subdirectories (/**), and matches any filename (/*) that ends in either .md or .mdx (.{md,mdx}).
Glob Patterns in Astro
To use with Astro.glob(), the glob pattern must be a string literal and cannot contain any variables. See the troubleshooting guide for a workaround.
Additionally, glob patterns must begin with one of the following:
./ (to start in the current directory)
../ (to start in the parent directory)
/ (to start at the root of the project)
Read more about the glob pattern syntax.
Astro.glob() vs getCollection()
Content collections provide a getCollection() API for loading multiple files instead of Astro.glob(). If your content files (e.g. Markdown, MDX, Markdoc) are located in collections within the src/content/ directory, use getCollection() to query a collection and return content entries.
WASM
// Loads and initializes the requested WASM file
const wasm = await WebAssembly.instantiateStreaming(fetch('/example.wasm'));
Astro supports loading WASM files directly into your application using the browser‚Äôs WebAssembly API.
Node Builtins
We encourage Astro users to avoid Node.js builtins (fs, path, etc.) whenever possible. Astro is compatible with multiple runtimes using adapters. This includes Deno and Cloudflare Workers which do not support Node builtin modules such as fs.
Our aim is to provide Astro alternatives to common Node.js builtins. However, no such alternatives exist today. So, if you really need to use these builtin modules we don‚Äôt want to stop you. Astro supports Node.js builtins using Node‚Äôs newer node: prefix. If you want to read a file, for example, you can do so like this:
src/components/MyComponent.astro
---
// Example: import the ""fs/promises"" builtin from Node.js
import fs from 'node:fs/promises';
const url = new URL('../../package.json', import.meta.url);
const json = await fs.readFile(url, 'utf-8');
const data = JSON.parse(json);
---
<span>Version: {data.version}</span>
Extending file type support
With Vite and compatible Rollup plugins, you can import file types which aren‚Äôt natively supported by Astro. Learn where to find the plugins you need in the Finding Plugins section of the Vite Documentation.
Plugin configuration
Refer to your plugin‚Äôs documentation for configuration options, and how to correctly install it.
Related recipe:
Installing a Vite or Rollup plugin
Edit page
Translate this page
Previous
Rendering Modes
Next
Integrations
Contribute
Give us feedback
Community""""""",2364,10864,astro
https://docs.astro.build/en/guides/integrations-guide/,"""""""On this page
Overview
Official Integrations
Automatic Integration Setup
Manual Installation
Custom Options
Toggle an Integration
Upgrading Integrations
Automatic Upgrading
Manual Upgrading
Removing an Integration
Finding More Integrations
Building Your Own Integration
Want to build your own Docs?
Grab this template to get started.‚Üí
Add Integrations
Astro integrations add new functionality and behaviors for your project with only a few lines of code. You can use an official integration, integrations built by the community or even build a custom integration yourself.
Integrations can‚Ä¶
Unlock React, Vue, Svelte, Solid, and other popular UI frameworks with a renderer.
Enable on-demand rendering with an SSR adapter.
Integrate tools like Tailwind, and Partytown with a few lines of code.
Add new features to your project, like automatic sitemap generation.
Write custom code that hooks into the build process, dev server, and more.
Integrations directory
Browse or search the complete set of hundreds of official and community integrations in our integrations directory. Find packages to add to your Astro project for authentication, analytics, performance, SEO, accessibility, UI, developer tools, and more.
Official Integrations
The following integrations are maintained by Astro.
UI Frameworks
@astrojs/alpinejs
@astrojs/lit
@astrojs/preact
@astrojs/react
@astrojs/solid‚Å†-‚Å†js
@astrojs/svelte
@astrojs/vue
SSR Adapters
@astrojs/cloudflare
@astrojs/netlify
@astrojs/node
@astrojs/vercel
Other integrations
@astrojs/db
@astrojs/markdoc
@astrojs/mdx
@astrojs/partytown
@astrojs/sitemap
@astrojs/tailwind
Automatic Integration Setup
Astro includes an astro add command to automate the setup of official integrations. Several community plugins can also be added using this command. Please check each integration‚Äôs own documentation to see whether astro add is supported, or whether you must install manually.
Run the astro add command using the package manager of your choice and our automatic integration wizard will update your configuration file and install any necessary dependencies.
npm
pnpm
Yarn
Terminal window
yarn astro add react
It‚Äôs even possible to add multiple integrations at the same time!
npm
pnpm
Yarn
Terminal window
yarn astro add react tailwind partytown
Handling integration dependencies
If you see any warnings like Cannot find package '[package-name]' after adding an integration, your package manager may not have installed peer dependencies for you. To install these missing packages, run npm install [package-name].
Manual Installation
Astro integrations are always added through the integrations property in your astro.config.mjs file.
There are three common ways to import an integration into your Astro project:
Install an npm package integration.
Import your own integration from a local file inside your project.
Write your integration inline, directly in your config file.
astro.config.mjs
import { defineConfig } from 'astro/config';
import installedIntegration from '@astrojs/vue';
import localIntegration from './my-integration.js';
export default defineConfig({
  integrations: [
    // 1. Imported from an installed npm package
    installedIntegration(),
    // 2. Imported from a local JS file
    localIntegration(),
    // 3. An inline object
    {name: 'namespace:id', hooks: { /* ... */ }},
  ]
});
Check out the Integration API reference to learn all of the different ways that you can write an integration.
Installing an NPM package
Install an NPM package integration using a package manager, and then update astro.config.mjs manually.
For example, to install the @astrojs/sitemap integration:
Install the integration to your project dependencies using your preferred package manager:
npm
pnpm
Yarn
Terminal window
yarn add @astrojs/sitemap
Import the integration to your astro.config.mjs file, and add it to your integrations[] array, along with any configuration options:
astro.config.mjs
import { defineConfig } from 'astro/config';
import sitemap from '@astrojs/sitemap';
export default defineConfig({
  // ...
  integrations: [sitemap()],
  // ...
});
Note that different integrations may have different configuration settings. Read each integration‚Äôs documentation, and apply any necessary config options to your chosen integration in astro.config.mjs
Custom Options
Integrations are almost always authored as factory functions that return the actual integration object. This lets you pass arguments and options to the factory function that customize the integration for your project.
integrations: [
  // Example: Customize your integration with function arguments
  sitemap({filter: true})
]
Toggle an Integration
Falsy integrations are ignored, so you can toggle integrations on & off without worrying about left-behind undefined and boolean values.
integrations: [
  // Example: Skip building a sitemap on Windows
  process.platform !== 'win32' && sitemap()
]
Upgrading Integrations
To upgrade all official integrations at once, run the @astrojs/upgrade command. This will upgrade both Astro and all official integrations to their latest versions.
Automatic Upgrading
npm
pnpm
Yarn
Terminal window
# Upgrade Astro and official integrations together to latest
yarn dlx @astrojs/upgrade
Manual Upgrading
To upgrade one or more integrations manually, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
# Example: upgrade React and Tailwind integrations
yarn add @astrojs/react@latest @astrojs/tailwind@latest
Removing an Integration
To remove an integration, first uninstall the integration from your project
npm
pnpm
Yarn
Terminal window
yarn remove @astrojs/react
Next, remove the integration from your astro.config.* file:
astro.config.mjs
import { defineConfig } from 'astro/config';
import react from '@astrojs/react';
export default defineConfig({
  integrations: [
    react()
  ]
});
Finding More Integrations
You can find many integrations developed by the community in the Astro Integrations Directory. Follow links there for detailed usage and configuration instructions.
Building Your Own Integration
Astro‚Äôs Integration API is inspired by Rollup and Vite, and designed to feel familiar to anyone who has ever written a Rollup or Vite plugin before.
Check out the Integration API reference to learn what integrations can do and how to write one yourself.
Edit page
Translate this page
Previous
Imports
Next
Authoring Content
Contribute
Give us feedback
Community

On this page
Overview
Official Integrations
Automatic Integration Setup
Manual Installation
Custom Options
Toggle an Integration
Upgrading Integrations
Automatic Upgrading
Manual Upgrading
Removing an Integration
Finding More Integrations
Building Your Own Integration
Want to build your own Docs?
Grab this template to get started.‚Üí
Add Integrations
Astro integrations add new functionality and behaviors for your project with only a few lines of code. You can use an official integration, integrations built by the community or even build a custom integration yourself.
Integrations can‚Ä¶
Unlock React, Vue, Svelte, Solid, and other popular UI frameworks with a renderer.
Enable on-demand rendering with an SSR adapter.
Integrate tools like Tailwind, and Partytown with a few lines of code.
Add new features to your project, like automatic sitemap generation.
Write custom code that hooks into the build process, dev server, and more.
Integrations directory
Browse or search the complete set of hundreds of official and community integrations in our integrations directory. Find packages to add to your Astro project for authentication, analytics, performance, SEO, accessibility, UI, developer tools, and more.
Official Integrations
The following integrations are maintained by Astro.
UI Frameworks
@astrojs/alpinejs
@astrojs/lit
@astrojs/preact
@astrojs/react
@astrojs/solid‚Å†-‚Å†js
@astrojs/svelte
@astrojs/vue
SSR Adapters
@astrojs/cloudflare
@astrojs/netlify
@astrojs/node
@astrojs/vercel
Other integrations
@astrojs/db
@astrojs/markdoc
@astrojs/mdx
@astrojs/partytown
@astrojs/sitemap
@astrojs/tailwind
Automatic Integration Setup
Astro includes an astro add command to automate the setup of official integrations. Several community plugins can also be added using this command. Please check each integration‚Äôs own documentation to see whether astro add is supported, or whether you must install manually.
Run the astro add command using the package manager of your choice and our automatic integration wizard will update your configuration file and install any necessary dependencies.
npm
pnpm
Yarn
Terminal window
npx astro add react
It‚Äôs even possible to add multiple integrations at the same time!
npm
pnpm
Yarn
Terminal window
npx astro add react tailwind partytown
Handling integration dependencies
If you see any warnings like Cannot find package '[package-name]' after adding an integration, your package manager may not have installed peer dependencies for you. To install these missing packages, run npm install [package-name].
Manual Installation
Astro integrations are always added through the integrations property in your astro.config.mjs file.
There are three common ways to import an integration into your Astro project:
Install an npm package integration.
Import your own integration from a local file inside your project.
Write your integration inline, directly in your config file.
astro.config.mjs
import { defineConfig } from 'astro/config';
import installedIntegration from '@astrojs/vue';
import localIntegration from './my-integration.js';
export default defineConfig({
  integrations: [
    // 1. Imported from an installed npm package
    installedIntegration(),
    // 2. Imported from a local JS file
    localIntegration(),
    // 3. An inline object
    {name: 'namespace:id', hooks: { /* ... */ }},
  ]
});
Check out the Integration API reference to learn all of the different ways that you can write an integration.
Installing an NPM package
Install an NPM package integration using a package manager, and then update astro.config.mjs manually.
For example, to install the @astrojs/sitemap integration:
Install the integration to your project dependencies using your preferred package manager:
npm
pnpm
Yarn
Terminal window
npm install @astrojs/sitemap
Import the integration to your astro.config.mjs file, and add it to your integrations[] array, along with any configuration options:
astro.config.mjs
import { defineConfig } from 'astro/config';
import sitemap from '@astrojs/sitemap';
export default defineConfig({
  // ...
  integrations: [sitemap()],
  // ...
});
Note that different integrations may have different configuration settings. Read each integration‚Äôs documentation, and apply any necessary config options to your chosen integration in astro.config.mjs
Custom Options
Integrations are almost always authored as factory functions that return the actual integration object. This lets you pass arguments and options to the factory function that customize the integration for your project.
integrations: [
  // Example: Customize your integration with function arguments
  sitemap({filter: true})
]
Toggle an Integration
Falsy integrations are ignored, so you can toggle integrations on & off without worrying about left-behind undefined and boolean values.
integrations: [
  // Example: Skip building a sitemap on Windows
  process.platform !== 'win32' && sitemap()
]
Upgrading Integrations
To upgrade all official integrations at once, run the @astrojs/upgrade command. This will upgrade both Astro and all official integrations to their latest versions.
Automatic Upgrading
npm
pnpm
Yarn
Terminal window
# Upgrade Astro and official integrations together to latest
npx @astrojs/upgrade
Manual Upgrading
To upgrade one or more integrations manually, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
# Example: upgrade React and Tailwind integrations
npm install @astrojs/react@latest @astrojs/tailwind@latest
Removing an Integration
To remove an integration, first uninstall the integration from your project
npm
pnpm
Yarn
Terminal window
npm uninstall @astrojs/react
Next, remove the integration from your astro.config.* file:
astro.config.mjs
import { defineConfig } from 'astro/config';
import react from '@astrojs/react';
export default defineConfig({
  integrations: [
    react()
  ]
});
Finding More Integrations
You can find many integrations developed by the community in the Astro Integrations Directory. Follow links there for detailed usage and configuration instructions.
Building Your Own Integration
Astro‚Äôs Integration API is inspired by Rollup and Vite, and designed to feel familiar to anyone who has ever written a Rollup or Vite plugin before.
Check out the Integration API reference to learn what integrations can do and how to write one yourself.
Edit page
Translate this page
Previous
Imports
Next
Authoring Content
Contribute
Give us feedback
Community

On this page
Overview
Official Integrations
Automatic Integration Setup
Manual Installation
Custom Options
Toggle an Integration
Upgrading Integrations
Automatic Upgrading
Manual Upgrading
Removing an Integration
Finding More Integrations
Building Your Own Integration
Want to build your own Docs?
Grab this template to get started.‚Üí
Add Integrations
Astro integrations add new functionality and behaviors for your project with only a few lines of code. You can use an official integration, integrations built by the community or even build a custom integration yourself.
Integrations can‚Ä¶
Unlock React, Vue, Svelte, Solid, and other popular UI frameworks with a renderer.
Enable on-demand rendering with an SSR adapter.
Integrate tools like Tailwind, and Partytown with a few lines of code.
Add new features to your project, like automatic sitemap generation.
Write custom code that hooks into the build process, dev server, and more.
Integrations directory
Browse or search the complete set of hundreds of official and community integrations in our integrations directory. Find packages to add to your Astro project for authentication, analytics, performance, SEO, accessibility, UI, developer tools, and more.
Official Integrations
The following integrations are maintained by Astro.
UI Frameworks
@astrojs/alpinejs
@astrojs/lit
@astrojs/preact
@astrojs/react
@astrojs/solid‚Å†-‚Å†js
@astrojs/svelte
@astrojs/vue
SSR Adapters
@astrojs/cloudflare
@astrojs/netlify
@astrojs/node
@astrojs/vercel
Other integrations
@astrojs/db
@astrojs/markdoc
@astrojs/mdx
@astrojs/partytown
@astrojs/sitemap
@astrojs/tailwind
Automatic Integration Setup
Astro includes an astro add command to automate the setup of official integrations. Several community plugins can also be added using this command. Please check each integration‚Äôs own documentation to see whether astro add is supported, or whether you must install manually.
Run the astro add command using the package manager of your choice and our automatic integration wizard will update your configuration file and install any necessary dependencies.
npm
pnpm
Yarn
Terminal window
pnpm astro add react
It‚Äôs even possible to add multiple integrations at the same time!
npm
pnpm
Yarn
Terminal window
pnpm astro add react tailwind partytown
Handling integration dependencies
If you see any warnings like Cannot find package '[package-name]' after adding an integration, your package manager may not have installed peer dependencies for you. To install these missing packages, run npm install [package-name].
Manual Installation
Astro integrations are always added through the integrations property in your astro.config.mjs file.
There are three common ways to import an integration into your Astro project:
Install an npm package integration.
Import your own integration from a local file inside your project.
Write your integration inline, directly in your config file.
astro.config.mjs
import { defineConfig } from 'astro/config';
import installedIntegration from '@astrojs/vue';
import localIntegration from './my-integration.js';
export default defineConfig({
  integrations: [
    // 1. Imported from an installed npm package
    installedIntegration(),
    // 2. Imported from a local JS file
    localIntegration(),
    // 3. An inline object
    {name: 'namespace:id', hooks: { /* ... */ }},
  ]
});
Check out the Integration API reference to learn all of the different ways that you can write an integration.
Installing an NPM package
Install an NPM package integration using a package manager, and then update astro.config.mjs manually.
For example, to install the @astrojs/sitemap integration:
Install the integration to your project dependencies using your preferred package manager:
npm
pnpm
Yarn
Terminal window
pnpm add @astrojs/sitemap
Import the integration to your astro.config.mjs file, and add it to your integrations[] array, along with any configuration options:
astro.config.mjs
import { defineConfig } from 'astro/config';
import sitemap from '@astrojs/sitemap';
export default defineConfig({
  // ...
  integrations: [sitemap()],
  // ...
});
Note that different integrations may have different configuration settings. Read each integration‚Äôs documentation, and apply any necessary config options to your chosen integration in astro.config.mjs
Custom Options
Integrations are almost always authored as factory functions that return the actual integration object. This lets you pass arguments and options to the factory function that customize the integration for your project.
integrations: [
  // Example: Customize your integration with function arguments
  sitemap({filter: true})
]
Toggle an Integration
Falsy integrations are ignored, so you can toggle integrations on & off without worrying about left-behind undefined and boolean values.
integrations: [
  // Example: Skip building a sitemap on Windows
  process.platform !== 'win32' && sitemap()
]
Upgrading Integrations
To upgrade all official integrations at once, run the @astrojs/upgrade command. This will upgrade both Astro and all official integrations to their latest versions.
Automatic Upgrading
npm
pnpm
Yarn
Terminal window
# Upgrade Astro and official integrations together to latest
pnpm dlx @astrojs/upgrade
Manual Upgrading
To upgrade one or more integrations manually, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
# Example: upgrade React and Tailwind integrations
pnpm add @astrojs/react@latest @astrojs/tailwind@latest
Removing an Integration
To remove an integration, first uninstall the integration from your project
npm
pnpm
Yarn
Terminal window
pnpm remove @astrojs/react
Next, remove the integration from your astro.config.* file:
astro.config.mjs
import { defineConfig } from 'astro/config';
import react from '@astrojs/react';
export default defineConfig({
  integrations: [
    react()
  ]
});
Finding More Integrations
You can find many integrations developed by the community in the Astro Integrations Directory. Follow links there for detailed usage and configuration instructions.
Building Your Own Integration
Astro‚Äôs Integration API is inspired by Rollup and Vite, and designed to feel familiar to anyone who has ever written a Rollup or Vite plugin before.
Check out the Integration API reference to learn what integrations can do and how to write one yourself.
Edit page
Translate this page
Previous
Imports
Next
Authoring Content
Contribute
Give us feedback
Community""""""",4146,19388,astro
https://docs.astro.build/en/guides/content/,"""""""On this page
Overview
Writing Content
Markdown Authoring
MDX Authoring
Headless CMS Authoring
Managing content pages
Page files
Local content
Content collections
Remote content
Showcasing your content
Community Integrations
Want to build your own Docs?
Grab this template to get started.‚Üí
Authoring Content
Astro is a perfect choice for your content-focused site: blogs, marketing sites, portfolios, and more!
Astro helps you author and present your content. You can write a blog post directly in Astro using Markdown/MDX, or fetch your content from a headless CMS. Astro lets you build a site around your content: you can add a layout to your pages, create an index of posts, and set up an RSS feed to allow readers to subscribe.
Writing Content
In Astro, you can author your content in a variety of ways:
In Markdown files (.md or alternative extensions), designed to make it easy to write rich text content.
In MDX (.mdx) or Markdoc (.mdoc) files with an official integration, which can include components and dynamic expressions in your document.
Using a third-party content management system (CMS), then pulling that content into a .astro page.
Other options (less commonly used for content-heavy pages) include .astro files and .html files.
Markdown Authoring
Markdown is a convenient syntax for writing rich text with basic formatting and common elements like headers, lists, and images. Astro has built-in support for Markdown files in your project.
Create and write a new .md file in your code editor or bring in an existing file written in your favorite Markdown editor. Some online Markdown editors like StackEdit and Dillinger will even allow you to edit and sync your work with your Astro repository stored on GitHub.
Learn more about writing Markdown content in Astro.
MDX Authoring
If you add the Astro MDX integration to your project, you can also write content using .mdx files, which can include JavaScript expressions and components within your Markdown. This includes both static Astro components and interactive framework components. This allows you to include UI elements such as a banner or an interactive carousel along with your text content.
Write and edit .mdx files directly in your code editor, alongside your project files. MDX files are a supported page file type in Astro, and may also be used as content collection entries.
Learn more about using MDX with Astro.
Headless CMS Authoring
Write blog posts in your existing Content Management System (CMS) such as Storyblok, WordPress, or Contentful. Some CMSes, like Storyblok, provide an official Astro integration. Others expose a JavaScript SDK that Astro pages can use to fetch your remote content.
Explore our collection of CMS guides and Astro CMS integrations for a wide selection of resources.
Managing content pages
Page files
Markdown and MDX files that live in your src/pages directory will automatically generate pages on your site using Astro‚Äôs file-based routing, built at a URL corresponding to the post‚Äôs file path.
Local content
You can also choose to keep your Markdown and MDX files outside of the src/pages directory, and instead import their content into .astro pages.
Content collections
Astro‚Äôs own content collections provide a powerful, type-safe way to work with Markdown, MDX, or Markdoc content organized in the src/content/ directory.
Remote content
You can also fetch markdown remotely from a source outside of your project. This will require your own Markdown parser, or a community integration (e.g. astro-remote).
Showcasing your content
To build common features to organize and display your content, such as a blog archive or a page for each blog tag, Astro allows you to fetch filenames and metadata from your Markdown and MDX frontmatter or use content collection helper utilities to query your entries and generate page content and routes.
To publish to a broader audience, create an RSS feed that can be distributed to feed readers.
Community Integrations
In addition to the official @astrojs/mdx and @astrojs/markdoc integrations, there are several third-party community integrations for working with content in your Astro project.
Edit page
Translate this page
Previous
Integrations
Next
Markdown
Contribute
Give us feedback
Community""""""",870,4254,astro
https://docs.astro.build/en/guides/markdown-content/,"""""""On this page
Overview
Organizing Markdown files
Dynamic JSX-like expressions
Available Properties
The <Content /> Component
Heading IDs
Heading IDs and plugins
Markdown Plugins
Adding remark and rehype plugins
Customizing a plugin
Modifying frontmatter programmatically
Extending Markdown config from MDX
Individual Markdown pages
Frontmatter layout property
Fetching Remote Markdown
Want to build your own Docs?
Grab this template to get started.‚Üí
Markdown in Astro
Markdown is commonly used to author text-heavy content like blog posts and documentation. Astro includes built-in support for Markdown files that can also include frontmatter YAML to define custom properties such as a title, description, and tags.
In Astro, you can author content in GitHub Flavored Markdown, then render it in .astro components. This combines a familiar writing format designed for content with the flexibility of Astro‚Äôs component syntax and architecture.
Tip
For additional functionality, such as including components and JSX expressions in Markdown, add the @astrojs/mdx integration to write your Markdown content using MDX.
Organizing Markdown files
Your local Markdown files can be kept anywhere within your src/ directory. Local Markdown can be imported into .astro components using an import statement for a single file and Vite‚Äôs import.meta.glob() to query multiple files at once.
If you have groups of related Markdown files, consider defining them as collections. This gives you several advantages, including the ability to store Markdown files anywhere on your filesystem or remotely.
Collections also allow you to use content-specfic, optimized API for querying and rendering your content. Collections are intended for sets of data that share the same structure, such as blog posts or product items. When you define that shape in a schema, you additionally get validation, type safety, and Intellisense in your editor.
Dynamic JSX-like expressions
After importing or querying Markdown files, you can write dynamic HTML templates in your .astro components that include frontmatter data and body content.
src/posts/great-post.md
---
title: 'The greatest post of all time'
author: 'Ben'
---
Here is my _great_ post!
src/pages/my-posts.astro
---
import * as greatPost from '../posts/great-post.md';
const posts = Object.values(await import.meta.glob('../posts/*.md', { eager: true }));
---
<p>{greatPost.frontmatter.title}</p>
<p>Written by: {greatPost.frontmatter.author}</p>
<p>Post Archive:</p>
<ul>
  {posts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
</ul>
Available Properties
Querying collections
When fetching data from your collections via helper functions, your Markdown‚Äôs frontmatter properties are available on a data object (e.g. post.data.title). Additionally, body contains the raw, uncompiled body content as a string.
See the full CollectionEntry type.
Importing Markdown
The following exported properties are available in your .astro component when importing Markdown using import or import.meta.glob():
file - The absolute file path (e.g. /home/user/projects/.../file.md).
url - The URL of the page (e.g. /en/guides/markdown-content).
frontmatter - Contains any data specified in the file‚Äôs YAML frontmatter.
<Content /> - A component that returns the full, rendered contents of the file.
rawContent() - A function that returns the raw Markdown document as a string.
compiledContent() - A function that returns the Markdown document compiled to an HTML string.
getHeadings() - An async function that returns an array of all headings (<h1> to <h6>) in the file with the type: { depth: number; slug: string; text: string }[]. Each heading‚Äôs slug corresponds to the generated ID for a given heading and can be used for anchor links.
An example Markdown blog post may pass the following Astro.props object:
Astro.props = {
  file: ""/home/user/projects/.../file.md"",
  url: ""/en/guides/markdown-content/"",
  frontmatter: {
    /** Frontmatter from a blog post */
    title: ""Astro 0.18 Release"",
    date: ""Tuesday, July 27 2021"",
    author: ""Matthew Phillips"",
    description: ""Astro 0.18 is our biggest release since Astro launch."",
  },
  getHeadings: () => [
    {""depth"": 1, ""text"": ""Astro 0.18 Release"", ""slug"": ""astro-018-release""},
    {""depth"": 2, ""text"": ""Responsive partial hydration"", ""slug"": ""responsive-partial-hydration""}
    /* ... */
  ],
  rawContent: () => ""# Astro 0.18 Release\nA little over a month ago, the first public beta [...]"",
  compiledContent: () => ""<h1>Astro 0.18 Release</h1>\n<p>A little over a month ago, the first public beta [...]</p>"",
}
The <Content /> Component
The <Content /> component is available by importing Content from a Markdown file. This component returns the file‚Äôs full body content, rendered to HTML. You can optionally rename Content to any component name you prefer.
You can similarly render the HTML content of a Markdown collection entry by rendering a <Content /> component.
src/pages/content.astro
---
// Import statement
import {Content as PromoBanner} from '../components/promoBanner.md';
// Collections query
import { getEntry, render } from 'astro:content';
const product = await getEntry('products', 'shirt');
const { Content } = await render();
---
<h2>Today's promo</h2>
<PromoBanner />
<p>Sale Ends: {product.data.saleEndDate.toDateString()}</p>
<Content />
Heading IDs
Writing headings in Markdown will automatically give you anchor links so you can link directly to certain sections of your page.
src/pages/page-1.md
---
title: My page of content
---
## Introduction
I can link internally to [my conclusion](#conclusion) on the same page when writing Markdown.
## Conclusion
I can visit `https://example.com/page-1/#introduction` in a browser to navigate directly to my Introduction.
Astro generates heading ids based on github-slugger. You can find more examples in the github-slugger documentation.
Heading IDs and plugins
Astro injects an id attribute into all heading elements (<h1> to <h6>) in Markdown and MDX files and provides a getHeadings() utility for retrieving these IDs in Markdown exported properties.
You can customize these heading IDs by adding a rehype plugin that injects id attributes (e.g. rehype-slug). Your custom IDs, instead of Astro‚Äôs defaults, will be reflected in the HTML output and the items returned by getHeadings().
By default, Astro injects id attributes after your rehype plugins have run. If one of your custom rehype plugins needs to access the IDs injected by Astro, you can import and use Astro‚Äôs rehypeHeadingIds plugin directly. Be sure to add rehypeHeadingIds before any plugins that rely on it:
astro.config.mjs
import { defineConfig } from 'astro/config';
import { rehypeHeadingIds } from '@astrojs/markdown-remark';
import { otherPluginThatReliesOnHeadingIDs } from 'some/plugin/source';
export default defineConfig({
  markdown: {
    rehypePlugins: [
      rehypeHeadingIds,
      otherPluginThatReliesOnHeadingIDs,
    ],
  },
});
Markdown Plugins
Markdown support in Astro is powered by remark, a powerful parsing and processing tool with an active ecosystem. Other Markdown parsers like Pandoc and markdown-it are not currently supported.
Astro applies the GitHub-flavored Markdown and SmartyPants plugins by default. This brings some niceties like generating clickable links from text, and formatting for quotations and em-dashes.
You can customize how remark parses your Markdown in astro.config.mjs. See the full list of Markdown configuration options.
Adding remark and rehype plugins
Astro supports adding third-party remark and rehype plugins for Markdown. These plugins allow you to extend your Markdown with new capabilities, like auto-generating a table of contents, applying accessible emoji labels, and styling your Markdown.
We encourage you to browse awesome-remark and awesome-rehype for popular plugins! See each plugin‚Äôs own README for specific installation instructions.
This example applies remark-toc and rehype-accessible-emojis to Markdown files:
astro.config.mjs
import { defineConfig } from 'astro/config';
import remarkToc from 'remark-toc';
import { rehypeAccessibleEmojis } from 'rehype-accessible-emojis';
export default defineConfig({
  markdown: {
    remarkPlugins: [ [remarkToc, { heading: 'toc', maxDepth: 3 } ] ],
    rehypePlugins: [rehypeAccessibleEmojis],
  },
});
Customizing a plugin
In order to customize a plugin, provide an options object after it in a nested array.
The example below adds the heading option to the remarkToc plugin to change where the table of contents is placed, and the behavior option to the rehype-autolink-headings plugin in order to add the anchor tag after the headline text.
astro.config.mjs
import remarkToc from 'remark-toc';
import rehypeSlug from 'rehype-slug';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
export default {
  markdown: {
    remarkPlugins: [ [remarkToc, { heading: ""contents""} ] ],
    rehypePlugins: [rehypeSlug, [rehypeAutolinkHeadings, { behavior: 'append' }]],
  },
}
Modifying frontmatter programmatically
You can add frontmatter properties to all of your Markdown and MDX files by using a remark or rehype plugin.
Append a customProperty to the data.astro.frontmatter property from your plugin‚Äôs file argument:
example-remark-plugin.mjs
export function exampleRemarkPlugin() {
  // All remark and rehype plugins return a separate function
  return function (tree, file) {
    file.data.astro.frontmatter.customProperty = 'Generated property';
  }
}
Tip
Added in: astro@2.0.0
data.astro.frontmatter contains all properties from a given Markdown or MDX document. This allows you to modify existing frontmatter properties, or compute new properties from this existing frontmatter.
Apply this plugin to your markdown or mdx integration config:
astro.config.mjs
import { defineConfig } from 'astro/config';
import { exampleRemarkPlugin } from './example-remark-plugin.mjs';
export default defineConfig({
  markdown: {
    remarkPlugins: [exampleRemarkPlugin]
  },
});
or
astro.config.mjs
import { defineConfig } from 'astro/config';
import { exampleRemarkPlugin } from './example-remark-plugin.mjs';
export default defineConfig({
  integrations: [
    mdx({
      remarkPlugins: [exampleRemarkPlugin],
    }),
  ],
});
Now, every Markdown or MDX file will have customProperty in its frontmatter, making it available when importing your markdown and from the Astro.props.frontmatter property in your layouts.
Related recipe:
Add reading time
Extending Markdown config from MDX
Astro‚Äôs MDX integration will extend your project‚Äôs existing Markdown configuration by default. To override individual options, you can specify their equivalent in your MDX configuration.
The following example disables GitHub-Flavored Markdown and applies a different set of remark plugins for MDX files:
astro.config.mjs
import { defineConfig } from 'astro/config';
import mdx from '@astrojs/mdx';
export default defineConfig({
  markdown: {
    syntaxHighlight: 'prism',
    remarkPlugins: [remarkPlugin1],
    gfm: true,
  },
  integrations: [
    mdx({
      // `syntaxHighlight` inherited from Markdown
      // Markdown `remarkPlugins` ignored,
      // only `remarkPlugin2` applied.
      remarkPlugins: [remarkPlugin2],
      // `gfm` overridden to `false`
      gfm: false,
    })
  ]
});
To avoid extending your Markdown config from MDX, set the extendMarkdownConfig option (enabled by default) to false:
astro.config.mjs
import { defineConfig } from 'astro/config';
import mdx from '@astrojs/mdx';
export default defineConfig({
  markdown: {
    remarkPlugins: [remarkPlugin],
  },
  integrations: [
    mdx({
      // Markdown config now ignored
      extendMarkdownConfig: false,
      // No `remarkPlugins` applied
    })
  ]
});
Individual Markdown pages
Tip
Content collections and importing Markdown into .astro components provide more features for rendering your Markdown and are the recommended way to handle most of your content. However, there may be times when you want the convenience of just adding a file to src/pages/ and having a simple page automatically created for you.
Astro treats any supported file inside of the /src/pages/ directory as a page, including .md and other Markdown file types.
Placing a file in this directory, or any sub-directory, will automatically build a page route using the pathname of the file and display the Markdown content rendered to HTML.
src/pages/page-1.md
---
title: Hello, World
---
# Hi there!
This Markdown file creates a page at `your-domain.com/page-1/`
It probably isn't styled much, but Markdown does support:
- **bold** and _italics._
- lists
- [links](https://astro.build)
- <p>HTML elements</p>
- and more!
Frontmatter layout property
To help with the limited functionality of Markdown pages, Astro provides a special frontmatter layout property which is a relative path to an Astro Markdown layout component. If your Markdown file is located within src/pages/, create a layout component and add it in this layout property to provide a page shell around your Markdown content.
src/pages/posts/post-1.md
---
layout: ../../layouts/BlogPostLayout.astro
title: Astro in brief
author: Himanshu
description: Find out what makes Astro awesome!
---
This is a post written in Markdown.
This layout component is a regular Astro component with specific properties automatically available through Astro.props for your Astro template. For example, you can access your Markdown file‚Äôs frontmatter properties through Astro.props.frontmatter:
src/layouts/BlogPostLayout.astro
---
const {frontmatter} = Astro.props;
---
<html>
  <!-- ... -->
  <h1>{frontmatter.title}</h1>
  <h2>Post author: {frontmatter.author}</h2>
  <p>{frontmatter.description}</p>
  <slot /> <!-- Markdown content is injected here -->
  <!-- ... -->
</html>
You can also style your Markdown in your layout component.
Learn more about Markdown Layouts.
Fetching Remote Markdown
Astro does not include built-in support for remote Markdown outside of experimental content collections!
To fetch remote Markdown directly and render it to HTML, you will need to install and configure your own Markdown parser from NPM. This will not inherit from any of Astro‚Äôs built-in Markdown settings that you have configured.
Be sure that you understand these limitations before implementing this in your project, and consider fetching your remote Markdown using a content collections loader instead.
src/pages/remote-example.astro
---
// Example: Fetch Markdown from a remote API
// and render it to HTML, at runtime.
// Using ""marked"" (https://github.com/markedjs/marked)
import { marked } from 'marked';
const response = await fetch('https://raw.githubusercontent.com/wiki/adam-p/markdown-here/Markdown-Cheatsheet.md');
const markdown = await response.text();
const content = marked.parse(markdown);
---
<article set:html={content} />
Edit page
Translate this page
Previous
Authoring Content
Next
Content Collections
Contribute
Give us feedback
Community""""""",3334,15009,astro
https://docs.astro.build/en/guides/content-collections/,"""""""On this page
Overview
What are Content Collections?
The ‚Äú.astro‚Äù Directory
Organizing with multiple collections
Organizing with subdirectories
Defining Collections
Setting up TypeScript
Defining a collection schema
Defining multiple collections
Using third-party collection schemas
Defining datatypes with Zod
Defining collection references
Defining custom slugs
Querying Collections
Accessing referenced data
Filtering collection queries
Using content in Astro templates
Passing content as props
Rendering content to HTML
Generating Routes from Content
Building for static output (default)
Building for server output (SSR)
Migrating from File-Based Routing
Enabling JSON Schema Generation
Enabling Build Caching
Modifying Frontmatter with Remark
Working with dates in the frontmatter
Want to build your own Docs?
Grab this template to get started.‚Üí
Want to try the new content collections? Upgrade to the v5 beta!
Content Collections
Added in: astro@2.0.0
Content collections are the best way to manage and author content in any Astro project. Collections help to organize your documents, validate your frontmatter, and provide automatic TypeScript type-safety for all of your content.
What are Content Collections?
A content collection is any top-level directory inside the reserved src/content project directory, such as src/content/newsletter and src/content/authors. Only content collections are allowed inside the src/content directory. This directory cannot be used for anything else.
A collection entry is any piece of content stored inside of your content collection directory. Entries can use content authoring formats including Markdown (.md) and MDX (.mdx using the MDX integration) or as one of two supported data formats: YAML (.yaml) and JSON (.json). We recommend using a consistent naming scheme (lower-case, dashes instead of spaces) for your files to make it easier to find and organize your content, but this is not required. You can also exclude entries from being built by prefixing the filename with an underscore (_).
Directory
src/content/
Directory
newsletter/
the ‚Äúnewsletter‚Äù collection
week-1.md
a collection entry
week-2.md
a collection entry
week-3.md
a collection entry
Once you have a collection, you can start querying your content using Astro‚Äôs built-in content APIs.
The ‚Äú.astro‚Äù Directory
Astro stores important metadata for content collections in an .astro directory in your project. No action is needed on your part to maintain or update this directory. You are encouraged to ignore it entirely while working in your project.
The .astro directory will be updated for you automatically anytime you run the astro dev, astro build commands. You can run astro sync at any time to update the .astro directory manually.
Tip
If you‚Äôre using Git for version control, we recommend ignoring the .astro directory by adding .astro to your .gitignore. This tells Git to ignore this directory and any files inside of it.
Organizing with multiple collections
If two files represent different kinds of content (e.g. a blog post and an author profile), they most likely belong in different collections. This is important because many features (frontmatter validation, automatic TypeScript type-safety) require that all entries in a collection share a similar structure.
If you find yourself working with different types of content, you should create multiple collections to represent each type. You can create as many different collections in your project as you‚Äôd like.
Directory
src/content/
Directory
newsletter/
week-1.md
week-2.md
Directory
blog/
post-1.md
post-2.md
Directory
authors/
grace-hopper.json
alan-turing.json
Organizing with subdirectories
A content collection is always a top-level folder inside of the src/content/ directory. You cannot nest one collection inside of another. However, you can use subdirectories to organize your content within a collection.
For example, you can use the following directory structure to organize i18n translations within a single docs collection. When you query this collection, you‚Äôll be able to filter the result by language using the file path.
Directory
src/content/
Directory
docs/
this collection uses subdirectories to organize by language
Directory
en/
Directory
es/
Directory
de/
Defining Collections
Note
The src/content/config.ts file is optional. However, choosing not to define your collections will disable some of their best features like frontmatter schema validation or automatic TypeScript typings.
To get the most out of your content collections, create a src/content/config.ts file in your project (.js and .mjs extensions are also supported.) This is a special file that Astro will automatically load and use to configure your content collections.
src/content/config.ts
// 1. Import utilities from `astro:content`
import { defineCollection } from 'astro:content';
// 2. Define your collection(s)
const blogCollection = defineCollection({ /* ... */ });
// 3. Export a single `collections` object to register your collection(s)
//    This key should match your collection directory name in ""src/content""
export const collections = {
  'blog': blogCollection,
};
Setting up TypeScript
If you do not already extend Astro‚Äôs strict or strictest recommended TypeScript settings in your tsconfig.json file, you may need to update your tsconfig.json to enable strictNullChecks.
tsconfig.json
{
  // Note: No change needed if you use ""astro/tsconfigs/strict"" or ""astro/tsconfigs/strictest""
  ""extends"": ""astro/tsconfigs/base"",
  ""compilerOptions"": {
    ""strictNullChecks"": true
  }
}
If you use .js or .mjs files in an Astro project, you can enable IntelliSense and type checking in your editor by enabling allowJs in your tsconfig.json:
tsconfig.json
{
  // Note: No change needed if you use ""astro/tsconfigs/strict"" or ""astro/tsconfigs/strictest""
  ""extends"": ""astro/tsconfigs/base"",
  ""compilerOptions"": {
    ""strictNullChecks"": true,
    ""allowJs"": true
  }
}
Defining a collection schema
Schemas enforce consistent frontmatter or entry data within a collection. A schema guarantees that this data exists in a predictable form when you need to reference or query it. If any file violates its collection schema, Astro will provide a helpful error to let you know.
Schemas also power Astro‚Äôs automatic TypeScript typings for your content. When you define a schema for your collection, Astro will automatically generate and apply a TypeScript interface to it. The result is full TypeScript support when you query your collection, including property autocompletion and type-checking.
To define your first collection, create a src/content/config.ts file if one does not already exist (.js and .mjs extensions are also supported.) This file should:
Import the proper utilities from astro:content.
Define each collection that you‚Äôd like to validate. This includes a type (introduced in Astro v2.5.0) specifying whether the collection contains content authoring formats like Markdown (type: 'content') or data formats like JSON or YAML (type: 'data'). It also includes a schema that defines the shape of your frontmatter or entry data.
Export a single collections object to register your collections.
src/content/config.ts
// 1. Import utilities from `astro:content`
import { z, defineCollection } from 'astro:content';
// 2. Define a `type` and `schema` for each collection
const blogCollection = defineCollection({
  type: 'content', // v2.5.0 and later
  schema: z.object({
    title: z.string(),
    tags: z.array(z.string()),
    image: z.string().optional(),
  }),
});
// 3. Export a single `collections` object to register your collection(s)
export const collections = {
  'blog': blogCollection,
};
Defining multiple collections
You can use defineCollection() as many times as you want to create multiple schemas. All collections must be exported from inside the single collections object.
src/content/config.ts
const blogCollection = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const newsletter = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const authors = defineCollection({
  type: 'data',
  schema: z.object({ /* ... */ })
});
export const collections = {
  'blog': blogCollection,
  'newsletter': newsletter,
  'authors': authors,
};
As your project grows, you are also free to reorganize your codebase and move logic out of the src/content/config.ts file. Defining your schemas separately can be useful for reusing schemas across multiple collections and sharing schemas with other parts of your project.
src/content/config.ts
// 1. Import your utilities and schemas
import { defineCollection } from 'astro:content';
import { blogSchema, authorSchema } from '../schemas';
// 2. Define your collections
const blogCollection = defineCollection({
  type: 'content',
  schema: blogSchema,
});
const authorCollection = defineCollection({
  type: 'data',
  schema: authorSchema,
});
// 3. Export multiple collections to register them
export const collections = {
  'blog': blogCollection,
  'authors': authorCollection,
};
Using third-party collection schemas
You can import collection schemas from anywhere, including external npm packages. This can be useful when working with themes and libraries that provide their own collection schemas for you to use.
src/content/config.ts
import { blogSchema } from 'my-blog-theme';
const blogCollection = defineCollection({ type: 'content', schema: blogSchema });
// Export the blog collection, using an external schema from 'my-blog-theme'
export const collections = {
  'blog': blogCollection,
};
Defining datatypes with Zod
Astro uses Zod to power its content schemas. With Zod, Astro is able to validate every file‚Äôs frontmatter within a collection and provide automatic TypeScript types when you go to query content from inside your project.
To use Zod in Astro, import the z utility from ""astro:content"". This is a re-export of the Zod library, and it supports all of the features of Zod. See Zod‚Äôs README for complete documentation on how Zod works and what features are available.
// Example: A cheatsheet of many common Zod datatypes
import { z, defineCollection } from 'astro:content';
defineCollection({
  schema: z.object({
    isDraft: z.boolean(),
    title: z.string(),
    sortOrder: z.number(),
    image: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    author: z.string().default('Anonymous'),
    language: z.enum(['en', 'es']),
    tags: z.array(z.string()),
    // An optional frontmatter property. Very common!
    footnote: z.string().optional(),
    // In frontmatter, dates written without quotes around them are interpreted as Date objects
    publishDate: z.date(),
    // You can also transform a date string (e.g. ""2022-07-08"") to a Date object
    // publishDate: z.string().transform((str) => new Date(str)),
    // Advanced: Validate that the string is also an email
    authorContact: z.string().email(),
    // Advanced: Validate that the string is also a URL
    canonicalURL: z.string().url(),
  })
})
Defining collection references
Collection entries can also ‚Äúreference‚Äù other related entries.
With the reference() function from the Collections API, you can define a property in a collection schema as an entry from another collection. For example, you can require that every space-shuttle entry includes a pilot property which uses the pilot collection‚Äôs own schema for type checking, autocomplete, and validation.
A common example is a blog post that references reusable author profiles stored as JSON, or related post URLs stored in the same collection:
import { defineCollection, reference, z } from 'astro:content';
const blog = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string(),
    // Reference a single author from the `authors` collection by `id`
    author: reference('authors'),
    // Reference an array of related posts from the `blog` collection by `slug`
    relatedPosts: z.array(reference('blog')),
  })
});
const authors = defineCollection({
  type: 'data',
  schema: z.object({
    name: z.string(),
    portfolio: z.string().url(),
  })
});
export const collections = { blog, authors };
This example blog post specifies the slugs of related posts and the id of the post author:
src/content/blog/welcome.md
---
title: ""Welcome to my blog""
author: ben-holmes # references `src/content/authors/ben-holmes.json`
relatedPosts:
- about-me # references `src/content/blog/about-me.md`
- my-year-in-review # references `src/content/blog/my-year-in-review.md`
---
Defining custom slugs
When using type: 'content', every content entry generates a URL-friendly slug property from its file id. The slug is used to query the entry directly from your collection. It is also useful when creating new pages and URLs from your content.
You can override an entry‚Äôs generated slug by adding your own slug property to the file frontmatter. This is similar to the ‚Äúpermalink‚Äù feature of other web frameworks. ""slug"" is a special, reserved property name that is not allowed in your custom collection schema and will not appear in your entry‚Äôs data property.
---
title: My Blog Post
slug: my-custom-slug/supports/slashes
---
Your blog post content here.
Querying Collections
Astro provides two functions to query a collection and return one (or more) content entries: getCollection() and getEntry().
import { getCollection, getEntry } from 'astro:content';
// Get all entries from a collection.
// Requires the name of the collection as an argument.
// Example: retrieve `src/content/blog/**`
const allBlogPosts = await getCollection('blog');
// Get a single entry from a collection.
// Requires the name of the collection and either
// the entry `slug` (content collections) or `id` (data collections)
// Example: retrieve `src/content/authors/grace-hopper.json`
const graceHopperProfile = await getEntry('authors', 'grace-hopper');
Both functions return content entries as defined by the CollectionEntry type.
Accessing referenced data
Any references defined in your schema must be queried separately after first querying your collection entry. You can use the getEntry() function again, or getEntries(), to retrieve the referenced entry from the returned data object.
src/pages/blog/welcome.astro
---
import { getEntry, getEntries } from 'astro:content';
const blogPost = await getEntry('blog', 'welcome');
// Resolve a singular reference
const author = await getEntry(blogPost.data.author);
// Resolve an array of references
const relatedPosts = await getEntries(blogPost.data.relatedPosts);
---
<h1>{blogPost.data.title}</h1>
<p>Author: {author.data.name}</p>
<!-- ... -->
<h2>You might also like:</h2>
{relatedPosts.map(p => (
  <a href={p.slug}>{p.data.title}</a>
))}
Filtering collection queries
getCollection() takes an optional ‚Äúfilter‚Äù callback that allows you to filter your query based on an entry‚Äôs id or data (frontmatter) properties. For collections of type: 'content', you can also filter based on slug.
Note
The slug property is specific to content collections, and will not be available when filtering collections of JSON or YAML.
You can use this to filter by any content criteria you like. For example, you can filter by properties like draft to prevent any draft blog posts from publishing to your blog:
// Example: Filter out content entries with `draft: true`
import { getCollection } from 'astro:content';
const publishedBlogEntries = await getCollection('blog', ({ data }) => {
  return data.draft !== true;
});
You can also create draft pages that are available when running the dev server, but not built in production:
// Example: Filter out content entries with `draft: true` only when building for production
import { getCollection } from 'astro:content';
const blogEntries = await getCollection('blog', ({ data }) => {
  return import.meta.env.PROD ? data.draft !== true : true;
});
The filter argument also supports filtering by nested directories within a collection. Since the id includes the full nested path, you can filter by the start of each id to only return items from a specific nested directory:
// Example: Filter entries by sub-directory in the collection
import { getCollection } from 'astro:content';
const englishDocsEntries = await getCollection('docs', ({ id }) => {
  return id.startsWith('en/');
});
Using content in Astro templates
Once you have queried your collection entries, you can access each entry directly inside of your Astro component template. This lets you render HTML for things like links to your content (using the content slug) or information about your content (using the data property).
For information about rendering your content to HTML, see Rendering Content to HTML below.
src/pages/index.astro
---
import { getCollection } from 'astro:content';
const blogEntries = await getCollection('blog');
---
<ul>
  {blogEntries.map(blogPostEntry => (
    <li>
      <a href={`/my-blog-url/${blogPostEntry.slug}`}>{blogPostEntry.data.title}</a>
      <time datetime={blogPostEntry.data.publishedDate.toISOString()}>
        {blogPostEntry.data.publishedDate.toDateString()}
      </time>
    </li>
  ))}
</ul>
Passing content as props
A component can also pass an entire content entry as a prop.
If you do this, you can use the CollectionEntry utility to correctly type your components props using TypeScript. This utility takes a string argument that matches the name of your collection schema, and will inherit all of the properties of that collection‚Äôs schema.
src/components/BlogCard.astro
---
import type { CollectionEntry } from 'astro:content';
interface Props {
  post: CollectionEntry<'blog'>;
}
// `post` will match your 'blog' collection schema type
const { post } = Astro.props;
---
Rendering content to HTML
Once queried, you can render Markdown and MDX entries to HTML using the entry render() function property. Calling this function gives you access to rendered content and metadata, including both a <Content /> component and a list of all rendered headings.
src/pages/render-example.astro
---
import { getEntry } from 'astro:content';
const entry = await getEntry('blog', 'post-1');
const { Content, headings } = await entry.render();
---
<p>Published on: {entry.data.published.toDateString()}</p>
<Content />
Generating Routes from Content
Content collections are stored outside of the src/pages/ directory. This means that no routes are generated for your collection items by default. You will need to manually create a new dynamic route to generate HTML pages from your collection entries. Your dynamic route will map the incoming request param (ex: Astro.params.slug in src/pages/blog/[...slug].astro) to fetch the correct entry inside a collection.
The exact method for generating routes will depend on your build output mode: ‚Äòstatic‚Äô (the default) or ‚Äòserver‚Äô (for SSR).
Building for static output (default)
If you are building a static website (Astro‚Äôs default behavior), you would use the getStaticPaths() function to create multiple pages from a single src/pages/ component during your build.
Call getCollection() inside of getStaticPaths() to query your content or data collection. Then, create your new URL paths using the slug property (content collections) or id property (data collections) of each content entry.
src/pages/posts/[...slug].astro
---
import { getCollection } from 'astro:content';
// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
  const blogEntries = await getCollection('blog');
  return blogEntries.map(entry => ({
    params: { slug: entry.slug }, props: { entry },
  }));
}
// 2. For your template, you can get the entry directly from the prop
const { entry } = Astro.props;
const { Content } = await entry.render();
---
<h1>{entry.data.title}</h1>
<Content />
This will generate a new page for every entry in the blog collection. For example, an entry at src/content/blog/hello-world.md will have a slug of hello-world, and therefore its final URL will be /posts/hello-world/.
Note
If your custom slugs contain the / character to produce URLs with multiple path segments, you must use a rest parameter ([...slug]) in the .astro filename for this dynamic routing page.
Building for server output (SSR)
If you are building a dynamic website (using Astro‚Äôs SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using Astro.request or Astro.params) to find the slug on-demand, and then fetch it using getEntry().
src/pages/posts/[...slug].astro
---
import { getEntry } from ""astro:content"";
// 1. Get the slug from the incoming server request
const { slug } = Astro.params;
if (slug === undefined) {
  throw new Error(""Slug is required"");
}
// 2. Query for the entry directly using the request slug
const entry = await getEntry(""blog"", slug);
// 3. Redirect if the entry does not exist
if (entry === undefined) {
  return Astro.redirect(""/404"");
}
// 4. (Optional) Render the entry to HTML in the template
const { Content } = await entry.render();
---
Tip
Explore the src/pages/ folder of the blog tutorial demo code on GitHub or open it in StackBlitz to see full examples of creating pages from your collections for blog features like a list of blog posts, tags pages, and more!
Migrating from File-Based Routing
If you have an existing Astro project, such as a blog, that uses Markdown or MDX files in subfolders inside src/pages/, consider migrating related content or data files to content collections.
See how to convert a basic blog example from src/pages/posts/ to src/content/posts in our step-by-step tutorial that uses the codebase from the Build a Blog tutorial‚Äôs finished project.
Enabling JSON Schema Generation
Added in: astro@4.13.0
If you are working with collections of type data, Astro will auto-generate JSON schema files for your editor to get IntelliSense and type-checking. A separate file will be created for each data collection in your project based on your collections defined in src/content/config.ts using a library called zod-to-json-schema.
This feature requires you to manually set your schema‚Äôs file path as the value for $schema in each data entry file of the collection:
src/content/authors/armand.json
{
  ""$schema"": ""../../../.astro/collections/authors.schema.json"",
  ""name"": ""Armand"",
  ""skills"": [""Astro"", ""Starlight""]
}
Alternatively, you can set this value in your editor settings. For example, to set this value in VSCode‚Äôs json.schemas setting, provide the path of files to match and the location of your JSON schema:
{
  ""json.schemas"": [
    {
      ""fileMatch"": [
        ""/src/content/authors/**""
      ],
      ""url"": ""./.astro/collections/authors.schema.json""
    }
  ]
}
Enabling Build Caching
Added in: astro@3.5.0 Experimental
If you are working with large collections, you may wish to enable cached builds with the experimental.contentCollectionCache flag. This experimental feature optimizes Astro‚Äôs build process, enabling unchanged collections to be stored and reused between builds.
In many cases, this can lead to significant build performance improvements.
While this feature stabilizes, you may run into issues with the stored cache. You can always reset your build cache by running the following command:
npm run astro build -- --force
Modifying Frontmatter with Remark
Caution
Not recommended. Remark and rehype plugins access the raw Markdown or MDX document frontmatter. This means that remarkPluginFrontmatter frontmatter is handled separately from your type-safe schema, and will not reflect any changes or defaults applied through Astro. Use at your own risk!
Astro supports remark or rehype plugins that modify your frontmatter directly. You can access this modified frontmatter inside of a content entry by using the remarkPluginFrontmatter property returned from render():
---
import { getEntry } from 'astro:content';
const blogPost = await getEntry('blog', 'post-1');
const { remarkPluginFrontmatter } = await blogPost.render();
---
<p>{blogPost.data.title} ‚Äî {remarkPluginFrontmatter.readingTime}</p>
Related recipe:
Add reading time
The remark and rehype pipelines only run when your content is rendered, which explains why remarkPluginFrontmatter is only available after you call render() on your content entry. In contrast, getCollection() and getEntry() cannot return these values directly because they do not render your content.
Working with dates in the frontmatter
Several date formats are possible in content collections, but your collection‚Äôs schema must match the format used in your Markdown or MDX YAML frontmatter.
YAML uses the ISO-8601 standard to express dates. Use the format yyyy-mm-dd (e.g. 2021-07-28) along with a schema type of z.date():
src/pages/posts/example-post.md
---
title: My Blog Post
pubDate: 2021-07-08
---
The date format will be specified in UTC if a timezone is not provided. If you need to specify a timezone, you can use the ISO 8601 format.
src/pages/posts/example-post.md
---
title: My Blog Post
pubDate: 2021-07-08T12:00:00-04:00
---
To render only the YYYY-MM-DD from the full UTC timestamp, use the JavaScript slice method to remove the timestamp:
src/layouts/ExampleLayout.astro
---
const { frontmatter } = Astro.props;
---
<h1>{frontmatter.title}</h1>
<p>{frontmatter.pubDate.toISOString().slice(0,10)}</p>
To see an example of using toLocaleDateString to format the day, month, and year instead, see the <FormattedDate /> component in the official Astro blog template.
Edit page
Translate this page
Previous
Markdown
Next
Connect a CMS
Contribute
Give us feedback
Community""""""",5578,25619,astro
https://docs.astro.build/en/guides/cms/,"""""""On this page
Overview
CMS Guides
Why use a CMS?
Which CMSes work well with Astro?
Can I use Astro without a CMS?
Want to build your own Docs?
Grab this template to get started.‚Üí
Use a CMS with Astro
Ready to connect a Headless CMS to your Astro project? Follow one of our guides to integrate a CMS.
Tip
Find community-maintained integrations for connecting a CMS to your project in our integrations directory.
CMS Guides
Note that many of these pages are stubs: they‚Äôre collections of resources waiting for your contribution!
Apostrophe
Builder.io
ButterCMS
Caisy
CloudCannon
Contentful
Cosmic
Craft CMS
Crystallize
DatoCMS
Decap CMS
Directus
Drupal
Flotiq
Front Matter CMS
Ghost
Hashnode
Hygraph
Keystatic
KeystoneJS
Kontent.ai
microCMS
Payload CMS
Prepr CMS
Prismic
Sanity
Sitecore XM
Spinal
Statamic
Storyblok
Strapi
Tina CMS
Umbraco
WordPress
Why use a CMS?
A Content Management System lets you write content and manage assets outside of your Astro project.
This unlocks new features for working with content. Most CMSes give you a visual content editor, the ability to specify standard types of content, and a way to collaborate with others.
A CMS can be useful for content that follows a particular structure, often giving you a dashboard-like experience and WYSIWYG editing tools. You might use a CMS to write blog posts using a CMS‚Äôs rich text editor instead of Markdown files. Or you might use a CMS to maintain product listings for an eCommerce shop, making certain fields required to avoid incomplete listings.
Your Astro project can then fetch your content from your CMS and display it, wherever and however you want on your site.
Which CMSes work well with Astro?
Because Astro takes care of the presentation of your content, you‚Äôll want to choose a headless CMS, like those in the list above. This means that the CMS helps you write your content, but doesn‚Äôt generate a site that displays it. Instead, you fetch the content data and use in your Astro project.
Some headless CMSes, like Storyblok, provide an Astro integration that helps fetch the content specifically for an Astro site. Others provide a JavaScript SDK, a library that you install and use to fetch your remote content.
Explore a list of over 100 headless content management systems External where you can filter by type (e.g. Git-based, API driven) and license (open-source or closed-source).
Can I use Astro without a CMS?
Yes! Astro provides built-in support for Markdown.
Edit page
Translate this page
Previous
Content Collections
Next
Add an RSS feed
Contribute
Give us feedback
Community""""""",589,2572,astro
https://docs.astro.build/en/guides/rss/,"""""""On this page
Overview
Setting up @astrojs/rss
Generating items
Using content collections
Using glob imports
Including full post content
Removing trailing slashes
Adding a stylesheet
Enabling RSS feed auto-discovery
Next Steps
Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Add an RSS feed
Astro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content.
Setting up @astrojs/rss
The package @astrojs/rss provides helpers for generating RSS feeds using API endpoints. This unlocks both static builds and on-demand generation when using an SSR adapter.
Install @astrojs/rss using your preferred package manager:
npm
pnpm
Yarn
Terminal window
yarn add @astrojs/rss
Tip
Ensure you‚Äôve configured a site in your project‚Äôs astro.config. This will be used to generate links to your RSS articles.
Create a file in src/pages/ with a name of your choice and the extension .xml.js to be used as the output URL for your feed. Some common RSS feed URL names are feed.xml or rss.xml.
The example file below src/pages/rss.xml.js will create an RSS feed at site/rss.xml.
Import the rss() helper from the @astrojs/rss package into your .xml.js file and export a function that returns it using the following parameters:
src/pages/rss.xml.js
import rss from '@astrojs/rss';
export function GET(context) {
  return rss({
    // `<title>` field in output xml
    title: 'Buzz‚Äôs Blog',
    // `<description>` field in output xml
    description: 'A humble Astronaut‚Äôs guide to the stars',
    // Pull in your project ""site"" from the endpoint context
    // https://docs.astro.build/en/reference/api-reference/#contextsite
    site: context.site,
    // Array of `<item>`s in output xml
    // See ""Generating items"" section for examples using content collections and glob imports
    items: [],
    // (optional) inject custom xml
    customData: `<language>en-us</language>`,
  });
}
See the @astrojs/rss README for the full configuration reference.
Generating items
The items field accepts a list of RSS feed objects, which can be generated from content collections entries using getCollection() or from your page files using pagesGlobToRssItems().
The RSS feed standard format includes metadata for each published item, including values such as:
title: The title of the entry. Optional only if a description is set. Otherwise, required.
description: A short excerpt from or describing the entry. Optional only if a title is set. Otherwise, required.
link: A URL to the original source of the entry. (optional)
pubDate: The date of publication of the entry. (optional)
content: The full content of your post. (optional)
See the items configuration reference for a complete list of options.
Using content collections
To create an RSS feed of pages managed in content collections, use the getCollection() function to retrieve the data required for your items array. You will need to specify the values for each desired property (e.g. title, description) from the returned data.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import { getCollection } from 'astro:content';
export async function GET(context) {
  const blog = await getCollection('blog');
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: blog.map((post) => ({
      title: post.data.title,
      pubDate: post.data.pubDate,
      description: post.data.description,
      // Compute RSS link from post `slug`
      // This example assumes all posts are rendered as `/blog/[slug]` routes
      link: `/blog/${post.slug}/`,
    })),
  });
}
Optional: replace your existing blog collection schema to enforce the expected RSS properties.
To ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply rssSchema instead of defining each individual property of your schema.
src/content/config.ts
import { defineCollection } from 'astro:content';
import { rssSchema } from '@astrojs/rss';
const blog = defineCollection({
  schema: rssSchema,
});
export const collections = { blog };
Using glob imports
Added in: @astrojs/rss@2.1.0
To create an RSS feed from documents in src/pages/, use the pagesGlobToRssItems() helper. This accepts an import.meta.glob result and outputs an array of valid RSS feed items (see more about writing glob patterns for specifying which pages to include).
Caution
This function assumes, but does not verify, that all necessary feed properties are present in each document‚Äôs frontmatter. If you encounter errors, verify each page frontmatter manually.
src/pages/rss.xml.js
import rss, { pagesGlobToRssItems } from '@astrojs/rss';
export async function GET(context) {
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: await pagesGlobToRssItems(
      import.meta.glob('./blog/*.{md,mdx}'),
    ),
  });
}
Using an older version?
In versions of @astrojs/rss before v2.1.0, pass your glob result straight to items without the pagesGlobToRssItems() wrapper:
items: import.meta.glob('./blog/*.{md,mdx}'),
This method is deprecated for all versions of Astro since v2.1.0, and cannot be used on modern projects.
Including full post content
Added in: astro@1.6.14
The content key contains the full content of the post as HTML. This allows you to make your entire post content available to RSS feed readers.
Tip
A package like sanitize-html will make sure that your content is properly sanitized, escaped, and encoded. In the process, such a package might also remove some harmless elements and attributes, so make sure to verify the output and configure the package according to your needs.
When using content collections, render the post body using a standard Markdown parser like markdown-it and sanitize the result, including any extra tags (e.g. <img>) needed to render your content:
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import { getCollection } from 'astro:content';
import sanitizeHtml from 'sanitize-html';
import MarkdownIt from 'markdown-it';
const parser = new MarkdownIt();
export async function GET(context) {
  const blog = await getCollection('blog');
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: blog.map((post) => ({
      link: `/blog/${post.slug}/`,
      // Note: this will not process components or JSX expressions in MDX files.
      content: sanitizeHtml(parser.render(post.body), {
        allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img'])
      }),
      ...post.data,
    })),
  });
}
When using glob imports with Markdown, you may use the compiledContent() helper to retrieve the rendered HTML for sanitization. Note: this feature is not supported for MDX files.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import sanitizeHtml from 'sanitize-html';
export function GET(context) {
  const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true });
  const posts = Object.values(postImportResult);
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: posts.map((post) => ({
      link: post.url,
      content: sanitizeHtml(post.compiledContent()),
      ...post.frontmatter,
    })),
  });
}
Removing trailing slashes
Astro‚Äôs RSS feed produces links with a trailing slash by default, no matter what value you have configured for trailingSlash. This means that your RSS links may not match your post URLs exactly.
If you have set trailingSlash: ""never"" on your astro.config.mjs, set trailingSlash: false in the rss() helper so that your feed matches your project configuration.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
export function GET(context) {
  const posts = Object.values(postImportResult);
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    trailingSlash: false,
    items: posts.map((post) => ({
      link: post.url,
      ...post.frontmatter,
    })),
  });
}
Adding a stylesheet
Style your RSS feed for a more pleasant user experience when viewing the file in your browser.
Use the rss function‚Äôs stylesheet option to specify an absolute path to your stylesheet.
rss({
  // ex. use your stylesheet from ""public/rss/styles.xsl""
  stylesheet: '/rss/styles.xsl',
  // ...
});
Tip
If you‚Äôd prefer not to create your own stylesheet, you may use a premade stylesheet such as the Pretty Feed v3 default stylesheet. Download the stylesheet from GitHub and save into your project‚Äôs public/ directory.
Enabling RSS feed auto-discovery
RSS autodiscovery allows browsers and other software to automatically find a site‚Äôs RSS feed from the main URL.
To enable, add a <link> tag with the following attributes to your site‚Äôs head element:
<link
    rel=""alternate""
    type=""application/rss+xml""
    title=""Your Site's Title""
    href={new URL(""rss.xml"", Astro.site)}
/>
With this tag, readers of your blog can enter your site‚Äôs base URL into their RSS reader to subscribe to your posts without needing the specific URL of your RSS feed.
Next Steps
After visiting your feed in the browser at your-domain.com/rss.xml and confirming that you can see data for each of your posts, you can now promote your feed on your website. Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader.
Resources
RSS Feeds
Edit page
Translate this page
Previous
Connect a CMS
Next
Routing
Contribute
Give us feedback
Community

On this page
Overview
Setting up @astrojs/rss
Generating items
Using content collections
Using glob imports
Including full post content
Removing trailing slashes
Adding a stylesheet
Enabling RSS feed auto-discovery
Next Steps
Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Add an RSS feed
Astro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content.
Setting up @astrojs/rss
The package @astrojs/rss provides helpers for generating RSS feeds using API endpoints. This unlocks both static builds and on-demand generation when using an SSR adapter.
Install @astrojs/rss using your preferred package manager:
npm
pnpm
Yarn
Terminal window
npm install @astrojs/rss
Tip
Ensure you‚Äôve configured a site in your project‚Äôs astro.config. This will be used to generate links to your RSS articles.
Create a file in src/pages/ with a name of your choice and the extension .xml.js to be used as the output URL for your feed. Some common RSS feed URL names are feed.xml or rss.xml.
The example file below src/pages/rss.xml.js will create an RSS feed at site/rss.xml.
Import the rss() helper from the @astrojs/rss package into your .xml.js file and export a function that returns it using the following parameters:
src/pages/rss.xml.js
import rss from '@astrojs/rss';
export function GET(context) {
  return rss({
    // `<title>` field in output xml
    title: 'Buzz‚Äôs Blog',
    // `<description>` field in output xml
    description: 'A humble Astronaut‚Äôs guide to the stars',
    // Pull in your project ""site"" from the endpoint context
    // https://docs.astro.build/en/reference/api-reference/#contextsite
    site: context.site,
    // Array of `<item>`s in output xml
    // See ""Generating items"" section for examples using content collections and glob imports
    items: [],
    // (optional) inject custom xml
    customData: `<language>en-us</language>`,
  });
}
See the @astrojs/rss README for the full configuration reference.
Generating items
The items field accepts a list of RSS feed objects, which can be generated from content collections entries using getCollection() or from your page files using pagesGlobToRssItems().
The RSS feed standard format includes metadata for each published item, including values such as:
title: The title of the entry. Optional only if a description is set. Otherwise, required.
description: A short excerpt from or describing the entry. Optional only if a title is set. Otherwise, required.
link: A URL to the original source of the entry. (optional)
pubDate: The date of publication of the entry. (optional)
content: The full content of your post. (optional)
See the items configuration reference for a complete list of options.
Using content collections
To create an RSS feed of pages managed in content collections, use the getCollection() function to retrieve the data required for your items array. You will need to specify the values for each desired property (e.g. title, description) from the returned data.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import { getCollection } from 'astro:content';
export async function GET(context) {
  const blog = await getCollection('blog');
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: blog.map((post) => ({
      title: post.data.title,
      pubDate: post.data.pubDate,
      description: post.data.description,
      // Compute RSS link from post `slug`
      // This example assumes all posts are rendered as `/blog/[slug]` routes
      link: `/blog/${post.slug}/`,
    })),
  });
}
Optional: replace your existing blog collection schema to enforce the expected RSS properties.
To ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply rssSchema instead of defining each individual property of your schema.
src/content/config.ts
import { defineCollection } from 'astro:content';
import { rssSchema } from '@astrojs/rss';
const blog = defineCollection({
  schema: rssSchema,
});
export const collections = { blog };
Using glob imports
Added in: @astrojs/rss@2.1.0
To create an RSS feed from documents in src/pages/, use the pagesGlobToRssItems() helper. This accepts an import.meta.glob result and outputs an array of valid RSS feed items (see more about writing glob patterns for specifying which pages to include).
Caution
This function assumes, but does not verify, that all necessary feed properties are present in each document‚Äôs frontmatter. If you encounter errors, verify each page frontmatter manually.
src/pages/rss.xml.js
import rss, { pagesGlobToRssItems } from '@astrojs/rss';
export async function GET(context) {
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: await pagesGlobToRssItems(
      import.meta.glob('./blog/*.{md,mdx}'),
    ),
  });
}
Using an older version?
In versions of @astrojs/rss before v2.1.0, pass your glob result straight to items without the pagesGlobToRssItems() wrapper:
items: import.meta.glob('./blog/*.{md,mdx}'),
This method is deprecated for all versions of Astro since v2.1.0, and cannot be used on modern projects.
Including full post content
Added in: astro@1.6.14
The content key contains the full content of the post as HTML. This allows you to make your entire post content available to RSS feed readers.
Tip
A package like sanitize-html will make sure that your content is properly sanitized, escaped, and encoded. In the process, such a package might also remove some harmless elements and attributes, so make sure to verify the output and configure the package according to your needs.
When using content collections, render the post body using a standard Markdown parser like markdown-it and sanitize the result, including any extra tags (e.g. <img>) needed to render your content:
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import { getCollection } from 'astro:content';
import sanitizeHtml from 'sanitize-html';
import MarkdownIt from 'markdown-it';
const parser = new MarkdownIt();
export async function GET(context) {
  const blog = await getCollection('blog');
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: blog.map((post) => ({
      link: `/blog/${post.slug}/`,
      // Note: this will not process components or JSX expressions in MDX files.
      content: sanitizeHtml(parser.render(post.body), {
        allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img'])
      }),
      ...post.data,
    })),
  });
}
When using glob imports with Markdown, you may use the compiledContent() helper to retrieve the rendered HTML for sanitization. Note: this feature is not supported for MDX files.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import sanitizeHtml from 'sanitize-html';
export function GET(context) {
  const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true });
  const posts = Object.values(postImportResult);
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: posts.map((post) => ({
      link: post.url,
      content: sanitizeHtml(post.compiledContent()),
      ...post.frontmatter,
    })),
  });
}
Removing trailing slashes
Astro‚Äôs RSS feed produces links with a trailing slash by default, no matter what value you have configured for trailingSlash. This means that your RSS links may not match your post URLs exactly.
If you have set trailingSlash: ""never"" on your astro.config.mjs, set trailingSlash: false in the rss() helper so that your feed matches your project configuration.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
export function GET(context) {
  const posts = Object.values(postImportResult);
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    trailingSlash: false,
    items: posts.map((post) => ({
      link: post.url,
      ...post.frontmatter,
    })),
  });
}
Adding a stylesheet
Style your RSS feed for a more pleasant user experience when viewing the file in your browser.
Use the rss function‚Äôs stylesheet option to specify an absolute path to your stylesheet.
rss({
  // ex. use your stylesheet from ""public/rss/styles.xsl""
  stylesheet: '/rss/styles.xsl',
  // ...
});
Tip
If you‚Äôd prefer not to create your own stylesheet, you may use a premade stylesheet such as the Pretty Feed v3 default stylesheet. Download the stylesheet from GitHub and save into your project‚Äôs public/ directory.
Enabling RSS feed auto-discovery
RSS autodiscovery allows browsers and other software to automatically find a site‚Äôs RSS feed from the main URL.
To enable, add a <link> tag with the following attributes to your site‚Äôs head element:
<link
    rel=""alternate""
    type=""application/rss+xml""
    title=""Your Site's Title""
    href={new URL(""rss.xml"", Astro.site)}
/>
With this tag, readers of your blog can enter your site‚Äôs base URL into their RSS reader to subscribe to your posts without needing the specific URL of your RSS feed.
Next Steps
After visiting your feed in the browser at your-domain.com/rss.xml and confirming that you can see data for each of your posts, you can now promote your feed on your website. Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader.
Resources
RSS Feeds
Edit page
Translate this page
Previous
Connect a CMS
Next
Routing
Contribute
Give us feedback
Community

On this page
Overview
Setting up @astrojs/rss
Generating items
Using content collections
Using glob imports
Including full post content
Removing trailing slashes
Adding a stylesheet
Enabling RSS feed auto-discovery
Next Steps
Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Add an RSS feed
Astro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content.
Setting up @astrojs/rss
The package @astrojs/rss provides helpers for generating RSS feeds using API endpoints. This unlocks both static builds and on-demand generation when using an SSR adapter.
Install @astrojs/rss using your preferred package manager:
npm
pnpm
Yarn
Terminal window
pnpm add @astrojs/rss
Tip
Ensure you‚Äôve configured a site in your project‚Äôs astro.config. This will be used to generate links to your RSS articles.
Create a file in src/pages/ with a name of your choice and the extension .xml.js to be used as the output URL for your feed. Some common RSS feed URL names are feed.xml or rss.xml.
The example file below src/pages/rss.xml.js will create an RSS feed at site/rss.xml.
Import the rss() helper from the @astrojs/rss package into your .xml.js file and export a function that returns it using the following parameters:
src/pages/rss.xml.js
import rss from '@astrojs/rss';
export function GET(context) {
  return rss({
    // `<title>` field in output xml
    title: 'Buzz‚Äôs Blog',
    // `<description>` field in output xml
    description: 'A humble Astronaut‚Äôs guide to the stars',
    // Pull in your project ""site"" from the endpoint context
    // https://docs.astro.build/en/reference/api-reference/#contextsite
    site: context.site,
    // Array of `<item>`s in output xml
    // See ""Generating items"" section for examples using content collections and glob imports
    items: [],
    // (optional) inject custom xml
    customData: `<language>en-us</language>`,
  });
}
See the @astrojs/rss README for the full configuration reference.
Generating items
The items field accepts a list of RSS feed objects, which can be generated from content collections entries using getCollection() or from your page files using pagesGlobToRssItems().
The RSS feed standard format includes metadata for each published item, including values such as:
title: The title of the entry. Optional only if a description is set. Otherwise, required.
description: A short excerpt from or describing the entry. Optional only if a title is set. Otherwise, required.
link: A URL to the original source of the entry. (optional)
pubDate: The date of publication of the entry. (optional)
content: The full content of your post. (optional)
See the items configuration reference for a complete list of options.
Using content collections
To create an RSS feed of pages managed in content collections, use the getCollection() function to retrieve the data required for your items array. You will need to specify the values for each desired property (e.g. title, description) from the returned data.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import { getCollection } from 'astro:content';
export async function GET(context) {
  const blog = await getCollection('blog');
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: blog.map((post) => ({
      title: post.data.title,
      pubDate: post.data.pubDate,
      description: post.data.description,
      // Compute RSS link from post `slug`
      // This example assumes all posts are rendered as `/blog/[slug]` routes
      link: `/blog/${post.slug}/`,
    })),
  });
}
Optional: replace your existing blog collection schema to enforce the expected RSS properties.
To ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply rssSchema instead of defining each individual property of your schema.
src/content/config.ts
import { defineCollection } from 'astro:content';
import { rssSchema } from '@astrojs/rss';
const blog = defineCollection({
  schema: rssSchema,
});
export const collections = { blog };
Using glob imports
Added in: @astrojs/rss@2.1.0
To create an RSS feed from documents in src/pages/, use the pagesGlobToRssItems() helper. This accepts an import.meta.glob result and outputs an array of valid RSS feed items (see more about writing glob patterns for specifying which pages to include).
Caution
This function assumes, but does not verify, that all necessary feed properties are present in each document‚Äôs frontmatter. If you encounter errors, verify each page frontmatter manually.
src/pages/rss.xml.js
import rss, { pagesGlobToRssItems } from '@astrojs/rss';
export async function GET(context) {
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: await pagesGlobToRssItems(
      import.meta.glob('./blog/*.{md,mdx}'),
    ),
  });
}
Using an older version?
In versions of @astrojs/rss before v2.1.0, pass your glob result straight to items without the pagesGlobToRssItems() wrapper:
items: import.meta.glob('./blog/*.{md,mdx}'),
This method is deprecated for all versions of Astro since v2.1.0, and cannot be used on modern projects.
Including full post content
Added in: astro@1.6.14
The content key contains the full content of the post as HTML. This allows you to make your entire post content available to RSS feed readers.
Tip
A package like sanitize-html will make sure that your content is properly sanitized, escaped, and encoded. In the process, such a package might also remove some harmless elements and attributes, so make sure to verify the output and configure the package according to your needs.
When using content collections, render the post body using a standard Markdown parser like markdown-it and sanitize the result, including any extra tags (e.g. <img>) needed to render your content:
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import { getCollection } from 'astro:content';
import sanitizeHtml from 'sanitize-html';
import MarkdownIt from 'markdown-it';
const parser = new MarkdownIt();
export async function GET(context) {
  const blog = await getCollection('blog');
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: blog.map((post) => ({
      link: `/blog/${post.slug}/`,
      // Note: this will not process components or JSX expressions in MDX files.
      content: sanitizeHtml(parser.render(post.body), {
        allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img'])
      }),
      ...post.data,
    })),
  });
}
When using glob imports with Markdown, you may use the compiledContent() helper to retrieve the rendered HTML for sanitization. Note: this feature is not supported for MDX files.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
import sanitizeHtml from 'sanitize-html';
export function GET(context) {
  const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true });
  const posts = Object.values(postImportResult);
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    items: posts.map((post) => ({
      link: post.url,
      content: sanitizeHtml(post.compiledContent()),
      ...post.frontmatter,
    })),
  });
}
Removing trailing slashes
Astro‚Äôs RSS feed produces links with a trailing slash by default, no matter what value you have configured for trailingSlash. This means that your RSS links may not match your post URLs exactly.
If you have set trailingSlash: ""never"" on your astro.config.mjs, set trailingSlash: false in the rss() helper so that your feed matches your project configuration.
src/pages/rss.xml.js
import rss from '@astrojs/rss';
export function GET(context) {
  const posts = Object.values(postImportResult);
  return rss({
    title: 'Buzz‚Äôs Blog',
    description: 'A humble Astronaut‚Äôs guide to the stars',
    site: context.site,
    trailingSlash: false,
    items: posts.map((post) => ({
      link: post.url,
      ...post.frontmatter,
    })),
  });
}
Adding a stylesheet
Style your RSS feed for a more pleasant user experience when viewing the file in your browser.
Use the rss function‚Äôs stylesheet option to specify an absolute path to your stylesheet.
rss({
  // ex. use your stylesheet from ""public/rss/styles.xsl""
  stylesheet: '/rss/styles.xsl',
  // ...
});
Tip
If you‚Äôd prefer not to create your own stylesheet, you may use a premade stylesheet such as the Pretty Feed v3 default stylesheet. Download the stylesheet from GitHub and save into your project‚Äôs public/ directory.
Enabling RSS feed auto-discovery
RSS autodiscovery allows browsers and other software to automatically find a site‚Äôs RSS feed from the main URL.
To enable, add a <link> tag with the following attributes to your site‚Äôs head element:
<link
    rel=""alternate""
    type=""application/rss+xml""
    title=""Your Site's Title""
    href={new URL(""rss.xml"", Astro.site)}
/>
With this tag, readers of your blog can enter your site‚Äôs base URL into their RSS reader to subscribe to your posts without needing the specific URL of your RSS feed.
Next Steps
After visiting your feed in the browser at your-domain.com/rss.xml and confirming that you can see data for each of your posts, you can now promote your feed on your website. Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader.
Resources
RSS Feeds
Edit page
Translate this page
Previous
Connect a CMS
Next
Routing
Contribute
Give us feedback
Community""""""",6499,29122,astro
https://docs.astro.build/en/guides/routing/,"""""""On this page
Overview
Navigating between pages
Static routes
Dynamic routes
Static (SSG) Mode
Server (SSR) Mode
Redirects
Configured Redirects
Dynamic redirects
Rewrites
Route Priority Order
Reserved routes
Pagination
The page prop
Nested Pagination
Excluding pages
Want to build your own Docs?
Grab this template to get started.‚Üí
Routing
Astro uses file-based routing to generate your build URLs based on the file layout of your project src/pages/ directory.
Navigating between pages
Astro uses standard HTML <a> elements to navigate between routes. There is no framework-specific <Link> component provided.
src/pages/index.astro
<p>Read more <a href=""/about/"">about</a> Astro!</p>
<!-- With `base: ""/docs""` configured -->
<p>Learn more in our <a href=""/docs/reference/"">reference</a> section!</p>
Static routes
.astro page components as well as Markdown and MDX Files (.md, .mdx) within the src/pages/ directory automatically become pages on your website. Each page‚Äôs route corresponds to its path and filename within the src/pages/ directory.
# Example: Static routes
src/pages/index.astro        -> mysite.com/
src/pages/about.astro        -> mysite.com/about
src/pages/about/index.astro  -> mysite.com/about
src/pages/about/me.astro     -> mysite.com/about/me
src/pages/posts/1.md         -> mysite.com/posts/1
Tip
There is no separate ‚Äúrouting config‚Äù to maintain in an Astro project! When you add a file to the src/pages/ directory, a new route is automatically created for you. In static builds, you can customize the file output format using the build.format configuration option.
Dynamic routes
An Astro page file can specify dynamic route parameters in its filename to generate multiple, matching pages. For example, src/pages/authors/[author].astro generates a bio page for every author on your blog. author becomes a parameter that you can access from inside the page.
In Astro‚Äôs default static output mode, these pages are generated at build time, and so you must predetermine the list of authors that get a corresponding file. In SSR mode, a page will be generated on request for any route that matches.
Static (SSG) Mode
Because all routes must be determined at build time, a dynamic route must export a getStaticPaths() that returns an array of objects with a params property. Each of these objects will generate a corresponding route.
[dog].astro defines the dynamic dog parameter in its filename, so the objects returned by getStaticPaths() must include dog in their params. The page can then access this parameter using Astro.params.
src/pages/dogs/[dog].astro
---
export function getStaticPaths() {
  return [
    {params: {dog: 'clifford'}},
    {params: {dog: 'rover'}},
    {params: {dog: 'spot'}},
  ];
}
const { dog } = Astro.params;
---
<div>Good dog, {dog}!</div>
This will generate three pages: /dogs/clifford, /dogs/rover, and /dogs/spot, each displaying the corresponding dog name.
The filename can include multiple parameters, which must all be included in the params objects in getStaticPaths():
src/pages/[lang]-[version]/info.astro
---
export function getStaticPaths () {
 return [
    {params: {lang: 'en', version: 'v1'}},
    {params: {lang: 'fr', version: 'v2'}},
  ];
}
const { lang, version } = Astro.params;
---
...
This will generate /en-v1/info and /fr-v2/info.
Parameters can be included in separate parts of the path. For example, the file src/pages/[lang]/[version]/info.astro with the same getStaticPaths() above will generate the routes /en/v1/info and /fr/v2/info.
Learn more about getStaticPaths().
Related recipe:
Add i18n features
Rest parameters
If you need more flexibility in your URL routing, you can use a rest parameter ([...path]) in your .astro filename to match file paths of any depth:
src/pages/sequences/[...path].astro
---
export function getStaticPaths() {
  return [
    {params: {path: 'one/two/three'}},
    {params: {path: 'four'}},
    {params: {path: undefined }}
  ]
}
const { path } = Astro.params;
---
...
This will generate /sequences/one/two/three, /sequences/four, and /sequences. (Setting the rest parameter to undefined allows it to match the top level page.)
Rest parameters can be used with other named parameters. For example, GitHub‚Äôs file viewer can be represented with the following dynamic route:
/[org]/[repo]/tree/[branch]/[...file]
In this example, a request for /withastro/astro/tree/main/docs/public/favicon.svg would be split into the following named parameters:
{
  org: 'withastro',
  repo: 'astro',
  branch: 'main',
  file: 'docs/public/favicon.svg'
}
Example: Dynamic pages at multiple levels
In the following example, a rest parameter ([...slug]) and the props feature of getStaticPaths() generate pages for slugs of different depths.
src/pages/[...slug].astro
---
export async function getStaticPaths() {
  const pages = [
    {
      slug: undefined,
      title: ""Astro Store"",
      text: ""Welcome to the Astro store!"",
    },
    {
      slug: ""products"",
      title: ""Astro products"",
      text: ""We have lots of products for you"",
    },
    {
      slug: ""products/astro-handbook"",
      title: ""The ultimate Astro handbook"",
      text: ""If you want to learn Astro, you must read this book."",
    },
  ];
  return pages.map(({ slug, title, text }) => {
    return {
      params: { slug },
      props: { title, text },
    };
  });
}
const { title, text } = Astro.props;
---
<html>
  <head>
    <title>{title}</title>
  </head>
  <body>
    <h1>{title}</h1>
    <p>{text}</p>
  </body>
</html>
Server (SSR) Mode
In SSR mode, dynamic routes are defined the same way: include [param] or [...path] brackets in your file names to match arbitrary strings or paths. But because the routes are no longer built ahead of time, the page will be served to any matching route. Since these are not ‚Äústatic‚Äù routes, getStaticPaths should not be used.
src/pages/resources/[resource]/[id].astro
---
const { resource, id } = Astro.params;
---
<h1>{resource}: {id}</h1>
This page will be served for any value of resource and id: resources/users/1, resources/colors/blue, etc.
Modifying the [...slug] example for SSR
Because SSR pages can‚Äôt use getStaticPaths(), they can‚Äôt receive props. The previous example can be adapted for SSR mode by looking up the value of the slug param in an object. If the route is at the root (‚Äù/‚Äù), the slug param will be undefined. If the value doesn‚Äôt exist in the object, we redirect to a 404 page.
src/pages/[...slug].astro
---
const pages = [
  {
    slug: undefined,
    title: 'Astro Store',
    text: 'Welcome to the Astro store!',
  },
  {
    slug: 'products',
    title: 'Astro products',
    text: 'We have lots of products for you',
  },
  {
    slug: 'products/astro-handbook',
    title: 'The ultimate Astro handbook',
    text: 'If you want to learn Astro, you must read this book.',
  }
];
const { slug } = Astro.params;
const page = pages.find((page) => page.slug === slug);
if (!page) return Astro.redirect(""/404"");
const { title, text } = page;
---
<html>
<head>
  <title>{title}</title>
</head>
<body>
  <h1>{title}</h1>
  <p>{text}</p>
</body>
</html>
Redirects
Sometimes you will need to redirect your readers to a new page, either permanently because your site structure has changed or in response to an action such as logging in to an authenticated route.
You can define rules to redirect users to permanently-moved pages in your Astro config. Or, redirect users dynamically as they use your site.
Configured Redirects
Added in: astro@2.9.0
You can specify a mapping of permanent redirects in your Astro config with the redirects value. For most redirects, this is a mapping of an old route to the new route:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  redirects: {
    '/old-page': '/new-page'
  }
});
These redirects follow the same priority rules as file-based routes and will always take lower precedence than an existing page file of the same name in your project. For example, /old-page will not redirect to /new-page if your project contains the file src/pages/old-page.astro.
Dynamic routes are allowed as long as both the new and old routes contain the same parameters, for example:
{
  ""/blog/[...slug]"": ""/articles/[...slug]""
}
Using SSR or a static adapter, you can also provide an object as the value, allowing you to specify the status code in addition to the new destination:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  redirects: {
    '/old-page': {
      status: 302,
      destination: '/new-page'
    }
  }
});
When running astro build, Astro will output HTML files with the meta refresh tag by default. Supported adapters will instead write out the host‚Äôs configuration file with the redirects.
The status code is 301 by default. If building to HTML files the status code is not used by the server.
Dynamic redirects
On the Astro global, the Astro.redirect method allows you to redirect to another page dynamically. You might do this after checking if the user is logged in by getting their session from a cookie.
src/pages/account.astro
---
import { isLoggedIn } from '../utils';
const cookie = Astro.request.headers.get('cookie');
// If the user is not logged in, redirect them to the login page
if (!isLoggedIn(cookie)) {
  return Astro.redirect('/login');
}
---
<html>
  <!-- Page here... -->
</html>
Rewrites
Added in: astro@4.13.0
A rewrite allows you to serve a different route without redirecting the browser to a different page. The browser will show the original address in the URL bar, but will instead display the content of the URL provided to Astro.rewrite().
Tip
For content that has permanently moved, or to direct your user to a different page with a new URL (e.g. a user dashboard after logging in), use a redirect instead.
Rewrites can be useful for showing the same content at multiple paths (e.g. /products/shoes/men/ and /products/men/shoes/) without needing to maintain two different source files.
Rewrites are also useful for SEO purposes and user experience. They allow you to display content that otherwise would require redirecting your visitor to a different page or would return a 404 status. One common use of rewrites is to show the same localized content for different variants of a language.
The following example uses a rewrite to render the /es/ version of a page when the /es-CU/ (Cuban Spanish) URL path is visited. When a visitor navigates to the URL /es-cu/articles/introduction, Astro will render the content generated by the file src/pages/es/articles/introduction.astro.
src/pages/es-cu/articles/introduction.astro
---
return Astro.rewrite(""/es/articles/introduction"")
---
Use context.rewrite() in your endpoint files to reroute to a different page:
src/pages/api.js
export function GET(context) {
  if (!context.locals.allowed) {
    return context.rewrite(""/"")
  }
}
If the URL passed to Astro.rewrite() emits a runtime error, Astro will show the overlay error in development and return a 500 status code in production. If the URL does not exist in your project, a 404 status code will be returned.
You can intentionally create a rewrite to render your /404 page, for example to indicate that a product in your e-commerce shop is no longer available:
src/pages/[item].astro
---
const { item } = Astro.params;
if (!itemExists(item)) {
  return Astro.rewrite(""/404"")
}
---
<div>...</div>
You can also conditionally rewrite based on an HTTP response status, for example to display a certain page on your site when visiting a URL that doesn‚Äôt exist:
src/middleware.mjs
export const onRequest = async (context, next) => {
  const response = await next();
  if (response.status === 404) {
    return context.rewrite(""/"");
  }
  return response;
}
Before displaying the content from the specified rewrite path, the function Astro.rewrite() will trigger a new, complete rendering phase. This re-executes any middleware for the new route/request.
See the Astro.rewrite() API reference for more information.
Route Priority Order
It‚Äôs possible for multiple defined routes to attempt to build the same URL path. For example, all of these routes could build /posts/create:
Directory
src/pages/
[‚Ä¶slug].astro
Directory
posts/
create.astro
[page].astro
[pid].ts
[‚Ä¶slug].astro
Astro needs to know which route should be used to build the page. To do so, it sorts them according to the following rules in order:
Astro reserved routes
Routes with more path segments will take precedence over less specific routes. In the example above, all routes under /posts/ take precedence over /[...slug].astro at the root.
Static routes without path parameters will take precedence over dynamic routes. E.g. /posts/create.astro takes precedence over all the other routes in the example.
Dynamic routes using named parameters take precedence over rest parameters. E.g. /posts/[page].astro takes precedence over /posts/[...slug].astro.
Pre-rendered dynamic routes take precedence over server dynamic routes.
Endpoints take precedence over pages.
File-based routes take precedence over redirects.
If none of the rules above decide the order, routes are sorted alphabetically based on the default locale of your Node installation.
Given the example above, here are a few examples of how the rules will match a requested URL to the route used to build the HTML:
pages/posts/create.astro - Will build only /posts/create
pages/posts/[pid].ts - Will build /posts/abc, /posts/xyz, etc. But not /posts/create
pages/posts/[page].astro - Will build /posts/1, /posts/2, etc. But not /posts/create, /posts/abc nor /posts/xyz
pages/posts/[...slug].astro - Will build /posts/1/2, /posts/a/b/c, etc. But not /posts/create, /posts/1, /posts/abc, etc.
pages/[...slug].astro - Will build /abc, /xyz, /abc/xyz, etc. But not /posts/create, /posts/1, /posts/abc, , etc.
Reserved routes
Internal routes take priority over any user-defined or integration-defined routes as they are required for Astro features to work. The following are Astro‚Äôs reserved routes:
_astro/: Serves all of the static assets to the client, including CSS documents, bundled client scripts, optimized images, and any Vite assets.
_server_islands/: Serves the dynamic components deferred into a server island.
_actions/: Serves any defined actions.
Pagination
Astro supports built-in pagination for large collections of data that need to be split into multiple pages. Astro will generate common pagination properties, including previous/next page URLs, total number of pages, and more.
Paginated route names should use the same [bracket] syntax as a standard dynamic route. For instance, the file name /astronauts/[page].astro will generate routes for /astronauts/1, /astronauts/2, etc, where [page] is the generated page number.
You can use the paginate() function to generate these pages for an array of values like so:
src/pages/astronauts/[page].astro
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  // Generate pages from our array of astronauts, with 2 to a page
  return paginate(astronautPages, { pageSize: 2 });
}
// All paginated data is passed on the ""page"" prop
const { page } = Astro.props;
---
<!--Display the current page number. Astro.params.page can also be used!-->
<h1>Page {page.currentPage}</h1>
<ul>
  <!--List the array of astronaut info-->
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
This generates the following pages, with 2 items to a page:
/astronauts/1 - Page 1: Displays ‚ÄúNeil Armstrong‚Äù and ‚ÄúBuzz Aldrin‚Äù
/astronauts/2 - Page 2: Displays ‚ÄúSally Ride‚Äù and ‚ÄúJohn Glenn‚Äù
The page prop
When you use the paginate() function, each page will be passed its data via a page prop. The page prop has many useful properties that you can use to build pages and links between them:
interface Page<T = any> {
  /** array containing the page‚Äôs slice of data that you passed to the paginate() function */
  data: T[];
  /** metadata */
  /** the count of the first item on the page, starting from 0 */
  start: number;
  /** the count of the last item on the page, starting from 0 */
  end: number;
  /** total number of results */
  total: number;
  /** the current page number, starting from 1 */
  currentPage: number;
  /** number of items per page (default: 10) */
  size: number;
  /** number of last page */
  lastPage: number;
  url: {
    /** url of the current page */
    current: string;
    /** url of the previous page (if there is one) */
    prev: string | undefined;
    /** url of the next page (if there is one) */
    next: string | undefined;
    /** url of the first page (if the current page is not the first page) */
    first: string | undefined;
    /** url of the last page (if the current page in not the last page) */
    last: string | undefined;
  };
}
The following example displays current information for the page along with links to navigate between pages:
src/pages/astronauts/[page].astro
---
// Paginate same list of { astronaut } objects as the previous example
export async function getStaticPaths({ paginate }) { /* ... */ }
const { page } = Astro.props;
---
<h1>Page {page.currentPage}</h1>
<ul>
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
{page.url.first ? <a href={page.url.first}>First</a> : null}
{page.url.prev ? <a href={page.url.prev}>Previous</a> : null}
{page.url.next ? <a href={page.url.next}>Next</a> : null}
{page.url.last ? <a href={page.url.last}>Last</a> : null}
Learn more about the pagination page prop.
Nested Pagination
A more advanced use-case for pagination is nested pagination. This is when pagination is combined with other dynamic route params. You can use nested pagination to group your paginated collection by some property or tag.
For example, if you want to group your paginated Markdown posts by some tag, you would use nested pagination by creating a /src/pages/[tag]/[page].astro page that would match the following URLS:
/red/1 (tag=red)
/red/2 (tag=red)
/blue/1 (tag=blue)
/green/1 (tag=green)
Nested pagination works by returning an array of paginate() results from getStaticPaths(), one for each grouping.
In the following example, we will implement nested pagination to build the URLs listed above:
src/pages/[tag]/[page].astro
---
export async function getStaticPaths({ paginate }) {
  const allTags = ['red', 'blue', 'green'];
  const allPosts = await Astro.glob('../../posts/*.md');
  // For every tag, return a paginate() result.
  // Make sure that you pass `{params: {tag}}` to `paginate()`
  // so that Astro knows which tag grouping the result is for.
  return allTags.flatMap((tag) => {
    const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);
    return paginate(filteredPosts, {
      params: { tag },
      pageSize: 10
    });
  });
}
const { page } = Astro.props;
const params = Astro.params;
Excluding pages
You can exclude pages or directories from being built by prefixing their names with an underscore (_). Files with the _ prefix won‚Äôt be recognized by the router and won‚Äôt be placed into the dist/ directory.
You can use this to temporarily disable pages, and also to put tests, utilities, and components in the same folder as their related pages.
In this example, only src/pages/index.astro and src/pages/posts/post1.md will be built as page routes and HTML files.
Directory
src/pages/
Directory
_hidden-directory/
page1.md
page2.md
_hidden-page.astro
index.astro
Directory
posts/
_SomeComponent.astro
_utils.js
post1.md
Edit page
Translate this page
Previous
Add an RSS feed
Next
Endpoints
Contribute
Give us feedback
Community""""""",4694,19733,astro
https://docs.astro.build/en/guides/endpoints/,"""""""On this page
Overview
Static File Endpoints
params and Dynamic routing
request
Server Endpoints (API Routes)
HTTP methods
request
Redirects
Want to build your own Docs?
Grab this template to get started.‚Üí
Endpoints
Astro lets you create custom endpoints to serve any kind of data. You can use this to generate images, expose an RSS document, or use them as API Routes to build a full API for your site.
In statically-generated sites, your custom endpoints are called at build time to produce static files. If you opt in to SSR mode, custom endpoints turn into live server endpoints that are called on request. Static and SSR endpoints are defined similarly, but SSR endpoints support additional features.
Static File Endpoints
To create a custom endpoint, add a .js or .ts file to the /pages directory. The .js or .ts extension will be removed during the build process, so the name of the file should include the extension of the data you want to create. For example, src/pages/data.json.ts will build a /data.json endpoint.
Endpoints export a GET function (optionally async) that receives a context object with properties similar to the Astro global. Here, it returns a Response object with a name and url, and Astro will call this at build time and use the contents of the body to generate the file.
src/pages/builtwith.json.ts
// Outputs: /builtwith.json
export async function GET({params, request}) {
  return new Response(
    JSON.stringify({
      name: 'Astro',
      url: 'https://astro.build/'
    })
  )
}
Since Astro v3.0, the returned Response object doesn‚Äôt have to include the encoding property anymore. For example, to produce a binary png image:
src/pages/astro-logo.png.ts
export async function GET({ params, request }) {
  const response = await fetch(""https://docs.astro.build/assets/full-logo-light.png"");
  return new Response(await response.arrayBuffer());
}
You can also type your endpoint functions using the APIRoute type:
import type { APIRoute } from 'astro';
export const GET: APIRoute = async ({ params, request }) => {...}
params and Dynamic routing
Endpoints support the same dynamic routing features that pages do. Name your file with a bracketed parameter name and export a getStaticPaths() function. Then, you can access the parameter using the params property passed to the endpoint function:
src/pages/api/[id].json.ts
import type { APIRoute } from 'astro';
const usernames = [""Sarah"", ""Chris"", ""Yan"", ""Elian""]
export const GET: APIRoute = ({ params, request }) => {
  const id = params.id;
  return new Response(
    JSON.stringify({
      name: usernames[id]
    })
  )
}
export function getStaticPaths() {
  return [
    { params: { id: ""0""} },
    { params: { id: ""1""} },
    { params: { id: ""2""} },
    { params: { id: ""3""} }
  ]
}
This will generate four JSON endpoints at build time: /api/0.json, /api/1.json, /api/2.json and /api/3.json. Dynamic routing with endpoints works the same as it does with pages, but because the endpoint is a function and not a component, props aren‚Äôt supported.
request
All endpoints receive a request property, but in static mode, you only have access to request.url. This returns the full URL of the current endpoint and works the same as Astro.request.url does for pages.
src/pages/request-path.json.ts
import type { APIRoute } from 'astro';
export const GET: APIRoute = ({ params, request }) => {
  return new Response(JSON.stringify({
      path: new URL(request.url).pathname
    })
  )
}
Server Endpoints (API Routes)
Everything described in the static file endpoints section can also be used in SSR mode: files can export a GET function which receives a context object with properties similar to the Astro global.
But, unlike in static mode, when you enable on-demand rendering for a route, the endpoint will be built when it is requested. This unlocks new features that are unavailable at build time, and allows you to build API routes that listen for requests and securely execute code on the server at runtime.
Your routes will be rendered on demand by default in server mode. In hybrid mode, you must opt out of prerendering for each custom endpoint with export const prerender = false.
Related recipe:
Call endpoints from the server
Note
Be sure to enable an on-demand rendering mode before trying these examples, and opt out of prerendering in hybrid mode.
Server endpoints can access params without exporting getStaticPaths, and they can return a Response object, allowing you to set status codes and headers:
src/pages/[id].json.js
import { getProduct } from '../db';
export async function GET({ params }) {
  const id = params.id;
  const product = await getProduct(id);
  if (!product) {
    return new Response(null, {
      status: 404,
      statusText: 'Not found'
    });
  }
  return new Response(
    JSON.stringify(product), {
      status: 200,
      headers: {
        ""Content-Type"": ""application/json""
      }
    }
  );
}
This will respond to any request that matches the dynamic route. For example, if we navigate to /helmet.json, params.id will be set to helmet. If helmet exists in the mock product database, the endpoint will use create a Response object to respond with JSON and return a successful HTTP status code. If not, it will use a Response object to respond with a 404.
In SSR mode, certain providers require the Content-Type header to return an image. In this case, use a Response object to specify a headers property. For example, to produce a binary .png image:
src/pages/astro-logo.png.ts
export async function GET({ params, request }) {
  const response = await fetch(""https://docs.astro.build/assets/full-logo-light.png"");
  const buffer = Buffer.from(await response.arrayBuffer());
  return new Response(buffer, {
    headers: { ""Content-Type"": ""image/png"" },
  });
}
HTTP methods
In addition to the GET function, you can export a function with the name of any HTTP method. When a request comes in, Astro will check the method and call the corresponding function.
You can also export an ALL function to match any method that doesn‚Äôt have a corresponding exported function. If there is a request with no matching method, it will redirect to your site‚Äôs 404 page.
src/pages/methods.json.ts
export const GET: APIRoute = ({ params, request }) => {
  return new Response(JSON.stringify({
      message: ""This was a GET!""
    })
  )
}
export const POST: APIRoute = ({ request }) => {
  return new Response(JSON.stringify({
      message: ""This was a POST!""
    })
  )
}
export const DELETE: APIRoute = ({ request }) => {
  return new Response(JSON.stringify({
      message: ""This was a DELETE!""
    })
  )
}
export const ALL: APIRoute = ({ request }) => {
  return new Response(JSON.stringify({
      message: `This was a ${request.method}!`
    })
  )
}
Related recipes
Verify a Captcha
Build forms with API routes
request
In SSR mode, the request property returns a fully usable Request object that refers to the current request. This allows you to accept data and check headers:
src/pages/test-post.json.ts
export const POST: APIRoute = async ({ request }) => {
  if (request.headers.get(""Content-Type"") === ""application/json"") {
    const body = await request.json();
    const name = body.name;
    return new Response(JSON.stringify({
      message: ""Your name was: "" + name
    }), {
      status: 200
    })
  }
  return new Response(null, { status: 400 });
}
Redirects
The endpoint context exports a redirect() utility similar to Astro.redirect:
src/pages/links/[id].js
import { getLinkUrl } from '../db';
export async function GET({ params, redirect }) {
  const { id } = params;
  const link = await getLinkUrl(id);
  if (!link) {
    return new Response(null, {
      status: 404,
      statusText: 'Not found'
    });
  }
  return redirect(link, 307);
}
Edit page
Translate this page
Previous
Routing
Next
Actions
Contribute
Give us feedback
Community""""""",1787,7884,astro
https://docs.astro.build/en/guides/actions/,"""""""On this page
Overview
Basic usage
Write your first action
Organizing actions
Handling returned data
Checking for errors
Accessing data directly without an error check
Handling backend errors in your action
Handling client redirects
Accepting form data from an action
Validating form data
Displaying form input errors
Call actions from an HTML form action
Redirect on action success
Handle form action errors
Update the UI with a form action result
Call actions from Astro components and server endpoints
Want to build your own Docs?
Grab this template to get started.‚Üí
Actions
Added in: astro@4.15
Astro Actions allow you to define and call backend functions with type-safety. Actions perform data fetching, JSON parsing, and input validation for you. This can greatly reduce the amount of boilerplate needed compared to using an API endpoint.
Use actions instead of API endpoints for seamless communication between your client and server code and to:
Automatically validate JSON and form data inputs using Zod validation.
Generate type-safe functions to call your backend from the client and even from HTML form actions. No need for manual fetch() calls.
Standardize backend errors with the ActionError object.
Basic usage
Actions are defined in a server object exported from src/actions/index.ts:
src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  myAction: defineAction({ /* ... */ })
}
Your actions are available as functions from the astro:actions module. Import actions and call them client-side within a UI framework component, a form POST request, or by using a <script> tag in an Astro component.
When you call an action, it returns an object with either data containing the JSON-serialized result, or error containing thrown errors.
src/pages/index.astro
---
---
<script>
import { actions } from 'astro:actions';
async () => {
  const { data, error } = await actions.myAction({ /* ... */ });
}
</script>
Write your first action
Follow these steps to define an action and call it in a script tag in your Astro page.
Create a src/actions/index.ts file and export a server object.
src/actions/index.ts
export const server = {
  // action declarations
}
Import the defineAction() utility from astro:actions, and the z object from astro:schema.
src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
 export const server = {
  // action declarations
}
Use the defineAction() utility to define a getGreeting action. The input property will be used to validate input parameters with a Zod schema and the handler() function includes the backend logic to run on the server.
src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  getGreeting: defineAction({
    input: z.object({
      name: z.string(),
    }),
    handler: async (input) => {
      return `Hello, ${input.name}!`
    }
  })
}
Create an Astro component with a button that will fetch a greeting using your getGreeting action when clicked.
src/pages/index.astro
---
---
<button>Get greeting</button>
<script>
const button = document.querySelector('button');
button?.addEventListener('click', async () => {
  // Show alert pop-up with greeting from action
});
</script>
To use your action, import actions from astro:actions and then call actions.getGreeting() in the click handler. The name option will be sent to your action‚Äôs handler() on the server and, if there are no errors, the result will be available as the data property.
src/pages/index.astro
---
---
<button>Get greeting</button>
<script>
import { actions } from 'astro:actions';
const button = document.querySelector('button');
button?.addEventListener('click', async () => {
  // Show alert pop-up with greeting from action
  const { data, error } = await actions.getGreeting({ name: ""Houston"" });
  if (!error) alert(data);
})
</script>
See the full Actions API documentation for details on defineAction() and its properties.
Organizing actions
All actions in your project must be exported from the server object in the src/actions/index.ts file. You can define actions inline or you can move action definitions to separate files and import them. You can even group related functions in nested objects.
For example, to colocate all of your user actions, you can create a src/actions/user.ts file and nest the definitions of both getUser and createUser inside a single user object.
src/actions/user.ts
import { defineAction } from 'astro:actions';
export const user = {
  getUser: defineAction(/* ... */),
  createUser: defineAction(/* ... */),
}
Then, you can import this user object into your src/actions/index.ts file and add it as a top-level key to the server object alongside any other actions:
src/actions/index.ts
import { user } from './user';
export const server = {
  myAction: defineAction({ /* ... */ }),
  user,
}
Now, all of your user actions are callable from the actions.user object:
actions.user.getUser()
actions.user.createUser()
Handling returned data
Actions return an object containing either data with the type-safe return value of your handler(), or an error with any backend errors. Errors may come from validation errors on the input property or thrown errors within the handler().
Checking for errors
It‚Äôs best to check if an error is present before using the data property. This allows you to handle errors in advance and ensures data is defined without an undefined check.
const { data, error } = await actions.example();
if (error) {
  // handle error cases
  return;
}
// use `data`
Accessing data directly without an error check
To skip error handling, for example while prototyping or using a library that will catch errors for you, use the .orThrow() property on your action call to throw errors instead of returning an error. This will return the action‚Äôs data directly.
This example calls a likePost() action that returns the updated number of likes as a number from the action handler:
const updatedLikes = await actions.likePost.orThrow({ postId: 'example' });
//    ^ type: number
Handling backend errors in your action
You can use the provided ActionError to throw an error from your action handler(), such as ‚Äúnot found‚Äù when a database entry is missing, or ‚Äúunauthorized‚Äù when a user is not logged in. This has two main benefits over returning undefined:
You can set a status code like 404 - Not found or 401 - Unauthorized. This improves debugging errors in both development and in production by letting you see the status code of each request.
In your application code, all errors are passed to the error object on an action result. This avoids the need for undefined checks on data, and allows you to display targeted feedback to the user depending on what went wrong.
Creating an ActionError
To throw an error, import the ActionError() class from the astro:actions module. Pass it a human-readable status code (e.g. ""NOT_FOUND"" or ""BAD_REQUEST""), and an optional message to provide further information about the error.
This example throws an error from a likePost action when a user is not logged in, after checking a hypothetical ‚Äúuser-session‚Äù cookie for authentication:
src/actions/index.ts
import { defineAction, ActionError } from ""astro:actions"";
import { z } from ""astro:schema"";
export const server = {
  likePost: defineAction({
    input: z.object({ postId: z.string() }),
    handler: async (input, ctx) => {
      if (!ctx.cookies.has('user-session')) {
        throw new ActionError({
          code: ""UNAUTHORIZED"",
          message: ""User must be logged in."",
        });
      }
      // Otherwise, like the post
    },
  }),
};
Handling an ActionError
To handle this error, you can call the action from your application and check whether an error property is present. This property will be of type ActionError and will contain your code and message.
In the following example, a LikeButton.tsx component calls the likePost() action when clicked. If an authentication error occurs, the error.code attribute is used to determine whether to display a login link:
src/components/LikeButton.tsx
import { actions } from 'astro:actions';
import { useState } from 'preact/hooks';
export function LikeButton({ postId }: { postId: string }) {
  const [showLogin, setShowLogin] = useState(false);
  return (
    <>
      {
        showLogin && <a href=""/signin"">Log in to like a post.</a>
      }
      <button onClick={async () => {
        const { data, error } = await actions.likePost({ postId });
        if (error?.code === 'UNAUTHORIZED') setShowLogin(true);
        // Early return for unexpected errors
        else if (error) return;
        // update likes
      }}>
        Like
      </button>
    </>
  )
}
Handling client redirects
When calling actions from the client, you can integrate with a client-side library like react-router, or you can use Astro‚Äôs navigate() function to redirect to a new page when an action succeeds.
This example navigates to the homepage after a logout action returns successfully:
src/pages/LogoutButton.tsx
import { actions } from 'astro:actions';
import { navigate } from 'astro:transitions/client';
export function LogoutButton() {
  return (
    <button onClick={async () => {
      const { error } = await actions.logout();
      if (!error) navigate('/');
    }}>
      Logout
    </button>
  );
}
Accepting form data from an action
Actions accept JSON data by default. To accept form data from an HTML form, set accept: 'form' in your defineAction() call:
src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  comment: defineAction({
    accept: 'form',
    input: z.object(/* ... */),
    handler: async (input) => { /* ... */ },
  })
}
Validating form data
Actions will parse submitted form data to an object, using the value of each input‚Äôs name attribute as the object keys. For example, a form containing <input name=""search""> will be parsed to an object like { search: 'user input' }. Your action‚Äôs input schema will be used to validate this object.
To receive the raw FormData object in your action handler instead of a parsed object, omit the input property in your action definition.
The following example shows a validated newsletter registration form that accepts a user‚Äôs email and requires a ‚Äúterms of service‚Äù agreement checkbox.
Create an HTML form component with unique name attributes on each input:
src/components/Newsletter.astro
<form>
  <label for=""email"">E-mail</label>
  <input id=""email"" required type=""email"" name=""email"" />
  <label>
    <input required type=""checkbox"" name=""terms"">
    I agree to the terms of service
  </label>
  <button>Sign up</button>
</form>
Define a newsletter action to handle the submitted form. Validate the email field using the z.string().email() validator, and the terms checkbox using z.boolean():
src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  newsletter: defineAction({
    accept: 'form',
    input: z.object({
      email: z.string().email(),
      terms: z.boolean(),
    }),
    handler: async ({ email, terms }) => { /* ... */ },
  })
}
See the input API reference for all available form validators.
Add a <script> to the HTML form to submit the user input. This example overrides the form‚Äôs default submit behavior to call actions.newsletter(), and redirects to /confirmation using the navigate() function:
src/components/Newsletter.astro
<form>
7 collapsed lines
</form>
<script>
  import { actions } from 'astro:actions';
  import { navigate } from 'astro:transitions/client';
  const form = document.querySelector('form');
  form?.addEventListener('submit', async (event) => {
    event.preventDefault();
    const formData = new FormData(form);
    const { error } = await actions.newsletter(formData);
    if (!error) navigate('/confirmation');
  })
</script>
See ‚ÄúCall actions from an HTML form action‚Äù for an alternative way to submit form data.
Displaying form input errors
You can validate form inputs before submission using native HTML form validation attributes like required, type=""email"", and pattern. For more complex input validation on the backend, you can use the provided isInputError() utility function.
To retrieve input errors, use the isInputError() utility to check whether an error was caused by invalid input. Input errors contain a fields object with messages for each input name that failed to validate. You can use these messages to prompt your user to correct their submission.
The following example checks the error with isInputError(), then checks whether the error is in the email field, before finally creating a message from the errors. You can use JavaScript DOM manipulation or your preferred UI framework to display this message to users.
import { actions, isInputError } from 'astro:actions';
const form = document.querySelector('form');
const formData = new FormData(form);
const { error } = await actions.newsletter(formData);
if (isInputError(error)) {
  // Handle input errors.
  if (error.fields.email) {
    const message = error.fields.email.join(', ');
  }
}
Call actions from an HTML form action
Note
Pages must be on-demand rendered when calling actions using a form action. Ensure prerendering is disabled on the page before using this API.
You can enable zero-JS form submissions with standard attributes on any <form> element. Form submissions without client-side JavaScript may be useful both as a fallback for when JavaScript fails to load, or if you prefer to handle forms entirely from the server.
Calling Astro.getActionResult() on the server returns the result of your form submission (data or error), and can be used to dynamically redirect, handle form errors, update the UI, and more.
To call an action from an HTML form, add method=""POST"" to your <form>, then set the form‚Äôs action attribute using your action, for example action={actions.logout}. This will set the action attribute to use a query string that is handled by the server automatically.
For example, this Astro component calls the logout action when the button is clicked and reloads the current page:
src/components/LogoutButton.astro
---
import { actions } from 'astro:actions';
---
<form method=""POST"" action={actions.logout}>
  <button>Log out</button>
</form>
Redirect on action success
To navigate to a different page when an action is successful without client-side JavaScript, you can prepend a path in the action attribute.
For example, action={'/confirmation' + actions.newsletter} will navigate to /confirmation when the newsletter action succeeds:
src/components/NewsletterSignup.astro
---
import { actions } from 'astro:actions';
---
<form method=""POST"" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type=""email"" name=""email"" /></label>
  <button>Sign up</button>
</form>
Dynamic redirect on action success
If you need to decide where to redirect to dynamically, you can use an action‚Äôs result on the server. A common example is creating a product record and redirecting to the new product‚Äôs page, e.g. /products/[id].
For example, say you have a createProduct action that returns the generated product id:
src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  createProduct: defineAction({
    accept: 'form',
    input: z.object({ /* ... */ }),
    handler: async (input) => {
      const product = await persistToDatabase(input);
      return { id: product.id };
    },
  })
}
You can retrieve the action result from your Astro component by calling Astro.getActionResult(). This returns an object containing data or error properties when an action is called, or undefined if the action was not called during this request.
Use the data property to construct a URL to use with Astro.redirect():
src/pages/products/create.astro
---
import { actions } from 'astro:actions';
const result = Astro.getActionResult(actions.createProduct);
if (result && !result.error) {
  return Astro.redirect(`/products/${result.data.id}`);
}
---
<form method=""POST"" action={actions.createProduct}>
  <!--...-->
</form>
Handle form action errors
Astro will not redirect to your action route when an action fails. Instead, the current page is reloaded with any errors the action returned. Calling Astro.getActionResult() in the Astro component containing your form gives you access to the error object for custom error handling.
The following example displays a general failure message when a newsletter action fails:
src/pages/index.astro
---
import { actions } from 'astro:actions';
const result = Astro.getActionResult(actions.newsletter);
---
{result?.error && (
  <p class=""error"">Unable to sign up. Please try again later.</p>
)}
<form method=""POST"" action={'/confirmation' + actions.newsletter}>
  <label>
    E-mail
    <input required type=""email"" name=""email"" />
  </label>
  <button>Sign up</button>
</form>
For more customization, you can use the isInputError() utility to check whether an error is caused by invalid input.
The following example renders an error banner under the email input field when an invalid email is submitted:
src/pages/index.astro
---
import { actions, isInputError } from 'astro:actions';
const result = Astro.getActionResult(actions.newsletter);
const inputErrors = isInputError(result?.error) ? result.error.fields : {};
---
<form method=""POST"" action={'/confirmation' + actions.newsletter}>
  <label>
    E-mail
    <input required type=""email"" name=""email"" aria-describedby=""error"" />
  </label>
  {inputErrors.email && <p id=""error"">{inputErrors.email.join(',')}</p>}
  <button>Sign up</button>
</form>
Note
Astro persists action data and error with a single-use cookie. This means getActionResult() will return a result on the first request only, and undefined when revisiting the page.
Preserve input values on error
Inputs will be cleared whenever a form is submitted. To persist input values, you can enable view transitions on the page and apply the transition:persist directive to each input:
<input transition:persist required type=""email"" name=""email"" />
Update the UI with a form action result
The result returned by Astro.getActionResult() is single-use, and will reset to undefined whenever the page is refreshed. This is ideal for displaying input errors and showing temporary notifications to the user on success.
Tip
If you need a result to be displayed across page refreshes, consider storing the result in a database or in a cookie.
Pass an action to Astro.getActionResult() and use the returned data property to render any temporary UI you want to display. This example uses the productName property returned by an addToCart action to show a success message:
src/pages/products/[slug].astro
---
import { actions } from 'astro:actions';
const result = Astro.getActionResult(actions.addToCart);
---
{result && !result.error && (
  <p class=""success"">Added {result.data.productName} to cart</p>
)}
<!--...-->
Caution
Action data is passed using a persisted cookie. This cookie is not encrypted and is limited to 4 KB in size, although the exact limit may vary between browsers.
In general, we recommend returning the minimum information required from your action handler to avoid vulnerabilities, and persist other sensitive information in a database.
For example, you might return the name of a product in an addToCart action, rather than returning the entire product object:
src/actions/index.ts
import { defineAction } from 'astro:actions';
export const server = {
  addToCart: defineAction({
    handler: async () => {
      /* ... */
      return product;
      return { productName: product.name };
    }
  })
}
Call actions from Astro components and server endpoints
You can call actions directly from Astro component scripts using the Astro.callAction() wrapper (or context.callAction() when using a server endpoint). This is common to reuse logic from your actions in other server code.
Pass the action as the first argument and any input parameters as the second argument. This returns the same data and error objects you receive when calling actions on the client:
src/pages/products.astro
---
import { actions } from 'astro:actions';
const searchQuery = Astro.url.searchParams.get('search');
if (searchQuery) {
  const { data, error } = Astro.callAction(actions.findProduct, { query: searchQuery });
  // handle result
}
---
Edit page
Translate this page
Previous
Endpoints
Next
Prefetch
Contribute
Give us feedback
Community""""""",4449,20663,astro
https://docs.astro.build/en/guides/prefetch/,"""""""On this page
Overview
Enable prefetching
Prefetch configuration
Prefetch strategies
Default prefetch strategy
Prefetch all links by default
Prefetch programmatically
Using with View Transitions
Browser support
Chrome
Firefox
Safari
Recommendations
Migrating from @astrojs/prefetch
Want to build your own Docs?
Grab this template to get started.‚Üí
Prefetch
Page load times play a big role in the usability and overall enjoyment of a site. Astro‚Äôs opt-in prefetching brings the benefits of near-instant page navigations to your multi-page application (MPA) as your visitors interact with the site.
Enable prefetching
You can enable prefetching with the prefetch config:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  prefetch: true
});
A prefetch script will be added to all pages of your site. You can then add the data-astro-prefetch attribute to any <a /> links on your site to opt-in to prefetching. When you hover over the link, the script will fetch the page in the background.
<a href=""/about"" data-astro-prefetch>
Note that prefetching only works for links within your site, and not external links.
Prefetch configuration
The prefetch config also accepts an option object to further customize prefetching.
Prefetch strategies
Astro supports 4 prefetch strategies for various use cases:
hover (default): Prefetch when you hover over or focus on the link.
tap: Prefetch just before you click on the link.
viewport: Prefetch as the links enter the viewport.
load: Prefetch all links on the page after the page is loaded.
You can specify a strategy for an individual link by passing it to the data-astro-prefetch attribute:
<a href=""/about"" data-astro-prefetch=""tap"">About</a>
Each strategy is fine-tuned to only prefetch when needed and save your users‚Äô bandwidth. For example:
If a visitor is using data saver mode or has a slow connection, prefetch will fallback to the tap strategy.
Quickly hovering or scrolling over links will not prefetch them.
Default prefetch strategy
The default prefetch strategy when adding the data-astro-prefetch attribute is hover. To change it, you can configure prefetch.defaultStrategy in your astro.config.mjs file:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  prefetch: {
    defaultStrategy: 'viewport'
  }
});
Prefetch all links by default
If you want to prefetch all links, including those without the data-astro-prefetch attribute, you can set prefetch.prefetchAll to true:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  prefetch: {
    prefetchAll: true
  }
});
You can then opt-out of prefetching for individual links by setting data-astro-prefetch=""false"":
<a href=""/about"" data-astro-prefetch=""false"">About</a>
The default prefetch strategy for all links can be changed with prefetch.defaultStrategy as shown in the Default prefetch strategy section.
Prefetch programmatically
As some navigation might not always appear as <a /> links, you can also prefetch programmatically with the prefetch() API from the astro:prefetch module:
<button id=""btn"">Click me</button>
<script>
  import { prefetch } from 'astro:prefetch';
  const btn = document.getElementById('btn');
  btn.addEventListener('click', () => {
    prefetch('/about');
  });
</script>
The prefetch() API includes the same data saver mode and slow connection detection so that it only prefetches when needed.
To ignore slow connection detection, you can use the ignoreSlowConnection option:
// Prefetch even on data saver mode or slow connection
prefetch('/about', { ignoreSlowConnection: true });
Make sure to only import prefetch() in client-side scripts as it relies on browser APIs.
Using with View Transitions
When you use View Transitions on a page, prefetching will also be enabled by default. It sets a default configuration of { prefetchAll: true } which enables prefetching for all links on the page.
You can customize the prefetch configuration in astro.config.mjs to override the default. For example:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  // Disable prefetch completely
  prefetch: false
});
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  // Keep prefetch, but only prefetch for links with `data-astro-prefetch`
  prefetch: {
    prefetchAll: false
  }
});
Browser support
Astro‚Äôs prefetching uses <link rel=""prefetch""> if supported by the browser, and falls back to the fetch() API otherwise.
The most common browsers support Astro‚Äôs prefetching with subtle differences:
Chrome
Chrome supports <link rel=""prefetch"">. Prefetching works as intended.
Firefox
Firefox supports <link rel=""prefetch""> but may display errors or fail entirely:
Without an explicit cache header (e.g. Cache-Control or Expires), prefetching will error with NS_BINDING_ABORTED.
Even in the event of an error, if the response has a proper ETag header, it will be re-used on navigation.
Otherwise, if it errors with no other cache headers, the prefetch will not work.
Safari
Safari does not support <link rel=""prefetch""> and will fall back to the fetch() API which requires cache headers (e.g. Cache-Control, Expires, and ETag) to be set. Otherwise, the prefetch will not work.
Edge case: ETag headers do not work in private windows.
Recommendations
To best support all browsers, make sure your pages have the proper cache headers.
For static or prerendered pages, the ETag header is often automatically set by the deployment platform and is expected to work out of the box.
For dynamic and server-side rendered pages, set the appropriate cache headers yourself based on the page content. Visit the MDN documentation on HTTP caching for more information.
Migrating from @astrojs/prefetch
The @astrojs/prefetch integration was deprecated in v3.5.0 and will eventually be removed entirely. Use the following instructions to migrate to Astro‚Äôs built-in prefetching which replaces this integration.
Remove the @astrojs/prefetch integration and enable the prefetch config in astro.config.mjs:
astro.config.mjs
import { defineConfig } from 'astro/config';
import prefetch from '@astrojs/prefetch';
export default defineConfig({
  integrations: [prefetch()],
  prefetch: true
});
Convert from @astrojs/prefetch‚Äôs configuration options:
The deprecated integration used the selector config option to specify which links should be prefetched upon entering the viewport.
Add data-astro-prefetch=""viewport"" to these individual links instead.
<a href=""/about"" data-astro-prefetch=""viewport"">
The deprecated integration used the intentSelector config option to specify which links should be prefetched when they were hovered over or focused.
Add data-astro-prefetch or data-astro-prefetch=""hover"" to these individual links instead:
<!-- You can omit the value if `defaultStrategy` is set to `hover` (default) -->
<a href=""/about"" data-astro-prefetch>
<!-- Otherwise, you can explicitly define the prefetch strategy -->
<a href=""/about"" data-astro-prefetch=""hover"">
The throttles option from @astrojs/prefetch is no longer needed as the new prefetch feature will automatically schedule and prefetch optimally.
Edit page
Translate this page
Previous
Actions
Next
Middleware
Contribute
Give us feedback
Community""""""",1603,7331,astro
https://docs.astro.build/en/guides/middleware/,"""""""On this page
Overview
Basic Usage
The context object
Storing data in context.locals
Example: redacting sensitive information
Middleware types
Chaining middleware
Rewriting
Error pages
Want to build your own Docs?
Grab this template to get started.‚Üí
Middleware
Middleware allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. This rendering occurs at build time for all prerendered pages, but occurs when the route is requested for pages rendered on demand, making additional SSR features like cookies and headers available.
Middleware also allows you to set and share request-specific information across endpoints and pages by mutating a locals object that is available in all Astro components and API endpoints. This object is available even when this middleware runs at build time.
Basic Usage
Create src/middleware.js|ts (Alternatively, you can create src/middleware/index.js|ts.)
Inside this file, export an onRequest() function that can be passed a context object and next() function. This must not be a default export.
src/middleware.js
export function onRequest (context, next) {
    // intercept data from a request
    // optionally, modify the properties in `locals`
    context.locals.title = ""New title"";
    // return a Response or the result of calling `next()`
    return next();
};
Inside any .astro file, access response data using Astro.locals.
src/components/Component.astro
---
const data = Astro.locals;
---
<h1>{data.title}</h1>
<p>This {data.property} is from middleware.</p>
The context object
The context object includes information to be made available to other middleware, API routes and .astro routes during the rendering process.
This is an optional argument passed to onRequest() that may contain the locals object as well as any additional properties to be shared during rendering. For example, the context object may include cookies used in authentication.
Storing data in context.locals
context.locals is an object that can be manipulated inside the middleware.
This locals object is forwarded across the request handling process and is available as a property to APIContext and AstroGlobal. This allows data to be shared between middlewares, API routes, and .astro pages. This is useful for storing request-specific data, such as user data, across the rendering step.
Integration properties
Integrations may set properties and provide functionality through the locals object. If you are using an integration, check its documentation to ensure you are not overriding any of its properties or doing unnecessary work.
You can store any type of data inside locals: strings, numbers, and even complex data types such as functions and maps.
src/middleware.js
export function onRequest (context, next) {
    // intercept data from a request
    // optionally, modify the properties in `locals`
    context.locals.user.name = ""John Wick"";
    context.locals.welcomeTitle = () => {
        return ""Welcome back "" + locals.user.name;
    };
    // return a Response or the result of calling `next()`
    return next();
};
Then you can use this information inside any .astro file with Astro.locals.
src/pages/orders.astro
---
const title = Astro.locals.welcomeTitle();
const orders = Array.from(Astro.locals.orders.entries());
---
<h1>{title}</h1>
<p>This {data.property} is from middleware.</p>
<ul>
    {orders.map(order => {
        return <li>{/* do something with each order */}</li>;
    })}
</ul>
locals is an object that lives and dies within a single Astro route; when your route page is rendered, locals won‚Äôt exist anymore and a new one will be created. Information that needs to persist across multiple page requests must be stored elsewhere.
Note
The value of locals cannot be overridden at run time. Doing so would risk wiping out all the information stored by the user. In dev mode, Astro performs checks and will throw an error if locals are overridden.
Example: redacting sensitive information
The example below uses middleware to replace ‚ÄúPRIVATE INFO‚Äù with the word ‚ÄúREDACTED‚Äù to allow you to render modified HTML on your page:
src/middleware.js
export const onRequest = async (context, next) => {
    const response = await next();
    const html = await response.text();
    const redactedHtml = html.replaceAll(""PRIVATE INFO"", ""REDACTED"");
    return new Response(redactedHtml, {
        status: 200,
        headers: response.headers
    });
};
Middleware types
You can import and use the utility function defineMiddleware() to take advantage of type safety:
src/middleware.ts
import { defineMiddleware } from ""astro:middleware"";
// `context` and `next` are automatically typed
export const onRequest = defineMiddleware((context, next) => {
});
Instead, if you‚Äôre using JsDoc to take advantage of type safety, you can use MiddlewareHandler:
src/middleware.js
/**
 * @type {import(""astro"").MiddlewareHandler}
 */
// `context` and `next` are automatically typed
export const onRequest = (context, next) => {
};
To type the information inside Astro.locals, which gives you autocompletion inside .astro files and middleware code, declare a global namespace in the env.d.ts file:
src/env.d.ts
/// <reference path=""../.astro/types.d.ts"" />
declare namespace App {
    interface Locals {
        user: {
            name: string
        },
        welcomeTitle: () => string,
        orders: Map<string, object>
    }
}
Then, inside the middleware file, you can take advantage of autocompletion and type safety.
Chaining middleware
Multiple middlewares can be joined in a specified order using sequence():
src/middleware.js
import { sequence } from ""astro:middleware"";
async function validation(_, next) {
    console.log(""validation request"");
    const response = await next();
    console.log(""validation response"");
    return response;
}
async function auth(_, next) {
    console.log(""auth request"");
    const response = await next();
    console.log(""auth response"");
    return response;
}
async function greeting(_, next) {
    console.log(""greeting request"");
    const response = await next();
    console.log(""greeting response"");
    return response;
}
export const onRequest = sequence(validation, auth, greeting);
This will result in the following console order:
Terminal window
validation request
auth request
greeting request
greeting response
auth response
validation response
Rewriting
Added in: astro@4.13.0
The APIContext exposes a method called rewrite() which works the same way as Astro.rewrite.
Use context.rewrite() inside middleware to display a different page‚Äôs content without redirecting your visitor to a new page. This will trigger a new rendering phase, causing any middleware to be re-executed.
src/middleware.js
import { isLoggedIn } from ""~/auth.js""
export function onRequest (context, next) {
  if (!isLoggedIn(context)) {
    // If the user is not logged in, update the Request to render the `/login` route and
    // add header to indicate where the user should be sent after a successful login.
    // Re-execute middleware.
    return context.rewrite(new Request(""/login"", {
      headers: {
        ""x-redirect-to"": context.url.pathname
      }
    }));
  }
  return next();
};
You can also pass the next() function an optional URL path parameter to rewrite the current Request without retriggering a new rendering phase. The location of the rewrite path can be provided as a string, URL, or Request:
src/middleware.js
import { isLoggedIn } from ""~/auth.js""
export function onRequest (context, next) {
  if (!isLoggedIn(context)) {
    // If the user is not logged in, update the Request to render the `/login` route and
    // add header to indicate where the user should be sent after a successful login.
    // Return a new `context` to any following middlewares.
    return next(new Request(""/login"", {
      headers: {
        ""x-redirect-to"": context.url.pathname
      }
    }));
  }
  return next();
};
The next() function accepts the same payload of the Astro.rewrite() function. The location of the rewrite path can be provided as a string, URL, or Request.
When you have multiple middleware functions chained via sequence(), submitting a path to next() will rewrite the Request in place and the middleware will not execute again. The next middleware function in the chain will receive the new Request with its updated context:
Calling next() with this signature will create a new Request object using the old ctx.request. This means that trying to consume Request.body, either before or after this rewrite, will throw a runtime error. This error is often raised with Astro Actions that use HTML forms. In these cases, we recommend handling rewrites from your Astro templates using Astro.rewrite() instead of using middleware.
src/middleware.js
// Current URL is https://example.com/blog
// First middleware function
async function first(_, next) {
  console.log(context.url.pathname) // this will log ""/blog""
  // Rewrite to a new route, the homepage
  // Return updated `context` which is passed to next function
  return next(""/"")
}
// Current URL is still https://example.com/blog
// Second middleware function
async function second(context, next) {
  // Receives updated `context`
  console.log(context.url.pathname) // this will log  ""/""
  return next()
}
export const onRequest = sequence(first, second);
Error pages
Middleware will attempt to run for all on-demand rendered pages, even when a matching route cannot be found. This includes Astro‚Äôs default (blank) 404 page and any custom 404 pages. However, it is up to the adapter to decide whether that code runs. Some adapters may serve a platform-specific error page instead.
Middleware will also attempt to run before serving a 500 error page, including a custom 500 page, unless the server error occured in the execution of the middleware itself. If your middleware does not run successfully, then you will not have access to Astro.locals to render your 500 page.
Edit page
Translate this page
Previous
Prefetch
Next
Internationalization
Contribute
Give us feedback
Community""""""",2119,10111,astro
https://docs.astro.build/en/guides/internationalization/,"""""""On this page
Overview
Routing Logic
Configure i18n routing
Create localized folders
Create links
routing
prefixDefaultLocale
redirectToDefaultLocale
manual
domains
Fallback
Custom locale paths
Browser language detection
Want to build your own Docs?
Grab this template to get started.‚Üí
Internationalization (i18n) Routing
Astro‚Äôs internationalization (i18n) features allow you to adapt your project for an international audience. This routing API helps you generate, use, and verify the URLs that your multi-language site produces.
Astro‚Äôs i18n routing allows you to bring your multilingual content with support for configuring a default language, computing relative page URLs, and accepting preferred languages provided by your visitor‚Äôs browser. You can also specify fallback languages on a per-language basis so that your visitors can always be directed to existing content on your site.
Routing Logic
Astro uses a middleware to implement its routing logic. This middleware function is placed in the first position where it awaits every Response coming from any additional middleware and each page route before finally executing its own logic.
This means that operations (e.g. redirects) from your own middleware and your page logic are run first, your routes are rendered, and then the i18n middleware performs its own actions such as verifying that a localized URL corresponds to a valid route.
You can also choose to add your own i18n logic in addition to or instead of Astro‚Äôs i18n middleware, giving you even more control over your routes while still having access to the astro:i18n helper functions.
Configure i18n routing
Both a default language (defaultLocale) and a list of all supported languages (locales) must be specified in an i18n configuration object. Additionally, you can configure more specific routing and fallback behavior to match your desired URLs.
astro.config.mjs
import { defineConfig } from ""astro/config""
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""es"", ""en"", ""pt-br""],
  }
})
Create localized folders
Organize your content folders with localized content by language. Create individual /[locale]/ folders anywhere within src/pages/ and Astro‚Äôs file-based routing will create your pages at corresponding URL paths.
Your folder names must match the items in locales exactly. Include a localized folder for your defaultLocale only if you configure prefixDefaultLocale: true to show a localized URL path for your default language (e.g. /en/about/).
Directory
src
Directory
pages
about.astro
index.astro
Directory
es
about.astro
index.astro
Directory
pt-br
about.astro
index.astro
Note
The localized folders do not need to be at the root of the /pages/ folder.
Create links
With i18n routing configured, you can now compute links to pages within your site using the helper functions such as getRelativeLocaleUrl() available from the astro:i18n module. These generated links will always provide the correct, localized route and can help you correctly use, or check, URLs on your site.
You can also still write the links manually.
src/pages/es/index.astro
---
import { getRelativeLocaleUrl } from 'astro:i18n';
// defaultLocale is ""es""
const aboutURL = getRelativeLocaleUrl(""es"", ""about"");
---
<a href=""/get-started/"">¬°Vamos!</a>
<a href={getRelativeLocaleUrl('es', 'blog')}>Blog</a>
<a href={aboutURL}>Acerca</a>
routing
Astro‚Äôs built-in file-based routing automatically creates URL routes for you based on your file structure within src/pages/.
When you configure i18n routing, information about this file structure (and the corresponding URL paths generated) is available to the i18n helper functions so they can generate, use, and verify the routes in your project. Many of these options can be used together for even more customization and per-language flexibility.
You can even choose to implement your own routing logic manually for even greater control.
prefixDefaultLocale
Added in: astro@3.5.0
This routing option defines whether or not your default language‚Äôs URLs should use a language prefix (e.g. /en/about/).
All non-default supported languages will use a localized prefix (e.g. /fr/ or /french/) and content files must be located in appropriate folders. This configuration option allows you to specify whether your default language should also follow a localized URL structure.
This setting also determines where the page files for your default language must exist (e.g. src/pages/about/ or src/pages/en/about) as the file structure and URL structure must match for all languages.
""prefixDefaultLocale: false"" (default): URLs in your default language will not have a /[locale]/ prefix. All other locales will.
""prefixDefaultLocale: true"": All URLs, including your default language, will have a /[locale]/ prefix.
prefixDefaultLocale: false
astro.config.mjs
import { defineConfig } from ""astro/config""
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""es"", ""en"", ""fr""],
    routing: {
        prefixDefaultLocale: false
    }
  }
})
This is the default value. Set this option when URLs in your default language will not have a /[locale]/ prefix and files in your default language exist at the root of src/pages/:
Directory
src
Directory
pages
about.astro
index.astro
Directory
es
about.astro
index.astro
Directory
fr
about.astro
index.astro
src/pages/about.astro will produce the route example.com/about/
src/pages/fr/about.astro will produce the route example.com/fr/about/
prefixDefaultLocale: true
astro.config.mjs
import { defineConfig } from ""astro/config""
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""es"", ""en"", ""fr""],
    routing: {
        prefixDefaultLocale: true
    }
  }
})
Set this option when all routes will have their /locale/ prefix in their URL and when all page content files, including those for your defaultLocale, exist in a localized folder:
Directory
src
Directory
pages
index.astro
// Note: this file is always required
Directory
en
index.astro
about.astro
Directory
es
about.astro
index.astro
Directory
pt-br
about.astro
index.astro
URLs without a locale prefix, (e.g. example.com/about/) will return a 404 (not found) status code unless you specify a fallback strategy.
redirectToDefaultLocale
Added in: astro@4.2.0
Configures whether or not the home URL (/) generated by src/pages/index.astro will redirect to /<defaultLocale>.
Setting prefixDefaultLocale: true will also automatically set redirectToDefaultLocale: true in your routing config object. By default, the required src/pages/index.astro file will automatically redirect to the index page of your default locale.
You can opt out of this behavior by setting redirectToDefaultLocale: false. This allows you to have a site home page that exists outside of your configured locale folder structure.
manual
Added in: astro@4.6.0
When this option is enabled, Astro will disable its i18n middleware so that you can implement your own custom logic. No other routing options (e.g. prefixDefaultLocale) may be configured with routing: ""manual"".
You will be responsible for writing your own routing logic, or executing Astro‚Äôs i18n middleware manually alongside your own.
astro.config.mjs
import { defineConfig } from ""astro/config""
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""es"", ""en"", ""fr""],
    routing: ""manual""
  }
})
Astro provides helper functions for your middleware so you can control your own default routing, exceptions, fallback behavior, error catching, etc: redirectToDefaultLocale(), notFound(), and redirectToFallback():
src/middleware.js
import { defineMiddleware } from ""astro:middleware"";
import { redirectToDefaultLocale } from ""astro:i18n""; // function available with `manual` routing
export const onRequest = defineMiddleware(async (ctx, next) => {
  if (ctx.url.startsWith(""/about"")) {
    return next();
  } else {
    return redirectToDefaultLocale(302);
  }
})
middleware function
The middleware function manually creates Astro‚Äôs i18n middleware. This allows you to extend Astro‚Äôs i18n routing instead of completely replacing it.
You can run middleware with routing options in combination with your own middleware, using the sequence utility to determine the order:
src/middleware.js
import {defineMiddleware, sequence} from ""astro:middleware"";
import { middleware } from ""astro:i18n""; // Astro's own i18n routing config
export const userMiddleware = defineMiddleware(async (ctx, next) => {
  // this response might come from Astro's i18n middleware, and it might return a 404
  const response = await next();
  // the /about page is an exception and we want to render it
  if (ctx.url.startsWith(""/about"")) {
    return new Response(""About page"", {
      status: 200
    });
  } else {
    return response;
  }
});
export const onRequest = sequence(
  userMiddleware,
  middleware({
    redirectToDefaultLocale: false,
    prefixDefaultLocale: true
  })
)
domains
Added in: astro@4.9.0
This routing option allows you to customize your domains on a per-language basis for server rendered projects using the @astrojs/node or @astrojs/vercel adapter with a site configured.
Add i18n.domains to map any of your supported locales to custom URLs:
astro.config.mjs
import { defineConfig } from ""astro/config""
export default defineConfig({
  site: ""https://example.com"",
  output: ""server"", // required, with no prerendered pages
  adapter: node({
    mode: 'standalone',
  }),
  i18n: {
    defaultLocale: ""en"",
    locales: [""es"", ""en"", ""fr"", ""ja""],
    routing: {
      prefixDefaultLocale: false
    },
    domains: {
        fr: ""https://fr.example.com"",
        es: ""https://example.es""
    }
  }
})
All non-mapped locales will follow your prefixDefaultLocales configuration. However, even if this value is false, page files for your defaultLocale must also exist within a localized folder. For the configuration above, an /en/ folder is required.
With the above configuration:
The file /fr/about.astro will create the URL https://fr.example.com/about.
The file /es/about.astro will create the URL https://example.es/about.
The file /ja/about.astro will create the URL https://example.com/ja/about.
The file /en/about.astro will create the URL https://example.com/about.
The above URLs will also be returned by the getAbsoluteLocaleUrl() and getAbsoluteLocaleUrlList() functions.
Fallback
When a page in one language doesn‚Äôt exist (e.g. a page that is not yet translated), instead of displaying a 404 page, you can choose to display fallback content from another locale on a per-language basis. This is useful when you do not yet have a page for every route, but you want to still provide some content to your visitors.
Your fallback strategy consists of two parts: choosing which languages should fallback to which other languages (i18n.fallback) and choosing whether to perform a redirect or a rewrite to show the fallback content (i18n.routing.fallbackType added in Astro v4.15.0).
For example, when you configure i18n.fallback: { fr: ""es"" }, Astro will ensure that a page is built in src/pages/fr/ for every page that exists in src/pages/es/.
If any page does not already exist, then a page will be created depending on your fallbackType:
With a redirect to the corresponding es route (default behavior).
With the content of the /es/ page (i18n.routing.fallbackType: ""rewrite"").
For example, the configuration below sets es as the fallback locale for any missing fr routes. This means that a user visiting example.com/fr/my-page/ will be shown the content for example.com/es/my-page/ (without being redirected) instead of being taken to a 404 page when src/pages/fr/my-page.astro does not exist.
astro.config.mjs
import { defineConfig } from ""astro/config""
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""es"", ""en"", ""fr""],
    fallback: {
      fr: ""es""
    },
    routing: {
      fallbackType: ""rewrite""
    }
  }
})
Custom locale paths
In addition to defining your site‚Äôs supported locales as strings (e.g. ‚Äúen‚Äù, ‚Äúpt-br‚Äù), Astro also allows you to map an arbitrary number of browser-recognized language codes to a custom URL path. While locales can be strings of any format as long as they correspond to your project folder structure, codes must follow the browser‚Äôs accepted syntax.
Pass an object to the locales array with a path key to define a custom URL prefix, and codes to indicate the languages mapped to this URL. In this case, your /[locale]/ folder name must match exactly the value of the path and your URLs will be generated using the path value.
This is useful if you support multiple variations of a language (e.g. ""fr"", ""fr-BR"", and ""fr-CA"") and you want to have all these variations mapped under the same URL /fr/, or even customize it entirely (e.g. /french/):
astro.config.mjs
import { defineConfig } from ""astro/config""
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""es"", ""en"", ""fr""],
    locales: [""es"", ""en"", {
        path: ""french"", // no slashes included
        codes: [""fr"", ""fr-BR"", ""fr-CA""]
    }],
    routing: {
        prefixDefaultLocale: true
    }
  }
})
When using functions from the astro:i18n virtual module to compute valid URL paths based on your configuration (e.g. getRelativeLocaleUrl()), use the path as the value for locale.
Limitations
This feature has some restrictions:
The site option is mandatory.
The output option must be set to ""server"".
There cannot be any individual prerendered pages.
The adapter feature functionPerRoute is not supported.
Astro relies on the following headers in order to support the feature:
X-Forwarded-Host and Host. Astro will use the former, and if not present, will try the latter.
X-Forwarded-Proto and URL#protocol of the server request.
Make sure that your server proxy/hosting platform is able to provide this information. Failing to retrieve these headers will result in a 404 (status code) page.
Browser language detection
Astro‚Äôs i18n routing allows you to access two properties for browser language detection in pages rendered on demand: Astro.preferredLocale and Astro.preferredLocaleList. All pages, including static prerendered pages, have access to Astro.currentLocale.
These combine the browser‚Äôs Accept-Language header, and your locales (strings or codes) to automatically respect your visitor‚Äôs preferred languages.
Astro.preferredLocale: Astro can compute a preferred locale for your visitor if their browser‚Äôs preferred locale is included in your locales array. This value is undefined if no such match exists.
Astro.preferredLocaleList: An array of all locales that are both requested by the browser and supported by your website. This produces a list of all compatible languages between your site and your visitor. The value is [] if none of the browser‚Äôs requested languages are found in your locales array. If the browser does not specify any preferred languages, then this value will be i18n.locales.
Astro.currentLocale: The locale computed from the current URL, using the syntax specified in your locales configuration. If the URL does not contain a /[locale]/ prefix, then the value will default to i18n.defaultLocale.
In order to successfully match your visitors‚Äô preferences, provide your codes using the same pattern used by the browser.
Edit page
Translate this page
Previous
Middleware
Next
View Transitions
Contribute
Give us feedback
Community""""""",3448,15405,astro
https://docs.astro.build/en/guides/view-transitions/,"""""""On this page
Overview
Adding View Transitions to a Page
Full site view transitions (SPA mode)
Transition Directives
Naming a transition
Maintaining State
Built-in Animation Directives
Customizing Animations
Router control
Preventing client-side navigation
Trigger navigation
Replace entries in the browser history
Transitions with forms
Fallback control
Client-side navigation process
Script behavior with view transitions
Script order
Script re-execution
Lifecycle events
astro:before-preparation
astro:after-preparation
astro:before-swap
astro:after-swap
astro:page-load
Accessibility
Route announcement
prefers-reduced-motion
Want to build your own Docs?
Grab this template to get started.‚Üí
View Transitions
Astro supports opt-in, per-page, view transitions with just a few lines of code. View transitions update your page content without the browser‚Äôs normal, full-page navigation refresh and provide seamless animations between pages.
Astro provides a <ViewTransitions /> routing component that can be added to a single page‚Äôs <head> to control page transitions as you navigate away to another page. It provides a lightweight client-side router that intercepts navigation and allows you to customize the transition between pages.
Add this component to a reusable .astro component, such as a common head or layout, for animated page transitions across your entire site (SPA mode).
Astro‚Äôs view transitions support is powered by the new View Transitions browser API and also includes:
A few built-in animation options, such as fade, slide, and none.
Support for both forwards and backwards navigation animations.
The ability to fully customize all aspects of transition animation, and build your own animations.
The option to prevent client-side navigation for non-page links.
Control over fallback behavior for browsers that do not yet support the View Transition APIs.
Automatic support for prefers-reduced-motion.
Note
By default, every page will use regular, full-page, browser navigation. You must opt in to view transitions and can use them either on a per-page basis or site-wide.
Adding View Transitions to a Page
Opt in to using view transitions on individual pages by importing and adding the <ViewTransitions /> routing component to <head> on every desired page.
src/pages/index.astro
---
import { ViewTransitions } from 'astro:transitions';
---
<html lang=""en"">
  <head>
    <title>My Homepage</title>
    <ViewTransitions />
  </head>
  <body>
    <h1>Welcome to my website!</h1>
  </body>
</html>
Full site view transitions (SPA mode)
Import and add the <ViewTransitions /> component to your common <head> or shared layout component. Astro will create default page animations based on the similarities between the old and new page, and will also provide fallback behavior for unsupported browsers.
The example below shows adding Astro‚Äôs default page navigation animations site-wide, including the default fallback control option for non-supporting browsers, by importing and adding this component to a <CommonHead /> Astro component:
src/components/CommonHead.astro
---
import { ViewTransitions } from 'astro:transitions';
---
<link rel=""icon"" type=""image/svg+xml"" href=""/favicon.svg"" />
<meta name=""generator"" content={Astro.generator} />
<!-- Primary Meta Tags -->
<title>{title}</title>
<meta name=""title"" content={title} />
<meta name=""description"" content={description} />
<ViewTransitions />
No other configuration is necessary to enable Astro‚Äôs default client-side navigation!
Use transition directives or override default client-side navigation on individual elements for finer control.
Transition Directives
Astro will automatically assign corresponding elements found in both the old page and the new page a shared, unique view-transition-name. This pair of matching elements is inferred by both the type of element and its location in the DOM.
Use optional transition:* directives on page elements in your .astro components for finer control over the page transition behaviour during navigation.
transition:name: Allows you to override Astro‚Äôs default element matching for old/new content animation and specify a transition name to associate a pair of DOM elements.
transition:animate: Allows you to override Astro‚Äôs default animation while replacing the old element with the new one by specifying an animation type. Use Astro‚Äôs built-in animation directives or create custom transition animations.
transition:persist: Allows you to override Astro‚Äôs default replacing old elements for new ones and instead persist components and HTML elements when navigating to another page.
Naming a transition
In some cases, you may want or need to identify the corresponding view transition elements yourself. You can specify a name for a pair of elements using the transition:name directive.
src/pages/old-page.astro
<aside transition:name=""hero"">
src/pages/new-page.astro
<aside transition:name=""hero"">
Note that the provided transition:name value can only be used once on each page. Set this manually when Astro can‚Äôt infer a proper name itself, or for more fine control over matching elements.
Maintaining State
Added in: astro@2.10.0
You can persist components and HTML elements (instead of replacing them) across page navigations using the transition:persist directive.
For example, the following <video> will continue to play as you navigate to another page that contains the same video element. This works for both forwards and backwards navigation.
src/components/Video.astro
<video controls="""" autoplay="""" transition:persist>
  <source src=""https://ia804502.us.archive.org/33/items/GoldenGa1939_3/GoldenGa1939_3_512kb.mp4"" type=""video/mp4"">
</video>
You can also place the directive on an Astro island (a UI framework component with a client: directive). If that component exists on the next page, the island from the old page with its current state will continue to be displayed, instead of replacing it with the island from the new page.
In the example below, the component‚Äôs internal state of the count will not be reset when navigating back and forth across pages that contain the <Counter /> component with the transition:persist attribute.
components/Header.astro
<Counter client:load transition:persist initialCount={5} />
Known limitations
Not all state can be preserved in this way. The restart of CSS animations and the reload of iframes cannot be avoided during view transitions even when using transition:persist.
You can also manually identify corresponding elements if the island/element is in a different component between the two pages.
src/pages/old-page.astro
<Video controls="""" autoplay="""" transition:name=""media-player"" transition:persist />
src/pages/new-page.astro
<MyVideo controls="""" autoplay="""" transition:name=""media-player"" transition:persist />
As a convenient shorthand, transition:persist can alternatively take a transition name as a value.
src/pages/index.astro
<video controls="""" autoplay="""" transition:persist=""media-player"">
transition:persist-props
Added in: astro@4.5.0
This allows you to control whether or not an island‚Äôs props should be persisted upon navigation.
By default, when you add transition:persist to an island, the state is retained upon navigation, but your component will re-render with new props. This is useful, for example, when a component receives page-specific props such as the current page‚Äôs title.
You can override this behavior by setting transition:persist-props in addition to transition:persist. Adding this directive will keep an island‚Äôs existing props (not re-render with new values) in addition to maintaining its existing state.
Built-in Animation Directives
Astro comes with a few built-in animations to override the default fade transition. Add the transition:animate directive to individual elements to customize the behavior of specific transitions.
fade (default): An opinionated crossfade animation. The old content fades out and the new content fades in.
initial: Opt out of Astro‚Äôs opinionated crossfade animation and use the browser‚Äôs default styling.
slide: An animation where the old content slides out to the left and new content slides in from the right. On backwards navigation, the animations are the opposite.
none: Disable the browser‚Äôs default animations. Use on a page‚Äôs <html> element to disable the default fade for every element on the page.
Combine directives for full control over your page animation. Set a page default on the <html> element, and override on any individual elements as desired.
The example below produces a slide animation for the body content while disabling the browser‚Äôs default fade animation for the rest of the page:
---
import CommonHead from '../components/CommonHead.astro';
---
<html transition:name=""root"" transition:animate=""none"">
  <head>
    <CommonHead />
  </head>
  <body>
    <header>
      ...
    </header>
    <!-- Override your page default on a single element -->
    <main transition:animate=""slide"">
      ...
    </main>
  </body>
</html>
Customizing Animations
You can customize all aspects of a transition with any CSS animation properties.
To customize a built-in animation, first import the animation from astro:transitions, and then pass in customization options.
The example below customizes the duration of the built-in fade animation:
---
import { fade } from 'astro:transitions';
---
<header transition:animate={fade({ duration: '0.4s' })}>
You can also define your own animations for use with transition:animate by defining both the forwards and backwards behavior, as well as new and old pages, according to the following types:
export interface TransitionAnimation {
  name: string; // The name of the keyframe
  delay?: number | string;
  duration?: number | string;
  easing?: string;
  fillMode?: string;
  direction?: string;
}
export interface TransitionAnimationPair {
  old: TransitionAnimation | TransitionAnimation[];
  new: TransitionAnimation | TransitionAnimation[];
}
export interface TransitionDirectionalAnimations {
  forwards: TransitionAnimationPair;
  backwards: TransitionAnimationPair;
}
The following example shows all the necessary properties to define a custom bump animation inside a <style is:global> tag in your root layout file:
src/layouts/Layout.astro
---
import { ViewTransitions } from 'astro:transitions';
---
<html lang=""en"">
  <head>
    <ViewTransitions />
  </head>
  <body>
    <slot />
  </body>
</html>
<style is:global>
  @keyframes bump {
    0% {
      opacity: 0;
      transform: scale(1) translateX(200px);
    }
    50% {
      opacity: 0.5;
      transform: scale(1.1);
    }
    100% {
      opacity: 1;
      transform: scale(1) translateX(0);
    }
  }
</style>
The animation‚Äôs behavior must be defined in the frontmatter of every component using the animation:
src/pages/index.astro
---
const anim = {
  old: {
    name: 'bump',
    duration: '0.5s',
    easing: 'ease-in',
    direction: 'reverse',
  },
  new: {
    name: 'bump',
    duration: '0.5s',
    easing: 'ease-in-out',
  },
};
const customTransition = {
  forwards: anim,
  backwards: anim,
};
---
<header transition:animate={customTransition}> ... </header>
You have great flexibility when defining custom animations. To achieve your desired result, you may wish to consider unusual combinations such as using different objects for forward and backward, or providing separate keyframe animations for old and new.
Router control
The <ViewTransitions /> router handles navigation by listening to:
Clicks on <a> elements.
Backwards and forwards navigation events.
The following options allow you to further control when navigation occurs within the router:
data-astro-reload: an <a> tag attribute to force a full-page navigation
data-astro-history=""auto | push | replace"": an <a> tag attribute to control the browser‚Äôs history
navigate(href, options): a method available to any client script or client component to trigger navigation
Preventing client-side navigation
There are some cases where you cannot navigate via client-side routing since both pages involved must use the <ViewTransitions /> router to prevent a full-page reload. You may also not want client-side routing on every navigation change and would prefer a traditional page navigation on select routes instead.
You can opt out of client-side routing on a per-link basis by adding the data-astro-reload attribute to any <a> or <form> tag. This attribute will override any existing <ViewTransitions /> component and instead trigger a browser refresh during navigation.
The following example shows preventing client-side routing when navigating to an article from the home page only. This still allows you to have animation on shared elements, such as a hero image, when navigating to the same page from an article listing page:
src/pages/index.astro
<a href=""/articles/emperor-penguins"" data-astro-reload>
src/pages/articles.astro
<a href=""/articles/emperor-penguins"">
Links with the data-astro-reload attribute will be ignored by the router and a full-page navigation will occur.
Trigger navigation
You can also trigger client-side navigation via events not normally listened to by the <ViewTransitions /> router using navigate. This function from the astro:transitions/client module can be used in scripts, and in framework components that are hydrated with a client directive.
The following example shows an Astro component that navigates a visitor to another page they select from a menu:
src/components/Form.astro
<script>
  import { navigate } from 'astro:transitions/client';
  // Navigate to the selected option automatically.
  document.querySelector('select').onchange = (event) => {
    let href = event.target.value;
    navigate(href);
  };
</script>
<select>
  <option value=""/play"">Play</option>
  <option value=""/blog"">Blog</option>
  <option value=""/about"">About</option>
  <option value=""/contact"">Contact</option>
</select>
src/pages/index.astro
---
import Form from ""../components/Form.astro"";
import { ViewTransitions } from ""astro:transitions"";
---
<html>
  <head>
    <ViewTransitions />
  </head>
  <body>
    <Form />
  </body>
</html>
The following example implements the same using navigate() in a React <Form /> component:
src/components/Form.jsx
import { navigate } from ""astro:transitions/client"";
export default function Form() {
  return (
    <select onChange={(e) => navigate(e.target.value)}>
      <option value=""/play"">Play</option>
      <option value=""/blog"">Blog</option>
      <option value=""/about"">About</option>
      <option value=""/contact"">Contact</option>
    </select>
  );
}
The <Form /> component can then be rendered on an Astro page that uses the <ViewTransitions /> router, with a client directive:
src/pages/index.astro
---
import Form from ""../components/Form.jsx"";
import { ViewTransitions } from ""astro:transitions"";
---
<html>
  <head>
    <ViewTransitions />
  </head>
  <body>
    <Form client:load />
  </body>
</html>
The navigate method takes these arguments:
href (required) - The new page to navigate to.
options - An optional object with the following properties:
history: 'push' | 'replace' | 'auto'
'push': the router will use history.pushState to create a new entry in the browser history.
'replace': the router will use history.replaceState to update the URL without adding a new entry into navigation.
'auto' (default): the router will attempt history.pushState, but if the URL is not one that can be transitioned to, the current URL will remain with no changes to the browser history.
formData: A FormData object for POST requests.
For backward and forward navigation through the browser history, you can combine navigate() with the built-in history.back(), history.forward() and history.go() functions of the browser. If navigate() is called during the server-side render of your component, it has no effect.
Replace entries in the browser history
Normally, each time you navigate, a new entry is written to the browser‚Äôs history. This allows navigation between pages using the browser‚Äôs back and forward buttons.
The <ViewTransitions /> router allows you to overwrite history entries by adding the data-astro-history attribute to any individual <a> tag.
The data-astro-history attribute can be set to the same three values as the history option of the navigate() function:
data-astro-history: 'push' | 'replace' | 'auto'
'push': the router will use history.pushState to create a new entry in the browser history.
'replace': the router will use history.replaceState to update the URL without adding a new entry into navigation.
'auto' (default): the router will attempt history.pushState, but if the URL is not one that can be transitioned to, the current URL will remain with no changes to the browser history.
The following example navigates to the /main page but does not add a new entry to the browsing history. Instead, it reuses the current entry in the history (/confirmation) and overwrites it.
src/pages/confirmation.astro
<a href=""/main"" data-astro-history=""replace"">
This has the effect that if you go back from the /main page, the browser will not display the /confirmation page, but the page before it.
Transitions with forms
Added in: astro@4.0.0
The <ViewTransitions /> router will trigger in-page transitions from <form> elements, supporting both GET and POST requests.
By default, Astro submits your form data as multipart/form-data when your method is set to POST. If you want to match the default behavior of web browsers, use the enctype attribute to submit your data encoded as application/x-www-form-urlencoded:
src/components/Form.astro
<form action=""/contact"" method=""POST"" enctype=""application/x-www-form-urlencoded"">
  <!-- -->
</form>
You can opt out of router transitions on any individual form using the data-astro-reload attribute:
src/components/Form.astro
<form action=""/contact"" data-astro-reload>
  <!-- -->
</form>
Fallback control
The <ViewTransitions /> router works best in browsers that support View Transitions (i.e. Chromium browsers), but also includes default fallback support for other browsers. Even if the browser does not support the View Transitions API, Astro will still provide in-browser navigation using one of the fallback options for a comparable experience.
You can override Astro‚Äôs default fallback support by adding a fallback property on the <ViewTransitions /> component and setting it to swap or none:
animate (default, recommended) - Astro will simulate view transitions using custom attributes before updating page content.
swap - Astro will not attempt to animate the page. Instead, the old page will be immediately replaced by the new one.
none - Astro will not do any animated page transitions at all. Instead, you will get full page navigation in non-supporting browsers.
---
import { ViewTransitions } from 'astro:transitions';
---
<title>My site</title>
<ViewTransitions fallback=""swap"" />
Known limitations
The initial browser animation is not simulated by Astro. So any element using this animation will not currently be animated.
Client-side navigation process
When using the <ViewTransitions /> router, the following steps occur to produce Astro‚Äôs client-side navigation:
A visitor to your site triggers navigation by any of the following actions:
Clicking an <a> tag linking internally to another page on your site.
Clicking the back button.
Clicking the forward button.
The router starts fetching the next page.
The router adds the data-astro-transition attribute to the HTML element with a value of 'forward' or 'back' as appropriate.
The router calls document.startViewTransition. This triggers the browser‚Äôs own view transition process. Importantly, the browser screenshots the current state of the page.
Inside the startViewTransition callback, the router performs a swap, which consists of the following sequence of events:
The contents of the <head> are swapped out, with some elements kept:
Stylesheet DOM nodes are left in if they exist on the new page, to prevent FOUC.
Scripts are left in if they exist on the new page.
Any other head elements with transition:persist are left in if there is a corresponding element in the new page.
The <body> is completely replaced with the new page‚Äôs body.
Elements marked transition:persist are moved over to the new DOM if they exist on the new page.
Scroll position is restored if necessary.
The astro:after-swap event is triggered on the document. This is the end of the swap process.
The router waits for any new stylesheets to load before resolving the transition.
The router executes any new scripts added to the page.
The astro:page-load event fires. This is the end of the navigation process.
Script behavior with view transitions
When you add view transitions to an existing Astro project, some of your scripts may no longer re-run after page navigation like they did with full-page browser refreshes. Use the following information to ensure that your scripts execute as expected.
Script order
When navigating between pages with the <ViewTransitions /> component, scripts are run in sequential order to match browser behavior.
Script re-execution
Bundled module scripts, which are the default scripts in Astro, are only ever executed once. After initial execution they will be ignored, even if the script exists on the new page after a transition.
Unlike bundled module scripts, inline scripts have the potential to be re-executed during a user‚Äôs visit to a site if they exist on a page that is visited multiple times. Inline scripts might also re-execute when a visitor navigates to a page without the script, and then back to one with the script.
With view transitions, some scripts may no longer re-run after page navigation like they do with full-page browser refreshes. There are several events during client-side routing that you can listen for, and fire events when they occur. You can wrap an existing script in an event listener to ensure it runs at the proper time in the navigation cycle.
src/scripts/menu.js
<script>
document.addEventListener('astro:page-load', () => {
  document.querySelector('.hamburger').addEventListener('click', () => {
    document.querySelector('.nav-links').classList.toggle('expanded');
  });
});
</script>
data-astro-rerun
Added in: astro@4.5.0
To force inline scripts to re-execute after every transition, add the data-astro-rerun property. Adding any attribute to a script also implicitly adds is:inline, so this is only available for scripts that are not bundled and processed by Astro.
<script is:inline data-astro-rerun>...</script>
To ensure that a script runs every time a page is loaded during client-side navigation, it should be executed by a lifecycle event. For example, event listeners for DOMContentLoaded can be replaced by the astro:page-load lifecycle event.
If you have code that sets up a global state in an inline script, this state will need to take into account that the script might execute more than once. Check for the global state in your <script> tag, and conditionally execute your code where possible. This works because window is preserved.
<script is:inline>
  if (!window.SomeGlobal) {
    window.SomeGlobal = {} // ....
  }
</script>
See the Add View Transitions Tutorial for an example of updating existing scripts in a project.
Lifecycle events
The <ViewTransition /> router fires a number of events on the document during navigation. These events provide hooks into the lifecycle of navigation, allowing you to do things like show indicators that a new page is loading, override default behavior, and restore state as navigation is completing.
The navigation process involves a preparation phase, when new content is loaded; a DOM swap phase, where the old page‚Äôs content is replaced by the new page‚Äôs content; and a completion phase where scripts are executed, loading is reported as completed and clean-up work is carried out.
Astro‚Äôs View Transition API lifecycle events in order are:
astro:before-preparation
astro:after-preparation
astro:before-swap
astro:after-swap
astro:page-load
Tip
before- events allow you to influence and modify actions that are about to take place, and after- events are notifications that a phase is complete.
While some actions can be triggered during any event, some tasks can only be performed during a specific event for best results, such as displaying a loading spinner before preparation or overriding animation pairs before swapping content.
astro:before-preparation
Added in: astro@3.6.0
An event that fires at the beginning of the preparation phase, after navigation has started (e.g. after the user has clicked a link), but before content is loaded.
This event is used:
To do something before loading has started, such as showing a loading spinner.
To alter loading, such as loading content you‚Äôve defined in a template rather than from the external URL.
To change the direction of the navigation (which is usually either forward or backward) for custom animation.
Here is an example of using the astro:before-preparation event to load a spinner before the content is loaded and stop it immediately after loading. Note that using the loader callback in this way allows asynchronous execution of code.
<script is:inline>
  document.addEventListener('astro:before-preparation', event => {
    const originalLoader = event.loader;
    event.loader = async function() {
      const { startSpinner } = await import('./spinner.js');
      const stop = startSpinner();
      await originalLoader();
      stop();
    };
  });
</script>
astro:after-preparation
Added in: astro@3.6.0
An event that fires at the end of the preparation phase, after the new page‚Äôs content has been loaded and parsed into a document. This event occurs before the view transitions phase.
This example uses the astro:before-preparation event to start a loading indicator and the astro:after-preparation event to stop it:
<script is:inline>
  document.addEventListener('astro:before-preparation', () => {
    document.querySelector('#loading').classList.add('show');
  });
  document.addEventListener('astro:after-preparation', () => {
    document.querySelector('#loading').classList.remove('show');
  });
</script>
This is a simpler version of loading a spinner than the example shown above: if all of the listener‚Äôs code can be executed synchronously, there is no need to hook into the loader‚Äôs callback.
astro:before-swap
Added in: astro@3.6.0
An event that fires before the new document (which is populated during the preparation phase) replaces the current document. This event occurs inside of the view transition, where the user is still seeing a snapshot of the old page.
This event can be used to make changes before the swap occurs. The newDocument property on the event represents the incoming document. Here is an example of ensuring the browser‚Äôs light or dark mode preference in localStorage is carried over to the new page:
<script is:inline>
  function setDarkMode(document) {
    let theme = localStorage.darkMode ? 'dark' : 'light';
    document.documentElement.dataset.theme = theme;
  }
  setDarkMode(document);
  document.addEventListener('astro:before-swap', event => {
    // Pass the incoming document to set the theme on it
    setDarkMode(event.newDocument);
  });
</script>
The astro:before-swap event can also be used to change the implementation of the swap. The default swap implementation diffs head content, moves persistent elements from the old document to the newDocument, and then replaces the entire body with the body of the new document.
At this point of the lifecycle, you could choose to define your own swap implementation, for example to diff the entire contents of the existing document (which some other routers do):
<script is:inline>
  document.addEventListener('astro:before-swap', event => {
    event.swap = () => {
      diff(document, event.newDocument);
    };
  });
</script>
Building a custom swap function
Added in: astro@4.15.0
The swapFunctions object of the astro:transitions/client module provides five utility functions that handle specific swap-related tasks, including handling document attributes, page elements, and script execution. These functions can be used directly to define a custom swap implementation.
The following example demonstrates how to use these functions to recreate Astro‚Äôs built-in swap implementation:
<script>
import { swapFunctions } from 'astro:transitions/client';
// substitutes window.document with doc
function mySwap(doc: Document) {
  swapFunctions.deselectScripts(doc);
  swapFunctions.swapRootAttributes(doc);
  swapFunctions.swapHeadElements(doc);
  const restoreFocusFunction = swapFunctions.saveFocus();
  swapFunctions.swapBodyElement(doc.body, document.body);
  restoreFocusFunction();
};
...
  event.swap = () => mySwap(event.newDocument);
...
<script>
Custom swap implementations can start with this template and add or replace individual steps with custom logic as needed.
astro:after-swap
An event that fires immediately after the new page replaces the old page. You can listen to this event on the document and trigger actions that will occur before the new page‚Äôs DOM elements render and scripts run.
This event, when listened to on the outgoing page, is useful to pass along and restore any state on the DOM that needs to transfer over to the new page.
This is the latest point in the lifecycle where it is still safe to, for example, add a dark mode class name (<html class=""dark-mode"">), though you may wish to do so in an earlier event.
The astro:after-swap event occurs immediately after the browser history has been updated and the scroll position has been set. Therefore, one use of targeting this event is to override the default scroll restore for history navigation. The following example resets the horizontal and vertical scroll position to the top left corner of the page for each navigation.
document.addEventListener('astro:after-swap',
  () => window.scrollTo({ left: 0, top: 0, behavior: 'instant' }))
astro:page-load
An event that fires at the end of page navigation, after the new page is visible to the user and blocking styles and scripts are loaded. You can listen to this event on the document.
The <ViewTransitions /> component fires this event both on initial page navigation for a pre-rendered page and on any subsequent navigation, either forwards or backwards.
You can use this event to run code on every page navigation, for example to set up event listeners that would otherwise be lost during navigation.
<script>
  document.addEventListener('astro:page-load', () => {
    // This runs on first page load and after every navigation.
    setupStuff(); // e.g. add event listeners
  });
</script>
Accessibility
Enabling client-side routing and animating page transitions both come with accessibility challenges, and Astro aims to make sites opting in to View Transitions as accessible-by-default as possible.
Route announcement
Added in: astro@3.2.0
The <ViewTransitions /> component includes a route announcer for page navigation during client-side routing. No configuration or action is needed to enable this.
Assistive technologies let visitors know that the page has changed by announcing the new page title after navigation. When using server-side routing with traditional full-page browser refreshes, this happens by default after the new page loads. In client-side routing, the <ViewTransitions /> component performs this action.
To add route announcement to client-side routing, the component adds an element to the new page with the aria-live attribute set to assertive. This tells AT (assistive technology) to announce immediately. The component also checks for the following, in priority order, to determine the announcement text:
The <title>, if it exists.
The first <h1> it finds.
The pathname of the page.
We strongly recommend you always include a <title> in each page for accessibility.
prefers-reduced-motion
Astro‚Äôs <ViewTransitions /> component includes a CSS media query that disables all view transition animations, including fallback animation, whenever the prefer-reduced-motion setting is detected. Instead, the browser will simply swap the DOM elements without an animation.
Edit page
Translate this page
Previous
Internationalization
Next
CSS & Styling
Contribute
Give us feedback
Community""""""",6714,32298,astro
https://docs.astro.build/en/guides/styling/,"""""""On this page
Overview
Styling in Astro
Scoped Styles
Global Styles
Combining classes with class:list
CSS Variables
Passing a class to a child component
Inline styles
External Styles
Import a local stylesheet
Import a stylesheet from an npm package
Load a static stylesheet via ‚Äúlink‚Äù tags
Cascading Order
Scoped Styles
Import Order
Link Tags
CSS Integrations
Tailwind
CSS Preprocessors
Sass and SCSS
Stylus
Less
LightningCSS
In framework components
PostCSS
Frameworks and Libraries
üìò React / Preact
üìó Vue
üìï Svelte
Markdown Styling
Production
Bundle control
Advanced
?raw CSS Imports
?url CSS Imports
Want to build your own Docs?
Grab this template to get started.‚Üí
Styles & CSS
Astro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like Tailwind. Advanced styling languages like Sass and Less are also supported.
Styling in Astro
Styling an Astro component is as easy as adding a <style> tag to your component or page template. When you place a <style> tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically.
src/components/MyComponent.astro
<style>
  h1 { color: red; }
</style>
Scoped Styles
Astro <style> CSS rules are automatically scoped by default. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component.
This CSS:
src/pages/index.astro
<style>
  h1 {
    color: red;
  }
  .text {
    color: blue;
  }
</style>
Compiles to this:
<style>
  h1[data-astro-cid-hhnqfkh6] {
     color: red;
  }
  .text[data-astro-cid-hhnqfkh6] {
    color: blue;
  }
</style>
Scoped styles don‚Äôt leak and won‚Äôt impact the rest of your site. In Astro, it is okay to use low-specificity selectors like h1 {} or p {} because they will be compiled with scopes in the final output.
Scoped styles also won‚Äôt apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a <div> (or other element) that you can then style.
The specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component.
Global Styles
While we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the <style is:global> attribute.
src/components/GlobalStyles.astro
<style is:global>
  /* Unscoped, delivered as-is to the browser.
     Applies to all <h1> tags on your site. */
  h1 { color: red; }
</style>
You can also mix global & scoped CSS rules together in the same <style> tag using the :global() selector. This becomes a powerful pattern for applying CSS styles to children of your component.
src/components/MixedStyles.astro
<style>
  /* Scoped to this component, only. */
  h1 { color: red; }
  /* Mixed: Applies to child `h1` elements only. */
  article :global(h1) {
    color: blue;
  }
</style>
<h1>Title</h1>
<article><slot /></article>
This is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot.
Scoped styles should be used as often as possible. Global styles should be used only as-needed.
Combining classes with class:list
If you need to combine classes on an element dynamically, you can use the class:list utility attribute in .astro files.
src/components/ClassList.astro
---
const { isRed } = Astro.props;
---
<!-- If `isRed` is truthy, class will be ""box red"". -->
<!-- If `isRed` is falsy, class will be ""box"". -->
<div class:list={['box', { red: isRed }]}><slot /></div>
<style>
  .box { border: 1px solid blue; }
  .red { border-color: red; }
</style>
See our directives reference page to learn more about class:list.
CSS Variables
Added in: astro@0.21.0
The Astro <style> can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the define:vars directive.
src/components/DefineVars.astro
---
const foregroundColor = ""rgb(221 243 228)"";
const backgroundColor = ""rgb(24 121 78)"";
---
<style define:vars={{ foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--foregroundColor);
  }
</style>
<h1>Hello</h1>
See our directives reference page to learn more about define:vars.
Passing a class to a child component
In Astro, HTML attributes like class do not automatically pass through to child components.
Instead, accept a class prop in the child component and apply it to the root element. When destructuring, you must rename it, because class is a reserved word in JavaScript.
Using the default scoped style strategy, you must also pass the data-astro-cid-* attribute. You can do this by passing the ...rest of the props to the component. If you have changed scopedStyleStrategy to 'class' or 'where', the ...rest prop is not necessary.
src/components/MyComponent.astro
---
const { class: className, ...rest } = Astro.props;
---
<div class={className} {...rest}>
  <slot/>
</div>
src/pages/index.astro
---
import MyComponent from ""../components/MyComponent.astro""
---
<style>
  .red {
    color: red;
  }
</style>
<MyComponent class=""red"">This will be red!</MyComponent>
Scoped styles from parent components
Because the data-astro-cid-* attribute includes the child in its parent‚Äôs scope, it is possible for styles to cascade from parent to child. To avoid this having unintended side effects, ensure you use unique class names in the child component.
Inline styles
You can style HTML elements inline using the style attribute. This can be a CSS string or an object of CSS properties:
src/pages/index.astro
// These are equivalent:
<p style={{ color: ""brown"", textDecoration: ""underline"" }}>My text</p>
<p style=""color: brown; text-decoration: underline;"">My text</p>
External Styles
There are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your public/ directory, or hosted outside of your project.
Read more about using static assets located in public/ or src/.
Import a local stylesheet
Using an npm package?
You may need to update your astro.config when importing from npm packages. See the ‚Äúimport stylesheets from an npm package‚Äù section below.
You can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like any other ESM import in an Astro component, which should be referenced as relative to the component and must be written at the top of your component script, with any other imports.
src/pages/index.astro
---
// Astro will bundle and optimize this CSS for you automatically
// This also works for preprocessor files like .scss, .styl, etc.
import '../styles/utils.css';
---
<html><!-- Your page here --></html>
CSS import via ESM are supported inside of any JavaScript file, including JSX components like React & Preact. This can be useful for writing granular, per-component styles for your React components.
Import a stylesheet from an npm package
You may also need to load stylesheets from an external npm package. This is especially common for utilities like Open Props. If your package recommends using a file extension (i.e. package-name/styles.css instead of package-name/styles), this should work like any local stylesheet:
src/pages/random-page.astro
---
import 'package-name/styles.css';
---
<html><!-- Your page here --></html>
If your package does not suggest using a file extension (i.e. package-name/styles), you‚Äôll need to update your Astro config first!
Say you are importing a CSS file from package-name called normalize (with the file extension omitted). To ensure we can prerender your page correctly, add package-name to the vite.ssr.noExternal array:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  vite: {
    ssr: {
      noExternal: ['package-name'],
    }
  }
})
Note
This is a Vite-specific setting that does not relate to (or require) Astro SSR.
Now, you are free to import package-name/normalize. This will be bundled and optimized by Astro like any other local stylesheet.
src/pages/random-page.astro
---
import 'package-name/normalize';
---
<html><!-- Your page here --></html>
Load a static stylesheet via ‚Äúlink‚Äù tags
You can also use the <link> element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your /public directory, or an URL to an external website. Relative <link> href values are not supported.
src/pages/index.astro
<head>
  <!-- Local: /public/styles/global.css -->
  <link rel=""stylesheet"" href=""/styles/global.css"" />
  <!-- External -->
  <link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css"" />
</head>
Because this approach uses the public/ directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the Import a Stylesheet method above.
Cascading Order
Astro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own <style> tag, and be rendered inside a layout that imports CSS.
When conflicting CSS rules apply to the same element, browsers first use specificity and then order of appearance to determine which value to show.
If one rule is more specific than another, no matter where the CSS rule appears, its value will take precedence:
src/components/MyComponent.astro
<style>
  h1 { color: red }
  div > h1 {
    color: purple
  }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
If two rules have the same specificity, then the order of appearance is evaluated, and the last rule‚Äôs value will take precedence:
src/components/MyComponent.astro
<style>
  h1 { color: purple }
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
Astro CSS rules are evaluated in this order of appearance:
<link> tags in the head (lowest precedence)
imported styles
scoped styles (highest precedence)
Scoped Styles
Using scoped styles does not increase the specificity of your CSS, but they will always come last in the order of appearance. They will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style‚Äôs value will apply:
src/components/make-it-purple.css
h1 {
  color: purple;
}
src/components/MyComponent.astro
---
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
If you make the imported style more specific, it will have higher precedence over the scoped style:
src/components/make-it-purple.css
div > h1 {
  color: purple;
}
src/components/MyComponent.astro
---
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
Import Order
When importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the last one imported wins:
src/components/make-it-purple.css
div > h1 {
  color: purple;
}
src/components/make-it-green.css
div > h1 {
  color: green;
}
src/components/MyComponent.astro
---
import ""./make-it-green.css""
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
While <style> tags are scoped and only apply to the component that declares them, imported CSS can ‚Äúleak‚Äù. Importing a component applies any CSS it imports, even if the component is never used:
src/components/PurpleComponent.astro
---
import ""./make-it-purple.css""
---
<div>
  <h1>I import purple CSS.</h1>
</div>
src/components/MyComponent.astro
---
import ""./make-it-green.css""
import PurpleComponent from ""./PurpleComponent.astro"";
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
Tip
A common pattern in Astro is to import global CSS inside a Layout component. Be sure to import the Layout component before other imports so that it has the lowest precedence.
Link Tags
Style sheets loaded via link tags are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles:
src/pages/index.astro
---
import ""../components/make-it-purple.css""
---
<html lang=""en"">
  <head>
    <meta charset=""utf-8"" />
    <link rel=""icon"" type=""image/svg+xml"" href=""/favicon.svg"" />
    <meta name=""viewport"" content=""width=device-width"" />
    <meta name=""generator"" content={Astro.generator} />
    <title>Astro</title>
    <link rel=""stylesheet"" href=""/styles/make-it-blue.css"" />
  </head>
  <body>
    <div>
      <h1>This will be purple</h1>
    </div>
  </body>
</html>
CSS Integrations
Astro comes with support for adding popular CSS libraries, tools, and frameworks to your project like Tailwind and more!
Tailwind
To use Tailwind in your project, install the official Astro Tailwind integration using the astro add command for your package manager:
npm
pnpm
Yarn
Terminal window
yarn astro add tailwind
See the Integrations Guide for instructions on installing, importing and configuring Astro integrations.
CSS Preprocessors
Astro supports CSS preprocessors such as Sass, Stylus, and Less through Vite.
Sass and SCSS
Terminal window
npm install sass
Use <style lang=""scss""> or <style lang=""sass""> in .astro files.
Stylus
Terminal window
npm install stylus
Use <style lang=""styl""> or <style lang=""stylus""> in .astro files.
Less
Terminal window
npm install less
Use <style lang=""less""> in .astro files.
LightningCSS
Terminal window
npm install lightningcss
Update your vite configuration in astro.config.mjs:
astro.config.mjs
import { defineConfig } from 'astro/config'
export default defineConfig({
  vite: {
    css: {
      transformer: ""lightningcss"",
    },
  },
})
In framework components
You can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends:
React / Preact: import Styles from './styles.module.scss';
Vue: <style lang=""scss"">
Svelte: <style lang=""scss"">
PostCSS
Astro comes with PostCSS included as part of Vite. To configure PostCSS for your project, create a postcss.config.cjs file in the project root. You can import plugins using require() after installing them (for example npm install autoprefixer).
postcss.config.cjs
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('cssnano'),
  ],
};
Frameworks and Libraries
üìò React / Preact
.jsx files support both global CSS and CSS Modules. To enable the latter, use the .module.css extension (or .module.scss/.module.sass if using Sass).
src/components/MyReactComponent.jsx
import './global.css'; // include global CSS
import Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)
üìó Vue
Vue in Astro supports the same methods as vue-loader does:
vue-loader - Scoped CSS
vue-loader - CSS Modules
üìï Svelte
Svelte in Astro also works exactly as expected: Svelte Styling Docs.
Markdown Styling
Any Astro styling methods are available to a Markdown layout component, but different methods will have different styling effects on your page.
You can apply global styles to your Markdown content by adding imported stylesheets to the layout that wraps your page content. It is also possible to style your Markdown with <style is:global> tags in the layout component. Note that any styles added are subject to Astro‚Äôs cascading order, and you should check your rendered page carefully to ensure your styles are being applied as intended.
You can also add CSS integrations including Tailwind. If you are using Tailwind, the typography plugin can be useful for styling Markdown.
Production
Bundle control
When Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse.
However, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as <link rel=""stylesheet""> tags, while inlining smaller ones into <style type=""text/css"">. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages.
You can configure the size at which stylesheets will be linked externally (in bytes) using the assetsInlineLimit vite build option. Note that this option affects script and image inlining as well.
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  vite: {
    build: {
      assetsInlineLimit: 1024,
    }
  };
});
If you would rather all project styles remain external, you can configure the inlineStylesheets build option.
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  build: {
    inlineStylesheets: 'never'
  }
});
You can also set this option to 'always' which will inline all stylesheets.
Advanced
Caution
Be careful when bypassing Astro‚Äôs built-in CSS bundling! Styles won‚Äôt be automatically included in the built output, and it is your responsibility to make sure that the referenced file is properly included in the final page output.
?raw CSS Imports
For advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro‚Äôs automatic CSS handling.
This is not recommended for most users.
src/components/RawInlineStyles.astro
---
// Advanced example! Not recommended for most users.
import rawStylesCSS from '../styles/main.css?raw';
---
<style is:inline set:html={rawStylesCSS}></style>
See Vite‚Äôs docs for full details.
?url CSS Imports
For advanced use cases, you can import a direct URL reference for a CSS file inside of your project src/ directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS .
This is not recommended for most users. Instead, place your CSS files inside of public/ to get a consistent URL reference.
Caution
Importing a smaller CSS file with ?url may return the base64 encoded contents of the CSS file as a data URL in your final build. Either write your code to support encoded data URLs (data:text/css;base64,...) or set the vite.build.assetsInlineLimit config option to 0 to disable this feature.
src/components/RawStylesUrl.astro
---
// Advanced example! Not recommended for most users.
import stylesUrl from '../styles/main.css?url';
---
<link rel=""preload"" href={stylesUrl} as=""style"">
<link rel=""stylesheet"" href={stylesUrl}>
See Vite‚Äôs docs for full details.
Edit page
Translate this page
Previous
View Transitions
Next
Images
Contribute
Give us feedback
Community

On this page
Overview
Styling in Astro
Scoped Styles
Global Styles
Combining classes with class:list
CSS Variables
Passing a class to a child component
Inline styles
External Styles
Import a local stylesheet
Import a stylesheet from an npm package
Load a static stylesheet via ‚Äúlink‚Äù tags
Cascading Order
Scoped Styles
Import Order
Link Tags
CSS Integrations
Tailwind
CSS Preprocessors
Sass and SCSS
Stylus
Less
LightningCSS
In framework components
PostCSS
Frameworks and Libraries
üìò React / Preact
üìó Vue
üìï Svelte
Markdown Styling
Production
Bundle control
Advanced
?raw CSS Imports
?url CSS Imports
Want to build your own Docs?
Grab this template to get started.‚Üí
Styles & CSS
Astro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like Tailwind. Advanced styling languages like Sass and Less are also supported.
Styling in Astro
Styling an Astro component is as easy as adding a <style> tag to your component or page template. When you place a <style> tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically.
src/components/MyComponent.astro
<style>
  h1 { color: red; }
</style>
Scoped Styles
Astro <style> CSS rules are automatically scoped by default. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component.
This CSS:
src/pages/index.astro
<style>
  h1 {
    color: red;
  }
  .text {
    color: blue;
  }
</style>
Compiles to this:
<style>
  h1[data-astro-cid-hhnqfkh6] {
     color: red;
  }
  .text[data-astro-cid-hhnqfkh6] {
    color: blue;
  }
</style>
Scoped styles don‚Äôt leak and won‚Äôt impact the rest of your site. In Astro, it is okay to use low-specificity selectors like h1 {} or p {} because they will be compiled with scopes in the final output.
Scoped styles also won‚Äôt apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a <div> (or other element) that you can then style.
The specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component.
Global Styles
While we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the <style is:global> attribute.
src/components/GlobalStyles.astro
<style is:global>
  /* Unscoped, delivered as-is to the browser.
     Applies to all <h1> tags on your site. */
  h1 { color: red; }
</style>
You can also mix global & scoped CSS rules together in the same <style> tag using the :global() selector. This becomes a powerful pattern for applying CSS styles to children of your component.
src/components/MixedStyles.astro
<style>
  /* Scoped to this component, only. */
  h1 { color: red; }
  /* Mixed: Applies to child `h1` elements only. */
  article :global(h1) {
    color: blue;
  }
</style>
<h1>Title</h1>
<article><slot /></article>
This is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot.
Scoped styles should be used as often as possible. Global styles should be used only as-needed.
Combining classes with class:list
If you need to combine classes on an element dynamically, you can use the class:list utility attribute in .astro files.
src/components/ClassList.astro
---
const { isRed } = Astro.props;
---
<!-- If `isRed` is truthy, class will be ""box red"". -->
<!-- If `isRed` is falsy, class will be ""box"". -->
<div class:list={['box', { red: isRed }]}><slot /></div>
<style>
  .box { border: 1px solid blue; }
  .red { border-color: red; }
</style>
See our directives reference page to learn more about class:list.
CSS Variables
Added in: astro@0.21.0
The Astro <style> can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the define:vars directive.
src/components/DefineVars.astro
---
const foregroundColor = ""rgb(221 243 228)"";
const backgroundColor = ""rgb(24 121 78)"";
---
<style define:vars={{ foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--foregroundColor);
  }
</style>
<h1>Hello</h1>
See our directives reference page to learn more about define:vars.
Passing a class to a child component
In Astro, HTML attributes like class do not automatically pass through to child components.
Instead, accept a class prop in the child component and apply it to the root element. When destructuring, you must rename it, because class is a reserved word in JavaScript.
Using the default scoped style strategy, you must also pass the data-astro-cid-* attribute. You can do this by passing the ...rest of the props to the component. If you have changed scopedStyleStrategy to 'class' or 'where', the ...rest prop is not necessary.
src/components/MyComponent.astro
---
const { class: className, ...rest } = Astro.props;
---
<div class={className} {...rest}>
  <slot/>
</div>
src/pages/index.astro
---
import MyComponent from ""../components/MyComponent.astro""
---
<style>
  .red {
    color: red;
  }
</style>
<MyComponent class=""red"">This will be red!</MyComponent>
Scoped styles from parent components
Because the data-astro-cid-* attribute includes the child in its parent‚Äôs scope, it is possible for styles to cascade from parent to child. To avoid this having unintended side effects, ensure you use unique class names in the child component.
Inline styles
You can style HTML elements inline using the style attribute. This can be a CSS string or an object of CSS properties:
src/pages/index.astro
// These are equivalent:
<p style={{ color: ""brown"", textDecoration: ""underline"" }}>My text</p>
<p style=""color: brown; text-decoration: underline;"">My text</p>
External Styles
There are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your public/ directory, or hosted outside of your project.
Read more about using static assets located in public/ or src/.
Import a local stylesheet
Using an npm package?
You may need to update your astro.config when importing from npm packages. See the ‚Äúimport stylesheets from an npm package‚Äù section below.
You can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like any other ESM import in an Astro component, which should be referenced as relative to the component and must be written at the top of your component script, with any other imports.
src/pages/index.astro
---
// Astro will bundle and optimize this CSS for you automatically
// This also works for preprocessor files like .scss, .styl, etc.
import '../styles/utils.css';
---
<html><!-- Your page here --></html>
CSS import via ESM are supported inside of any JavaScript file, including JSX components like React & Preact. This can be useful for writing granular, per-component styles for your React components.
Import a stylesheet from an npm package
You may also need to load stylesheets from an external npm package. This is especially common for utilities like Open Props. If your package recommends using a file extension (i.e. package-name/styles.css instead of package-name/styles), this should work like any local stylesheet:
src/pages/random-page.astro
---
import 'package-name/styles.css';
---
<html><!-- Your page here --></html>
If your package does not suggest using a file extension (i.e. package-name/styles), you‚Äôll need to update your Astro config first!
Say you are importing a CSS file from package-name called normalize (with the file extension omitted). To ensure we can prerender your page correctly, add package-name to the vite.ssr.noExternal array:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  vite: {
    ssr: {
      noExternal: ['package-name'],
    }
  }
})
Note
This is a Vite-specific setting that does not relate to (or require) Astro SSR.
Now, you are free to import package-name/normalize. This will be bundled and optimized by Astro like any other local stylesheet.
src/pages/random-page.astro
---
import 'package-name/normalize';
---
<html><!-- Your page here --></html>
Load a static stylesheet via ‚Äúlink‚Äù tags
You can also use the <link> element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your /public directory, or an URL to an external website. Relative <link> href values are not supported.
src/pages/index.astro
<head>
  <!-- Local: /public/styles/global.css -->
  <link rel=""stylesheet"" href=""/styles/global.css"" />
  <!-- External -->
  <link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css"" />
</head>
Because this approach uses the public/ directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the Import a Stylesheet method above.
Cascading Order
Astro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own <style> tag, and be rendered inside a layout that imports CSS.
When conflicting CSS rules apply to the same element, browsers first use specificity and then order of appearance to determine which value to show.
If one rule is more specific than another, no matter where the CSS rule appears, its value will take precedence:
src/components/MyComponent.astro
<style>
  h1 { color: red }
  div > h1 {
    color: purple
  }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
If two rules have the same specificity, then the order of appearance is evaluated, and the last rule‚Äôs value will take precedence:
src/components/MyComponent.astro
<style>
  h1 { color: purple }
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
Astro CSS rules are evaluated in this order of appearance:
<link> tags in the head (lowest precedence)
imported styles
scoped styles (highest precedence)
Scoped Styles
Using scoped styles does not increase the specificity of your CSS, but they will always come last in the order of appearance. They will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style‚Äôs value will apply:
src/components/make-it-purple.css
h1 {
  color: purple;
}
src/components/MyComponent.astro
---
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
If you make the imported style more specific, it will have higher precedence over the scoped style:
src/components/make-it-purple.css
div > h1 {
  color: purple;
}
src/components/MyComponent.astro
---
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
Import Order
When importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the last one imported wins:
src/components/make-it-purple.css
div > h1 {
  color: purple;
}
src/components/make-it-green.css
div > h1 {
  color: green;
}
src/components/MyComponent.astro
---
import ""./make-it-green.css""
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
While <style> tags are scoped and only apply to the component that declares them, imported CSS can ‚Äúleak‚Äù. Importing a component applies any CSS it imports, even if the component is never used:
src/components/PurpleComponent.astro
---
import ""./make-it-purple.css""
---
<div>
  <h1>I import purple CSS.</h1>
</div>
src/components/MyComponent.astro
---
import ""./make-it-green.css""
import PurpleComponent from ""./PurpleComponent.astro"";
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
Tip
A common pattern in Astro is to import global CSS inside a Layout component. Be sure to import the Layout component before other imports so that it has the lowest precedence.
Link Tags
Style sheets loaded via link tags are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles:
src/pages/index.astro
---
import ""../components/make-it-purple.css""
---
<html lang=""en"">
  <head>
    <meta charset=""utf-8"" />
    <link rel=""icon"" type=""image/svg+xml"" href=""/favicon.svg"" />
    <meta name=""viewport"" content=""width=device-width"" />
    <meta name=""generator"" content={Astro.generator} />
    <title>Astro</title>
    <link rel=""stylesheet"" href=""/styles/make-it-blue.css"" />
  </head>
  <body>
    <div>
      <h1>This will be purple</h1>
    </div>
  </body>
</html>
CSS Integrations
Astro comes with support for adding popular CSS libraries, tools, and frameworks to your project like Tailwind and more!
Tailwind
To use Tailwind in your project, install the official Astro Tailwind integration using the astro add command for your package manager:
npm
pnpm
Yarn
Terminal window
npx astro add tailwind
See the Integrations Guide for instructions on installing, importing and configuring Astro integrations.
CSS Preprocessors
Astro supports CSS preprocessors such as Sass, Stylus, and Less through Vite.
Sass and SCSS
Terminal window
npm install sass
Use <style lang=""scss""> or <style lang=""sass""> in .astro files.
Stylus
Terminal window
npm install stylus
Use <style lang=""styl""> or <style lang=""stylus""> in .astro files.
Less
Terminal window
npm install less
Use <style lang=""less""> in .astro files.
LightningCSS
Terminal window
npm install lightningcss
Update your vite configuration in astro.config.mjs:
astro.config.mjs
import { defineConfig } from 'astro/config'
export default defineConfig({
  vite: {
    css: {
      transformer: ""lightningcss"",
    },
  },
})
In framework components
You can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends:
React / Preact: import Styles from './styles.module.scss';
Vue: <style lang=""scss"">
Svelte: <style lang=""scss"">
PostCSS
Astro comes with PostCSS included as part of Vite. To configure PostCSS for your project, create a postcss.config.cjs file in the project root. You can import plugins using require() after installing them (for example npm install autoprefixer).
postcss.config.cjs
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('cssnano'),
  ],
};
Frameworks and Libraries
üìò React / Preact
.jsx files support both global CSS and CSS Modules. To enable the latter, use the .module.css extension (or .module.scss/.module.sass if using Sass).
src/components/MyReactComponent.jsx
import './global.css'; // include global CSS
import Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)
üìó Vue
Vue in Astro supports the same methods as vue-loader does:
vue-loader - Scoped CSS
vue-loader - CSS Modules
üìï Svelte
Svelte in Astro also works exactly as expected: Svelte Styling Docs.
Markdown Styling
Any Astro styling methods are available to a Markdown layout component, but different methods will have different styling effects on your page.
You can apply global styles to your Markdown content by adding imported stylesheets to the layout that wraps your page content. It is also possible to style your Markdown with <style is:global> tags in the layout component. Note that any styles added are subject to Astro‚Äôs cascading order, and you should check your rendered page carefully to ensure your styles are being applied as intended.
You can also add CSS integrations including Tailwind. If you are using Tailwind, the typography plugin can be useful for styling Markdown.
Production
Bundle control
When Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse.
However, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as <link rel=""stylesheet""> tags, while inlining smaller ones into <style type=""text/css"">. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages.
You can configure the size at which stylesheets will be linked externally (in bytes) using the assetsInlineLimit vite build option. Note that this option affects script and image inlining as well.
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  vite: {
    build: {
      assetsInlineLimit: 1024,
    }
  };
});
If you would rather all project styles remain external, you can configure the inlineStylesheets build option.
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  build: {
    inlineStylesheets: 'never'
  }
});
You can also set this option to 'always' which will inline all stylesheets.
Advanced
Caution
Be careful when bypassing Astro‚Äôs built-in CSS bundling! Styles won‚Äôt be automatically included in the built output, and it is your responsibility to make sure that the referenced file is properly included in the final page output.
?raw CSS Imports
For advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro‚Äôs automatic CSS handling.
This is not recommended for most users.
src/components/RawInlineStyles.astro
---
// Advanced example! Not recommended for most users.
import rawStylesCSS from '../styles/main.css?raw';
---
<style is:inline set:html={rawStylesCSS}></style>
See Vite‚Äôs docs for full details.
?url CSS Imports
For advanced use cases, you can import a direct URL reference for a CSS file inside of your project src/ directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS .
This is not recommended for most users. Instead, place your CSS files inside of public/ to get a consistent URL reference.
Caution
Importing a smaller CSS file with ?url may return the base64 encoded contents of the CSS file as a data URL in your final build. Either write your code to support encoded data URLs (data:text/css;base64,...) or set the vite.build.assetsInlineLimit config option to 0 to disable this feature.
src/components/RawStylesUrl.astro
---
// Advanced example! Not recommended for most users.
import stylesUrl from '../styles/main.css?url';
---
<link rel=""preload"" href={stylesUrl} as=""style"">
<link rel=""stylesheet"" href={stylesUrl}>
See Vite‚Äôs docs for full details.
Edit page
Translate this page
Previous
View Transitions
Next
Images
Contribute
Give us feedback
Community

On this page
Overview
Styling in Astro
Scoped Styles
Global Styles
Combining classes with class:list
CSS Variables
Passing a class to a child component
Inline styles
External Styles
Import a local stylesheet
Import a stylesheet from an npm package
Load a static stylesheet via ‚Äúlink‚Äù tags
Cascading Order
Scoped Styles
Import Order
Link Tags
CSS Integrations
Tailwind
CSS Preprocessors
Sass and SCSS
Stylus
Less
LightningCSS
In framework components
PostCSS
Frameworks and Libraries
üìò React / Preact
üìó Vue
üìï Svelte
Markdown Styling
Production
Bundle control
Advanced
?raw CSS Imports
?url CSS Imports
Want to build your own Docs?
Grab this template to get started.‚Üí
Styles & CSS
Astro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like Tailwind. Advanced styling languages like Sass and Less are also supported.
Styling in Astro
Styling an Astro component is as easy as adding a <style> tag to your component or page template. When you place a <style> tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically.
src/components/MyComponent.astro
<style>
  h1 { color: red; }
</style>
Scoped Styles
Astro <style> CSS rules are automatically scoped by default. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component.
This CSS:
src/pages/index.astro
<style>
  h1 {
    color: red;
  }
  .text {
    color: blue;
  }
</style>
Compiles to this:
<style>
  h1[data-astro-cid-hhnqfkh6] {
     color: red;
  }
  .text[data-astro-cid-hhnqfkh6] {
    color: blue;
  }
</style>
Scoped styles don‚Äôt leak and won‚Äôt impact the rest of your site. In Astro, it is okay to use low-specificity selectors like h1 {} or p {} because they will be compiled with scopes in the final output.
Scoped styles also won‚Äôt apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a <div> (or other element) that you can then style.
The specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component.
Global Styles
While we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the <style is:global> attribute.
src/components/GlobalStyles.astro
<style is:global>
  /* Unscoped, delivered as-is to the browser.
     Applies to all <h1> tags on your site. */
  h1 { color: red; }
</style>
You can also mix global & scoped CSS rules together in the same <style> tag using the :global() selector. This becomes a powerful pattern for applying CSS styles to children of your component.
src/components/MixedStyles.astro
<style>
  /* Scoped to this component, only. */
  h1 { color: red; }
  /* Mixed: Applies to child `h1` elements only. */
  article :global(h1) {
    color: blue;
  }
</style>
<h1>Title</h1>
<article><slot /></article>
This is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot.
Scoped styles should be used as often as possible. Global styles should be used only as-needed.
Combining classes with class:list
If you need to combine classes on an element dynamically, you can use the class:list utility attribute in .astro files.
src/components/ClassList.astro
---
const { isRed } = Astro.props;
---
<!-- If `isRed` is truthy, class will be ""box red"". -->
<!-- If `isRed` is falsy, class will be ""box"". -->
<div class:list={['box', { red: isRed }]}><slot /></div>
<style>
  .box { border: 1px solid blue; }
  .red { border-color: red; }
</style>
See our directives reference page to learn more about class:list.
CSS Variables
Added in: astro@0.21.0
The Astro <style> can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the define:vars directive.
src/components/DefineVars.astro
---
const foregroundColor = ""rgb(221 243 228)"";
const backgroundColor = ""rgb(24 121 78)"";
---
<style define:vars={{ foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--foregroundColor);
  }
</style>
<h1>Hello</h1>
See our directives reference page to learn more about define:vars.
Passing a class to a child component
In Astro, HTML attributes like class do not automatically pass through to child components.
Instead, accept a class prop in the child component and apply it to the root element. When destructuring, you must rename it, because class is a reserved word in JavaScript.
Using the default scoped style strategy, you must also pass the data-astro-cid-* attribute. You can do this by passing the ...rest of the props to the component. If you have changed scopedStyleStrategy to 'class' or 'where', the ...rest prop is not necessary.
src/components/MyComponent.astro
---
const { class: className, ...rest } = Astro.props;
---
<div class={className} {...rest}>
  <slot/>
</div>
src/pages/index.astro
---
import MyComponent from ""../components/MyComponent.astro""
---
<style>
  .red {
    color: red;
  }
</style>
<MyComponent class=""red"">This will be red!</MyComponent>
Scoped styles from parent components
Because the data-astro-cid-* attribute includes the child in its parent‚Äôs scope, it is possible for styles to cascade from parent to child. To avoid this having unintended side effects, ensure you use unique class names in the child component.
Inline styles
You can style HTML elements inline using the style attribute. This can be a CSS string or an object of CSS properties:
src/pages/index.astro
// These are equivalent:
<p style={{ color: ""brown"", textDecoration: ""underline"" }}>My text</p>
<p style=""color: brown; text-decoration: underline;"">My text</p>
External Styles
There are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your public/ directory, or hosted outside of your project.
Read more about using static assets located in public/ or src/.
Import a local stylesheet
Using an npm package?
You may need to update your astro.config when importing from npm packages. See the ‚Äúimport stylesheets from an npm package‚Äù section below.
You can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like any other ESM import in an Astro component, which should be referenced as relative to the component and must be written at the top of your component script, with any other imports.
src/pages/index.astro
---
// Astro will bundle and optimize this CSS for you automatically
// This also works for preprocessor files like .scss, .styl, etc.
import '../styles/utils.css';
---
<html><!-- Your page here --></html>
CSS import via ESM are supported inside of any JavaScript file, including JSX components like React & Preact. This can be useful for writing granular, per-component styles for your React components.
Import a stylesheet from an npm package
You may also need to load stylesheets from an external npm package. This is especially common for utilities like Open Props. If your package recommends using a file extension (i.e. package-name/styles.css instead of package-name/styles), this should work like any local stylesheet:
src/pages/random-page.astro
---
import 'package-name/styles.css';
---
<html><!-- Your page here --></html>
If your package does not suggest using a file extension (i.e. package-name/styles), you‚Äôll need to update your Astro config first!
Say you are importing a CSS file from package-name called normalize (with the file extension omitted). To ensure we can prerender your page correctly, add package-name to the vite.ssr.noExternal array:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  vite: {
    ssr: {
      noExternal: ['package-name'],
    }
  }
})
Note
This is a Vite-specific setting that does not relate to (or require) Astro SSR.
Now, you are free to import package-name/normalize. This will be bundled and optimized by Astro like any other local stylesheet.
src/pages/random-page.astro
---
import 'package-name/normalize';
---
<html><!-- Your page here --></html>
Load a static stylesheet via ‚Äúlink‚Äù tags
You can also use the <link> element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your /public directory, or an URL to an external website. Relative <link> href values are not supported.
src/pages/index.astro
<head>
  <!-- Local: /public/styles/global.css -->
  <link rel=""stylesheet"" href=""/styles/global.css"" />
  <!-- External -->
  <link rel=""stylesheet"" href=""https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css"" />
</head>
Because this approach uses the public/ directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the Import a Stylesheet method above.
Cascading Order
Astro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own <style> tag, and be rendered inside a layout that imports CSS.
When conflicting CSS rules apply to the same element, browsers first use specificity and then order of appearance to determine which value to show.
If one rule is more specific than another, no matter where the CSS rule appears, its value will take precedence:
src/components/MyComponent.astro
<style>
  h1 { color: red }
  div > h1 {
    color: purple
  }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
If two rules have the same specificity, then the order of appearance is evaluated, and the last rule‚Äôs value will take precedence:
src/components/MyComponent.astro
<style>
  h1 { color: purple }
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
Astro CSS rules are evaluated in this order of appearance:
<link> tags in the head (lowest precedence)
imported styles
scoped styles (highest precedence)
Scoped Styles
Using scoped styles does not increase the specificity of your CSS, but they will always come last in the order of appearance. They will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style‚Äôs value will apply:
src/components/make-it-purple.css
h1 {
  color: purple;
}
src/components/MyComponent.astro
---
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be red!
  </h1>
</div>
If you make the imported style more specific, it will have higher precedence over the scoped style:
src/components/make-it-purple.css
div > h1 {
  color: purple;
}
src/components/MyComponent.astro
---
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
Import Order
When importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the last one imported wins:
src/components/make-it-purple.css
div > h1 {
  color: purple;
}
src/components/make-it-green.css
div > h1 {
  color: green;
}
src/components/MyComponent.astro
---
import ""./make-it-green.css""
import ""./make-it-purple.css""
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
While <style> tags are scoped and only apply to the component that declares them, imported CSS can ‚Äúleak‚Äù. Importing a component applies any CSS it imports, even if the component is never used:
src/components/PurpleComponent.astro
---
import ""./make-it-purple.css""
---
<div>
  <h1>I import purple CSS.</h1>
</div>
src/components/MyComponent.astro
---
import ""./make-it-green.css""
import PurpleComponent from ""./PurpleComponent.astro"";
---
<style>
  h1 { color: red }
</style>
<div>
  <h1>
    This header will be purple!
  </h1>
</div>
Tip
A common pattern in Astro is to import global CSS inside a Layout component. Be sure to import the Layout component before other imports so that it has the lowest precedence.
Link Tags
Style sheets loaded via link tags are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles:
src/pages/index.astro
---
import ""../components/make-it-purple.css""
---
<html lang=""en"">
  <head>
    <meta charset=""utf-8"" />
    <link rel=""icon"" type=""image/svg+xml"" href=""/favicon.svg"" />
    <meta name=""viewport"" content=""width=device-width"" />
    <meta name=""generator"" content={Astro.generator} />
    <title>Astro</title>
    <link rel=""stylesheet"" href=""/styles/make-it-blue.css"" />
  </head>
  <body>
    <div>
      <h1>This will be purple</h1>
    </div>
  </body>
</html>
CSS Integrations
Astro comes with support for adding popular CSS libraries, tools, and frameworks to your project like Tailwind and more!
Tailwind
To use Tailwind in your project, install the official Astro Tailwind integration using the astro add command for your package manager:
npm
pnpm
Yarn
Terminal window
pnpm astro add tailwind
See the Integrations Guide for instructions on installing, importing and configuring Astro integrations.
CSS Preprocessors
Astro supports CSS preprocessors such as Sass, Stylus, and Less through Vite.
Sass and SCSS
Terminal window
npm install sass
Use <style lang=""scss""> or <style lang=""sass""> in .astro files.
Stylus
Terminal window
npm install stylus
Use <style lang=""styl""> or <style lang=""stylus""> in .astro files.
Less
Terminal window
npm install less
Use <style lang=""less""> in .astro files.
LightningCSS
Terminal window
npm install lightningcss
Update your vite configuration in astro.config.mjs:
astro.config.mjs
import { defineConfig } from 'astro/config'
export default defineConfig({
  vite: {
    css: {
      transformer: ""lightningcss"",
    },
  },
})
In framework components
You can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends:
React / Preact: import Styles from './styles.module.scss';
Vue: <style lang=""scss"">
Svelte: <style lang=""scss"">
PostCSS
Astro comes with PostCSS included as part of Vite. To configure PostCSS for your project, create a postcss.config.cjs file in the project root. You can import plugins using require() after installing them (for example npm install autoprefixer).
postcss.config.cjs
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('cssnano'),
  ],
};
Frameworks and Libraries
üìò React / Preact
.jsx files support both global CSS and CSS Modules. To enable the latter, use the .module.css extension (or .module.scss/.module.sass if using Sass).
src/components/MyReactComponent.jsx
import './global.css'; // include global CSS
import Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)
üìó Vue
Vue in Astro supports the same methods as vue-loader does:
vue-loader - Scoped CSS
vue-loader - CSS Modules
üìï Svelte
Svelte in Astro also works exactly as expected: Svelte Styling Docs.
Markdown Styling
Any Astro styling methods are available to a Markdown layout component, but different methods will have different styling effects on your page.
You can apply global styles to your Markdown content by adding imported stylesheets to the layout that wraps your page content. It is also possible to style your Markdown with <style is:global> tags in the layout component. Note that any styles added are subject to Astro‚Äôs cascading order, and you should check your rendered page carefully to ensure your styles are being applied as intended.
You can also add CSS integrations including Tailwind. If you are using Tailwind, the typography plugin can be useful for styling Markdown.
Production
Bundle control
When Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse.
However, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as <link rel=""stylesheet""> tags, while inlining smaller ones into <style type=""text/css"">. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages.
You can configure the size at which stylesheets will be linked externally (in bytes) using the assetsInlineLimit vite build option. Note that this option affects script and image inlining as well.
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  vite: {
    build: {
      assetsInlineLimit: 1024,
    }
  };
});
If you would rather all project styles remain external, you can configure the inlineStylesheets build option.
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  build: {
    inlineStylesheets: 'never'
  }
});
You can also set this option to 'always' which will inline all stylesheets.
Advanced
Caution
Be careful when bypassing Astro‚Äôs built-in CSS bundling! Styles won‚Äôt be automatically included in the built output, and it is your responsibility to make sure that the referenced file is properly included in the final page output.
?raw CSS Imports
For advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro‚Äôs automatic CSS handling.
This is not recommended for most users.
src/components/RawInlineStyles.astro
---
// Advanced example! Not recommended for most users.
import rawStylesCSS from '../styles/main.css?raw';
---
<style is:inline set:html={rawStylesCSS}></style>
See Vite‚Äôs docs for full details.
?url CSS Imports
For advanced use cases, you can import a direct URL reference for a CSS file inside of your project src/ directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS .
This is not recommended for most users. Instead, place your CSS files inside of public/ to get a consistent URL reference.
Caution
Importing a smaller CSS file with ?url may return the base64 encoded contents of the CSS file as a data URL in your final build. Either write your code to support encoded data URLs (data:text/css;base64,...) or set the vite.build.assetsInlineLimit config option to 0 to disable this feature.
src/components/RawStylesUrl.astro
---
// Advanced example! Not recommended for most users.
import stylesUrl from '../styles/main.css?url';
---
<link rel=""preload"" href={stylesUrl} as=""style"">
<link rel=""stylesheet"" href={stylesUrl}>
See Vite‚Äôs docs for full details.
Edit page
Translate this page
Previous
View Transitions
Next
Images
Contribute
Give us feedback
Community""""""",13685,59625,astro
https://docs.astro.build/en/guides/images/,"""""""On this page
Overview
Where to store images
src/ vs public/
Remote images
Images in .astro files
Display optimized images with the <Image /> component
Create responsive images with the <Picture /> component
Display unprocessed images with the HTML <img> tag
Choosing <Image /> vs <img>
Setting Default Values
Authorizing remote images
Using Images from a CMS or CDN
Images in Markdown files
Images in MDX files
Images in content collections
Images in UI framework components
Generating images with getImage()
Alt Text
Default image service
Configure Squoosh
Configure no-op passthrough service
Community Integrations
Want to build your own Docs?
Grab this template to get started.‚Üí
Images
Astro provides several ways for you to use images on your site, whether they are stored locally inside your project, linked to from an external URL, or managed in a CMS or CDN!
See the full API reference for the <Image /> and <Picture /> components.
Where to store images
src/ vs public/
Section titled src/ vs public/
We recommend that local images are kept in src/ when possible so that Astro can transform, optimize and bundle them. Files in the /public directory are always served or copied into the build folder as-is, with no processing.
Your local images stored in src/ can be used by all files in your project: .astro, .md, .mdx, .mdoc, and other UI frameworks. Images can be stored in any folder, including alongside your content.
Store your images in the public/ folder if you want to avoid any processing or to have a direct public link to them.
Remote images
You can also choose to store your images remotely, in a content management system (CMS) or digital asset management (DAM) platform. Astro can fetch your data remotely using APIs or display images from their full URL path.
For extra protection when dealing with external sources, Astro‚Äôs image components and helper function will only process (e.g. optimize, transform) images from authorized image sources specified in your configuration. Remote images from other sources will be displayed with no processing.
Images in .astro files
In .astro files, a local image must be imported from its relative path. This import provides the src value for your image.
Remote and public/ images do not require importing, and instead require a URL (full, or relative path on your site) for src.
Import and use Astro‚Äôs native <Image /> and <Picture /> components for optimized images. Astro syntax also supports writing an HTML <img> tag directly, which skips image processing.
src/pages/blog/my-images.astro
---
import { Image } from 'astro:assets';
import localBirdImage from '../../images/subfolder/localBirdImage.png';
---
<Image src={localBirdImage} alt=""A bird sitting on a nest of eggs."" />
<Image src=""/images/bird-in-public-folder.jpg"" alt=""A bird."" width=""50"" height=""50"" />
<Image src=""https://example.com/remote-bird.jpg"" alt=""A bird."" width=""50"" height=""50"" />
<img src={localBirdImage.src} alt=""A bird sitting on a nest of eggs."">
<img src=""/images/bird-in-public-folder.jpg"" alt=""A bird."">
<img src=""https://example.com/remote-bird.jpg"" alt=""A bird."">
See the full API reference for the <Image /> and <Picture /> components.
Related recipe:
Dynamically import images
Display optimized images with the <Image /> component
Use the built-in <Image /> Astro component to display optimized versions of:
your local images located within the src/ folder
configured remote images from authorized sources
<Image /> can transform a local or authorized remote image‚Äôs dimensions, file type, and quality for control over your displayed image. The resulting <img> tag includes alt, loading, and decoding attributes and infers image dimensions to avoid Cumulative Layout Shift (CLS).
What is Cumulative Layout Shift?
Cumulative Layout Shift (CLS) is a Core Web Vital metric for measuring how much content shifted on your page during loading. The <Image /> component optimizes for CLS by automatically setting the correct width and height for your images.
src/components/MyComponent.astro
---
// import the Image component and the image
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png'; // Image is 1600x900
---
<!-- `alt` is mandatory on the Image component -->
<Image src={myImage} alt=""A description of my image."" />
<!-- Output -->
<!-- Image is optimized, proper attributes are enforced -->
<img
  src=""/_astro/my_image.hash.webp""
  width=""1600""
  height=""900""
  decoding=""async""
  loading=""lazy""
  alt=""A description of my image.""
/>
The <Image /> component accepts several component properties as well as any attributes accepted by the HTML <img> tag.
The following example provides a class to the image component which will apply to the final <img> element.
src/pages/index.astro
---
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png';
---
<!-- `alt` is mandatory on the Image component -->
<Image src={myImage} alt="""" class=""my-class"" />
<!-- Output -->
<img
  src=""/_astro/my_image.hash.webp""
  width=""1600""
  height=""900""
  decoding=""async""
  loading=""lazy""
  class=""my-class""
  alt=""""
/>
Tip
You can also use the <Image /> component for images in the public/ folder, or remote images not specifically configured in your project, even though these images will not be optimized or processed. The resulting image will be the same as using the HTML <img>.
However, using the image component for all images provides a consistent authoring experience and prevents Cumulative Layout Shift (CLS) even for your unoptimized images.
Create responsive images with the <Picture /> component
Added in: astro@3.3.0
Use the built-in <Picture /> Astro component to display a responsive image with multiple formats and/or sizes.
src/pages/index.astro
---
import { Picture } from 'astro:assets';
import myImage from '../assets/my_image.png'; // Image is 1600x900
---
<!-- `alt` is mandatory on the Picture component -->
<Picture src={myImage} formats={['avif', 'webp']} alt=""A description of my image."" />
<!-- Output -->
<picture>
  <source srcset=""/_astro/my_image.hash.avif"" type=""image/avif"" />
  <source srcset=""/_astro/my_image.hash.webp"" type=""image/webp"" />
  <img
    src=""/_astro/my_image.hash.png""
    width=""1600""
    height=""900""
    decoding=""async""
    loading=""lazy""
    alt=""A description of my image.""
  />
</picture>
See details about the <Picture /> component properties in the astro:assets reference.
Display unprocessed images with the HTML <img> tag
The Astro template syntax also supports writing an <img> tag directly, with full control over its final output. These images will not be processed and optimized. It accepts all HTML <img> tag properties, and the only required property is src.
Local images must be imported from the relative path from the existing .astro file, or you can configure and use an import alias. Then, you can access the image‚Äôs src and other properties to use in the <img> tag.
Imported image assets match the following signature:
interface ImageMetadata {
  src: string;
  width: number;
  height: number;
  format: string;
}
The following example uses the image‚Äôs own height and width properties to avoid Cumulative Layout Shift (CLS) and improve Core Web Vitals:
src/pages/posts/post-1.astro
---
// import local images
import myDog from '../../images/pets/local-dog.jpg';
---
// access the image properties
<img src={myDog.src} width={myDog.width} height={myDog.height} alt=""A barking dog."" />
Images in public/
For images located within public/ use the image‚Äôs file path relative to the public folder as the src value:
<img src=""/images/public-cat.jpg"" alt=""A sleeping cat."" >
Remote images
For remote images, use the image‚Äôs full URL as the src value:
<img src=""https://example.com/remote-cat.jpg"" alt=""A sleeping cat."" >
Choosing <Image /> vs <img>
The <Image /> component optimizes your image and infers width and height (for images it can process) based on the original aspect ratio to avoid CLS. It is the preferred way to use images in .astro files whenever possible.
Use the HTML <img> element when you cannot use the <Image /> component, for example:
for unsupported image formats
when you do not want your image optimized by Astro
to access and change the src attribute dynamically client-side
Setting Default Values
Currently, there is no way to specify default values for all <Image /> or <Picture/> components. Required attributes should be set on each individual component.
As an alternative, you can wrap these components in another Astro component for reuse. For example, you could create a component for your blog post images that receives attributes as props and applies consistent styles to each image:
src/components/BlogPostImage.astro
---
import { Image } from 'astro:assets';
const { src, ...attrs } = Astro.props;
---
<Image src={src} {...attrs} />
<style>
  img {
    margin-block: 2.5rem;
    border-radius: 0.75rem;
  }
</style>
Authorizing remote images
You can configure lists of authorized image source URL domains and patterns for image optimization using image.domains and image.remotePatterns. This configuration is an extra layer of safety to protect your site when showing images from an external source.
Remote images from other sources will not be optimized, but using the <Image /> component for these images will prevent Cumulative Layout Shift (CLS).
For example, the following configuration will only allow remote images from astro.build to be optimized:
astro.config.mjs
export default defineConfig({
  image: {
    domains: [""astro.build""],
  }
});
The following configuration will only allow remote images from HTTPS hosts:
astro.config.mjs
export default defineConfig({
  image: {
    remotePatterns: [{ protocol: ""https"" }],
  }
});
Using Images from a CMS or CDN
Image CDNs work with all Astro image options. Use an image‚Äôs full URL as the src attribute in the <Image /> component, an <img> tag, or in Markdown notation. For image optimization with remote images, also configure your authorized domains or URL patterns.
Alternatively, the CDN may provide its own SDKs to more easily integrate in an Astro project. For example, Cloudinary supports an Astro SDK which allows you to easily drop in images with their CldImage component or a Node.js SDK that can generate URLs to use with an <img> tag in a Node.js environment.
See the full API reference for the <Image /> and <Picture /> components.
Images in Markdown files
Use standard Markdown ![alt](src) syntax in your .md files. This syntax works with Astro‚Äôs Image Service API to optimize your local images stored in src/. Remote images and images stored in the public/ folder are not optimized.
src/pages/post-1.md
# My Markdown Page
<!-- Local image stored in src/assets/ -->
<!-- Use a relative file path or import alias -->
![A starry night sky.](../assets/stars.png)
<!-- Image stored in public/images/ -->
<!-- Use the file path relative to public/ -->
![A starry night sky.](/images/stars.png)
<!-- Remote image on another server -->
<!-- Use the full URL of the image -->
![Astro](https://example.com/images/remote-image.png)
The <img> tag is not supported for local images, and the <Image /> and <Picture /> components are unavailable in .md files.
If you require more control over your image attributes, we recommend using Astro‚Äôs MDX integration to add support for.mdx file format. MDX allows adding components to Markdown and there are additional image options available in MDX.
Images in MDX files
You can use Astro‚Äôs <Image /> and <Picture /> components in your .mdx files by importing both the component and your image. Use them just as they are used in .astro files. The JSX <img /> tag is also supported for unprocessed images and uses the same image import as the HTML <img> tag.
Additionally, there is support for standard Markdown ![alt](src) syntax with no import required.
src/pages/post-1.mdx
---
title: My Page title
---
import { Image } from 'astro:assets';
import rocket from '../assets/rocket.png';
# My MDX Page
// Local image stored in the the same folder
![Houston in the wild](houston.png)
// Local image stored in src/assets/
<Image src={rocket} alt=""A rocketship in space."" />
<img src={rocket.src} alt=""A rocketship in space."" />
![A rocketship in space](../assets/rocket.png)
// Image stored in public/images/
<Image src=""/images/stars.png"" alt=""A starry night sky."" />
<img src=""/images/stars.png"" alt=""A starry night sky."" />
![A starry night sky.](/images/stars.png)
// Remote image on another server
<Image src=""https://example.com/images/remote-image.png"" />
<img src=""https://example.com/images/remote-image.png"" />
![Astro](https://example.com/images/remote-image.png)
See the full API reference for the <Image /> and <Picture /> components.
Images in content collections
Images in content collections will be processed the same way they are in Markdown and MDX depending on which file type you are using.
Additionally, you can declare an associated image for a content collections entry, such as a blog post‚Äôs cover image, in your frontmatter using its path relative to the current folder:
src/content/blog/my-post.md
---
title: ""My first blog post""
cover: ""./firstpostcover.jpeg"" # will resolve to ""src/content/blog/firstblogcover.jpeg""
coverAlt: ""A photograph of a sunset behind a mountain range.""
---
This is a blog post
The image helper for the content collections schema lets you validate the image metadata using Zod.
src/content/config.ts
import { defineCollection, z } from ""astro:content"";
const blogCollection = defineCollection({
  schema: ({ image }) => z.object({
    title: z.string(),
    cover: image().refine((img) => img.width >= 1080, {
      message: ""Cover image must be at least 1080 pixels wide!"",
    }),
    coverAlt: z.string(),
  }),
});
export const collections = {
  blog: blogCollection,
};
The image will be imported and transformed into metadata, allowing you to pass it as a src to <Image/>, <img>, or getImage().
The example below shows a blog index page that renders the cover photo and title of each blog post from the schema above:
src/pages/blog.astro
---
import { Image } from ""astro:assets"";
import { getCollection } from ""astro:content"";
const allBlogPosts = await getCollection(""blog"");
---
{
  allBlogPosts.map((post) => (
    <div>
      <Image src={post.data.cover} alt={post.data.coverAlt} />
      <h2>
        <a href={""/blog/"" + post.slug}>{post.data.title}</a>
      </h2>
    </div>
  ))
}
Images in UI framework components
The <Image /> component, like any other Astro component, is unavailable inside UI framework components.
But, you can pass the static content generated by <Image /> to a framework component inside a .astro file as children or using a named <slot/>:
src/components/ImageWrapper.astro
---
import ReactComponent from './ReactComponent.jsx';
import { Image } from 'astro:assets';
import stars from '~/stars/docline.png';
---
<ReactComponent>
  <Image src={stars} alt=""A starry night sky."" />
</ReactComponent>
You can also use the framework‚Äôs own image syntax to render an image (e.g. <img /> in JSX, <img> in Svelte).
Local images must first be imported to access their image properties such as src.
src/components/ReactImage.jsx
import stars from ""../assets/stars.png"";
export default function ReactImage() {
  return (
    <img src={stars.src} alt=""A starry night sky."" />
  )
}
src/components/SvelteImage.svelte
<script>
  import stars from '../assets/stars.png';
</script>
<img src={stars.src} alt=""A starry night sky."" />
Generating images with getImage()
The getImage() function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an API Route. When you need options that the <Picture> and <Image> components do not currently support, you can use the getImage() function to create your own custom <Image /> component.
See more in the getImage() reference.
Related recipe:
Build a custom image component
Alt Text
Not all users can see images in the same way, so accessibility is an especially important concern when using images. Use the alt attribute to provide descriptive alt text for images.
This attribute is required for both the <Image /> and <Picture /> components. If no alt text is provided, a helpful error message will be provided reminding you to include the alt attribute.
If the image is merely decorative (i.e. doesn‚Äôt contribute to the understanding of the page), set alt="""" so that screen readers know to ignore the image.
Default image service
Sharp is the default image service used for astro:assets. You can further configure the image service using the image.service option.
Note
When using a strict package manager like pnpm, you may need to manually install Sharp into your project even though it is an Astro dependency:
Terminal window
pnpm add sharp
Configure Squoosh
If you would prefer to use Squoosh to transform your images, update your config with the following:
astro.config.mjs
import { defineConfig, squooshImageService } from 'astro/config';
export default defineConfig({
  image: {
    service: squooshImageService(),
  },
});
Configure no-op passthrough service
If your adapter for server or hybrid mode does not support Astro‚Äôs built-in Squoosh and Sharp image optimization (e.g. Deno, Cloudflare), you can configure a no-op image service to allow you to use the <Image /> and <Picture /> components. Note that Astro does not perform any image transformation and processing in these environments. However, you can still enjoy the other benefits of using astro:assets, including no Cumulative Layout Shift (CLS), the enforced alt attribute, and a consistent authoring experience.
Configure the passthroughImageService() to avoid both Squoosh and Sharp image processing:
astro.config.mjs
import { defineConfig, passthroughImageService } from 'astro/config';
export default defineConfig({
  image: {
    service: passthroughImageService()
  }
});
Community Integrations
There are several third-party community image integrations for optimizing and working with images in your Astro project.
Edit page
Translate this page
Previous
CSS & Styling
Next
Fonts
Contribute
Give us feedback
Community""""""",4077,18159,astro
https://docs.astro.build/en/guides/fonts/,"""""""On this page
Overview
Using a local font file
Using Fontsource
Register fonts in Tailwind
More resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Using custom fonts
This guide will show you how to add web fonts to your project and use them in your components.
Using a local font file
This example will demonstrate adding a custom font using the font file DistantGalaxy.woff.
Add your font file to public/fonts/.
Add the following @font-face statement to your CSS. This could be in a global .css file you import, a <style is:global> block, or a <style> block in a specific layout or component where you want to use this font.
/* Register your custom font family and tell the browser where to find it. */
@font-face {
  font-family: 'DistantGalaxy';
  src: url('/fonts/DistantGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
Use the font-family value from the @font-face statement to style elements in your component or layout. In this example, the <h1> heading will have the custom font applied, while the paragraph <p> will not.
src/pages/example.astro
---
---
<h1>In a galaxy far, far away...</h1>
<p>Custom fonts make my headings much cooler!</p>
<style>
h1 {
  font-family: 'DistantGalaxy', sans-serif;
}
</style>
Using Fontsource
The Fontsource project simplifies using Google Fonts and other open-source fonts. It provides npm modules you can install for the fonts you want to use.
Find the font you want to use in Fontsource‚Äôs catalog. This example will use Twinkle Star.
Install the package for your chosen font.
npm
pnpm
Yarn
Terminal window
yarn add @fontsource/twinkle-star
Tip
You‚Äôll find the correct package name in the ‚ÄúQuick Installation‚Äù section of each font page on Fontsource‚Äôs website. It will start with @fontsource/ or @fontsource-variable/ followed by the name of the font.
Import the font package in the component where you want to use the font. Usually, you will want to do this in a common layout component to make sure the font is available across your site.
The import will automatically add the necessary @font-face rules needed to set up the font.
src/layouts/BaseLayout.astro
---
import '@fontsource/twinkle-star';
---
Use the font‚Äôs name as shown in the body example on its Fontsource page as the font-family value. This will work anywhere you can write CSS in your Astro project.
h1 {
  font-family: ""Twinkle Star"", cursive;
}
To optimize your website‚Äôs rendering times, you may want to preload fonts that are essential for the initial page display. See the Fontsource guide to preloading fonts for more information and usage.
Register fonts in Tailwind
If you are using the Tailwind integration, you can use either of the previous methods on this page to install your font, with some modification. You can either add an @font-face statement for a local font or use Fontsource‚Äôs import strategy to install your font.
To register your font in Tailwind:
Follow either of the guides above, but skip the final step of adding font-family to your CSS.
Add the typeface name to tailwind.config.mjs.
This example adds Inter to the sans-serif font stack, with default fallback fonts from Tailwind CSS.
tailwind.config.mjs
import defaultTheme from 'tailwindcss/defaultTheme'
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', ...defaultTheme.fontFamily.sans],
      },
    },
  },
  plugins: [],
}
Now, all sans-serif text (the default with Tailwind) in your project will use your chosen font and the font-sans class will also apply the Inter font.
See Tailwind‚Äôs docs on adding custom font families for more information.
More resources
Learn how web fonts work in MDN‚Äôs web fonts guide.
Generate CSS for your font with Font Squirrel‚Äôs Webfont Generator.
Edit page
Translate this page
Previous
Images
Next
Syntax Highlighting
Contribute
Give us feedback
Community

On this page
Overview
Using a local font file
Using Fontsource
Register fonts in Tailwind
More resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Using custom fonts
This guide will show you how to add web fonts to your project and use them in your components.
Using a local font file
This example will demonstrate adding a custom font using the font file DistantGalaxy.woff.
Add your font file to public/fonts/.
Add the following @font-face statement to your CSS. This could be in a global .css file you import, a <style is:global> block, or a <style> block in a specific layout or component where you want to use this font.
/* Register your custom font family and tell the browser where to find it. */
@font-face {
  font-family: 'DistantGalaxy';
  src: url('/fonts/DistantGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
Use the font-family value from the @font-face statement to style elements in your component or layout. In this example, the <h1> heading will have the custom font applied, while the paragraph <p> will not.
src/pages/example.astro
---
---
<h1>In a galaxy far, far away...</h1>
<p>Custom fonts make my headings much cooler!</p>
<style>
h1 {
  font-family: 'DistantGalaxy', sans-serif;
}
</style>
Using Fontsource
The Fontsource project simplifies using Google Fonts and other open-source fonts. It provides npm modules you can install for the fonts you want to use.
Find the font you want to use in Fontsource‚Äôs catalog. This example will use Twinkle Star.
Install the package for your chosen font.
npm
pnpm
Yarn
Terminal window
npm install @fontsource/twinkle-star
Tip
You‚Äôll find the correct package name in the ‚ÄúQuick Installation‚Äù section of each font page on Fontsource‚Äôs website. It will start with @fontsource/ or @fontsource-variable/ followed by the name of the font.
Import the font package in the component where you want to use the font. Usually, you will want to do this in a common layout component to make sure the font is available across your site.
The import will automatically add the necessary @font-face rules needed to set up the font.
src/layouts/BaseLayout.astro
---
import '@fontsource/twinkle-star';
---
Use the font‚Äôs name as shown in the body example on its Fontsource page as the font-family value. This will work anywhere you can write CSS in your Astro project.
h1 {
  font-family: ""Twinkle Star"", cursive;
}
To optimize your website‚Äôs rendering times, you may want to preload fonts that are essential for the initial page display. See the Fontsource guide to preloading fonts for more information and usage.
Register fonts in Tailwind
If you are using the Tailwind integration, you can use either of the previous methods on this page to install your font, with some modification. You can either add an @font-face statement for a local font or use Fontsource‚Äôs import strategy to install your font.
To register your font in Tailwind:
Follow either of the guides above, but skip the final step of adding font-family to your CSS.
Add the typeface name to tailwind.config.mjs.
This example adds Inter to the sans-serif font stack, with default fallback fonts from Tailwind CSS.
tailwind.config.mjs
import defaultTheme from 'tailwindcss/defaultTheme'
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', ...defaultTheme.fontFamily.sans],
      },
    },
  },
  plugins: [],
}
Now, all sans-serif text (the default with Tailwind) in your project will use your chosen font and the font-sans class will also apply the Inter font.
See Tailwind‚Äôs docs on adding custom font families for more information.
More resources
Learn how web fonts work in MDN‚Äôs web fonts guide.
Generate CSS for your font with Font Squirrel‚Äôs Webfont Generator.
Edit page
Translate this page
Previous
Images
Next
Syntax Highlighting
Contribute
Give us feedback
Community

On this page
Overview
Using a local font file
Using Fontsource
Register fonts in Tailwind
More resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Using custom fonts
This guide will show you how to add web fonts to your project and use them in your components.
Using a local font file
This example will demonstrate adding a custom font using the font file DistantGalaxy.woff.
Add your font file to public/fonts/.
Add the following @font-face statement to your CSS. This could be in a global .css file you import, a <style is:global> block, or a <style> block in a specific layout or component where you want to use this font.
/* Register your custom font family and tell the browser where to find it. */
@font-face {
  font-family: 'DistantGalaxy';
  src: url('/fonts/DistantGalaxy.woff') format('woff');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
Use the font-family value from the @font-face statement to style elements in your component or layout. In this example, the <h1> heading will have the custom font applied, while the paragraph <p> will not.
src/pages/example.astro
---
---
<h1>In a galaxy far, far away...</h1>
<p>Custom fonts make my headings much cooler!</p>
<style>
h1 {
  font-family: 'DistantGalaxy', sans-serif;
}
</style>
Using Fontsource
The Fontsource project simplifies using Google Fonts and other open-source fonts. It provides npm modules you can install for the fonts you want to use.
Find the font you want to use in Fontsource‚Äôs catalog. This example will use Twinkle Star.
Install the package for your chosen font.
npm
pnpm
Yarn
Terminal window
pnpm add @fontsource/twinkle-star
Tip
You‚Äôll find the correct package name in the ‚ÄúQuick Installation‚Äù section of each font page on Fontsource‚Äôs website. It will start with @fontsource/ or @fontsource-variable/ followed by the name of the font.
Import the font package in the component where you want to use the font. Usually, you will want to do this in a common layout component to make sure the font is available across your site.
The import will automatically add the necessary @font-face rules needed to set up the font.
src/layouts/BaseLayout.astro
---
import '@fontsource/twinkle-star';
---
Use the font‚Äôs name as shown in the body example on its Fontsource page as the font-family value. This will work anywhere you can write CSS in your Astro project.
h1 {
  font-family: ""Twinkle Star"", cursive;
}
To optimize your website‚Äôs rendering times, you may want to preload fonts that are essential for the initial page display. See the Fontsource guide to preloading fonts for more information and usage.
Register fonts in Tailwind
If you are using the Tailwind integration, you can use either of the previous methods on this page to install your font, with some modification. You can either add an @font-face statement for a local font or use Fontsource‚Äôs import strategy to install your font.
To register your font in Tailwind:
Follow either of the guides above, but skip the final step of adding font-family to your CSS.
Add the typeface name to tailwind.config.mjs.
This example adds Inter to the sans-serif font stack, with default fallback fonts from Tailwind CSS.
tailwind.config.mjs
import defaultTheme from 'tailwindcss/defaultTheme'
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', ...defaultTheme.fontFamily.sans],
      },
    },
  },
  plugins: [],
}
Now, all sans-serif text (the default with Tailwind) in your project will use your chosen font and the font-sans class will also apply the Inter font.
See Tailwind‚Äôs docs on adding custom font families for more information.
More resources
Learn how web fonts work in MDN‚Äôs web fonts guide.
Generate CSS for your font with Font Squirrel‚Äôs Webfont Generator.
Edit page
Translate this page
Previous
Images
Next
Syntax Highlighting
Contribute
Give us feedback
Community""""""",2812,12034,astro
https://docs.astro.build/en/guides/syntax-highlighting/,"""""""On this page
Overview
Markdown code blocks
Setting a default Shiki theme
Setting light and dark mode themes
Adding your own Shiki theme
Customizing Shiki themes
Components for code blocks
<Code />
<Prism />
Add a Prism stylesheet
Want to build your own Docs?
Grab this template to get started.‚Üí
Syntax Highlighting
Astro comes with built-in support for Shiki and Prism. This provides syntax highlighting for:
all code fences (```) used in a Markdown or MDX file.
content within the built-in <Code /> component (powered by Shiki) in .astro files.
content within the <Prism /> component (powered by Prism) in .astro files.
Add community integrations such as Expressive Code for even more text marking and annotation options in your code blocks.
Markdown code blocks
A Markdown code block is indicated by a block with three backticks ``` at the start and end. You can indicate the programming language being used after the opening backticks to indicate how to color and style your code to make it easier to read.
```js
// Javascript code with syntax highlighting.
var fun = function lang(l) {
  dateformat.i18n = require('./lang/' + l);
  return true;
};
```
Astro‚Äôs Markdown code blocks are styled by Shiki by default, preconfigured with the github-dark theme. The compiled output will be limited to inline styles without any extraneous CSS classes, stylesheets, or client-side JS.
You can add a Prism stylesheet and switch to Prism‚Äôs highlighting, or disable Astro‚Äôs syntax highlighting entirely, with the markdown.syntaxHighlighting configuration option.
See the full markdown.shikiConfig reference for the complete set of Markdown syntax highlighting options available when using Shiki.
Setting a default Shiki theme
You can configure any built-in Shiki theme for your Markdown code blocks in your Astro config:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  markdown: {
    shikiConfig: {
      theme: 'dracula',
    },
  },
});
See the full Shiki config reference for the complete set of Markdown code block options.
Setting light and dark mode themes
You can specify dual Shiki themes for light and dark mode in your Astro config:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  markdown: {
    shikiConfig: {
      themes: {
        light: 'github-light',
        dark: 'github-dark',
      },
    },
  },
});
Then, add Shiki‚Äôs dark mode CSS variables via media query or classes to apply to all your Markdown code blocks by default. Replace the .shiki class in the examples from Shiki‚Äôs documentation with .astro-code:
src/styles/global.css
@media (prefers-color-scheme: dark) {
  .shiki,
  .shiki span {
  .astro-code,
  .astro-code span {
    color: var(--shiki-dark) !important;
    background-color: var(--shiki-dark-bg) !important;
    /* Optional, if you also want font styles */
    font-style: var(--shiki-dark-font-style) !important;
    font-weight: var(--shiki-dark-font-weight) !important;
    text-decoration: var(--shiki-dark-text-decoration) !important;
  }
}
See the full Shiki config reference for the complete set of Markdown code block options.
Adding your own Shiki theme
Instead of using one of Shiki‚Äôs predefined themes, you can import a custom Shiki theme from a local file.
astro.config.mjs
import { defineConfig } from 'astro/config';
import customTheme from './my-shiki-theme.json';
export default defineConfig({
  markdown: {
    shikiConfig: {
      theme: customTheme,
    },
  },
});
Customizing Shiki themes
You can follow Shiki‚Äôs own theme documentation for more customization options for themes, light vs dark mode toggles, or styling via CSS variables.
Astro code blocks are styled using the .astro-code class, so you will need to replace the .shiki class in the examples with .astro-code.
Components for code blocks
There are two Astro components available for .astro and .mdx files to render code blocks: <Code /> and <Prism />.
You can reference the Props of these components using the ComponentProps type utility.
<Code />
This component is powered internally by Shiki. It supports all popular Shiki themes and languages as well as several other Shiki options such as custom themes, languages, transformers, and default colors.
These values are passed to the <Code /> component using the theme, lang, transformers, and defaultColor attributes respectively as props. The <Code /> component will not inherit your shikiConfig settings for Markdown code blocks.
---
import { Code } from 'astro:components';
---
<!-- Syntax highlight some JavaScript code. -->
<Code code={`const foo = 'bar';`} lang=""js"" />
<!-- Optional: Customize your theme. -->
<Code code={`const foo = 'bar';`} lang=""js"" theme=""dark-plus"" />
<!-- Optional: Enable word wrapping. -->
<Code code={`const foo = 'bar';`} lang=""js"" wrap />
<!-- Optional: Output inline code. -->
<p>
  <Code code={`const foo = 'bar';`} lang=""js"" inline />
  will be rendered inline.
</p>
<!-- Optional: defaultColor -->
<Code code={`const foo = 'bar';`} lang=""js"" defaultColor={false} />
Transformers
Added in: astro@4.11.0
Shiki transformers can optionally be applied to code by passing them in through the transformers property as an array. Since Astro v4.14.0, you can also provide a string for Shiki‚Äôs meta attribute to pass options to transformers.
Note that transformers only applies classes and you must provide your own CSS rules to target the elements of your code block.
src/pages/index.astro
---
import { transformerNotationFocus, transformerMetaHighlight } from '@shikijs/transformers'
import { Code } from 'astro:components'
const code = `const foo = 'hello'
const bar = ' world'
console.log(foo + bar) // [!code focus]
`
---
<Code
  code={code}
  lang=""js""
  transformers={[transformerMetaHighlight()]}
  meta=""{1,3}""
/>
<style is:global>
  pre.has-focused .line:not(.focused) {
    filter: blur(1px);
  }
</style>
<Prism />
This component provides language-specific syntax highlighting for code blocks by applying Prism‚Äôs CSS classes. Note that you must provide a Prism CSS stylesheet (or bring your own) to style the classes.
To use the Prism highlighter component, you must install the @astrojs/prism package:
npm
pnpm
Yarn
Terminal window
yarn add @astrojs/prism
Then, you can import and use the <Prism /> component like any other Astro component, passing a language and the code to render.
---
import { Prism } from '@astrojs/prism';
---
<Prism lang=""js"" code={`const foo = 'bar';`} />
In addition to the list of languages supported by Prism, you can also use lang=""astro"" to display Astro code blocks.
Add a Prism stylesheet
If you opt to use Prism (either by configuring markdown.syntaxHighlighting: 'prism' or with the <Prism /> component), Astro will apply Prism‚Äôs CSS classes instead of Shiki‚Äôs to your code. You will need to bring your own CSS stylesheet for syntax highlighting to appear.
Choose a premade stylesheet from the available Prism Themes.
Add this stylesheet to your project‚Äôs public/ directory.
Load this into your page‚Äôs <head> in a layout component via a <link> tag. (See Prism basic usage.)
You can also visit the list of languages supported by Prism for options and usage.
Edit page
Translate this page
Previous
Fonts
Next
Connect Hosted Media or DAM
Contribute
Give us feedback
Community

On this page
Overview
Markdown code blocks
Setting a default Shiki theme
Setting light and dark mode themes
Adding your own Shiki theme
Customizing Shiki themes
Components for code blocks
<Code />
<Prism />
Add a Prism stylesheet
Want to build your own Docs?
Grab this template to get started.‚Üí
Syntax Highlighting
Astro comes with built-in support for Shiki and Prism. This provides syntax highlighting for:
all code fences (```) used in a Markdown or MDX file.
content within the built-in <Code /> component (powered by Shiki) in .astro files.
content within the <Prism /> component (powered by Prism) in .astro files.
Add community integrations such as Expressive Code for even more text marking and annotation options in your code blocks.
Markdown code blocks
A Markdown code block is indicated by a block with three backticks ``` at the start and end. You can indicate the programming language being used after the opening backticks to indicate how to color and style your code to make it easier to read.
```js
// Javascript code with syntax highlighting.
var fun = function lang(l) {
  dateformat.i18n = require('./lang/' + l);
  return true;
};
```
Astro‚Äôs Markdown code blocks are styled by Shiki by default, preconfigured with the github-dark theme. The compiled output will be limited to inline styles without any extraneous CSS classes, stylesheets, or client-side JS.
You can add a Prism stylesheet and switch to Prism‚Äôs highlighting, or disable Astro‚Äôs syntax highlighting entirely, with the markdown.syntaxHighlighting configuration option.
See the full markdown.shikiConfig reference for the complete set of Markdown syntax highlighting options available when using Shiki.
Setting a default Shiki theme
You can configure any built-in Shiki theme for your Markdown code blocks in your Astro config:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  markdown: {
    shikiConfig: {
      theme: 'dracula',
    },
  },
});
See the full Shiki config reference for the complete set of Markdown code block options.
Setting light and dark mode themes
You can specify dual Shiki themes for light and dark mode in your Astro config:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  markdown: {
    shikiConfig: {
      themes: {
        light: 'github-light',
        dark: 'github-dark',
      },
    },
  },
});
Then, add Shiki‚Äôs dark mode CSS variables via media query or classes to apply to all your Markdown code blocks by default. Replace the .shiki class in the examples from Shiki‚Äôs documentation with .astro-code:
src/styles/global.css
@media (prefers-color-scheme: dark) {
  .shiki,
  .shiki span {
  .astro-code,
  .astro-code span {
    color: var(--shiki-dark) !important;
    background-color: var(--shiki-dark-bg) !important;
    /* Optional, if you also want font styles */
    font-style: var(--shiki-dark-font-style) !important;
    font-weight: var(--shiki-dark-font-weight) !important;
    text-decoration: var(--shiki-dark-text-decoration) !important;
  }
}
See the full Shiki config reference for the complete set of Markdown code block options.
Adding your own Shiki theme
Instead of using one of Shiki‚Äôs predefined themes, you can import a custom Shiki theme from a local file.
astro.config.mjs
import { defineConfig } from 'astro/config';
import customTheme from './my-shiki-theme.json';
export default defineConfig({
  markdown: {
    shikiConfig: {
      theme: customTheme,
    },
  },
});
Customizing Shiki themes
You can follow Shiki‚Äôs own theme documentation for more customization options for themes, light vs dark mode toggles, or styling via CSS variables.
Astro code blocks are styled using the .astro-code class, so you will need to replace the .shiki class in the examples with .astro-code.
Components for code blocks
There are two Astro components available for .astro and .mdx files to render code blocks: <Code /> and <Prism />.
You can reference the Props of these components using the ComponentProps type utility.
<Code />
This component is powered internally by Shiki. It supports all popular Shiki themes and languages as well as several other Shiki options such as custom themes, languages, transformers, and default colors.
These values are passed to the <Code /> component using the theme, lang, transformers, and defaultColor attributes respectively as props. The <Code /> component will not inherit your shikiConfig settings for Markdown code blocks.
---
import { Code } from 'astro:components';
---
<!-- Syntax highlight some JavaScript code. -->
<Code code={`const foo = 'bar';`} lang=""js"" />
<!-- Optional: Customize your theme. -->
<Code code={`const foo = 'bar';`} lang=""js"" theme=""dark-plus"" />
<!-- Optional: Enable word wrapping. -->
<Code code={`const foo = 'bar';`} lang=""js"" wrap />
<!-- Optional: Output inline code. -->
<p>
  <Code code={`const foo = 'bar';`} lang=""js"" inline />
  will be rendered inline.
</p>
<!-- Optional: defaultColor -->
<Code code={`const foo = 'bar';`} lang=""js"" defaultColor={false} />
Transformers
Added in: astro@4.11.0
Shiki transformers can optionally be applied to code by passing them in through the transformers property as an array. Since Astro v4.14.0, you can also provide a string for Shiki‚Äôs meta attribute to pass options to transformers.
Note that transformers only applies classes and you must provide your own CSS rules to target the elements of your code block.
src/pages/index.astro
---
import { transformerNotationFocus, transformerMetaHighlight } from '@shikijs/transformers'
import { Code } from 'astro:components'
const code = `const foo = 'hello'
const bar = ' world'
console.log(foo + bar) // [!code focus]
`
---
<Code
  code={code}
  lang=""js""
  transformers={[transformerMetaHighlight()]}
  meta=""{1,3}""
/>
<style is:global>
  pre.has-focused .line:not(.focused) {
    filter: blur(1px);
  }
</style>
<Prism />
This component provides language-specific syntax highlighting for code blocks by applying Prism‚Äôs CSS classes. Note that you must provide a Prism CSS stylesheet (or bring your own) to style the classes.
To use the Prism highlighter component, you must install the @astrojs/prism package:
npm
pnpm
Yarn
Terminal window
npm install @astrojs/prism
Then, you can import and use the <Prism /> component like any other Astro component, passing a language and the code to render.
---
import { Prism } from '@astrojs/prism';
---
<Prism lang=""js"" code={`const foo = 'bar';`} />
In addition to the list of languages supported by Prism, you can also use lang=""astro"" to display Astro code blocks.
Add a Prism stylesheet
If you opt to use Prism (either by configuring markdown.syntaxHighlighting: 'prism' or with the <Prism /> component), Astro will apply Prism‚Äôs CSS classes instead of Shiki‚Äôs to your code. You will need to bring your own CSS stylesheet for syntax highlighting to appear.
Choose a premade stylesheet from the available Prism Themes.
Add this stylesheet to your project‚Äôs public/ directory.
Load this into your page‚Äôs <head> in a layout component via a <link> tag. (See Prism basic usage.)
You can also visit the list of languages supported by Prism for options and usage.
Edit page
Translate this page
Previous
Fonts
Next
Connect Hosted Media or DAM
Contribute
Give us feedback
Community

On this page
Overview
Markdown code blocks
Setting a default Shiki theme
Setting light and dark mode themes
Adding your own Shiki theme
Customizing Shiki themes
Components for code blocks
<Code />
<Prism />
Add a Prism stylesheet
Want to build your own Docs?
Grab this template to get started.‚Üí
Syntax Highlighting
Astro comes with built-in support for Shiki and Prism. This provides syntax highlighting for:
all code fences (```) used in a Markdown or MDX file.
content within the built-in <Code /> component (powered by Shiki) in .astro files.
content within the <Prism /> component (powered by Prism) in .astro files.
Add community integrations such as Expressive Code for even more text marking and annotation options in your code blocks.
Markdown code blocks
A Markdown code block is indicated by a block with three backticks ``` at the start and end. You can indicate the programming language being used after the opening backticks to indicate how to color and style your code to make it easier to read.
```js
// Javascript code with syntax highlighting.
var fun = function lang(l) {
  dateformat.i18n = require('./lang/' + l);
  return true;
};
```
Astro‚Äôs Markdown code blocks are styled by Shiki by default, preconfigured with the github-dark theme. The compiled output will be limited to inline styles without any extraneous CSS classes, stylesheets, or client-side JS.
You can add a Prism stylesheet and switch to Prism‚Äôs highlighting, or disable Astro‚Äôs syntax highlighting entirely, with the markdown.syntaxHighlighting configuration option.
See the full markdown.shikiConfig reference for the complete set of Markdown syntax highlighting options available when using Shiki.
Setting a default Shiki theme
You can configure any built-in Shiki theme for your Markdown code blocks in your Astro config:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  markdown: {
    shikiConfig: {
      theme: 'dracula',
    },
  },
});
See the full Shiki config reference for the complete set of Markdown code block options.
Setting light and dark mode themes
You can specify dual Shiki themes for light and dark mode in your Astro config:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  markdown: {
    shikiConfig: {
      themes: {
        light: 'github-light',
        dark: 'github-dark',
      },
    },
  },
});
Then, add Shiki‚Äôs dark mode CSS variables via media query or classes to apply to all your Markdown code blocks by default. Replace the .shiki class in the examples from Shiki‚Äôs documentation with .astro-code:
src/styles/global.css
@media (prefers-color-scheme: dark) {
  .shiki,
  .shiki span {
  .astro-code,
  .astro-code span {
    color: var(--shiki-dark) !important;
    background-color: var(--shiki-dark-bg) !important;
    /* Optional, if you also want font styles */
    font-style: var(--shiki-dark-font-style) !important;
    font-weight: var(--shiki-dark-font-weight) !important;
    text-decoration: var(--shiki-dark-text-decoration) !important;
  }
}
See the full Shiki config reference for the complete set of Markdown code block options.
Adding your own Shiki theme
Instead of using one of Shiki‚Äôs predefined themes, you can import a custom Shiki theme from a local file.
astro.config.mjs
import { defineConfig } from 'astro/config';
import customTheme from './my-shiki-theme.json';
export default defineConfig({
  markdown: {
    shikiConfig: {
      theme: customTheme,
    },
  },
});
Customizing Shiki themes
You can follow Shiki‚Äôs own theme documentation for more customization options for themes, light vs dark mode toggles, or styling via CSS variables.
Astro code blocks are styled using the .astro-code class, so you will need to replace the .shiki class in the examples with .astro-code.
Components for code blocks
There are two Astro components available for .astro and .mdx files to render code blocks: <Code /> and <Prism />.
You can reference the Props of these components using the ComponentProps type utility.
<Code />
This component is powered internally by Shiki. It supports all popular Shiki themes and languages as well as several other Shiki options such as custom themes, languages, transformers, and default colors.
These values are passed to the <Code /> component using the theme, lang, transformers, and defaultColor attributes respectively as props. The <Code /> component will not inherit your shikiConfig settings for Markdown code blocks.
---
import { Code } from 'astro:components';
---
<!-- Syntax highlight some JavaScript code. -->
<Code code={`const foo = 'bar';`} lang=""js"" />
<!-- Optional: Customize your theme. -->
<Code code={`const foo = 'bar';`} lang=""js"" theme=""dark-plus"" />
<!-- Optional: Enable word wrapping. -->
<Code code={`const foo = 'bar';`} lang=""js"" wrap />
<!-- Optional: Output inline code. -->
<p>
  <Code code={`const foo = 'bar';`} lang=""js"" inline />
  will be rendered inline.
</p>
<!-- Optional: defaultColor -->
<Code code={`const foo = 'bar';`} lang=""js"" defaultColor={false} />
Transformers
Added in: astro@4.11.0
Shiki transformers can optionally be applied to code by passing them in through the transformers property as an array. Since Astro v4.14.0, you can also provide a string for Shiki‚Äôs meta attribute to pass options to transformers.
Note that transformers only applies classes and you must provide your own CSS rules to target the elements of your code block.
src/pages/index.astro
---
import { transformerNotationFocus, transformerMetaHighlight } from '@shikijs/transformers'
import { Code } from 'astro:components'
const code = `const foo = 'hello'
const bar = ' world'
console.log(foo + bar) // [!code focus]
`
---
<Code
  code={code}
  lang=""js""
  transformers={[transformerMetaHighlight()]}
  meta=""{1,3}""
/>
<style is:global>
  pre.has-focused .line:not(.focused) {
    filter: blur(1px);
  }
</style>
<Prism />
This component provides language-specific syntax highlighting for code blocks by applying Prism‚Äôs CSS classes. Note that you must provide a Prism CSS stylesheet (or bring your own) to style the classes.
To use the Prism highlighter component, you must install the @astrojs/prism package:
npm
pnpm
Yarn
Terminal window
pnpm add @astrojs/prism
Then, you can import and use the <Prism /> component like any other Astro component, passing a language and the code to render.
---
import { Prism } from '@astrojs/prism';
---
<Prism lang=""js"" code={`const foo = 'bar';`} />
In addition to the list of languages supported by Prism, you can also use lang=""astro"" to display Astro code blocks.
Add a Prism stylesheet
If you opt to use Prism (either by configuring markdown.syntaxHighlighting: 'prism' or with the <Prism /> component), Astro will apply Prism‚Äôs CSS classes instead of Shiki‚Äôs to your code. You will need to bring your own CSS stylesheet for syntax highlighting to appear.
Choose a premade stylesheet from the available Prism Themes.
Add this stylesheet to your project‚Äôs public/ directory.
Load this into your page‚Äôs <head> in a layout component via a <link> tag. (See Prism basic usage.)
You can also visit the list of languages supported by Prism for options and usage.
Edit page
Translate this page
Previous
Fonts
Next
Connect Hosted Media or DAM
Contribute
Give us feedback
Community""""""",5029,21937,astro
https://docs.astro.build/en/guides/media/,"""""""On this page
Overview
Hosted Media Guides
Why use a DAM or hosted media?
Which hosted media systems or DAMs work well with Astro?
Can I use Astro without a hosted media system or DAM?
Want to build your own Docs?
Grab this template to get started.‚Üí
Use a DAM with Astro
Ready to connect a headless Digital Asset Manager (DAM) to your Astro project? Follow one of our guides to integrate a hosted media system.
Tip
Find community-maintained integrations for connecting a DAM or hosted media system to your project in our integrations directory.
Hosted Media Guides
Note that many of these pages are stubs: they‚Äôre collections of resources waiting for your contribution!
Cloudinary
Why use a DAM or hosted media?
Using a DAM, or Digital Asset Manager, helps individuals, teams, and organizations manage their image and video assets from a central location much like a CMS.
The difference is the type of content being managed: a DAM would primarily manage images, videos, other media assets like 3D models, and any metadata associated with those assets.
This can be useful particularly when using a single source of truth for your assets between multiple web or mobile properties. This is important if you‚Äôre part of an organization that requires multiple teams to use the same assets, or are integrating into other content systems like a PIM (Product Information Manager) to connect your assets to products.
Which hosted media systems or DAMs work well with Astro?
Much like when using a CMS, as Astro handles the presentation of your content, you‚Äôll want to use a headless DAM that allows you to fetch and interact with your assets via an API or SDK.
Some headless DAMs, like Cloudinary, provide an Astro integration that allows you to easily fetch your assets as well as display them on your website or app.
Can I use Astro without a hosted media system or DAM?
Yes! Astro provides built-in ways to store images, including support for referencing remote images.
Edit page
Translate this page
Previous
Syntax Highlighting
Next
Data Fetching
Contribute
Give us feedback
Community""""""",432,2077,astro
https://docs.astro.build/en/guides/data-fetching/,"""""""On this page
Overview
fetch() in Astro
fetch() in Framework Components
GraphQL queries
Fetch from a Headless CMS
Community resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Data Fetching
.astro files can fetch remote data to help you generate your pages.
fetch() in Astro
All Astro components have access to the global fetch() function in their component script to make HTTP requests to APIs using the full URL (e.g. https://example.com/api). Additionally, you can construct a URL to your project‚Äôs pages and endpoints that are rendered on demand on the server using new URL(""/api"", Astro.url).
This fetch call will be executed at build time, and the data will be available to the component template for generating dynamic HTML. If SSR mode is enabled, any fetch calls will be executed at runtime.
üí° Take advantage of top-level await inside of your Astro component script.
üí° Pass fetched data to both Astro and framework components, as props.
src/components/User.astro
---
import Contact from '../components/Contact.jsx';
import Location from '../components/Location.astro';
const response = await fetch('https://randomuser.me/api/');
const data = await response.json();
const randomUser = data.results[0];
---
<!-- Data fetched at build can be rendered in HTML -->
<h1>User</h1>
<h2>{randomUser.name.first} {randomUser.name.last}</h2>
<!-- Data fetched at build can be passed to components as props -->
<Contact client:load email={randomUser.email} />
<Location city={randomUser.location.city} />
Note
Remember, all data in Astro components is fetched when a component is rendered.
Your deployed Astro site will fetch data once, at build time. In dev, you will see data fetches on component refreshes. If you need to re-fetch data multiple times client-side, use a framework component or a client-side script in an Astro component.
fetch() in Framework Components
The fetch() function is also globally available to any framework components:
src/components/Movies.tsx
import type { FunctionalComponent } from 'preact';
const data = await fetch('https://example.com/movies.json').then((response) =>
  response.json()
);
// Components that are build-time rendered also log to the CLI.
// When rendered with a client:* directive, they also log to the browser console.
console.log(data);
const Movies: FunctionalComponent = () => {
// Output the result to the page
  return <div>{JSON.stringify(data)}</div>;
};
export default Movies;
GraphQL queries
Astro can also use fetch() to query a GraphQL server with any valid GraphQL query.
src/components/Film.astro
---
const response = await fetch(""https://swapi-graphql.netlify.app/.netlify/functions/index"",
  {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({
      query: `
        query getFilm ($id:ID!) {
          film(id: $id) {
            title
            releaseDate
          }
        }
      `,
      variables: {
        id: ""ZmlsbXM6MQ=="",
      },
    }),
  });
const json = await response.json();
const { film } = json.data;
---
<h1>Fetching information about Star Wars: A New Hope</h1>
<h2>Title: {film.title}</h2>
<p>Year: {film.releaseDate}</p>
Fetch from a Headless CMS
Astro components can fetch data from your favorite CMS and then render it as your page content. Using dynamic routes, components can even generate pages based on your CMS content.
See our CMS Guides for full details on integrating Astro with headless CMSes including Storyblok, Contentful, and WordPress.
Community resources
Creating a fullstack app with Astro + GraphQL
Edit page
Translate this page
Previous
Connect Hosted Media or DAM
Next
Astro DB
Contribute
Give us feedback
Community""""""",822,3697,astro
https://docs.astro.build/en/guides/astro-db/,"""""""On this page
Overview
Installation
Define your database
Tables
Columns
Table References
Seed your database for development
Connect a libSQL database for production
Getting started with Turso
Connecting to remote databases
Remote URL configuration options
Query your database
Drizzle ORM
Select
Insert
Delete
Filtering
Drizzle utilities
Relationships
Batch Transactions
Pushing changes to your database
Pushing table schemas
Renaming tables
Pushing table data
Building Astro DB integrations
Type safe operations in integrations
Migrate from Astro Studio to Turso
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro DB
Astro DB is a fully-managed SQL database designed for the Astro ecosystem. Develop locally in Astro and deploy to any libSQL-compatible database.
Astro DB is a complete solution to configuring, developing, and querying your data. A local database is created in .astro/content.db whenever you run astro dev to manage your data without the need for Docker or a network connection.
Installation
Section titled Installation
Install the @astrojs/db integration using the built-in astro add command:
npm
pnpm
Yarn
Terminal window
yarn astro add db
Define your database
Installing @astrojs/db with the astro add command will automatically create a db/config.ts file in your project where you will define your database tables:
db/config.ts
import { defineDb } from 'astro:db';
export default defineDb({
  tables: { },
})
Tables
Data in Astro DB is stored using SQL tables. Tables structure your data into rows and columns, where columns enforce the type of each row value.
Define your tables in your db/config.ts file by providing the structure of the data in your existing libSQL database, or the data you will collect in a new database. This will allow Astro to generate a TypeScript interface to query that table from your project. The result is full TypeScript support when you access your data with property autocompletion and type-checking.
To configure a database table, import and use the defineTable() and column utilities from astro:db. Then, define a name (case-sensitive) for your table and the type of data in each column.
This example configures a Comment table with required text columns for author and body. Then, makes it available to your project through the defineDb() export.
db/config.ts
import { defineDb, defineTable, column } from 'astro:db';
const Comment = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
})
export default defineDb({
  tables: { Comment },
})
See the table configuration reference for a complete reference of table options.
Columns
Astro DB supports the following column types:
db/config.ts
import { defineTable, column } from 'astro:db';
const Comment = defineTable({
  columns: {
    // A string of text.
    author: column.text(),
    // A whole integer value.
    likes: column.number(),
    // A true or false value.
    flagged: column.boolean(),
    // Date/time values queried as JavaScript Date objects.
    published: column.date(),
    // An untyped JSON object.
    metadata: column.json(),
  }
});
See the table columns reference for more details.
Table References
Relationships between tables are a common pattern in database design. For example, a Blog table may be closely related to other tables of Comment, Author, and Category.
You can define these relations between tables and save them into your database schema using reference columns. To establish a relationship, you will need:
An identifier column on the referenced table. This is usually an id column with the primaryKey property.
A column on the base table to store the referenced id. This uses the references property to establish a relationship.
This example shows a Comment table‚Äôs authorId column referencing an Author table‚Äôs id column.
db/config.ts
const Author = defineTable({
  columns: {
    id: column.number({ primaryKey: true }),
    name: column.text(),
  }
});
const Comment = defineTable({
  columns: {
    authorId: column.number({ references: () => Author.columns.id }),
    body: column.text(),
  }
});
Seed your database for development
In development, Astro will use your DB config to generate local types according to your schemas. These will be generated fresh from your seed file each time the dev server is started, and will allow you to query and work with the shape of your data with type safety and autocompletion.
You will not have access to production data during development unless you connect to a remote database during development. This protects your data while allowing you to test and develop with a working database with type-safety.
To seed development data for testing and debugging into your Astro project, create a db/seed.ts file. Import both the db object and your tables defined in astro:db. insert some initial data into each table. This development data should match the form of both your database schema and production data.
The following example defines two rows of development data for a Comment table, and an Author table:
db/seed.ts
import { db, Comment, Author } from 'astro:db';
export default async function() {
  await db.insert(Author).values([
    { id: 1, name: ""Kasim"" },
    { id: 2, name: ""Mina"" },
  ]);
  await db.insert(Comment).values([
    { authorId: 1, body: 'Hope you like Astro DB!' },
    { authorId: 2, body: 'Enjoy!'},
  ])
}
Your development server will automatically restart your database whenever this file changes, regenerating your types and seeding this development data from seed.ts fresh each time.
Connect a libSQL database for production
Astro DB can connect to any local libSQL database or to any server that exposes the libSQL remote protocol, whether managed or self-hosted.
To connect Astro DB to a libSQL database, set the following environment variables obtained from your database provider:
ASTRO_DB_REMOTE_URL: the connection URL to the location of your local or remote libSQL DB. This may include URL configuration options such as sync and encryption as paramaters.
ASTRO_DB_APP_TOKEN: the auth token to your libSQL server. This is required for remote databases, and not needed for local DBs like files or in-memory databases
Depending on your service, you may have access to a CLI or web UI to retrieve these values. The following section will demonstrate connecting to Turso and setting these values as an example, but you are free to use any provider.
Getting started with Turso
Turso is the company behind libSQL, the open-source fork of SQLite that powers Astro DB. They provide a fully managed libSQL database platform and are fully compatible with Astro.
The steps below will guide you through the process of installing the Turso CLI, logging in (or signing up), creating a new database, getting the required environmental variables, and pushing the schema to the remote database.
Install the Turso CLI.
Login or signup to Turso.
Create a new database. In this example the database name is andromeda.
Terminal window
turso db create andromeda
Run the show command to see information about the newly created database:
Terminal window
turso db show andromeda
Copy the URL value and set it as the value for ASTRO_DB_REMOTE_URL.
.env
ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io
Create a new token to authenticate requests to the database:
Terminal window
turso db tokens create andromeda
Copy the output of the command and set it as the value for ASTRO_DB_APP_TOKEN.
.env
ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io
ASTRO_DB_APP_TOKEN=eyJhbGciOiJF...3ahJpTkKDw
Push your DB schema and metadata to the new Turso database.
Terminal window
astro db push --remote
Congratulations, now you have a database connected! Give yourself a break. üëæ
Terminal window
turso relax
To explore more features of Turso, check out the Turso docs.
Connecting to remote databases
Astro DB allows you to connect to both local and remote databases. By default, Astro uses a local database file for dev and build commands, recreating tables and inserting development seed data each time.
To connect to a hosted remote database, use the --remote flag. This flag enables both readable and writable access to your remote database, allowing you to accept and persist user data in production environments.
Note
While remote connections are generally possible with any deployment platform using static or server rendering mode, there are currently some limitations. Non-Node runtimes like Cloudflare and Deno don‚Äôt currently support DB on server-rendered routes when using libSQL. Support for these platforms is planned for future implementation.
Configure your build command to use the --remote flag:
package.json
{
  ""scripts"": {
    ""build"": ""astro build --remote""
  }
}
You can also use the flag directly in the command line:
Terminal window
# Build with a remote connection
astro build --remote
# Develop with a remote connection
astro dev --remote
Caution
Be careful when using --remote in development. This connects to your live production database, and all changes (inserts, updates, deletions) will be persisted.
The --remote flag uses the connection to the remote DB both locally during the build and on the server. Ensure you set the necessary environment variables in both your local development environment and your deployment platform.
When deploying your Astro DB project, make sure your deployment platform‚Äôs build command is set to npm run build (or the equivalent for your package manager) to utilize the --remote flag configured in your package.json.
Remote URL configuration options
The ASTRO_DB_REMOTE_URL environment variable configures the location of your database as well as other options like sync and encryption.
URL scheme and host
libSQL supports both HTTP and WebSockets as the transport protocol for a remote server. It also supports using a local file or an in-memory DB. Those can be configured using the following URL schemes in the connection URL:
memory: will use an in-memory DB. The host must be empty in this case.
file: will use a local file. The host is the path to the file (file:path/to/file.db).
libsql: will use a remote server through the protocol preferred by the library (this might be different across versions). The host is the address of the server (libsql://your.server.io).
http: will use a remote server through HTTP. https: can be used to enable a secure connection. The host is the same as for libsql:.
ws: will use a remote server through WebSockets. wss: can be used to enable a secure connection. The host is the same as for libsql:.
Details of the libSQL connection (e.g. encryption key, replication, sync interval) can be configured as query parameters in the remote connection URL.
For example, to have an encrypted local file work as an embedded replica to a libSQL server, you can set the following environment variables:
.env
ASTRO_DB_REMOTE_URL=file://local-copy.db?encryptionKey=your-encryption-key&syncInterval=60&syncUrl=libsql%3A%2F%2Fyour.server.io
ASTRO_DB_APP_TOKEN=token-to-your-remote-url
Caution
Using a database file is an advanced feature, and care should be taken when deploying to prevent overriding your database and losing your production data.
Additionally, this method will not work in serverless deployments, as the file system is not persisted in those environments.
encryptionKey
libSQL has native support for encrypted databases. Passing this search parameter will enable encryption using the given key:
.env
ASTRO_DB_REMOTE_URL=file:path/to/file.db?encryptionKey=your-encryption-key
syncUrl
Embedded replicas are a feature of libSQL clients that creates a full synchronized copy of your database on a local file or in memory for ultra-fast reads. Writes are sent to a remote database defined on the syncUrl and synchronized with the local copy.
Use this property to pass a separate connection URL to turn the database into an embedded replica of another database. This should only be used with the schemes file: and memory:. The parameter must be URL encoded.
For example, to have an in-memory embedded replica of a database on libsql://your.server.io, you can set the connection URL as such:
.env
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io
syncInterval
Interval between embedded replica synchronizations in seconds. By default it only synchronizes on startup and after writes.
This property is only used when syncUrl is also set. For example, to set an in-memory embedded replica to synchronize every minute set the following environment variable:
.env
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io&syncInterval=60
Query your database
You can query your database from any Astro page, endpoint, or action in your project using the provided db ORM and query builder.
Drizzle ORM
import { db } from 'astro:db';
Astro DB includes a built-in Drizzle ORM client. There is no setup or manual configuration required to use the client. The Astro DB db client is automatically configured to communicate with your database (local or remote) when you run Astro. It uses your exact database schema definition for type-safe SQL queries with TypeScript errors when you reference a column or table that doesn‚Äôt exist.
Select
The following example selects all rows of a Comment table. This returns the complete array of seeded development data from db/seed.ts which is then available for use in your page template:
src/pages/index.astro
---
import { db, Comment } from 'astro:db';
const comments = await db.select().from(Comment);
---
<h2>Comments</h2>
{
  comments.map(({ author, body }) => (
    <article>
      <p>Author: {author}</p>
      <p>{body}</p>
    </article>
  ))
}
See the Drizzle select() API reference for a complete overview.
Insert
To accept user input, such as handling form requests and inserting data into your remotely hosted database, configure your Astro project for on-demand rendering and add an SSR adapter for your deployment environment.
This example inserts a row into a Comment table based on a parsed form POST request:
src/pages/index.astro
---
import { db, Comment } from 'astro:db';
if (Astro.request.method === 'POST') {
  // Parse form data
  const formData = await Astro.request.formData();
  const author = formData.get('author');
  const body = formData.get('body');
  if (typeof author === 'string' && typeof body === 'string') {
    // Insert form data into the Comment table
    await db.insert(Comment).values({ author, body });
  }
}
// Render the new list of comments on each request
const comments = await db.select().from(Comment);
---
<form method=""POST"" style=""display: grid"">
  <label for=""author"">Author</label>
  <input id=""author"" name=""author"" />
  <label for=""body"">Body</label>
  <textarea id=""body"" name=""body""></textarea>
  <button type=""submit"">Submit</button>
</form>
<!-- Render `comments` -->
You can also use Astro actions to insert data into an Astro DB table. The following example inserts a row into a Comment table using an action:
src/actions/index.ts
import { db, Comment } from 'astro:db';
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  addComment: defineAction({
    // Actions include type safety with Zod, removing the need
    // to check if typeof {value} === 'string' in your pages
    input: z.object({
      author: z.string(),
      body: z.string(),
    }),
    handler: async (input) => {
      const updatedComments = await db
        .insert(Comment)
        .values(input)
        .returning(); // Return the updated comments
      return updatedComments;
    },
  }),
};
See the Drizzle insert() API reference for a complete overview.
Delete
You can also query your database from an API endpoint. This example deletes a row from a Comment table by the id parameter:
src/pages/api/comments/[id].ts
import type { APIRoute } from ""astro"";
import { db, Comment, eq } from 'astro:db';
export const DELETE: APIRoute = async (ctx) => {
  await db.delete(Comment).where(eq(Comment.id, ctx.params.id ));
  return new Response(null, { status: 204 });
}
See the Drizzle delete() API reference for a complete overview.
Filtering
To query for table results by a specific property, use Drizzle options for partial selects. For example, add a .where() call to your select() query and pass the comparison you want to make.
The following example queries for all rows in a Comment table that contain the phrase ‚ÄúAstro DB.‚Äù Use the like() operator to check if a phrase is present within the body:
src/pages/index.astro
---
import { db, Comment, like } from 'astro:db';
const comments = await db.select().from(Comment).where(
    like(Comment.body, '%Astro DB%')
);
---
Drizzle utilities
All Drizzle utilities for building queries are exposed from the astro:db module. This includes:
Filter operators like eq() and gt()
Aggregation helpers like count()
The sql helper for writing raw SQL queries
import { eq, gt, count, sql } from 'astro:db';
Relationships
You can query related data from multiple tables using a SQL join. To create a join query, extend your db.select() statement with a join operator. Each function accepts a table to join with and a condition to match rows between the two tables.
This example uses an innerJoin() function to join Comment authors with their related Author information based on the authorId column. This returns an array of objects with each Author and Comment row as top-level properties:
src/pages/index.astro
---
import { db, eq, Comment, Author } from 'astro:db';
const comments = await db.select()
  .from(Comment)
  .innerJoin(Author, eq(Comment.authorId, Author.id));
---
<h2>Comments</h2>
{
  comments.map(({ Author, Comment }) => (
    <article>
      <p>Author: {Author.name}</p>
      <p>{Comment.body}</p>
    </article>
  ))
}
See the Drizzle join reference for all available join operators and config options.
Batch Transactions
All remote database queries are made as a network request. You may need to ‚Äúbatch‚Äù queries together into a single transaction when making a large number of queries, or to have automatic rollbacks if any query fails.
This example seeds multiple rows in a single request using the db.batch() method:
db/seed.ts
import { db, Author, Comment } from 'astro:db';
export default async function () {
  const queries = [];
  // Seed 100 sample comments into your remote database
  // with a single network request.
  for (let i = 0; i < 100; i++) {
    queries.push(db.insert(Comment).values({ body: `Test comment ${i}` }));
  }
  await db.batch(queries);
}
See the Drizzle db.batch() docs for more details.
Pushing changes to your database
You can push changes made during development to your database.
Pushing table schemas
Your table schema may change over time as your project grows. You can safely test configuration changes locally and push to your remote database when you deploy.
You can push your local schema changes to your remote database via the CLI using the astro db push --remote command:
npm
pnpm
Yarn
Terminal window
yarn astro db push --remote
This command will verify that your local changes can be made without data loss and, if necessary, suggest how to safely make changes to your schema in order to resolve conflicts.
Pushing breaking schema changes
Caution
This will destroy your database. Only perform this command if you do not need your production data.
If you must change your table schema in a way that is incompatible with your existing data hosted on your remote database, you will need to reset your production database.
To push a table schema update that includes a breaking change, add the --force-reset flag to reset all production data:
npm
pnpm
Yarn
Terminal window
yarn astro db push --remote --force-reset
Renaming tables
It is possible to rename a table after pushing your schema to your remote database.
If you do not have any important production data, then you can reset your database using the --force-reset flag. This flag will drop all of the tables in the database and create new ones so that it matches your current schema exactly.
To rename a table while preserving your production data, you must perform a series of non-breaking changes to push your local schema to your remote database safely.
The following example renames a table from Comment to Feedback:
In your database config file, add the deprecated: true property to the table you want to rename:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Add a new table schema (matching the existing table‚Äôs properties exactly) with the new name:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
const Feedback = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Push to your remote database with astro db push --remote. This will add the new table and mark the old as deprecated.
Update any of your local project code to use the new table instead of the old table. You might need to migrate data to the new table as well.
Once you are confident that the old table is no longer used in your project, you can remove the schema from your config.ts:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
const Feedback = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Push to your remote database again with astro db push --remote. The old table will be dropped, leaving only the new, renamed table.
Pushing table data
You may need to push data to your remote database for seeding or data migrations. You can author a .ts file with the astro:db module to write type-safe queries. Then, execute the file against your remote database using the command astro db execute <file-path> --remote:
The following Comments can be seeded using the command astro db execute db/seed.ts --remote:
db/seed.ts
import { Comment } from 'astro:db';
export default async function () {
  await db.insert(Comment).values([
    { authorId: 1, body: 'Hope you like Astro DB!' },
    { authorId: 2, body: 'Enjoy!' },
  ])
}
See the CLI reference for a complete list of commands.
Building Astro DB integrations
Astro integrations can extend user projects with additional Astro DB tables and seed data.
Use the extendDb() method in the astro:db:setup hook to register additional Astro DB config and seed files. The defineDbIntegration() helper provides TypeScript support and auto-complete for the astro:db:setup hook.
my-integration/index.ts
import { defineDbIntegration } from '@astrojs/db/utils';
export default function MyIntegration() {
  return defineDbIntegration({
    name: 'my-astro-db-powered-integration',
    hooks: {
      'astro:db:setup': ({ extendDb }) => {
        extendDb({
          configEntrypoint: '@astronaut/my-package/config',
          seedEntrypoint: '@astronaut/my-package/seed',
        });
      },
      // Other integration hooks...
    },
  });
}
Integration config and seed files follow the same format as their user-defined equivalents.
Type safe operations in integrations
While working on integrations, you may not be able to benefit from Astro‚Äôs generated table types exported from astro:db. For full type safety, use the asDrizzleTable() utility to create a table reference object you can use for database operations.
For example, given an integration setting up the following Pets database table:
my-integration/config.ts
import { defineDb, defineTable, column } from 'astro:db';
export const Pets = defineTable({
  columns: {
    name: column.text(),
    species: column.text(),
  },
});
export default defineDb({ tables: { Pets } });
The seed file can import Pets and use asDrizzleTable() to insert rows into your table with type checking:
my-integration/seed.ts
import { asDrizzleTable } from '@astrojs/db/utils';
import { db } from 'astro:db';
import { Pets } from './config';
export default async function() {
  const typeSafePets = asDrizzleTable('Pets', Pets);
  await db.insert(typeSafePets).values([
    { name: 'Palomita', species: 'cat' },
    { name: 'Pan', species: 'dog' },
  ]);
}
The value returned by asDrizzleTable('Pets', Pets) is equivalent to import { Pets } from 'astro:db', but is available even when Astro‚Äôs type generation can‚Äôt run. You can use it in any integration code that needs to query or insert into the database.
Migrate from Astro Studio to Turso
In the Studio dashboard, navigate to the project you wish to migrate. In the settings tab, use the ‚ÄúExport Database‚Äù button to download a dump of your database.
Follow the official instructions to install the Turso CLI and sign up or log in to your Turso account.
Create a new database on Turso using the turso db create command.
Terminal window
turso db create [database-name]
Fetch the database URL using the Turso CLI, and use it as the environment variable ASTRO_DB_REMOTE_URL.
Terminal window
turso db show [database-name]
ASTRO_DB_REMOTE_URL=[your-database-url]
Create a token to access your database, and use it as the environment variable ASTRO_DB_APP_TOKEN.
Terminal window
turso db tokens create [database-name]
ASTRO_DB_APP_TOKEN=[your-app-token]
Push your DB schema and metadata to the new Turso database.
Terminal window
astro db push --remote
Import the database dump from step 1 into your new Turso DB.
Terminal window
turso db shell [database-name] < ./path/to/dump.sql
Once you have confirmed your project connects to the new database, you can safely delete the project from Astro Studio.
Edit page
Translate this page
Previous
Data Fetching
Next
Add Backend Services
Contribute
Give us feedback
Community

On this page
Overview
Installation
Define your database
Tables
Columns
Table References
Seed your database for development
Connect a libSQL database for production
Getting started with Turso
Connecting to remote databases
Remote URL configuration options
Query your database
Drizzle ORM
Select
Insert
Delete
Filtering
Drizzle utilities
Relationships
Batch Transactions
Pushing changes to your database
Pushing table schemas
Renaming tables
Pushing table data
Building Astro DB integrations
Type safe operations in integrations
Migrate from Astro Studio to Turso
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro DB
Astro DB is a fully-managed SQL database designed for the Astro ecosystem. Develop locally in Astro and deploy to any libSQL-compatible database.
Astro DB is a complete solution to configuring, developing, and querying your data. A local database is created in .astro/content.db whenever you run astro dev to manage your data without the need for Docker or a network connection.
Installation
Section titled Installation
Install the @astrojs/db integration using the built-in astro add command:
npm
pnpm
Yarn
Terminal window
npx astro add db
Define your database
Installing @astrojs/db with the astro add command will automatically create a db/config.ts file in your project where you will define your database tables:
db/config.ts
import { defineDb } from 'astro:db';
export default defineDb({
  tables: { },
})
Tables
Data in Astro DB is stored using SQL tables. Tables structure your data into rows and columns, where columns enforce the type of each row value.
Define your tables in your db/config.ts file by providing the structure of the data in your existing libSQL database, or the data you will collect in a new database. This will allow Astro to generate a TypeScript interface to query that table from your project. The result is full TypeScript support when you access your data with property autocompletion and type-checking.
To configure a database table, import and use the defineTable() and column utilities from astro:db. Then, define a name (case-sensitive) for your table and the type of data in each column.
This example configures a Comment table with required text columns for author and body. Then, makes it available to your project through the defineDb() export.
db/config.ts
import { defineDb, defineTable, column } from 'astro:db';
const Comment = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
})
export default defineDb({
  tables: { Comment },
})
See the table configuration reference for a complete reference of table options.
Columns
Astro DB supports the following column types:
db/config.ts
import { defineTable, column } from 'astro:db';
const Comment = defineTable({
  columns: {
    // A string of text.
    author: column.text(),
    // A whole integer value.
    likes: column.number(),
    // A true or false value.
    flagged: column.boolean(),
    // Date/time values queried as JavaScript Date objects.
    published: column.date(),
    // An untyped JSON object.
    metadata: column.json(),
  }
});
See the table columns reference for more details.
Table References
Relationships between tables are a common pattern in database design. For example, a Blog table may be closely related to other tables of Comment, Author, and Category.
You can define these relations between tables and save them into your database schema using reference columns. To establish a relationship, you will need:
An identifier column on the referenced table. This is usually an id column with the primaryKey property.
A column on the base table to store the referenced id. This uses the references property to establish a relationship.
This example shows a Comment table‚Äôs authorId column referencing an Author table‚Äôs id column.
db/config.ts
const Author = defineTable({
  columns: {
    id: column.number({ primaryKey: true }),
    name: column.text(),
  }
});
const Comment = defineTable({
  columns: {
    authorId: column.number({ references: () => Author.columns.id }),
    body: column.text(),
  }
});
Seed your database for development
In development, Astro will use your DB config to generate local types according to your schemas. These will be generated fresh from your seed file each time the dev server is started, and will allow you to query and work with the shape of your data with type safety and autocompletion.
You will not have access to production data during development unless you connect to a remote database during development. This protects your data while allowing you to test and develop with a working database with type-safety.
To seed development data for testing and debugging into your Astro project, create a db/seed.ts file. Import both the db object and your tables defined in astro:db. insert some initial data into each table. This development data should match the form of both your database schema and production data.
The following example defines two rows of development data for a Comment table, and an Author table:
db/seed.ts
import { db, Comment, Author } from 'astro:db';
export default async function() {
  await db.insert(Author).values([
    { id: 1, name: ""Kasim"" },
    { id: 2, name: ""Mina"" },
  ]);
  await db.insert(Comment).values([
    { authorId: 1, body: 'Hope you like Astro DB!' },
    { authorId: 2, body: 'Enjoy!'},
  ])
}
Your development server will automatically restart your database whenever this file changes, regenerating your types and seeding this development data from seed.ts fresh each time.
Connect a libSQL database for production
Astro DB can connect to any local libSQL database or to any server that exposes the libSQL remote protocol, whether managed or self-hosted.
To connect Astro DB to a libSQL database, set the following environment variables obtained from your database provider:
ASTRO_DB_REMOTE_URL: the connection URL to the location of your local or remote libSQL DB. This may include URL configuration options such as sync and encryption as paramaters.
ASTRO_DB_APP_TOKEN: the auth token to your libSQL server. This is required for remote databases, and not needed for local DBs like files or in-memory databases
Depending on your service, you may have access to a CLI or web UI to retrieve these values. The following section will demonstrate connecting to Turso and setting these values as an example, but you are free to use any provider.
Getting started with Turso
Turso is the company behind libSQL, the open-source fork of SQLite that powers Astro DB. They provide a fully managed libSQL database platform and are fully compatible with Astro.
The steps below will guide you through the process of installing the Turso CLI, logging in (or signing up), creating a new database, getting the required environmental variables, and pushing the schema to the remote database.
Install the Turso CLI.
Login or signup to Turso.
Create a new database. In this example the database name is andromeda.
Terminal window
turso db create andromeda
Run the show command to see information about the newly created database:
Terminal window
turso db show andromeda
Copy the URL value and set it as the value for ASTRO_DB_REMOTE_URL.
.env
ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io
Create a new token to authenticate requests to the database:
Terminal window
turso db tokens create andromeda
Copy the output of the command and set it as the value for ASTRO_DB_APP_TOKEN.
.env
ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io
ASTRO_DB_APP_TOKEN=eyJhbGciOiJF...3ahJpTkKDw
Push your DB schema and metadata to the new Turso database.
Terminal window
astro db push --remote
Congratulations, now you have a database connected! Give yourself a break. üëæ
Terminal window
turso relax
To explore more features of Turso, check out the Turso docs.
Connecting to remote databases
Astro DB allows you to connect to both local and remote databases. By default, Astro uses a local database file for dev and build commands, recreating tables and inserting development seed data each time.
To connect to a hosted remote database, use the --remote flag. This flag enables both readable and writable access to your remote database, allowing you to accept and persist user data in production environments.
Note
While remote connections are generally possible with any deployment platform using static or server rendering mode, there are currently some limitations. Non-Node runtimes like Cloudflare and Deno don‚Äôt currently support DB on server-rendered routes when using libSQL. Support for these platforms is planned for future implementation.
Configure your build command to use the --remote flag:
package.json
{
  ""scripts"": {
    ""build"": ""astro build --remote""
  }
}
You can also use the flag directly in the command line:
Terminal window
# Build with a remote connection
astro build --remote
# Develop with a remote connection
astro dev --remote
Caution
Be careful when using --remote in development. This connects to your live production database, and all changes (inserts, updates, deletions) will be persisted.
The --remote flag uses the connection to the remote DB both locally during the build and on the server. Ensure you set the necessary environment variables in both your local development environment and your deployment platform.
When deploying your Astro DB project, make sure your deployment platform‚Äôs build command is set to npm run build (or the equivalent for your package manager) to utilize the --remote flag configured in your package.json.
Remote URL configuration options
The ASTRO_DB_REMOTE_URL environment variable configures the location of your database as well as other options like sync and encryption.
URL scheme and host
libSQL supports both HTTP and WebSockets as the transport protocol for a remote server. It also supports using a local file or an in-memory DB. Those can be configured using the following URL schemes in the connection URL:
memory: will use an in-memory DB. The host must be empty in this case.
file: will use a local file. The host is the path to the file (file:path/to/file.db).
libsql: will use a remote server through the protocol preferred by the library (this might be different across versions). The host is the address of the server (libsql://your.server.io).
http: will use a remote server through HTTP. https: can be used to enable a secure connection. The host is the same as for libsql:.
ws: will use a remote server through WebSockets. wss: can be used to enable a secure connection. The host is the same as for libsql:.
Details of the libSQL connection (e.g. encryption key, replication, sync interval) can be configured as query parameters in the remote connection URL.
For example, to have an encrypted local file work as an embedded replica to a libSQL server, you can set the following environment variables:
.env
ASTRO_DB_REMOTE_URL=file://local-copy.db?encryptionKey=your-encryption-key&syncInterval=60&syncUrl=libsql%3A%2F%2Fyour.server.io
ASTRO_DB_APP_TOKEN=token-to-your-remote-url
Caution
Using a database file is an advanced feature, and care should be taken when deploying to prevent overriding your database and losing your production data.
Additionally, this method will not work in serverless deployments, as the file system is not persisted in those environments.
encryptionKey
libSQL has native support for encrypted databases. Passing this search parameter will enable encryption using the given key:
.env
ASTRO_DB_REMOTE_URL=file:path/to/file.db?encryptionKey=your-encryption-key
syncUrl
Embedded replicas are a feature of libSQL clients that creates a full synchronized copy of your database on a local file or in memory for ultra-fast reads. Writes are sent to a remote database defined on the syncUrl and synchronized with the local copy.
Use this property to pass a separate connection URL to turn the database into an embedded replica of another database. This should only be used with the schemes file: and memory:. The parameter must be URL encoded.
For example, to have an in-memory embedded replica of a database on libsql://your.server.io, you can set the connection URL as such:
.env
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io
syncInterval
Interval between embedded replica synchronizations in seconds. By default it only synchronizes on startup and after writes.
This property is only used when syncUrl is also set. For example, to set an in-memory embedded replica to synchronize every minute set the following environment variable:
.env
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io&syncInterval=60
Query your database
You can query your database from any Astro page, endpoint, or action in your project using the provided db ORM and query builder.
Drizzle ORM
import { db } from 'astro:db';
Astro DB includes a built-in Drizzle ORM client. There is no setup or manual configuration required to use the client. The Astro DB db client is automatically configured to communicate with your database (local or remote) when you run Astro. It uses your exact database schema definition for type-safe SQL queries with TypeScript errors when you reference a column or table that doesn‚Äôt exist.
Select
The following example selects all rows of a Comment table. This returns the complete array of seeded development data from db/seed.ts which is then available for use in your page template:
src/pages/index.astro
---
import { db, Comment } from 'astro:db';
const comments = await db.select().from(Comment);
---
<h2>Comments</h2>
{
  comments.map(({ author, body }) => (
    <article>
      <p>Author: {author}</p>
      <p>{body}</p>
    </article>
  ))
}
See the Drizzle select() API reference for a complete overview.
Insert
To accept user input, such as handling form requests and inserting data into your remotely hosted database, configure your Astro project for on-demand rendering and add an SSR adapter for your deployment environment.
This example inserts a row into a Comment table based on a parsed form POST request:
src/pages/index.astro
---
import { db, Comment } from 'astro:db';
if (Astro.request.method === 'POST') {
  // Parse form data
  const formData = await Astro.request.formData();
  const author = formData.get('author');
  const body = formData.get('body');
  if (typeof author === 'string' && typeof body === 'string') {
    // Insert form data into the Comment table
    await db.insert(Comment).values({ author, body });
  }
}
// Render the new list of comments on each request
const comments = await db.select().from(Comment);
---
<form method=""POST"" style=""display: grid"">
  <label for=""author"">Author</label>
  <input id=""author"" name=""author"" />
  <label for=""body"">Body</label>
  <textarea id=""body"" name=""body""></textarea>
  <button type=""submit"">Submit</button>
</form>
<!-- Render `comments` -->
You can also use Astro actions to insert data into an Astro DB table. The following example inserts a row into a Comment table using an action:
src/actions/index.ts
import { db, Comment } from 'astro:db';
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  addComment: defineAction({
    // Actions include type safety with Zod, removing the need
    // to check if typeof {value} === 'string' in your pages
    input: z.object({
      author: z.string(),
      body: z.string(),
    }),
    handler: async (input) => {
      const updatedComments = await db
        .insert(Comment)
        .values(input)
        .returning(); // Return the updated comments
      return updatedComments;
    },
  }),
};
See the Drizzle insert() API reference for a complete overview.
Delete
You can also query your database from an API endpoint. This example deletes a row from a Comment table by the id parameter:
src/pages/api/comments/[id].ts
import type { APIRoute } from ""astro"";
import { db, Comment, eq } from 'astro:db';
export const DELETE: APIRoute = async (ctx) => {
  await db.delete(Comment).where(eq(Comment.id, ctx.params.id ));
  return new Response(null, { status: 204 });
}
See the Drizzle delete() API reference for a complete overview.
Filtering
To query for table results by a specific property, use Drizzle options for partial selects. For example, add a .where() call to your select() query and pass the comparison you want to make.
The following example queries for all rows in a Comment table that contain the phrase ‚ÄúAstro DB.‚Äù Use the like() operator to check if a phrase is present within the body:
src/pages/index.astro
---
import { db, Comment, like } from 'astro:db';
const comments = await db.select().from(Comment).where(
    like(Comment.body, '%Astro DB%')
);
---
Drizzle utilities
All Drizzle utilities for building queries are exposed from the astro:db module. This includes:
Filter operators like eq() and gt()
Aggregation helpers like count()
The sql helper for writing raw SQL queries
import { eq, gt, count, sql } from 'astro:db';
Relationships
You can query related data from multiple tables using a SQL join. To create a join query, extend your db.select() statement with a join operator. Each function accepts a table to join with and a condition to match rows between the two tables.
This example uses an innerJoin() function to join Comment authors with their related Author information based on the authorId column. This returns an array of objects with each Author and Comment row as top-level properties:
src/pages/index.astro
---
import { db, eq, Comment, Author } from 'astro:db';
const comments = await db.select()
  .from(Comment)
  .innerJoin(Author, eq(Comment.authorId, Author.id));
---
<h2>Comments</h2>
{
  comments.map(({ Author, Comment }) => (
    <article>
      <p>Author: {Author.name}</p>
      <p>{Comment.body}</p>
    </article>
  ))
}
See the Drizzle join reference for all available join operators and config options.
Batch Transactions
All remote database queries are made as a network request. You may need to ‚Äúbatch‚Äù queries together into a single transaction when making a large number of queries, or to have automatic rollbacks if any query fails.
This example seeds multiple rows in a single request using the db.batch() method:
db/seed.ts
import { db, Author, Comment } from 'astro:db';
export default async function () {
  const queries = [];
  // Seed 100 sample comments into your remote database
  // with a single network request.
  for (let i = 0; i < 100; i++) {
    queries.push(db.insert(Comment).values({ body: `Test comment ${i}` }));
  }
  await db.batch(queries);
}
See the Drizzle db.batch() docs for more details.
Pushing changes to your database
You can push changes made during development to your database.
Pushing table schemas
Your table schema may change over time as your project grows. You can safely test configuration changes locally and push to your remote database when you deploy.
You can push your local schema changes to your remote database via the CLI using the astro db push --remote command:
npm
pnpm
Yarn
Terminal window
npm run astro db push --remote
This command will verify that your local changes can be made without data loss and, if necessary, suggest how to safely make changes to your schema in order to resolve conflicts.
Pushing breaking schema changes
Caution
This will destroy your database. Only perform this command if you do not need your production data.
If you must change your table schema in a way that is incompatible with your existing data hosted on your remote database, you will need to reset your production database.
To push a table schema update that includes a breaking change, add the --force-reset flag to reset all production data:
npm
pnpm
Yarn
Terminal window
npm run astro db push --remote --force-reset
Renaming tables
It is possible to rename a table after pushing your schema to your remote database.
If you do not have any important production data, then you can reset your database using the --force-reset flag. This flag will drop all of the tables in the database and create new ones so that it matches your current schema exactly.
To rename a table while preserving your production data, you must perform a series of non-breaking changes to push your local schema to your remote database safely.
The following example renames a table from Comment to Feedback:
In your database config file, add the deprecated: true property to the table you want to rename:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Add a new table schema (matching the existing table‚Äôs properties exactly) with the new name:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
const Feedback = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Push to your remote database with astro db push --remote. This will add the new table and mark the old as deprecated.
Update any of your local project code to use the new table instead of the old table. You might need to migrate data to the new table as well.
Once you are confident that the old table is no longer used in your project, you can remove the schema from your config.ts:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
const Feedback = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Push to your remote database again with astro db push --remote. The old table will be dropped, leaving only the new, renamed table.
Pushing table data
You may need to push data to your remote database for seeding or data migrations. You can author a .ts file with the astro:db module to write type-safe queries. Then, execute the file against your remote database using the command astro db execute <file-path> --remote:
The following Comments can be seeded using the command astro db execute db/seed.ts --remote:
db/seed.ts
import { Comment } from 'astro:db';
export default async function () {
  await db.insert(Comment).values([
    { authorId: 1, body: 'Hope you like Astro DB!' },
    { authorId: 2, body: 'Enjoy!' },
  ])
}
See the CLI reference for a complete list of commands.
Building Astro DB integrations
Astro integrations can extend user projects with additional Astro DB tables and seed data.
Use the extendDb() method in the astro:db:setup hook to register additional Astro DB config and seed files. The defineDbIntegration() helper provides TypeScript support and auto-complete for the astro:db:setup hook.
my-integration/index.ts
import { defineDbIntegration } from '@astrojs/db/utils';
export default function MyIntegration() {
  return defineDbIntegration({
    name: 'my-astro-db-powered-integration',
    hooks: {
      'astro:db:setup': ({ extendDb }) => {
        extendDb({
          configEntrypoint: '@astronaut/my-package/config',
          seedEntrypoint: '@astronaut/my-package/seed',
        });
      },
      // Other integration hooks...
    },
  });
}
Integration config and seed files follow the same format as their user-defined equivalents.
Type safe operations in integrations
While working on integrations, you may not be able to benefit from Astro‚Äôs generated table types exported from astro:db. For full type safety, use the asDrizzleTable() utility to create a table reference object you can use for database operations.
For example, given an integration setting up the following Pets database table:
my-integration/config.ts
import { defineDb, defineTable, column } from 'astro:db';
export const Pets = defineTable({
  columns: {
    name: column.text(),
    species: column.text(),
  },
});
export default defineDb({ tables: { Pets } });
The seed file can import Pets and use asDrizzleTable() to insert rows into your table with type checking:
my-integration/seed.ts
import { asDrizzleTable } from '@astrojs/db/utils';
import { db } from 'astro:db';
import { Pets } from './config';
export default async function() {
  const typeSafePets = asDrizzleTable('Pets', Pets);
  await db.insert(typeSafePets).values([
    { name: 'Palomita', species: 'cat' },
    { name: 'Pan', species: 'dog' },
  ]);
}
The value returned by asDrizzleTable('Pets', Pets) is equivalent to import { Pets } from 'astro:db', but is available even when Astro‚Äôs type generation can‚Äôt run. You can use it in any integration code that needs to query or insert into the database.
Migrate from Astro Studio to Turso
In the Studio dashboard, navigate to the project you wish to migrate. In the settings tab, use the ‚ÄúExport Database‚Äù button to download a dump of your database.
Follow the official instructions to install the Turso CLI and sign up or log in to your Turso account.
Create a new database on Turso using the turso db create command.
Terminal window
turso db create [database-name]
Fetch the database URL using the Turso CLI, and use it as the environment variable ASTRO_DB_REMOTE_URL.
Terminal window
turso db show [database-name]
ASTRO_DB_REMOTE_URL=[your-database-url]
Create a token to access your database, and use it as the environment variable ASTRO_DB_APP_TOKEN.
Terminal window
turso db tokens create [database-name]
ASTRO_DB_APP_TOKEN=[your-app-token]
Push your DB schema and metadata to the new Turso database.
Terminal window
astro db push --remote
Import the database dump from step 1 into your new Turso DB.
Terminal window
turso db shell [database-name] < ./path/to/dump.sql
Once you have confirmed your project connects to the new database, you can safely delete the project from Astro Studio.
Edit page
Translate this page
Previous
Data Fetching
Next
Add Backend Services
Contribute
Give us feedback
Community

On this page
Overview
Installation
Define your database
Tables
Columns
Table References
Seed your database for development
Connect a libSQL database for production
Getting started with Turso
Connecting to remote databases
Remote URL configuration options
Query your database
Drizzle ORM
Select
Insert
Delete
Filtering
Drizzle utilities
Relationships
Batch Transactions
Pushing changes to your database
Pushing table schemas
Renaming tables
Pushing table data
Building Astro DB integrations
Type safe operations in integrations
Migrate from Astro Studio to Turso
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro DB
Astro DB is a fully-managed SQL database designed for the Astro ecosystem. Develop locally in Astro and deploy to any libSQL-compatible database.
Astro DB is a complete solution to configuring, developing, and querying your data. A local database is created in .astro/content.db whenever you run astro dev to manage your data without the need for Docker or a network connection.
Installation
Section titled Installation
Install the @astrojs/db integration using the built-in astro add command:
npm
pnpm
Yarn
Terminal window
pnpm astro add db
Define your database
Installing @astrojs/db with the astro add command will automatically create a db/config.ts file in your project where you will define your database tables:
db/config.ts
import { defineDb } from 'astro:db';
export default defineDb({
  tables: { },
})
Tables
Data in Astro DB is stored using SQL tables. Tables structure your data into rows and columns, where columns enforce the type of each row value.
Define your tables in your db/config.ts file by providing the structure of the data in your existing libSQL database, or the data you will collect in a new database. This will allow Astro to generate a TypeScript interface to query that table from your project. The result is full TypeScript support when you access your data with property autocompletion and type-checking.
To configure a database table, import and use the defineTable() and column utilities from astro:db. Then, define a name (case-sensitive) for your table and the type of data in each column.
This example configures a Comment table with required text columns for author and body. Then, makes it available to your project through the defineDb() export.
db/config.ts
import { defineDb, defineTable, column } from 'astro:db';
const Comment = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
})
export default defineDb({
  tables: { Comment },
})
See the table configuration reference for a complete reference of table options.
Columns
Astro DB supports the following column types:
db/config.ts
import { defineTable, column } from 'astro:db';
const Comment = defineTable({
  columns: {
    // A string of text.
    author: column.text(),
    // A whole integer value.
    likes: column.number(),
    // A true or false value.
    flagged: column.boolean(),
    // Date/time values queried as JavaScript Date objects.
    published: column.date(),
    // An untyped JSON object.
    metadata: column.json(),
  }
});
See the table columns reference for more details.
Table References
Relationships between tables are a common pattern in database design. For example, a Blog table may be closely related to other tables of Comment, Author, and Category.
You can define these relations between tables and save them into your database schema using reference columns. To establish a relationship, you will need:
An identifier column on the referenced table. This is usually an id column with the primaryKey property.
A column on the base table to store the referenced id. This uses the references property to establish a relationship.
This example shows a Comment table‚Äôs authorId column referencing an Author table‚Äôs id column.
db/config.ts
const Author = defineTable({
  columns: {
    id: column.number({ primaryKey: true }),
    name: column.text(),
  }
});
const Comment = defineTable({
  columns: {
    authorId: column.number({ references: () => Author.columns.id }),
    body: column.text(),
  }
});
Seed your database for development
In development, Astro will use your DB config to generate local types according to your schemas. These will be generated fresh from your seed file each time the dev server is started, and will allow you to query and work with the shape of your data with type safety and autocompletion.
You will not have access to production data during development unless you connect to a remote database during development. This protects your data while allowing you to test and develop with a working database with type-safety.
To seed development data for testing and debugging into your Astro project, create a db/seed.ts file. Import both the db object and your tables defined in astro:db. insert some initial data into each table. This development data should match the form of both your database schema and production data.
The following example defines two rows of development data for a Comment table, and an Author table:
db/seed.ts
import { db, Comment, Author } from 'astro:db';
export default async function() {
  await db.insert(Author).values([
    { id: 1, name: ""Kasim"" },
    { id: 2, name: ""Mina"" },
  ]);
  await db.insert(Comment).values([
    { authorId: 1, body: 'Hope you like Astro DB!' },
    { authorId: 2, body: 'Enjoy!'},
  ])
}
Your development server will automatically restart your database whenever this file changes, regenerating your types and seeding this development data from seed.ts fresh each time.
Connect a libSQL database for production
Astro DB can connect to any local libSQL database or to any server that exposes the libSQL remote protocol, whether managed or self-hosted.
To connect Astro DB to a libSQL database, set the following environment variables obtained from your database provider:
ASTRO_DB_REMOTE_URL: the connection URL to the location of your local or remote libSQL DB. This may include URL configuration options such as sync and encryption as paramaters.
ASTRO_DB_APP_TOKEN: the auth token to your libSQL server. This is required for remote databases, and not needed for local DBs like files or in-memory databases
Depending on your service, you may have access to a CLI or web UI to retrieve these values. The following section will demonstrate connecting to Turso and setting these values as an example, but you are free to use any provider.
Getting started with Turso
Turso is the company behind libSQL, the open-source fork of SQLite that powers Astro DB. They provide a fully managed libSQL database platform and are fully compatible with Astro.
The steps below will guide you through the process of installing the Turso CLI, logging in (or signing up), creating a new database, getting the required environmental variables, and pushing the schema to the remote database.
Install the Turso CLI.
Login or signup to Turso.
Create a new database. In this example the database name is andromeda.
Terminal window
turso db create andromeda
Run the show command to see information about the newly created database:
Terminal window
turso db show andromeda
Copy the URL value and set it as the value for ASTRO_DB_REMOTE_URL.
.env
ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io
Create a new token to authenticate requests to the database:
Terminal window
turso db tokens create andromeda
Copy the output of the command and set it as the value for ASTRO_DB_APP_TOKEN.
.env
ASTRO_DB_REMOTE_URL=libsql://andromeda-houston.turso.io
ASTRO_DB_APP_TOKEN=eyJhbGciOiJF...3ahJpTkKDw
Push your DB schema and metadata to the new Turso database.
Terminal window
astro db push --remote
Congratulations, now you have a database connected! Give yourself a break. üëæ
Terminal window
turso relax
To explore more features of Turso, check out the Turso docs.
Connecting to remote databases
Astro DB allows you to connect to both local and remote databases. By default, Astro uses a local database file for dev and build commands, recreating tables and inserting development seed data each time.
To connect to a hosted remote database, use the --remote flag. This flag enables both readable and writable access to your remote database, allowing you to accept and persist user data in production environments.
Note
While remote connections are generally possible with any deployment platform using static or server rendering mode, there are currently some limitations. Non-Node runtimes like Cloudflare and Deno don‚Äôt currently support DB on server-rendered routes when using libSQL. Support for these platforms is planned for future implementation.
Configure your build command to use the --remote flag:
package.json
{
  ""scripts"": {
    ""build"": ""astro build --remote""
  }
}
You can also use the flag directly in the command line:
Terminal window
# Build with a remote connection
astro build --remote
# Develop with a remote connection
astro dev --remote
Caution
Be careful when using --remote in development. This connects to your live production database, and all changes (inserts, updates, deletions) will be persisted.
The --remote flag uses the connection to the remote DB both locally during the build and on the server. Ensure you set the necessary environment variables in both your local development environment and your deployment platform.
When deploying your Astro DB project, make sure your deployment platform‚Äôs build command is set to npm run build (or the equivalent for your package manager) to utilize the --remote flag configured in your package.json.
Remote URL configuration options
The ASTRO_DB_REMOTE_URL environment variable configures the location of your database as well as other options like sync and encryption.
URL scheme and host
libSQL supports both HTTP and WebSockets as the transport protocol for a remote server. It also supports using a local file or an in-memory DB. Those can be configured using the following URL schemes in the connection URL:
memory: will use an in-memory DB. The host must be empty in this case.
file: will use a local file. The host is the path to the file (file:path/to/file.db).
libsql: will use a remote server through the protocol preferred by the library (this might be different across versions). The host is the address of the server (libsql://your.server.io).
http: will use a remote server through HTTP. https: can be used to enable a secure connection. The host is the same as for libsql:.
ws: will use a remote server through WebSockets. wss: can be used to enable a secure connection. The host is the same as for libsql:.
Details of the libSQL connection (e.g. encryption key, replication, sync interval) can be configured as query parameters in the remote connection URL.
For example, to have an encrypted local file work as an embedded replica to a libSQL server, you can set the following environment variables:
.env
ASTRO_DB_REMOTE_URL=file://local-copy.db?encryptionKey=your-encryption-key&syncInterval=60&syncUrl=libsql%3A%2F%2Fyour.server.io
ASTRO_DB_APP_TOKEN=token-to-your-remote-url
Caution
Using a database file is an advanced feature, and care should be taken when deploying to prevent overriding your database and losing your production data.
Additionally, this method will not work in serverless deployments, as the file system is not persisted in those environments.
encryptionKey
libSQL has native support for encrypted databases. Passing this search parameter will enable encryption using the given key:
.env
ASTRO_DB_REMOTE_URL=file:path/to/file.db?encryptionKey=your-encryption-key
syncUrl
Embedded replicas are a feature of libSQL clients that creates a full synchronized copy of your database on a local file or in memory for ultra-fast reads. Writes are sent to a remote database defined on the syncUrl and synchronized with the local copy.
Use this property to pass a separate connection URL to turn the database into an embedded replica of another database. This should only be used with the schemes file: and memory:. The parameter must be URL encoded.
For example, to have an in-memory embedded replica of a database on libsql://your.server.io, you can set the connection URL as such:
.env
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io
syncInterval
Interval between embedded replica synchronizations in seconds. By default it only synchronizes on startup and after writes.
This property is only used when syncUrl is also set. For example, to set an in-memory embedded replica to synchronize every minute set the following environment variable:
.env
ASTRO_DB_REMOTE_URL=memory:?syncUrl=libsql%3A%2F%2Fyour.server.io&syncInterval=60
Query your database
You can query your database from any Astro page, endpoint, or action in your project using the provided db ORM and query builder.
Drizzle ORM
import { db } from 'astro:db';
Astro DB includes a built-in Drizzle ORM client. There is no setup or manual configuration required to use the client. The Astro DB db client is automatically configured to communicate with your database (local or remote) when you run Astro. It uses your exact database schema definition for type-safe SQL queries with TypeScript errors when you reference a column or table that doesn‚Äôt exist.
Select
The following example selects all rows of a Comment table. This returns the complete array of seeded development data from db/seed.ts which is then available for use in your page template:
src/pages/index.astro
---
import { db, Comment } from 'astro:db';
const comments = await db.select().from(Comment);
---
<h2>Comments</h2>
{
  comments.map(({ author, body }) => (
    <article>
      <p>Author: {author}</p>
      <p>{body}</p>
    </article>
  ))
}
See the Drizzle select() API reference for a complete overview.
Insert
To accept user input, such as handling form requests and inserting data into your remotely hosted database, configure your Astro project for on-demand rendering and add an SSR adapter for your deployment environment.
This example inserts a row into a Comment table based on a parsed form POST request:
src/pages/index.astro
---
import { db, Comment } from 'astro:db';
if (Astro.request.method === 'POST') {
  // Parse form data
  const formData = await Astro.request.formData();
  const author = formData.get('author');
  const body = formData.get('body');
  if (typeof author === 'string' && typeof body === 'string') {
    // Insert form data into the Comment table
    await db.insert(Comment).values({ author, body });
  }
}
// Render the new list of comments on each request
const comments = await db.select().from(Comment);
---
<form method=""POST"" style=""display: grid"">
  <label for=""author"">Author</label>
  <input id=""author"" name=""author"" />
  <label for=""body"">Body</label>
  <textarea id=""body"" name=""body""></textarea>
  <button type=""submit"">Submit</button>
</form>
<!-- Render `comments` -->
You can also use Astro actions to insert data into an Astro DB table. The following example inserts a row into a Comment table using an action:
src/actions/index.ts
import { db, Comment } from 'astro:db';
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  addComment: defineAction({
    // Actions include type safety with Zod, removing the need
    // to check if typeof {value} === 'string' in your pages
    input: z.object({
      author: z.string(),
      body: z.string(),
    }),
    handler: async (input) => {
      const updatedComments = await db
        .insert(Comment)
        .values(input)
        .returning(); // Return the updated comments
      return updatedComments;
    },
  }),
};
See the Drizzle insert() API reference for a complete overview.
Delete
You can also query your database from an API endpoint. This example deletes a row from a Comment table by the id parameter:
src/pages/api/comments/[id].ts
import type { APIRoute } from ""astro"";
import { db, Comment, eq } from 'astro:db';
export const DELETE: APIRoute = async (ctx) => {
  await db.delete(Comment).where(eq(Comment.id, ctx.params.id ));
  return new Response(null, { status: 204 });
}
See the Drizzle delete() API reference for a complete overview.
Filtering
To query for table results by a specific property, use Drizzle options for partial selects. For example, add a .where() call to your select() query and pass the comparison you want to make.
The following example queries for all rows in a Comment table that contain the phrase ‚ÄúAstro DB.‚Äù Use the like() operator to check if a phrase is present within the body:
src/pages/index.astro
---
import { db, Comment, like } from 'astro:db';
const comments = await db.select().from(Comment).where(
    like(Comment.body, '%Astro DB%')
);
---
Drizzle utilities
All Drizzle utilities for building queries are exposed from the astro:db module. This includes:
Filter operators like eq() and gt()
Aggregation helpers like count()
The sql helper for writing raw SQL queries
import { eq, gt, count, sql } from 'astro:db';
Relationships
You can query related data from multiple tables using a SQL join. To create a join query, extend your db.select() statement with a join operator. Each function accepts a table to join with and a condition to match rows between the two tables.
This example uses an innerJoin() function to join Comment authors with their related Author information based on the authorId column. This returns an array of objects with each Author and Comment row as top-level properties:
src/pages/index.astro
---
import { db, eq, Comment, Author } from 'astro:db';
const comments = await db.select()
  .from(Comment)
  .innerJoin(Author, eq(Comment.authorId, Author.id));
---
<h2>Comments</h2>
{
  comments.map(({ Author, Comment }) => (
    <article>
      <p>Author: {Author.name}</p>
      <p>{Comment.body}</p>
    </article>
  ))
}
See the Drizzle join reference for all available join operators and config options.
Batch Transactions
All remote database queries are made as a network request. You may need to ‚Äúbatch‚Äù queries together into a single transaction when making a large number of queries, or to have automatic rollbacks if any query fails.
This example seeds multiple rows in a single request using the db.batch() method:
db/seed.ts
import { db, Author, Comment } from 'astro:db';
export default async function () {
  const queries = [];
  // Seed 100 sample comments into your remote database
  // with a single network request.
  for (let i = 0; i < 100; i++) {
    queries.push(db.insert(Comment).values({ body: `Test comment ${i}` }));
  }
  await db.batch(queries);
}
See the Drizzle db.batch() docs for more details.
Pushing changes to your database
You can push changes made during development to your database.
Pushing table schemas
Your table schema may change over time as your project grows. You can safely test configuration changes locally and push to your remote database when you deploy.
You can push your local schema changes to your remote database via the CLI using the astro db push --remote command:
npm
pnpm
Yarn
Terminal window
pnpm astro db push --remote
This command will verify that your local changes can be made without data loss and, if necessary, suggest how to safely make changes to your schema in order to resolve conflicts.
Pushing breaking schema changes
Caution
This will destroy your database. Only perform this command if you do not need your production data.
If you must change your table schema in a way that is incompatible with your existing data hosted on your remote database, you will need to reset your production database.
To push a table schema update that includes a breaking change, add the --force-reset flag to reset all production data:
npm
pnpm
Yarn
Terminal window
pnpm astro db push --remote --force-reset
Renaming tables
It is possible to rename a table after pushing your schema to your remote database.
If you do not have any important production data, then you can reset your database using the --force-reset flag. This flag will drop all of the tables in the database and create new ones so that it matches your current schema exactly.
To rename a table while preserving your production data, you must perform a series of non-breaking changes to push your local schema to your remote database safely.
The following example renames a table from Comment to Feedback:
In your database config file, add the deprecated: true property to the table you want to rename:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Add a new table schema (matching the existing table‚Äôs properties exactly) with the new name:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
const Feedback = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Push to your remote database with astro db push --remote. This will add the new table and mark the old as deprecated.
Update any of your local project code to use the new table instead of the old table. You might need to migrate data to the new table as well.
Once you are confident that the old table is no longer used in your project, you can remove the schema from your config.ts:
db/config.ts
const Comment = defineTable({
  deprecated: true,
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
const Feedback = defineTable({
  columns: {
    author: column.text(),
    body: column.text(),
  }
});
Push to your remote database again with astro db push --remote. The old table will be dropped, leaving only the new, renamed table.
Pushing table data
You may need to push data to your remote database for seeding or data migrations. You can author a .ts file with the astro:db module to write type-safe queries. Then, execute the file against your remote database using the command astro db execute <file-path> --remote:
The following Comments can be seeded using the command astro db execute db/seed.ts --remote:
db/seed.ts
import { Comment } from 'astro:db';
export default async function () {
  await db.insert(Comment).values([
    { authorId: 1, body: 'Hope you like Astro DB!' },
    { authorId: 2, body: 'Enjoy!' },
  ])
}
See the CLI reference for a complete list of commands.
Building Astro DB integrations
Astro integrations can extend user projects with additional Astro DB tables and seed data.
Use the extendDb() method in the astro:db:setup hook to register additional Astro DB config and seed files. The defineDbIntegration() helper provides TypeScript support and auto-complete for the astro:db:setup hook.
my-integration/index.ts
import { defineDbIntegration } from '@astrojs/db/utils';
export default function MyIntegration() {
  return defineDbIntegration({
    name: 'my-astro-db-powered-integration',
    hooks: {
      'astro:db:setup': ({ extendDb }) => {
        extendDb({
          configEntrypoint: '@astronaut/my-package/config',
          seedEntrypoint: '@astronaut/my-package/seed',
        });
      },
      // Other integration hooks...
    },
  });
}
Integration config and seed files follow the same format as their user-defined equivalents.
Type safe operations in integrations
While working on integrations, you may not be able to benefit from Astro‚Äôs generated table types exported from astro:db. For full type safety, use the asDrizzleTable() utility to create a table reference object you can use for database operations.
For example, given an integration setting up the following Pets database table:
my-integration/config.ts
import { defineDb, defineTable, column } from 'astro:db';
export const Pets = defineTable({
  columns: {
    name: column.text(),
    species: column.text(),
  },
});
export default defineDb({ tables: { Pets } });
The seed file can import Pets and use asDrizzleTable() to insert rows into your table with type checking:
my-integration/seed.ts
import { asDrizzleTable } from '@astrojs/db/utils';
import { db } from 'astro:db';
import { Pets } from './config';
export default async function() {
  const typeSafePets = asDrizzleTable('Pets', Pets);
  await db.insert(typeSafePets).values([
    { name: 'Palomita', species: 'cat' },
    { name: 'Pan', species: 'dog' },
  ]);
}
The value returned by asDrizzleTable('Pets', Pets) is equivalent to import { Pets } from 'astro:db', but is available even when Astro‚Äôs type generation can‚Äôt run. You can use it in any integration code that needs to query or insert into the database.
Migrate from Astro Studio to Turso
In the Studio dashboard, navigate to the project you wish to migrate. In the settings tab, use the ‚ÄúExport Database‚Äù button to download a dump of your database.
Follow the official instructions to install the Turso CLI and sign up or log in to your Turso account.
Create a new database on Turso using the turso db create command.
Terminal window
turso db create [database-name]
Fetch the database URL using the Turso CLI, and use it as the environment variable ASTRO_DB_REMOTE_URL.
Terminal window
turso db show [database-name]
ASTRO_DB_REMOTE_URL=[your-database-url]
Create a token to access your database, and use it as the environment variable ASTRO_DB_APP_TOKEN.
Terminal window
turso db tokens create [database-name]
ASTRO_DB_APP_TOKEN=[your-app-token]
Push your DB schema and metadata to the new Turso database.
Terminal window
astro db push --remote
Import the database dump from step 1 into your new Turso DB.
Terminal window
turso db shell [database-name] < ./path/to/dump.sql
Once you have confirmed your project connects to the new database, you can safely delete the project from Astro Studio.
Edit page
Translate this page
Previous
Data Fetching
Next
Add Backend Services
Contribute
Give us feedback
Community""""""",17075,77199,astro
https://docs.astro.build/en/guides/backend/,"""""""On this page
Overview
Backend service guides
What is a backend service?
Why would I use a backend service?
Want to build your own Docs?
Grab this template to get started.‚Üí
Use a backend service with Astro
Ready to add features like authentication, monitoring, storage, or data to your Astro project? Follow one of our guides to integrate a backend service.
Tip
Find community-maintained integrations for adding popular features to your project in our integrations directory.
Backend service guides
Note that many of these pages are stubs: they‚Äôre collections of resources waiting for your contribution!
Appwrite
Firebase
Neon
Sentry
Supabase
Turso
Xata
What is a backend service?
A backend service is a cloud-based system that helps you build and manage your backend infrastructure. It provides a set of tools and services for managing databases, user authentication, and other server-side functionality. This enables you to focus on building your applications without having to worry about managing the underlying infrastructure.
Why would I use a backend service?
You might want to consider a backend service if your project has complex server-side needs, for example:
user sign-ups and authentication
persistent data storage
user-uploaded asset storage
API generation
realtime communication
application monitoring
Edit page
Translate this page
Previous
Astro DB
Next
E-commerce
Contribute
Give us feedback
Community""""""",287,1418,astro
https://docs.astro.build/en/guides/ecommerce/,"""""""On this page
Overview
Payment processing overlays
Lemon Squeezy
Paddle
Full-featured e-commerce solutions
Snipcart
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
E-commerce
With Astro, you can build several e-commerce options, from checkout links to hosted payment pages to building an entire storefront using a payment service API.
Payment processing overlays
Some payment processing services (e.g. Lemon Squeezy, Paddle) add a payment form to allow your customer to purchase from your site. These can be hosted overlays or embedded in a page on your site. These may offer some basic customization or site branding, and may be added to your Astro project as scripts, buttons, or external links.
Lemon Squeezy
Lemon Squeezy is an all-in-one platform for payments and subscriptions with multi-currency support, global tax compliance, PayPal integration and more. It allows you to create and manage digital products and services through your account dashboard and provides product URLs for the checkout process.
The basic Lemon.js JavaScript library allows you to sell your Lemon Squeezy products with a checkout link.
Basic Usage
The following is an example of adding a Lemon Squeezy ‚ÄúBuy now‚Äù element to an Astro page. Clicking this link will open a checkout and allow the visitor to complete a single purchase.
Add the following <script> tag to your page head or body:
src/pages/my-product-page.astro
<script src=""https://app.lemonsqueezy.com/js/lemon.js"" defer></script>
Create an anchor tag on the page linking to your product URL. Include the class lemonsqueezy-button to open a checkout overlay when clicked.
src/pages/my-product-page.astro
<a class=""lemonsqueezy-button"" href=""https://demo.lemonsqueezy.com/checkout/..."">
  Buy Now
</a>
Lemon.js
Lemon.js also provides additional behavior such as programmatically opening overlays and handling overlay events.
Read the Lemon Squeezy developer getting started guide for more information.
Paddle
Paddle is a billing solution for digital products and services. It handles payments, taxes, and subscription management through an overlay or inline checkout.
Paddle.js is a lightweight JavaScript library that lets you build rich, integrated subscription billing experiences using Paddle.
Basic Usage
The following is an example of adding a Paddle ‚ÄúBuy Now‚Äù element to an Astro page. Clicking this link will open a checkout and allow the visitor to complete a single purchase.
After your default payment link domain (your own website) is approved by Paddle, you can turn any element on your page into a trigger for a checkout overlay using HTML data attributes.
Add the following two <script> tags to your page head or body:
src/pages/my-product-page.astro
<script src=""https://cdn.paddle.com/paddle/v2/paddle.js""></script>
<script type=""text/javascript"">
  Paddle.Setup({
    token: '7d279f61a3499fed520f7cd8c08' // replace with a client-side token
  });
</script>
Turn any element on your page into a Paddle Checkout button by adding the paddle_button class:
src/pages/my-product-page.astro
<a href=""#"" class=""paddle_button"">Buy Now</a>
Add a data-items attribute to specify your product‚Äôs Paddle priceId and quantity. You can also optionally pass additional supported HTML data attributes to prefill data, handle checkout success, or style your button and checkout overlay:
src/pages/my-product-page.astro
<a
  href=""#""
  class=""paddle_button""
  data-display-mode=""overlay""
  data-theme=""light""
  data-locale=""en""
  data-success-url=""https://example.com/thankyou""
  data-items='[
    {
      ""priceId"": ""pri_01gs59hve0hrz6nyybj56z04eq"",
      ""quantity"": 1
    }
  ]'
>
  Buy now
</a>
Paddle.js
Instead of passing HTML data attributes, you can send data to the checkout overlay using JavaScript for passing multiple attributes and even greater customization. You can also create upgrade workflows using an inline checkout.
Read more about using Paddle.js to build an inline checkout.
Full-featured e-commerce solutions
For more customization over your site‚Äôs shopping cart and checkout process, you can connect a more fully-featured financial service provider (e.g. Snipcart) to your Astro project. These e-commerce platforms may also integrate with other third-party services for user account management, personalization, inventory and analytics.
Snipcart
Snipcart is a powerful, developer-first HTML/JavaScript shopping cart platform.
Snipcart also allows you to integrate with third-party services such as shipping providers, enable webhooks for an advanced e-commerce integration between your shopping cart and other systems, choose from several payment gateways (e.g. Stripe, Paypal, and Square), customize email templates, and even provides live testing environments.
Tip
Want a pre-built Snipcart solution instead? Check out astro-snipcart, a fully functional Astro community template including an optional design system, ready for you to integrate with your existing Snipcart account.
Basic Usage
The following is an example of configuring a Snipcart checkout and adding button elements for ‚ÄúAdd to cart‚Äù and ‚ÄúCheck out now‚Äù to an Astro page. This will allow your visitors to add products to a cart without being immediately sent to a checkout page.
For complete instructions, including setting up your Snipcart store, please see the Snipcart installation documentation.
Add the script as shown in the Snipcart installation instructions on your page after the <body> element.
src/pages/my-product-page.astro
<body></body>
<script>
  window.SnipcartSettings = {
    publicApiKey: ""YOUR_API_KEY"",
    loadStrategy: ""on-user-interaction"",
  };
  (function()...); // available from the Snipcart documentation
</script>
Customize window.SnipcartSettings with any of the available Snipcart settings to control the behavior and appearance of your cart.
src/pages/my-product-page.astro
<script>
  window.SnipcartSettings = {
    publicApiKey: ""YOUR_API_KEY"",
    loadStrategy: ""manual"",
    version: ""3.7.1"",
    addProductBehavior: ""none"",
    modalStyle: ""side"",
  };
  (function()...); // available from the Snipcart documentation
</script>
Add class=""snipcart-add-item"" to any HTML element, such as a <button>, to add an item to the cart when clicked on. Also include any other data elements for common Snipcart product attributes such as price and description, and any optional fields.
src/pages/my-product-page.astro
<button
  class=""snipcart-add-item""
  data-item-id=""astro-print""
  data-item-price=""39.99""
  data-item-description=""A framed print of the Astro logo.""
  data-item-image=""/assets/images/astro-print.jpg""
  data-item-name=""Astro Print""
  data-item-custom1-name=""Frame color""
  data-item-custom1-options=""Brown|Silver[+10.00]|Gold[+20.00]""
  data-item-custom2-name=""Delivery instructions""
  data-item-custom2-type=""textarea""
>
  Add to cart
</button>
Add a Snipcart checkout button with the snipcart-checkout class to open the cart and allow guests to complete their purchase with a checkout modal.
src/pages/my-product-page.astro
<button class=""snipcart-checkout"">Click here to checkout</button>
Snipcart JavaScript SDK
The Snipcart JavaScript SDK lets you configure, customize and manage your Snipcart cart programmatically.
This allows you to perform actions such as:
Retrieve relevant information about the current Snipcart session and apply certain operations to the cart.
Listen to incoming events and trigger callbacks dynamically.
Listen to state changes and receive a full snapshot of the state of the cart.
See the Snipcart documentation for more information about all the options to integrate Snipcart with your Astro Project.
astro-snipcart
There are two astro-snipcart community packages that can simplify using Snipcart.
@lloydjatkinson/astro-snipcart Astro template: This Astro template includes an optional design system for a complete e-commerce solution out of the box. Learn more on its own extensive documentation site, including the motivation behind building astro-snipcart as providing a convenient, Astro-native way for you to interact with the Snipcart API.
@Adammatthiesen/astro-snipcart integration: This integration was heavily inspired by the astro-snipcart theme and provides Astro components (or Vue components) that you can add to your existing Astro project for creating products, controlling the cart, and more. See the full tutorial for more information.
Community Resources
Hands-On Experience: eCommerce Store with Astro?
Collecting Payments with Stripe using Astro
Edit page
Translate this page
Previous
Add Backend Services
Next
Authentication
Contribute
Give us feedback
Community""""""",1890,8630,astro
https://docs.astro.build/en/guides/authentication/,"""""""On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
yarn astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
yarn add auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
yarn add better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/react';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
yarn add @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
npx astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
npm install auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
npm install better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/react';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
npm install @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
pnpm astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
pnpm add auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
pnpm add better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/react';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
pnpm add @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
npx astro add auth-astro
Manual installation
Section titled Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
npm install auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
npm install better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/react';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
npm install @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
yarn astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
yarn add auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
yarn add better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/solid';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
yarn add @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
yarn astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
yarn add auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
yarn add better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/svelte';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
yarn add @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
yarn astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
yarn add auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
yarn add better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/vue';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
yarn add @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
npx astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
npm install auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
npm install better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/vue';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
npm install @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community

On this page
Overview
Auth.js
Installation
Configuration
Usage
Next Steps
Better Auth
Installation
Configuration
Usage
Next Steps
Clerk
Installation
Configuration
Usage
Next Steps
Lucia
Guides
Examples
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Authentication
Authentication and authorization are two security processes that manage access to your website or app. Authentication verifies a visitor‚Äôs identity, while authorization grants access to protected areas and resources.
Authentication allows you to customize areas of your site for logged-in individuals and provides the greatest protection for personal or private information. Authentication libraries (e.g. Auth.js, Clerk) provide utilities for multiple authentication methods such as email sign-in and OAuth providers.
Tip
There is no official authentication solution for Astro, but you can find community ‚Äúauth‚Äù integrations in the integrations directory.
See how to add authentication with Supabase or add authentication with Firebase in our dedicated guides for these backend services.
Auth.js
Auth.js is a framework agnostic solution for authentication. A community framework adapter auth-astro is available for Astro.
Installation
Use the astro add command for your preferred package manager to add the auth-astro integration.
npm
pnpm
Yarn
Terminal window
pnpm astro add auth-astro
Manual installation
To install auth-astro manually, install the required package for your package manager:
npm
pnpm
Yarn
Terminal window
pnpm add auth-astro @auth/core@^0.18.6
Then, apply the integration to your astro.config.* file using the integrations property:
astro.config.mjs
import { defineConfig } from 'astro/config';
import auth from 'auth-astro';
export default defineConfig({
  // ...
  integrations: [auth()],
});
Configuration
Create an auth.config.mjs file in your project‚Äôs root directory. Add any auth providers or methods you wish to support, along with any environment variables they require.
auth.config.mjs
import GitHub from '@auth/core/providers/github';
import { defineConfig } from 'auth-astro';
export default defineConfig({
  providers: [
    GitHub({
      clientId: import.meta.env.GITHUB_CLIENT_ID,
      clientSecret: import.meta.env.GITHUB_CLIENT_SECRET,
    }),
  ],
});
Create a .env file in the root of your project if it does not already exist. Add the following two environment variables. AUTH_SECRET should be a private string with a minimum of 32 characters.
.env
AUTH_TRUST_HOST=true
AUTH_SECRET=<my-auth-secret>
Usage
You can add sign-in and sign-out buttons using the auth-astro/client module in a script tag or client-side framework component.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""auth-astro/client"")
    document.querySelector(""#login"").onclick = () => signIn(""github"")
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can fetch the user‚Äôs session using the getSession method.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { getSession } from 'auth-astro/server';
const session = await getSession(Astro.request);
---
<Layout>
  {
    session ? (
      <p>Welcome {session.user?.name}</p>
    ) : (
      <p>Not logged in</p>
    )
  }
</Layout>
Next Steps
auth-astro on GitHub
Auth.js documentation
Better Auth
Better Auth is a framework-agnostic authentication (and authorization) framework for TypeScript. It provides a comprehensive set of features out of the box and includes a plugin ecosystem that simplifies adding advanced functionalities.
It supports Astro out of the box, and you can use it to add authentication to your astro project.
Installation
npm
pnpm
Yarn
Terminal window
pnpm add better-auth
For detailed setup instructions, check out the Better Auth Installation Guide.
Configuration
Configure your database table to store user data and your preferred authentication methods as described in the the Better Auth Installation Guide. Then, you‚Äôll need to mount the Better Auth handler in your Astro project.
page/api/auth/[...all].ts
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
import type { APIRoute } from ""astro"";
export const ALL: APIRoute = async (ctx) => {
  return auth.handler(ctx.request);
};
Follow the Better Auth Astro Guide to learn more.
Usage
Better Auth offers a createAuthClient helper for various frameworks, including Vanilla JS, React, Vue, Svelte, and Solid.
For example, to create a client for React, import the helper from 'better-auth/react':
React
Solid
Svelte
Vue
src/lib/auth-client.ts
import { createAuthClient } from 'better-auth/vue';
export const authClient = createAuthClient();
export const { signIn, signOut } = authClient;
Once your client is set up, you can use it to authenticate users in your Astro components or any framework-specific files. The following example adds the ability to log in or log out with your configured signIn() and signOut() functions.
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
---
<Layout>
  <button id=""login"">Login</button>
  <button id=""logout"">Logout</button>
  <script>
    const { signIn, signOut } = await import(""./lib/auth-client"")
    document.querySelector(""#login"").onclick = () => signIn.social({
      provider: ""github"",
      callbackURL: ""/dashboard"",
    })
    document.querySelector(""#logout"").onclick = () => signOut()
  </script>
</Layout>
You can then use the auth object to get the user‚Äôs session data in your server-side code. The following example personalizes page content by displaying an authenticated user‚Äôs name:
src/pages/index.astro
---
import { auth } from ""../../../lib/auth""; // import your Better Auth instance
const session = await auth.api.getSession({
  headers: Astro.request.headers,
});
---
<p>{session.user?.name}</p>
You can also use the auth object to protect your routes using middleware. The following example checks whether a user trying to access a logged-in dashbord route is authenticated, and redirects them to the home page if not.
src/middleware.ts
import { auth } from ""../../../auth""; // import your Better Auth instance
import { defineMiddleware } from ""astro:middleware"";
export const onRequest = defineMiddleware(async (context, next) => {
  const isAuthed = await auth.api
    .getSession({
      headers: context.request.headers,
    })
  if (context.url.pathname === ""/dashboard"" && !isAuthed) {
    return context.redirect(""/"");
  }
  return next();
});
Next Steps
Better Auth Astro Guide
Better Auth Astro Example
Better Auth Documentation
Better Auth GitHub Repository
Clerk
Clerk is a complete suite of embeddable UIs, flexible APIs, and admin dashboards to authenticate and manage your users. An official Clerk SDK for Astro is available.
Installation
Install @clerk/astro using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
pnpm add @clerk/astro
Configuration
Follow Clerk‚Äôs own Astro Quickstart guide to set up Clerk integration and middleware in your Astro project.
Usage
Clerk provides components that allow you to control the visibility of pages based on your user‚Äôs authentication state. Show logged out users a sign in button instead of the content available to users who are logged in:
src/pages/index.astro
---
import Layout from 'src/layouts/Base.astro';
import { SignedIn, SignedOut, UserButton, SignInButton } from '@clerk/astro/components';
---
<Layout>
    <SignedIn>
        <UserButton />
    </SignedIn>
    <SignedOut>
        <SignInButton />
    </SignedOut>
</Layout>
Clerk also allows you to protect routes on the server using middleware. Specify which routes are protected, and prompt unauthenticated users to sign in:
src/middleware.ts
import { clerkMiddleware, createRouteMatcher } from '@clerk/astro/server';
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
]);
export const onRequest = clerkMiddleware((auth, context) => {
  if (!auth().userId && isProtectedRoute(context.request)) {
    return auth().redirectToSignIn();
  }
});
Next Steps
Read the official @clerk/astro documentation
Start from a template with the Clerk + Astro Quickstart project
Lucia
Lucia is a resource for implementing session-based authentication in a number of frameworks, including Astro.
Guides
Create a basic sessions API with your chosen database.
Add session cookies using endpoints and middleware.
Implement GitHub OAuth using the APIs you implemented.
Examples
GitHub OAuth example in Astro
Google OAuth example in Astro
Email and password example with 2FA in Astro
Email and password example with 2FA and WebAuthn in Astro
Community Resources
Using Microsoft Entra Id EasyAuth with Astro and Azure Static Web App
Edit page
Translate this page
Previous
E-commerce
Next
Environment Variables
Contribute
Give us feedback
Community""""""",17574,80944,astro
https://docs.astro.build/en/guides/environment-variables/,"""""""On this page
Overview
Default environment variables
Setting environment variables
.env files
Using the CLI
Getting environment variables
IntelliSense for TypeScript
Want to build your own Docs?
Grab this template to get started.‚Üí
Using environment variables
Looking for astro:env?
Find out more about the experimental astro:env API for type-safe environment variables!
Astro uses Vite‚Äôs built-in support for environment variables, which are statically replaced at build time, and lets you use any of its methods to work with them.
Note that while all environment variables are available in server-side code, only environment variables prefixed with PUBLIC_ are available in client-side code for security purposes.
.env
SECRET_PASSWORD=password123
PUBLIC_ANYBODY=there
In this example, PUBLIC_ANYBODY (accessible via import.meta.env.PUBLIC_ANYBODY) will be available in server or client code, while SECRET_PASSWORD (accessible via import.meta.env.SECRET_PASSWORD) will be server-side only.
Caution
.env files are not loaded inside configuration files.
Default environment variables
Astro includes a few environment variables out-of-the-box:
import.meta.env.MODE: The mode your site is running in. This is development when running astro dev and production when running astro build.
import.meta.env.PROD: true if your site is running in production; false otherwise.
import.meta.env.DEV: true if your site is running in development; false otherwise. Always the opposite of import.meta.env.PROD.
import.meta.env.BASE_URL: The base url your site is being served from. This is determined by the base config option.
import.meta.env.SITE: This is set to the site option specified in your project‚Äôs astro.config.
import.meta.env.ASSETS_PREFIX: The prefix for Astro-generated asset links if the build.assetsPrefix config option is set. This can be used to create asset links not handled by Astro.
Use them like any other environment variable.
const isProd = import.meta.env.PROD;
const isDev = import.meta.env.DEV;
Setting environment variables
.env files
Environment variables can be loaded from .env files in your project directory.
You can also attach a mode (either production or development) to the filename, like .env.production or .env.development, which makes the environment variables only take effect in that mode.
Just create a .env file in the project directory and add some variables to it.
.env
# This will only be available when run on the server!
DB_PASSWORD=""foobar""
# This will be available everywhere!
PUBLIC_POKEAPI=""https://pokeapi.co/api/v2""
For more on .env files, see the Vite documentation.
Using the CLI
You can also add environment variables as you run your project:
npm
pnpm
Yarn
Terminal window
PUBLIC_POKEAPI=https://pokeapi.co/api/v2 yarn run dev
Getting environment variables
Environment variables in Astro are accessed with import.meta.env, using the import.meta feature added in ES2020, instead of process.env.
For example, use import.meta.env.PUBLIC_POKEAPI to get the PUBLIC_POKEAPI environment variable.
// When import.meta.env.SSR === true
const data = await db(import.meta.env.DB_PASSWORD);
// When import.meta.env.SSR === false
const data = fetch(`${import.meta.env.PUBLIC_POKEAPI}/pokemon/squirtle`);
When using SSR, environment variables can be accessed at runtime based on the SSR adapter being used. With most adapters you can access environment variables with process.env, but some adapters work differently. For the Deno adapter, you will use Deno.env.get(). See how to access the Cloudflare runtime to handle environment variables when using the Cloudflare adapter. Astro will first check the server environment for variables, and if they don‚Äôt exist, Astro will look for them in .env files.
IntelliSense for TypeScript
By default, Astro provides type definition for import.meta.env in astro/client.d.ts.
While you can define more custom env variables in .env.[mode] files, you may want to get TypeScript IntelliSense for user-defined env variables which are prefixed with PUBLIC_.
To achieve this, you can create an env.d.ts in src/ and configure ImportMetaEnv like this:
src/env.d.ts
interface ImportMetaEnv {
  readonly DB_PASSWORD: string;
  readonly PUBLIC_POKEAPI: string;
  // more env variables...
}
interface ImportMeta {
  readonly env: ImportMetaEnv;
}
Edit page
Translate this page
Previous
Authentication
Next
UI Frameworks
Contribute
Give us feedback
Community

On this page
Overview
Default environment variables
Setting environment variables
.env files
Using the CLI
Getting environment variables
IntelliSense for TypeScript
Want to build your own Docs?
Grab this template to get started.‚Üí
Using environment variables
Looking for astro:env?
Find out more about the experimental astro:env API for type-safe environment variables!
Astro uses Vite‚Äôs built-in support for environment variables, which are statically replaced at build time, and lets you use any of its methods to work with them.
Note that while all environment variables are available in server-side code, only environment variables prefixed with PUBLIC_ are available in client-side code for security purposes.
.env
SECRET_PASSWORD=password123
PUBLIC_ANYBODY=there
In this example, PUBLIC_ANYBODY (accessible via import.meta.env.PUBLIC_ANYBODY) will be available in server or client code, while SECRET_PASSWORD (accessible via import.meta.env.SECRET_PASSWORD) will be server-side only.
Caution
.env files are not loaded inside configuration files.
Default environment variables
Astro includes a few environment variables out-of-the-box:
import.meta.env.MODE: The mode your site is running in. This is development when running astro dev and production when running astro build.
import.meta.env.PROD: true if your site is running in production; false otherwise.
import.meta.env.DEV: true if your site is running in development; false otherwise. Always the opposite of import.meta.env.PROD.
import.meta.env.BASE_URL: The base url your site is being served from. This is determined by the base config option.
import.meta.env.SITE: This is set to the site option specified in your project‚Äôs astro.config.
import.meta.env.ASSETS_PREFIX: The prefix for Astro-generated asset links if the build.assetsPrefix config option is set. This can be used to create asset links not handled by Astro.
Use them like any other environment variable.
const isProd = import.meta.env.PROD;
const isDev = import.meta.env.DEV;
Setting environment variables
.env files
Environment variables can be loaded from .env files in your project directory.
You can also attach a mode (either production or development) to the filename, like .env.production or .env.development, which makes the environment variables only take effect in that mode.
Just create a .env file in the project directory and add some variables to it.
.env
# This will only be available when run on the server!
DB_PASSWORD=""foobar""
# This will be available everywhere!
PUBLIC_POKEAPI=""https://pokeapi.co/api/v2""
For more on .env files, see the Vite documentation.
Using the CLI
You can also add environment variables as you run your project:
npm
pnpm
Yarn
Terminal window
PUBLIC_POKEAPI=https://pokeapi.co/api/v2 npm run dev
Getting environment variables
Environment variables in Astro are accessed with import.meta.env, using the import.meta feature added in ES2020, instead of process.env.
For example, use import.meta.env.PUBLIC_POKEAPI to get the PUBLIC_POKEAPI environment variable.
// When import.meta.env.SSR === true
const data = await db(import.meta.env.DB_PASSWORD);
// When import.meta.env.SSR === false
const data = fetch(`${import.meta.env.PUBLIC_POKEAPI}/pokemon/squirtle`);
When using SSR, environment variables can be accessed at runtime based on the SSR adapter being used. With most adapters you can access environment variables with process.env, but some adapters work differently. For the Deno adapter, you will use Deno.env.get(). See how to access the Cloudflare runtime to handle environment variables when using the Cloudflare adapter. Astro will first check the server environment for variables, and if they don‚Äôt exist, Astro will look for them in .env files.
IntelliSense for TypeScript
By default, Astro provides type definition for import.meta.env in astro/client.d.ts.
While you can define more custom env variables in .env.[mode] files, you may want to get TypeScript IntelliSense for user-defined env variables which are prefixed with PUBLIC_.
To achieve this, you can create an env.d.ts in src/ and configure ImportMetaEnv like this:
src/env.d.ts
interface ImportMetaEnv {
  readonly DB_PASSWORD: string;
  readonly PUBLIC_POKEAPI: string;
  // more env variables...
}
interface ImportMeta {
  readonly env: ImportMetaEnv;
}
Edit page
Translate this page
Previous
Authentication
Next
UI Frameworks
Contribute
Give us feedback
Community

On this page
Overview
Default environment variables
Setting environment variables
.env files
Using the CLI
Getting environment variables
IntelliSense for TypeScript
Want to build your own Docs?
Grab this template to get started.‚Üí
Using environment variables
Looking for astro:env?
Find out more about the experimental astro:env API for type-safe environment variables!
Astro uses Vite‚Äôs built-in support for environment variables, which are statically replaced at build time, and lets you use any of its methods to work with them.
Note that while all environment variables are available in server-side code, only environment variables prefixed with PUBLIC_ are available in client-side code for security purposes.
.env
SECRET_PASSWORD=password123
PUBLIC_ANYBODY=there
In this example, PUBLIC_ANYBODY (accessible via import.meta.env.PUBLIC_ANYBODY) will be available in server or client code, while SECRET_PASSWORD (accessible via import.meta.env.SECRET_PASSWORD) will be server-side only.
Caution
.env files are not loaded inside configuration files.
Default environment variables
Astro includes a few environment variables out-of-the-box:
import.meta.env.MODE: The mode your site is running in. This is development when running astro dev and production when running astro build.
import.meta.env.PROD: true if your site is running in production; false otherwise.
import.meta.env.DEV: true if your site is running in development; false otherwise. Always the opposite of import.meta.env.PROD.
import.meta.env.BASE_URL: The base url your site is being served from. This is determined by the base config option.
import.meta.env.SITE: This is set to the site option specified in your project‚Äôs astro.config.
import.meta.env.ASSETS_PREFIX: The prefix for Astro-generated asset links if the build.assetsPrefix config option is set. This can be used to create asset links not handled by Astro.
Use them like any other environment variable.
const isProd = import.meta.env.PROD;
const isDev = import.meta.env.DEV;
Setting environment variables
.env files
Environment variables can be loaded from .env files in your project directory.
You can also attach a mode (either production or development) to the filename, like .env.production or .env.development, which makes the environment variables only take effect in that mode.
Just create a .env file in the project directory and add some variables to it.
.env
# This will only be available when run on the server!
DB_PASSWORD=""foobar""
# This will be available everywhere!
PUBLIC_POKEAPI=""https://pokeapi.co/api/v2""
For more on .env files, see the Vite documentation.
Using the CLI
You can also add environment variables as you run your project:
npm
pnpm
Yarn
Terminal window
PUBLIC_POKEAPI=https://pokeapi.co/api/v2 pnpm run dev
Getting environment variables
Environment variables in Astro are accessed with import.meta.env, using the import.meta feature added in ES2020, instead of process.env.
For example, use import.meta.env.PUBLIC_POKEAPI to get the PUBLIC_POKEAPI environment variable.
// When import.meta.env.SSR === true
const data = await db(import.meta.env.DB_PASSWORD);
// When import.meta.env.SSR === false
const data = fetch(`${import.meta.env.PUBLIC_POKEAPI}/pokemon/squirtle`);
When using SSR, environment variables can be accessed at runtime based on the SSR adapter being used. With most adapters you can access environment variables with process.env, but some adapters work differently. For the Deno adapter, you will use Deno.env.get(). See how to access the Cloudflare runtime to handle environment variables when using the Cloudflare adapter. Astro will first check the server environment for variables, and if they don‚Äôt exist, Astro will look for them in .env files.
IntelliSense for TypeScript
By default, Astro provides type definition for import.meta.env in astro/client.d.ts.
While you can define more custom env variables in .env.[mode] files, you may want to get TypeScript IntelliSense for user-defined env variables which are prefixed with PUBLIC_.
To achieve this, you can create an env.d.ts in src/ and configure ImportMetaEnv like this:
src/env.d.ts
interface ImportMetaEnv {
  readonly DB_PASSWORD: string;
  readonly PUBLIC_POKEAPI: string;
  // more env variables...
}
interface ImportMeta {
  readonly env: ImportMetaEnv;
}
Edit page
Translate this page
Previous
Authentication
Next
UI Frameworks
Contribute
Give us feedback
Community""""""",2808,13233,astro
https://docs.astro.build/en/guides/framework-components/,"""""""On this page
Overview
Official UI Framework Integrations
Installing Integrations
Using Framework Components
Hydrating Interactive Components
Available Hydration Directives
Mixing Frameworks
Passing Props to Framework Components
Passing Children to Framework Components
Nesting Framework Components
Can I use Astro Components inside my Framework Components?
Can I Hydrate Astro Components?
Want to build your own Docs?
Grab this template to get started.‚Üí
Framework Components
Build your Astro website without sacrificing your favorite component framework. Create Astro islands with the UI frameworks of your choice.
Official UI Framework Integrations
Astro supports a variety of popular frameworks including React, Preact, Svelte, Vue, SolidJS, AlpineJS and Lit with official integrations.
Find even more community-maintained framework integrations (e.g. Angular, Qwik, Elm) in our integrations directory.
UI Frameworks
@astrojs/alpinejs
@astrojs/lit
@astrojs/preact
@astrojs/react
@astrojs/solid‚Å†-‚Å†js
@astrojs/svelte
@astrojs/vue
Installing Integrations
One or several of these Astro integrations can be installed and configured in your project.
See the Integrations Guide for more details on installing and configuring Astro integrations.
Tip
Want to see an example for the framework of your choice? Visit astro.new and select one of the framework templates.
Using Framework Components
Use your JavaScript framework components in your Astro pages, layouts and components just like Astro components! All your components can live together in /src/components, or can be organized in any way you like.
To use a framework component, import it from its relative path in your Astro component script. Then, use the component alongside other components, HTML elements and JSX-like expressions in the component template.
src/pages/static-components.astro
---
import MyReactComponent from '../components/MyReactComponent.jsx';
---
<html>
  <body>
    <h1>Use React components directly in Astro!</h1>
    <MyReactComponent />
  </body>
</html>
By default, your framework components will only render on the server, as static HTML. This is useful for templating components that are not interactive and avoids sending any unnecessary JavaScript to the client.
Hydrating Interactive Components
A framework component can be made interactive (hydrated) using a client:* directive. These are component attributes that determine when your component‚Äôs JavaScript should be sent to the browser.
With all client directives except client:only, your component will first render on the server to generate static HTML. Component JavaScript will be sent to the browser according to the directive you chose. The component will then hydrate and become interactive.
src/pages/interactive-components.astro
---
// Example: hydrating framework components in the browser.
import InteractiveButton from '../components/InteractiveButton.jsx';
import InteractiveCounter from '../components/InteractiveCounter.jsx';
import InteractiveModal from '../components/InteractiveModal.svelte';
---
<!-- This component's JS will begin importing when the page loads -->
<InteractiveButton client:load />
<!-- This component's JS will not be sent to the client until
the user scrolls down and the component is visible on the page -->
<InteractiveCounter client:visible />
<!-- This component won't render on the server, but will render on the client when the page loads -->
<InteractiveModal client:only=""svelte"" />
The JavaScript framework (React, Svelte, etc.) needed to render the component will be sent to the browser along with the component‚Äôs own JavaScript. If two or more components on a page use the same framework, the framework will only be sent once.
Accessibility
Most framework-specific accessibility patterns should work the same when these components are used in Astro. Be sure to choose a client directive that will ensure any accessibility-related JavaScript is properly loaded and executed at the appropriate time!
Available Hydration Directives
There are several hydration directives available for UI framework components: client:load, client:idle, client:visible, client:media={QUERY} and client:only={FRAMEWORK}.
See our directives reference page for a full description of these hydration directives, and their usage.
Mixing Frameworks
You can import and render components from multiple frameworks in the same Astro component.
src/pages/mixing-frameworks.astro
---
// Example: Mixing multiple framework components on the same page.
import MyReactComponent from '../components/MyReactComponent.jsx';
import MySvelteComponent from '../components/MySvelteComponent.svelte';
import MyVueComponent from '../components/MyVueComponent.vue';
---
<div>
  <MySvelteComponent />
  <MyReactComponent />
  <MyVueComponent />
</div>
Caution
Only Astro components (.astro) can contain components from multiple frameworks.
Passing Props to Framework Components
You can pass props from Astro components to framework components:
src/pages/frameworks-props.astro
---
import TodoList from '../components/TodoList.jsx';
import Counter from '../components/Counter.svelte';
---
<div>
  <TodoList initialTodos={[""learn Astro"", ""review PRs""]} />
  <Counter startingCount={1} />
</div>
Passing functions as props
You can pass a function as a prop to a framework component, but it only works during server rendering. If you try to use the function in a hydrated component (for example, as an event handler), an error will occur.
This is because functions can‚Äôt be serialized (transferred from the server to the client) by Astro.
Passing Children to Framework Components
Inside of an Astro component, you can pass children to framework components. Each framework has its own patterns for how to reference these children: React, Preact, and Solid all use a special prop named children, while Svelte and Vue use the <slot /> element.
src/pages/component-children.astro
---
import MyReactSidebar from '../components/MyReactSidebar.jsx';
---
<MyReactSidebar>
  <p>Here is a sidebar with some text and a button.</p>
</MyReactSidebar>
Additionally, you can use Named Slots to group specific children together.
For React, Preact, and Solid, these slots will be converted to a top-level prop. Slot names using kebab-case will be converted to camelCase.
src/pages/named-slots.astro
---
import MySidebar from '../components/MySidebar.jsx';
---
<MySidebar>
  <h2 slot=""title"">Menu</h2>
  <p>Here is a sidebar with some text and a button.</p>
  <ul slot=""social-links"">
    <li><a href=""https://twitter.com/astrodotbuild"">Twitter</a></li>
    <li><a href=""https://github.com/withastro"">GitHub</a></li>
  </ul>
</MySidebar>
src/components/MySidebar.jsx
export default function MySidebar(props) {
  return (
    <aside>
      <header>{props.title}</header>
      <main>{props.children}</main>
      <footer>{props.socialLinks}</footer>
    </aside>
  )
}
For Svelte and Vue these slots can be referenced using a <slot> element with the name attribute. Slot names using kebab-case will be preserved.
src/components/MySidebar.svelte
<aside>
  <header><slot name=""title"" /></header>
  <main><slot /></main>
  <footer><slot name=""social-links"" /></footer>
</aside>
Nesting Framework Components
Inside of an Astro file, framework component children can also be hydrated components. This means that you can recursively nest components from any of these frameworks.
src/pages/nested-components.astro
---
import MyReactSidebar from '../components/MyReactSidebar.jsx';
import MyReactButton from '../components/MyReactButton.jsx';
import MySvelteButton from '../components/MySvelteButton.svelte';
---
<MyReactSidebar>
  <p>Here is a sidebar with some text and a button.</p>
  <div slot=""actions"">
    <MyReactButton client:idle />
    <MySvelteButton client:idle />
  </div>
</MyReactSidebar>
Caution
Remember: framework component files themselves (e.g. .jsx, .svelte) cannot mix multiple frameworks.
This allows you to build entire ‚Äúapps‚Äù in your preferred JavaScript framework and render them, via a parent component, to an Astro page.
Note
Astro components are always rendered to static HTML, even when they include framework components that are hydrated. This means that you can only pass props that don‚Äôt do any HTML rendering. Passing React‚Äôs ‚Äúrender props‚Äù to framework components from an Astro component will not work, because Astro components can‚Äôt provide the client runtime behavior that this pattern requires. Instead, use named slots.
Can I use Astro Components inside my Framework Components?
Any UI framework component becomes an ‚Äúisland‚Äù of that framework. These components must be written entirely as valid code for that framework, using only its own imports and packages. You cannot import .astro components in a UI framework component (e.g. .jsx or .svelte).
You can, however, use the Astro <slot /> pattern to pass static content generated by Astro components as children to your framework components inside an .astro component.
src/pages/astro-children.astro
---
import MyReactComponent from  '../components/MyReactComponent.jsx';
import MyAstroComponent from '../components/MyAstroComponent.astro';
---
<MyReactComponent>
  <MyAstroComponent slot=""name"" />
</MyReactComponent>
Can I Hydrate Astro Components?
If you try to hydrate an Astro component with a client: modifier, you will get an error.
Astro components are HTML-only templating components with no client-side runtime. But, you can use a <script> tag in your Astro component template to send JavaScript to the browser that executes in the global scope.
Learn more about client-side <script> tags in Astro components
Edit page
Translate this page
Previous
Environment Variables
Next
Scripts & Event Handling
Contribute
Give us feedback
Community""""""",2080,9748,astro
https://docs.astro.build/en/guides/client-side-scripts/,"""""""On this page
Overview
Client-Side Scripts
Using <script> in Astro
Script processing
Opting out of processing
Include JavaScript files on your page
Common script patterns
Handle onclick and other events
Web components with custom elements
Pass frontmatter variables to scripts
Combining scripts and UI Frameworks
Want to build your own Docs?
Grab this template to get started.‚Üí
Scripts and Event Handling
You can add interactivity to your Astro components without using a UI framework like React, Svelte, Vue, etc. using standard HTML <script> tags. This allows you to send JavaScript to run in the browser and add functionality to your Astro components.
Client-Side Scripts
Scripts can be used to add event listeners, send analytics data, play animations, and everything else JavaScript can do on the web.
src/components/ConfettiButton.astro
<button data-confetti-button>Celebrate!</button>
<script>
  // Import npm modules.
  import confetti from 'canvas-confetti';
  // Find our component DOM on the page.
  const buttons = document.querySelectorAll('[data-confetti-button]');
  // Add event listeners to fire confetti when a button is clicked.
  buttons.forEach((button) => {
    button.addEventListener('click', () => confetti());
  });
</script>
By default, Astro processes and bundles <script> tags, adding support for importing npm modules, writing TypeScript, and more.
Using <script> in Astro
In .astro files, you can add client-side JavaScript by adding one (or more) <script> tags.
In this example, adding the <Hello /> component to a page will log a message to the browser console.
src/components/Hello.astro
<h1>Welcome, world!</h1>
<script>
  console.log('Welcome, browser console!');
</script>
Script processing
By default, <script> tags are processed by Astro.
Any imports will be bundled, allowing you to import local files or Node modules.
The processed script will be injected into your page‚Äôs <head> with type=""module"".
TypeScript is fully supported, including importing TypeScript files.
If your component is used several times on a page, the script will only be included once.
src/components/Example.astro
<script>
  // Processed! Bundled! TypeScript-supported!
  // Importing local scripts and Node modules works.
</script>
The type=""module"" attribute makes the browser treat the script as a JavaScript module. This has several performance benefits:
Rendering is not blocked. The browser continues to process the rest of the HTML while the module script and its dependencies load.
The browser waits for HTML to be processed before executing module scripts. You do not need to listen for the ‚Äúload‚Äù event.
async and defer attributes are unnecessary. Module scripts are always deferred.
Note
The async attribute is valuable for normal scripts because it prevents them from blocking rendering. However, module scripts already have this behavior. Adding async to a module script will cause it to execute before the page has fully loaded. This is probably not what you want.
Opting out of processing
To prevent Astro from processing a script, add the is:inline directive.
src/components/InlineScript.astro
<script is:inline>
  // Will be rendered into the HTML exactly as written!
  // Local imports are not resolved and will not work.
  // If in a component, repeats each time the component is used.
</script>
Note
Astro will not process your script tags in some situations. In particular, adding type=""module"" or any attribute other than src to a <script> tag will cause Astro to treat the tag as if it had an is:inline directive. The same will be true when the script is written in a JSX expression.
See our directives reference page for more information about the directives available on <script> tags.
Include JavaScript files on your page
You may want to write your scripts as separate .js/.ts files or need to reference an external script on another server. You can do this by referencing these in a <script> tag‚Äôs src attribute.
Import local scripts
When to use this: when your script lives inside of src/.
Astro will build, optimize, and add these scripts to the page for you, following its script processing rules.
src/components/LocalScripts.astro
<!-- relative path to script at `src/scripts/local.js` -->
<script src=""../scripts/local.js""></script>
<!-- also works for local TypeScript files -->
<script src=""./script-with-types.ts""></script>
Load external scripts
When to use this: when your JavaScript file lives inside of public/ or on a CDN.
To load scripts outside of your project‚Äôs src/ folder, include the is:inline directive. This approach skips the JavaScript processing, bundling, and optimizations that are provided by Astro when you import scripts as described above.
src/components/ExternalScripts.astro
<!-- absolute path to a script at `public/my-script.js` -->
<script is:inline src=""/my-script.js""></script>
<!-- full URL to a script on a remote server -->
<script is:inline src=""https://my-analytics.com/script.js""></script>
Common script patterns
Handle onclick and other events
Some UI frameworks use custom syntax for event handling like onClick={...} (React/Preact) or @click=""..."" (Vue). Astro follows standard HTML more closely and does not use custom syntax for events.
Instead, you can use addEventListener in a <script> tag to handle user interactions.
src/components/AlertButton.astro
<button class=""alert"">Click me!</button>
<script>
  // Find all buttons with the `alert` class on the page.
  const buttons = document.querySelectorAll('button.alert');
  // Handle clicks on each button.
  buttons.forEach((button) => {
    button.addEventListener('click', () => {
      alert('Button was clicked!');
    });
  });
</script>
Note
If you have multiple <AlertButton /> components on a page, Astro will not run the script multiple times. Scripts are bundled and only included once per page. Using querySelectorAll ensures that this script attaches the event listener to every button with the alert class found on the page.
Web components with custom elements
You can create your own HTML elements with custom behavior using the Web Components standard. Defining a custom element in a .astro component allows you to build interactive components without needing a UI framework library.
In this example, we define a new <astro-heart> HTML element that tracks how many times you click the heart button and updates the <span> with the latest count.
src/components/AstroHeart.astro
<!-- Wrap the component elements in our custom element ‚Äúastro-heart‚Äù. -->
<astro-heart>
  <button aria-label=""Heart"">üíú</button> √ó <span>0</span>
</astro-heart>
<script>
  // Define the behaviour for our new type of HTML element.
  class AstroHeart extends HTMLElement {
    connectedCallback() {
      let count = 0;
      const heartButton = this.querySelector('button');
      const countSpan = this.querySelector('span');
      // Each time the button is clicked, update the count.
      heartButton.addEventListener('click', () => {
        count++;
        countSpan.textContent = count.toString();
      });
    }
  }
  // Tell the browser to use our AstroHeart class for <astro-heart> elements.
  customElements.define('astro-heart', AstroHeart);
</script>
There are two advantages to using a custom element here:
Instead of searching the whole page using document.querySelector(), you can use this.querySelector(), which only searches within the current custom element instance. This makes it easier to work with only the children of one component instance at a time.
Although a <script> only runs once, the browser will run our custom element‚Äôs constructor() method each time it finds <astro-heart> on the page. This means you can safely write code for one component at a time, even if you intend to use this component multiple times on a page.
You can learn more about custom elements in web.dev‚Äôs Reusable Web Components guide and MDN‚Äôs introduction to custom elements.
Pass frontmatter variables to scripts
In Astro components, the code in the frontmatter between the --- fences runs on the server and is not available in the browser. To send variables from the server to the client, we need a way to store our variables and then read them when JavaScript runs in the browser.
One way to do this is to use data-* attributes to store the value of variables in your HTML output. Scripts, including custom elements, can then read these attributes using an element‚Äôs dataset property once your HTML loads in the browser.
In this example component, a message prop is stored in a data-message attribute, so the custom element can read this.dataset.message and get the value of the prop in the browser.
src/components/AstroGreet.astro
---
const { message = 'Welcome, world!' } = Astro.props;
---
<!-- Store the message prop as a data attribute. -->
<astro-greet data-message={message}>
  <button>Say hi!</button>
</astro-greet>
<script>
  class AstroGreet extends HTMLElement {
    connectedCallback() {
      // Read the message from the data attribute.
      const message = this.dataset.message;
      const button = this.querySelector('button');
      button.addEventListener('click', () => {
        alert(message);
      });
    }
  }
  customElements.define('astro-greet', AstroGreet);
</script>
Now we can use our component multiple times and be greeted by a different message for each one.
src/pages/example.astro
---
import AstroGreet from '../components/AstroGreet.astro';
---
<!-- Use the default message: ‚ÄúWelcome, world!‚Äù -->
<AstroGreet />
<!-- Use custom messages passed as a props. -->
<AstroGreet message=""Lovely day to build components!"" />
<AstroGreet message=""Glad you made it! üëã"" />
Did you know?
This is actually what Astro does behind the scenes when you pass props to a component written using a UI framework like React! For components with a client:* directive, Astro creates an <astro-island> custom element with a props attribute that stores your server-side props in the HTML output.
Combining scripts and UI Frameworks
Elements rendered by a UI framework may not be available yet when a <script> tag executes. If your script also needs to handle UI framework components, using a custom element is recommended.
Edit page
Translate this page
Previous
UI Frameworks
Next
Upgrade Astro
Contribute
Give us feedback
Community""""""",2165,10287,astro
https://docs.astro.build/en/upgrade-astro/,"""""""On this page
Overview
What has changed?
Upgrade to the latest version
Manual Upgrading
Install a specific version number
Documentation updates
Upgrade Guides
Older docs (unmaintained)
Semantic versioning
Patch changes
Minor changes
Major changes
Exceptions
Node.js support and upgrade policies
Extended maintenance
Want to build your own Docs?
Grab this template to get started.‚Üí
Want to upgrade to Astro 5 beta? Read our v5 upgrade guide!
Upgrade Astro
This guide covers how to update your version of Astro and related dependencies, how to learn what has changed from one version to the next, and how to understand Astro‚Äôs versioning system and corresponding documentation updates.
What has changed?
The latest release of Astro is v4.16.14.
You can find an exhaustive list of all changes in Astro‚Äôs changelog, and important instructions for upgrading to each new major version in our upgrade guides.
Upgrade to the latest version
Update your project‚Äôs version of Astro and all official integrations to the latest versions with one command using your package manager:
npm
pnpm
Yarn
Terminal window
# Upgrade Astro and official integrations together
yarn dlx @astrojs/upgrade
Manual Upgrading
To update Astro and integrations to their current versions manually, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
# Example: upgrade Astro with React and Tailwind integrations
yarn add astro@latest @astrojs/react@latest @astrojs/tailwind@latest
Install a specific version number
To install a specific version of Astro or integrations, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
yarn add astro@4.5.3 @astrojs/react@3.0.10
Documentation updates
This documentation is updated for each minor release and major version release. When new features are added, or existing usage changes, the docs will update to reflect the current behavior of Astro. If your project is not updated, then you may notice some behaviors do not match the up-to-date documentation.
New features are added to docs with the specific version number in which they were added. This means that if you have not updated to the latest release of Astro, some documented features may be unavailable. Always check the Added in: version number and make sure your project is updated before attempting to use new features!
If you have not upgraded to the latest major version of Astro, you may encounter significant differences between the Astro documentation and your project‚Äôs behavior. We strongly recommend upgrading to the current major version of Astro as soon as you are able. Both the code and the documentation for earlier versions is unsupported.
Upgrade Guides
After every major version release, you will find an upgrade guide with information about important changes and instructions for upgrading your project code.
The main Astro documentation pages are always accurate for the latest released version of Astro. They do not describe or compare to how things worked in previous versions, nor do they highlight updated or changed behavior.
See the upgrade guides below for an explanation of changes, comparing the new version to the old. The upgrade guides include everything that could require you to change your own code: breaking changes, deprecations, feature removals and replacements as well as updated usage guidance. Each change to Astro includes a ‚ÄúWhat should I do?‚Äù section to help you successfully update your project code.
Tip
Want to upgrade to the v5 beta? Check out the v5 upgrade guide in the beta docs.
Upgrade to v4
Upgrade to v3
Upgrade to v2
Upgrade to v1
Older docs (unmaintained)
Documentation for older versions of Astro is not maintained, but is available as a static snapshot. Use these versions of docs if you are unable to upgrade your project, but still wish to consult guides and reference:
unmaintained v3.6.3 snapshot
unmaintained v2.10.15 snapshot
Semantic versioning
Astro attempts to adhere as much as possible to semantic versioning, which is a set of rules developers use to determine how to assign a version number to a release. Semantic version follows a predictable pattern to inform users of the kind of changes they can expect from one version to the next.
Semantic versioning enforces a pattern of X.Y.Z for software version numbers. These values represent major (X), minor (Y), and patch (Z) updates.
Patch changes
Patch changes are the least disruptive changes. They do not change the way you use Astro, and no change to your own code is required when you update.
When Astro issues a ‚Äúpatch‚Äù version, the last number increases. (e.g. astro@4.3.14 -> astro@4.3.15)
Patches may be released for reasons such as:
Internal changes that do not change Astro‚Äôs functionality:
refactors
performance improvements
increase or change in test coverage
aligning with stated documentation and expected behavior
Improvements to logging and error messages.
Re-releases after a failed release.
Patch changes also include most bug fixes, even in cases where users were taking advantage of existing unintended or undesirable behavior.
Minor changes
Minor releases primarily introduce new features and improvements that you may wish to try, but require no changes to your code. Some existing features may also be deprecated (marked for deletion in a future version while continuing to function) in a minor release, giving you the opportunity to prepare for their eventual removal.
Minor releases include changes such as:
Deprecations of existing features/options with a warning that they will be removed in an upcoming major release.
Introduction of new functionalities.
Introduction of new options in the integration hooks.
Introduction of new functionalities in astro/app, notably used for creating new adapters.
A minor release may also include smaller, patch changes at the same time.
Major changes
Major releases will include breaking changes to at least some existing code. These breaking changes are always documented in an ‚ÄúUpgrade to vX‚Äù guide in Astro.
Major releases allow Astro to make significant changes not only to internal logic, but also to intended behavior and usage. Documentation will be updated to reflect the latest version only, and static, unmaintained snapshots of older docs are available as a historical record for older projects that are not yet upgraded.
Major releases include changes such as:
Removal of previously deprecated functionalities.
Changes of existing functionalities.
Changes of existing options in the integration hooks.
Changes of existing options and functionalities in astro/app, notably used for creating new adapters.
A major release may also include some non-breaking changes and improvements that would normally be released separately in a minor or patch release.
Exceptions
Experimental features. Releasing versions of Astro without adhering to semantic versioning allows Astro developers the greatest flexibility to explore, and even radically change course, during the development of experimental features. Therefore, the behavior of these features can break in minor and patch changes.
These features are usually accompanied by an ongoing, public Request for Consideration (RFC) stage 3. It is expected that beta users will follow for updates, and leave early feedback on the discussion to help guide development of these features.
Once these features are out of their experimental period, they will follow the normal semantic versioning contract.
Improvements to the documentation (e.g. reference and error messages). They are built from source for the docs repository. This allows Astro to quickly update docs fixes and improvements in the cases where documentation source content is stored in the main astro repository.
Node.js support and upgrade policies
Support
Astro supports the latest Maintenance LTS version of Node.js.
Astro supports the current Active LTS version of Node.js
Astro can support odd versions of Node.js.
Upgrade
The following rules define when Astro may deprecate, drop, or add support for versions of Node.js:
Odd versions of Node.js can be deprecated and/or dropped when the next even version of Node.js published. This change can occur in a minor release of Astro, after a reasonable period of extended support as decided by the Astro Core team.
Upgrading the minimum Maintenance LTS (within the same major range, e.g. from v18.14.* to v18.20.*) version of Node.js can occur in a minor release of Astro.
Security exception: If a security flaw in Node.js that affects Astro is disclosed and fixed, the Core team can bump the minimum version of the Maintenance LTS in a patch release.
Upgrading minor or major versions of Node.js (not Maintenance LTS) occurs only in major versions of Astro.
Security exception: If a security flaw in Node.js that affects Astro is disclosed and fixed, the Core team can bump the minimum version in a minor release.
Extended maintenance
The Core team will provide extended maintenance for security fixes only for one previous major version. This means that if the current major is v4.*, the Core team will back port security fixes and issue a new v3.* release.
Edit page
Translate this page
Previous
Scripts & Event Handling
Next
Testing
Contribute
Give us feedback
Community

On this page
Overview
What has changed?
Upgrade to the latest version
Manual Upgrading
Install a specific version number
Documentation updates
Upgrade Guides
Older docs (unmaintained)
Semantic versioning
Patch changes
Minor changes
Major changes
Exceptions
Node.js support and upgrade policies
Extended maintenance
Want to build your own Docs?
Grab this template to get started.‚Üí
Want to upgrade to Astro 5 beta? Read our v5 upgrade guide!
Upgrade Astro
This guide covers how to update your version of Astro and related dependencies, how to learn what has changed from one version to the next, and how to understand Astro‚Äôs versioning system and corresponding documentation updates.
What has changed?
The latest release of Astro is v4.16.14.
You can find an exhaustive list of all changes in Astro‚Äôs changelog, and important instructions for upgrading to each new major version in our upgrade guides.
Upgrade to the latest version
Update your project‚Äôs version of Astro and all official integrations to the latest versions with one command using your package manager:
npm
pnpm
Yarn
Terminal window
# Upgrade Astro and official integrations together
npx @astrojs/upgrade
Manual Upgrading
To update Astro and integrations to their current versions manually, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
# Example: upgrade Astro with React and Tailwind integrations
npm install astro@latest @astrojs/react@latest @astrojs/tailwind@latest
Install a specific version number
To install a specific version of Astro or integrations, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
npm install astro@4.5.3 @astrojs/react@3.0.10
Documentation updates
This documentation is updated for each minor release and major version release. When new features are added, or existing usage changes, the docs will update to reflect the current behavior of Astro. If your project is not updated, then you may notice some behaviors do not match the up-to-date documentation.
New features are added to docs with the specific version number in which they were added. This means that if you have not updated to the latest release of Astro, some documented features may be unavailable. Always check the Added in: version number and make sure your project is updated before attempting to use new features!
If you have not upgraded to the latest major version of Astro, you may encounter significant differences between the Astro documentation and your project‚Äôs behavior. We strongly recommend upgrading to the current major version of Astro as soon as you are able. Both the code and the documentation for earlier versions is unsupported.
Upgrade Guides
After every major version release, you will find an upgrade guide with information about important changes and instructions for upgrading your project code.
The main Astro documentation pages are always accurate for the latest released version of Astro. They do not describe or compare to how things worked in previous versions, nor do they highlight updated or changed behavior.
See the upgrade guides below for an explanation of changes, comparing the new version to the old. The upgrade guides include everything that could require you to change your own code: breaking changes, deprecations, feature removals and replacements as well as updated usage guidance. Each change to Astro includes a ‚ÄúWhat should I do?‚Äù section to help you successfully update your project code.
Tip
Want to upgrade to the v5 beta? Check out the v5 upgrade guide in the beta docs.
Upgrade to v4
Upgrade to v3
Upgrade to v2
Upgrade to v1
Older docs (unmaintained)
Documentation for older versions of Astro is not maintained, but is available as a static snapshot. Use these versions of docs if you are unable to upgrade your project, but still wish to consult guides and reference:
unmaintained v3.6.3 snapshot
unmaintained v2.10.15 snapshot
Semantic versioning
Astro attempts to adhere as much as possible to semantic versioning, which is a set of rules developers use to determine how to assign a version number to a release. Semantic version follows a predictable pattern to inform users of the kind of changes they can expect from one version to the next.
Semantic versioning enforces a pattern of X.Y.Z for software version numbers. These values represent major (X), minor (Y), and patch (Z) updates.
Patch changes
Patch changes are the least disruptive changes. They do not change the way you use Astro, and no change to your own code is required when you update.
When Astro issues a ‚Äúpatch‚Äù version, the last number increases. (e.g. astro@4.3.14 -> astro@4.3.15)
Patches may be released for reasons such as:
Internal changes that do not change Astro‚Äôs functionality:
refactors
performance improvements
increase or change in test coverage
aligning with stated documentation and expected behavior
Improvements to logging and error messages.
Re-releases after a failed release.
Patch changes also include most bug fixes, even in cases where users were taking advantage of existing unintended or undesirable behavior.
Minor changes
Minor releases primarily introduce new features and improvements that you may wish to try, but require no changes to your code. Some existing features may also be deprecated (marked for deletion in a future version while continuing to function) in a minor release, giving you the opportunity to prepare for their eventual removal.
Minor releases include changes such as:
Deprecations of existing features/options with a warning that they will be removed in an upcoming major release.
Introduction of new functionalities.
Introduction of new options in the integration hooks.
Introduction of new functionalities in astro/app, notably used for creating new adapters.
A minor release may also include smaller, patch changes at the same time.
Major changes
Major releases will include breaking changes to at least some existing code. These breaking changes are always documented in an ‚ÄúUpgrade to vX‚Äù guide in Astro.
Major releases allow Astro to make significant changes not only to internal logic, but also to intended behavior and usage. Documentation will be updated to reflect the latest version only, and static, unmaintained snapshots of older docs are available as a historical record for older projects that are not yet upgraded.
Major releases include changes such as:
Removal of previously deprecated functionalities.
Changes of existing functionalities.
Changes of existing options in the integration hooks.
Changes of existing options and functionalities in astro/app, notably used for creating new adapters.
A major release may also include some non-breaking changes and improvements that would normally be released separately in a minor or patch release.
Exceptions
Experimental features. Releasing versions of Astro without adhering to semantic versioning allows Astro developers the greatest flexibility to explore, and even radically change course, during the development of experimental features. Therefore, the behavior of these features can break in minor and patch changes.
These features are usually accompanied by an ongoing, public Request for Consideration (RFC) stage 3. It is expected that beta users will follow for updates, and leave early feedback on the discussion to help guide development of these features.
Once these features are out of their experimental period, they will follow the normal semantic versioning contract.
Improvements to the documentation (e.g. reference and error messages). They are built from source for the docs repository. This allows Astro to quickly update docs fixes and improvements in the cases where documentation source content is stored in the main astro repository.
Node.js support and upgrade policies
Support
Astro supports the latest Maintenance LTS version of Node.js.
Astro supports the current Active LTS version of Node.js
Astro can support odd versions of Node.js.
Upgrade
The following rules define when Astro may deprecate, drop, or add support for versions of Node.js:
Odd versions of Node.js can be deprecated and/or dropped when the next even version of Node.js published. This change can occur in a minor release of Astro, after a reasonable period of extended support as decided by the Astro Core team.
Upgrading the minimum Maintenance LTS (within the same major range, e.g. from v18.14.* to v18.20.*) version of Node.js can occur in a minor release of Astro.
Security exception: If a security flaw in Node.js that affects Astro is disclosed and fixed, the Core team can bump the minimum version of the Maintenance LTS in a patch release.
Upgrading minor or major versions of Node.js (not Maintenance LTS) occurs only in major versions of Astro.
Security exception: If a security flaw in Node.js that affects Astro is disclosed and fixed, the Core team can bump the minimum version in a minor release.
Extended maintenance
The Core team will provide extended maintenance for security fixes only for one previous major version. This means that if the current major is v4.*, the Core team will back port security fixes and issue a new v3.* release.
Edit page
Translate this page
Previous
Scripts & Event Handling
Next
Testing
Contribute
Give us feedback
Community

On this page
Overview
What has changed?
Upgrade to the latest version
Manual Upgrading
Install a specific version number
Documentation updates
Upgrade Guides
Older docs (unmaintained)
Semantic versioning
Patch changes
Minor changes
Major changes
Exceptions
Node.js support and upgrade policies
Extended maintenance
Want to build your own Docs?
Grab this template to get started.‚Üí
Want to upgrade to Astro 5 beta? Read our v5 upgrade guide!
Upgrade Astro
This guide covers how to update your version of Astro and related dependencies, how to learn what has changed from one version to the next, and how to understand Astro‚Äôs versioning system and corresponding documentation updates.
What has changed?
The latest release of Astro is v4.16.14.
You can find an exhaustive list of all changes in Astro‚Äôs changelog, and important instructions for upgrading to each new major version in our upgrade guides.
Upgrade to the latest version
Update your project‚Äôs version of Astro and all official integrations to the latest versions with one command using your package manager:
npm
pnpm
Yarn
Terminal window
# Upgrade Astro and official integrations together
pnpm dlx @astrojs/upgrade
Manual Upgrading
To update Astro and integrations to their current versions manually, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
# Example: upgrade Astro with React and Tailwind integrations
pnpm add astro@latest @astrojs/react@latest @astrojs/tailwind@latest
Install a specific version number
To install a specific version of Astro or integrations, use the appropriate command for your package manager.
npm
pnpm
Yarn
Terminal window
pnpm add astro@4.5.3 @astrojs/react@3.0.10
Documentation updates
This documentation is updated for each minor release and major version release. When new features are added, or existing usage changes, the docs will update to reflect the current behavior of Astro. If your project is not updated, then you may notice some behaviors do not match the up-to-date documentation.
New features are added to docs with the specific version number in which they were added. This means that if you have not updated to the latest release of Astro, some documented features may be unavailable. Always check the Added in: version number and make sure your project is updated before attempting to use new features!
If you have not upgraded to the latest major version of Astro, you may encounter significant differences between the Astro documentation and your project‚Äôs behavior. We strongly recommend upgrading to the current major version of Astro as soon as you are able. Both the code and the documentation for earlier versions is unsupported.
Upgrade Guides
After every major version release, you will find an upgrade guide with information about important changes and instructions for upgrading your project code.
The main Astro documentation pages are always accurate for the latest released version of Astro. They do not describe or compare to how things worked in previous versions, nor do they highlight updated or changed behavior.
See the upgrade guides below for an explanation of changes, comparing the new version to the old. The upgrade guides include everything that could require you to change your own code: breaking changes, deprecations, feature removals and replacements as well as updated usage guidance. Each change to Astro includes a ‚ÄúWhat should I do?‚Äù section to help you successfully update your project code.
Tip
Want to upgrade to the v5 beta? Check out the v5 upgrade guide in the beta docs.
Upgrade to v4
Upgrade to v3
Upgrade to v2
Upgrade to v1
Older docs (unmaintained)
Documentation for older versions of Astro is not maintained, but is available as a static snapshot. Use these versions of docs if you are unable to upgrade your project, but still wish to consult guides and reference:
unmaintained v3.6.3 snapshot
unmaintained v2.10.15 snapshot
Semantic versioning
Astro attempts to adhere as much as possible to semantic versioning, which is a set of rules developers use to determine how to assign a version number to a release. Semantic version follows a predictable pattern to inform users of the kind of changes they can expect from one version to the next.
Semantic versioning enforces a pattern of X.Y.Z for software version numbers. These values represent major (X), minor (Y), and patch (Z) updates.
Patch changes
Patch changes are the least disruptive changes. They do not change the way you use Astro, and no change to your own code is required when you update.
When Astro issues a ‚Äúpatch‚Äù version, the last number increases. (e.g. astro@4.3.14 -> astro@4.3.15)
Patches may be released for reasons such as:
Internal changes that do not change Astro‚Äôs functionality:
refactors
performance improvements
increase or change in test coverage
aligning with stated documentation and expected behavior
Improvements to logging and error messages.
Re-releases after a failed release.
Patch changes also include most bug fixes, even in cases where users were taking advantage of existing unintended or undesirable behavior.
Minor changes
Minor releases primarily introduce new features and improvements that you may wish to try, but require no changes to your code. Some existing features may also be deprecated (marked for deletion in a future version while continuing to function) in a minor release, giving you the opportunity to prepare for their eventual removal.
Minor releases include changes such as:
Deprecations of existing features/options with a warning that they will be removed in an upcoming major release.
Introduction of new functionalities.
Introduction of new options in the integration hooks.
Introduction of new functionalities in astro/app, notably used for creating new adapters.
A minor release may also include smaller, patch changes at the same time.
Major changes
Major releases will include breaking changes to at least some existing code. These breaking changes are always documented in an ‚ÄúUpgrade to vX‚Äù guide in Astro.
Major releases allow Astro to make significant changes not only to internal logic, but also to intended behavior and usage. Documentation will be updated to reflect the latest version only, and static, unmaintained snapshots of older docs are available as a historical record for older projects that are not yet upgraded.
Major releases include changes such as:
Removal of previously deprecated functionalities.
Changes of existing functionalities.
Changes of existing options in the integration hooks.
Changes of existing options and functionalities in astro/app, notably used for creating new adapters.
A major release may also include some non-breaking changes and improvements that would normally be released separately in a minor or patch release.
Exceptions
Experimental features. Releasing versions of Astro without adhering to semantic versioning allows Astro developers the greatest flexibility to explore, and even radically change course, during the development of experimental features. Therefore, the behavior of these features can break in minor and patch changes.
These features are usually accompanied by an ongoing, public Request for Consideration (RFC) stage 3. It is expected that beta users will follow for updates, and leave early feedback on the discussion to help guide development of these features.
Once these features are out of their experimental period, they will follow the normal semantic versioning contract.
Improvements to the documentation (e.g. reference and error messages). They are built from source for the docs repository. This allows Astro to quickly update docs fixes and improvements in the cases where documentation source content is stored in the main astro repository.
Node.js support and upgrade policies
Support
Astro supports the latest Maintenance LTS version of Node.js.
Astro supports the current Active LTS version of Node.js
Astro can support odd versions of Node.js.
Upgrade
The following rules define when Astro may deprecate, drop, or add support for versions of Node.js:
Odd versions of Node.js can be deprecated and/or dropped when the next even version of Node.js published. This change can occur in a minor release of Astro, after a reasonable period of extended support as decided by the Astro Core team.
Upgrading the minimum Maintenance LTS (within the same major range, e.g. from v18.14.* to v18.20.*) version of Node.js can occur in a minor release of Astro.
Security exception: If a security flaw in Node.js that affects Astro is disclosed and fixed, the Core team can bump the minimum version of the Maintenance LTS in a patch release.
Upgrading minor or major versions of Node.js (not Maintenance LTS) occurs only in major versions of Astro.
Security exception: If a security flaw in Node.js that affects Astro is disclosed and fixed, the Core team can bump the minimum version in a minor release.
Extended maintenance
The Core team will provide extended maintenance for security fixes only for one previous major version. This means that if the current major is v4.*, the Core team will back port security fixes and issue a new v3.* release.
Edit page
Translate this page
Previous
Scripts & Event Handling
Next
Testing
Contribute
Give us feedback
Community""""""",5515,27764,astro
https://docs.astro.build/en/guides/testing/,"""""""On this page
Overview
Unit and integration tests
Vitest
End-to-end tests
Playwright
Cypress
NightwatchJS
Want to build your own Docs?
Grab this template to get started.‚Üí
Testing
Testing helps you write and maintain working Astro code. Astro supports many popular tools for unit tests, component tests, and end-to-end tests including Jest, Mocha, Jasmine, Cypress and Playwright. You can even install framework-specific testing libraries such as React Testing Library to test your UI framework components.
Testing frameworks allow you to state assertions or expectations about how your code should behave in specific situations, then compare these to the actual behavior of your current code.
Unit and integration tests
Vitest
A Vite-native unit test framework with ESM, TypeScript and JSX support powered by esbuild.
Use Astro‚Äôs getViteConfig() helper in your vitest.config.ts configuration file to set up Vitest with your Astro project‚Äôs settings:
vitest.config.ts
/// <reference types=""vitest"" />
import { getViteConfig } from 'astro/config';
export default getViteConfig({
  test: {
    // Vitest configuration options
  },
});
By default, getViteConfig() will try to load an Astro config file in your project and apply it to the test environment. As of Astro 4.8, if you need to customize the Astro configuration applied in your tests, pass a second argument to getViteConfig():
export default getViteConfig(
  { test: { /* Vitest configuration options */ } },
  {
    site: 'https://example.com/',
    trailingSlash: 'always',
  },
);
See the Astro + Vitest starter template on GitHub.
Vitest and Container API
Added in: astro@4.9.0
You can natively test Astro components using the container API. First, setup vitest as explained above, then create a .test.js file to test your component:
example.test.js
import { experimental_AstroContainer as AstroContainer } from 'astro/container';
import { expect, test } from 'vitest';
import Card from '../src/components/Card.astro';
test('Card with slots', async () => {
  const container = await AstroContainer.create();
  const result = await container.renderToString(Card, {
    slots: {
      default: 'Card content',
    },
  });
  expect(result).toContain('This is a card');
  expect(result).toContain('Card content');
});
End-to-end tests
Playwright
Playwright is an end-to-end testing framework for modern web apps. Use the Playwright API in JavaScript or TypeScript to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.
Installation
You can get started and run your tests using the VS Code Extension.
Alternatively, you can install Playwright within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and add an optional GitHub Actions workflow.
npm
pnpm
Yarn
Terminal window
yarn create playwright
Create your first Playwright test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body></body>
</html>
Create a new folder and add the following test file in src/test. Copy and paste the following test into the file to verify that the page meta information is correct. Update the value of the page <title> to match the page you are testing.
src/test/index.spec.ts
import { test, expect } from '@playwright/test';
test('meta is correct', async ({ page }) => {
  await page.goto(""http://localhost:4321/"");
  await expect(page).toHaveTitle('Astro is awesome!');
});
Set a
baseUrl
You can set ""baseURL"": ""http://localhost:4321"" in the playwright.config.ts configuration file to use page.goto(""/"") instead of page.goto(""http://localhost:4321/"") for a more convenient URL.
Running your Playwright tests
You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.
To run our test from the previous example using the command line, use the test command. Optionally, include the file name to run just the single test:
Terminal window
npx playwright test index.spec.ts
To see the full HTML Test Report, open it using the following command:
Terminal window
npx playwright show-report
Tip
Run your tests against your production code to more closely resemble your live, deployed site.
Advanced: Launching a development web server during the tests
You can also have Playwright start your server when you run your testing script by using the webServer option in the Playwright configuration file.
Here is an example of the configuration and commands required when using npm:
Add a test script to your package.json file in the project root, such as ""test:e2e"": ""playwright test"".
In playwright.config.ts, add the webServer object and update the command value to npm run preview.
playwright.config.ts
import { defineConfig } from '@playwright/test';
export default defineConfig({
  webServer: {
    command: 'npm run preview',
    url: 'http://localhost:4321/',
    timeout: 120 * 1000,
    reuseExistingServer: !process.env.CI,
  },
  use: {
    baseURL: 'http://localhost:4321/',
  },
});
Run npm run build, then run npm run test:e2e to run the Playwright tests.
More information about Playwright can be found in the links below:
Getting started with Playwright
Use a development server
Cypress
Cypress is a front-end testing tool built for the modern web. Cypress enables you to write end-to-end tests for your Astro site.
Installation
You can install Cypress using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
yarn add cypress --dev
Configuration
In the root of your project, create a cypress.config.js file with the following content:
cypress.config.js
import { defineConfig } from 'cypress'
export default defineConfig({
  e2e: {
    supportFile: false
  }
})
Create your first Cypress test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body>
  <h1>Hello world from Astro</h1>
  </body>
</html>
Create an index.cy.js file in the cypress/e2e folder. Use the following test in the file to verify that the page title and header are correct.
cypress/e2e/index.cy.js
it('titles are correct', () => {
  const page = cy.visit('http://localhost:4321');
  page.get('title').should('have.text', 'Astro is awesome!')
  page.get('h1').should('have.text', 'Hello world from Astro');
});
Set a
baseUrl
You can set ""baseUrl"": ""http://localhost:4321"" in the cypress.config.js configuration file to use cy.visit(""/"") instead of cy.visit(""http://localhost:4321/"") for a more convenient URL.
Running your Cypress tests
Cypress can be run from the command line or from the Cypress App. The App provides a visual interface for running and debugging your tests.
First, start the dev server so Cypress can access your live site.
To run our test from the previous example using the command line, execute the following command:
Terminal window
npx cypress run
Alternatively, to run the test using the Cypress App, execute the following command:
Terminal window
npx cypress open
Once the Cypress App is launched, choose E2E Testing, then select the browser to be used to run tests.
Once the test run is finished, you should see green check marks in the output confirming that your test passed:
Output from npx cypress run
Running:  index.cy.js                                                                     (1 of 1)
‚úì titles are correct (107ms)
1 passing (1s)
Fail the test
To check that your test really does work, you can change the following line in the index.astro file:
src/pages/index.astro
 <body>
   <h1>Hello world from Astro</h1>
   <h1>Hello from Astro</h1>
 </body>
Then run the test again. You should see a red ‚Äúx‚Äù in the output confirming that your test failed.
Next steps
More information about Cypress can be found in the links below:
Introduction to Cypress
Testing Your App
NightwatchJS
Nightwatch.js is a test automation framework with a powerful set of tools to write, run, and debug your tests across the web with built-in support for all major browsers and their mobile equivalents, as well as native mobile applications.
Installation
You can install NightwatchJS within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and select whether or not to include component testing and testing on mobile browsers.
npm
pnpm
Yarn
Terminal window
yarn create nightwatch
Create your first Nightwatch test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body></body>
</html>
Create a new folder src/test/ and add the following test file:
src/test/index.js
describe('Astro testing with Nightwatch', function () {
    before(browser => browser.navigateTo('http://localhost:4321/'));
    it(""check that the title is correct"", function (browser) {
        browser.assert.titleEquals('Astro is awesome!')
    });
    after(browser => browser.end());
});
Set a
baseUrl
You can set ""baseURL"": ""http://localhost:4321"" in the nightwatch.conf.js configuration file to use browser.navigateTo(""/"") instead of browser.navigateTo(""http://localhost:4321/"") for a more convenient URL.
Running your NightwatchJS tests
You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.
You can run the tests with the NightwatchJS VSCode Extension or using the CLI steps below:
To run all tests, enter the following command in the terminal. Optionally, include the file name to run just the single test:
Terminal window
npx nightwatch test/index.js
Additionally, you can run the tests against a specific browser using the --environment or -e CLI argument. If you don‚Äôt have the relevant browser installed, Nightwatch will attempt to set it up for you using Selenium Manager:
Terminal window
npx nightwatch test/index.ts -e firefox
To see the full HTML Test Report, open it using the following command:
Terminal window
npx nightwatch test/index.ts --open
Tip
Run your tests against your production code to more closely resemble your live, deployed site.
More information about NightwatchJS can be found in the links below:
Intro to Nightwatch
Testing with Nightwatch
Edit page
Translate this page
Previous
Upgrade Astro
Next
Troubleshooting
Contribute
Give us feedback
Community

On this page
Overview
Unit and integration tests
Vitest
End-to-end tests
Playwright
Cypress
NightwatchJS
Want to build your own Docs?
Grab this template to get started.‚Üí
Testing
Testing helps you write and maintain working Astro code. Astro supports many popular tools for unit tests, component tests, and end-to-end tests including Jest, Mocha, Jasmine, Cypress and Playwright. You can even install framework-specific testing libraries such as React Testing Library to test your UI framework components.
Testing frameworks allow you to state assertions or expectations about how your code should behave in specific situations, then compare these to the actual behavior of your current code.
Unit and integration tests
Vitest
A Vite-native unit test framework with ESM, TypeScript and JSX support powered by esbuild.
Use Astro‚Äôs getViteConfig() helper in your vitest.config.ts configuration file to set up Vitest with your Astro project‚Äôs settings:
vitest.config.ts
/// <reference types=""vitest"" />
import { getViteConfig } from 'astro/config';
export default getViteConfig({
  test: {
    // Vitest configuration options
  },
});
By default, getViteConfig() will try to load an Astro config file in your project and apply it to the test environment. As of Astro 4.8, if you need to customize the Astro configuration applied in your tests, pass a second argument to getViteConfig():
export default getViteConfig(
  { test: { /* Vitest configuration options */ } },
  {
    site: 'https://example.com/',
    trailingSlash: 'always',
  },
);
See the Astro + Vitest starter template on GitHub.
Vitest and Container API
Added in: astro@4.9.0
You can natively test Astro components using the container API. First, setup vitest as explained above, then create a .test.js file to test your component:
example.test.js
import { experimental_AstroContainer as AstroContainer } from 'astro/container';
import { expect, test } from 'vitest';
import Card from '../src/components/Card.astro';
test('Card with slots', async () => {
  const container = await AstroContainer.create();
  const result = await container.renderToString(Card, {
    slots: {
      default: 'Card content',
    },
  });
  expect(result).toContain('This is a card');
  expect(result).toContain('Card content');
});
End-to-end tests
Playwright
Playwright is an end-to-end testing framework for modern web apps. Use the Playwright API in JavaScript or TypeScript to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.
Installation
You can get started and run your tests using the VS Code Extension.
Alternatively, you can install Playwright within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and add an optional GitHub Actions workflow.
npm
pnpm
Yarn
Terminal window
npm init playwright@latest
Create your first Playwright test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body></body>
</html>
Create a new folder and add the following test file in src/test. Copy and paste the following test into the file to verify that the page meta information is correct. Update the value of the page <title> to match the page you are testing.
src/test/index.spec.ts
import { test, expect } from '@playwright/test';
test('meta is correct', async ({ page }) => {
  await page.goto(""http://localhost:4321/"");
  await expect(page).toHaveTitle('Astro is awesome!');
});
Set a
baseUrl
You can set ""baseURL"": ""http://localhost:4321"" in the playwright.config.ts configuration file to use page.goto(""/"") instead of page.goto(""http://localhost:4321/"") for a more convenient URL.
Running your Playwright tests
You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.
To run our test from the previous example using the command line, use the test command. Optionally, include the file name to run just the single test:
Terminal window
npx playwright test index.spec.ts
To see the full HTML Test Report, open it using the following command:
Terminal window
npx playwright show-report
Tip
Run your tests against your production code to more closely resemble your live, deployed site.
Advanced: Launching a development web server during the tests
You can also have Playwright start your server when you run your testing script by using the webServer option in the Playwright configuration file.
Here is an example of the configuration and commands required when using npm:
Add a test script to your package.json file in the project root, such as ""test:e2e"": ""playwright test"".
In playwright.config.ts, add the webServer object and update the command value to npm run preview.
playwright.config.ts
import { defineConfig } from '@playwright/test';
export default defineConfig({
  webServer: {
    command: 'npm run preview',
    url: 'http://localhost:4321/',
    timeout: 120 * 1000,
    reuseExistingServer: !process.env.CI,
  },
  use: {
    baseURL: 'http://localhost:4321/',
  },
});
Run npm run build, then run npm run test:e2e to run the Playwright tests.
More information about Playwright can be found in the links below:
Getting started with Playwright
Use a development server
Cypress
Cypress is a front-end testing tool built for the modern web. Cypress enables you to write end-to-end tests for your Astro site.
Installation
You can install Cypress using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
npm install -D cypress
This will install Cypress locally as a dev dependency for your project.
Configuration
In the root of your project, create a cypress.config.js file with the following content:
cypress.config.js
import { defineConfig } from 'cypress'
export default defineConfig({
  e2e: {
    supportFile: false
  }
})
Create your first Cypress test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body>
  <h1>Hello world from Astro</h1>
  </body>
</html>
Create an index.cy.js file in the cypress/e2e folder. Use the following test in the file to verify that the page title and header are correct.
cypress/e2e/index.cy.js
it('titles are correct', () => {
  const page = cy.visit('http://localhost:4321');
  page.get('title').should('have.text', 'Astro is awesome!')
  page.get('h1').should('have.text', 'Hello world from Astro');
});
Set a
baseUrl
You can set ""baseUrl"": ""http://localhost:4321"" in the cypress.config.js configuration file to use cy.visit(""/"") instead of cy.visit(""http://localhost:4321/"") for a more convenient URL.
Running your Cypress tests
Cypress can be run from the command line or from the Cypress App. The App provides a visual interface for running and debugging your tests.
First, start the dev server so Cypress can access your live site.
To run our test from the previous example using the command line, execute the following command:
Terminal window
npx cypress run
Alternatively, to run the test using the Cypress App, execute the following command:
Terminal window
npx cypress open
Once the Cypress App is launched, choose E2E Testing, then select the browser to be used to run tests.
Once the test run is finished, you should see green check marks in the output confirming that your test passed:
Output from npx cypress run
Running:  index.cy.js                                                                     (1 of 1)
‚úì titles are correct (107ms)
1 passing (1s)
Fail the test
To check that your test really does work, you can change the following line in the index.astro file:
src/pages/index.astro
 <body>
   <h1>Hello world from Astro</h1>
   <h1>Hello from Astro</h1>
 </body>
Then run the test again. You should see a red ‚Äúx‚Äù in the output confirming that your test failed.
Next steps
More information about Cypress can be found in the links below:
Introduction to Cypress
Testing Your App
NightwatchJS
Nightwatch.js is a test automation framework with a powerful set of tools to write, run, and debug your tests across the web with built-in support for all major browsers and their mobile equivalents, as well as native mobile applications.
Installation
You can install NightwatchJS within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and select whether or not to include component testing and testing on mobile browsers.
npm
pnpm
Yarn
Terminal window
npm init nightwatch@latest
Create your first Nightwatch test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body></body>
</html>
Create a new folder src/test/ and add the following test file:
src/test/index.js
describe('Astro testing with Nightwatch', function () {
    before(browser => browser.navigateTo('http://localhost:4321/'));
    it(""check that the title is correct"", function (browser) {
        browser.assert.titleEquals('Astro is awesome!')
    });
    after(browser => browser.end());
});
Set a
baseUrl
You can set ""baseURL"": ""http://localhost:4321"" in the nightwatch.conf.js configuration file to use browser.navigateTo(""/"") instead of browser.navigateTo(""http://localhost:4321/"") for a more convenient URL.
Running your NightwatchJS tests
You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.
You can run the tests with the NightwatchJS VSCode Extension or using the CLI steps below:
To run all tests, enter the following command in the terminal. Optionally, include the file name to run just the single test:
Terminal window
npx nightwatch test/index.js
Additionally, you can run the tests against a specific browser using the --environment or -e CLI argument. If you don‚Äôt have the relevant browser installed, Nightwatch will attempt to set it up for you using Selenium Manager:
Terminal window
npx nightwatch test/index.ts -e firefox
To see the full HTML Test Report, open it using the following command:
Terminal window
npx nightwatch test/index.ts --open
Tip
Run your tests against your production code to more closely resemble your live, deployed site.
More information about NightwatchJS can be found in the links below:
Intro to Nightwatch
Testing with Nightwatch
Edit page
Translate this page
Previous
Upgrade Astro
Next
Troubleshooting
Contribute
Give us feedback
Community

On this page
Overview
Unit and integration tests
Vitest
End-to-end tests
Playwright
Cypress
NightwatchJS
Want to build your own Docs?
Grab this template to get started.‚Üí
Testing
Testing helps you write and maintain working Astro code. Astro supports many popular tools for unit tests, component tests, and end-to-end tests including Jest, Mocha, Jasmine, Cypress and Playwright. You can even install framework-specific testing libraries such as React Testing Library to test your UI framework components.
Testing frameworks allow you to state assertions or expectations about how your code should behave in specific situations, then compare these to the actual behavior of your current code.
Unit and integration tests
Vitest
A Vite-native unit test framework with ESM, TypeScript and JSX support powered by esbuild.
Use Astro‚Äôs getViteConfig() helper in your vitest.config.ts configuration file to set up Vitest with your Astro project‚Äôs settings:
vitest.config.ts
/// <reference types=""vitest"" />
import { getViteConfig } from 'astro/config';
export default getViteConfig({
  test: {
    // Vitest configuration options
  },
});
By default, getViteConfig() will try to load an Astro config file in your project and apply it to the test environment. As of Astro 4.8, if you need to customize the Astro configuration applied in your tests, pass a second argument to getViteConfig():
export default getViteConfig(
  { test: { /* Vitest configuration options */ } },
  {
    site: 'https://example.com/',
    trailingSlash: 'always',
  },
);
See the Astro + Vitest starter template on GitHub.
Vitest and Container API
Added in: astro@4.9.0
You can natively test Astro components using the container API. First, setup vitest as explained above, then create a .test.js file to test your component:
example.test.js
import { experimental_AstroContainer as AstroContainer } from 'astro/container';
import { expect, test } from 'vitest';
import Card from '../src/components/Card.astro';
test('Card with slots', async () => {
  const container = await AstroContainer.create();
  const result = await container.renderToString(Card, {
    slots: {
      default: 'Card content',
    },
  });
  expect(result).toContain('This is a card');
  expect(result).toContain('Card content');
});
End-to-end tests
Playwright
Playwright is an end-to-end testing framework for modern web apps. Use the Playwright API in JavaScript or TypeScript to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.
Installation
You can get started and run your tests using the VS Code Extension.
Alternatively, you can install Playwright within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and add an optional GitHub Actions workflow.
npm
pnpm
Yarn
Terminal window
pnpm dlx create-playwright
Create your first Playwright test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body></body>
</html>
Create a new folder and add the following test file in src/test. Copy and paste the following test into the file to verify that the page meta information is correct. Update the value of the page <title> to match the page you are testing.
src/test/index.spec.ts
import { test, expect } from '@playwright/test';
test('meta is correct', async ({ page }) => {
  await page.goto(""http://localhost:4321/"");
  await expect(page).toHaveTitle('Astro is awesome!');
});
Set a
baseUrl
You can set ""baseURL"": ""http://localhost:4321"" in the playwright.config.ts configuration file to use page.goto(""/"") instead of page.goto(""http://localhost:4321/"") for a more convenient URL.
Running your Playwright tests
You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.
To run our test from the previous example using the command line, use the test command. Optionally, include the file name to run just the single test:
Terminal window
npx playwright test index.spec.ts
To see the full HTML Test Report, open it using the following command:
Terminal window
npx playwright show-report
Tip
Run your tests against your production code to more closely resemble your live, deployed site.
Advanced: Launching a development web server during the tests
You can also have Playwright start your server when you run your testing script by using the webServer option in the Playwright configuration file.
Here is an example of the configuration and commands required when using npm:
Add a test script to your package.json file in the project root, such as ""test:e2e"": ""playwright test"".
In playwright.config.ts, add the webServer object and update the command value to npm run preview.
playwright.config.ts
import { defineConfig } from '@playwright/test';
export default defineConfig({
  webServer: {
    command: 'npm run preview',
    url: 'http://localhost:4321/',
    timeout: 120 * 1000,
    reuseExistingServer: !process.env.CI,
  },
  use: {
    baseURL: 'http://localhost:4321/',
  },
});
Run npm run build, then run npm run test:e2e to run the Playwright tests.
More information about Playwright can be found in the links below:
Getting started with Playwright
Use a development server
Cypress
Cypress is a front-end testing tool built for the modern web. Cypress enables you to write end-to-end tests for your Astro site.
Installation
You can install Cypress using the package manager of your choice.
npm
pnpm
Yarn
Terminal window
pnpm add cypress --save-dev
Configuration
In the root of your project, create a cypress.config.js file with the following content:
cypress.config.js
import { defineConfig } from 'cypress'
export default defineConfig({
  e2e: {
    supportFile: false
  }
})
Create your first Cypress test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body>
  <h1>Hello world from Astro</h1>
  </body>
</html>
Create an index.cy.js file in the cypress/e2e folder. Use the following test in the file to verify that the page title and header are correct.
cypress/e2e/index.cy.js
it('titles are correct', () => {
  const page = cy.visit('http://localhost:4321');
  page.get('title').should('have.text', 'Astro is awesome!')
  page.get('h1').should('have.text', 'Hello world from Astro');
});
Set a
baseUrl
You can set ""baseUrl"": ""http://localhost:4321"" in the cypress.config.js configuration file to use cy.visit(""/"") instead of cy.visit(""http://localhost:4321/"") for a more convenient URL.
Running your Cypress tests
Cypress can be run from the command line or from the Cypress App. The App provides a visual interface for running and debugging your tests.
First, start the dev server so Cypress can access your live site.
To run our test from the previous example using the command line, execute the following command:
Terminal window
npx cypress run
Alternatively, to run the test using the Cypress App, execute the following command:
Terminal window
npx cypress open
Once the Cypress App is launched, choose E2E Testing, then select the browser to be used to run tests.
Once the test run is finished, you should see green check marks in the output confirming that your test passed:
Output from npx cypress run
Running:  index.cy.js                                                                     (1 of 1)
‚úì titles are correct (107ms)
1 passing (1s)
Fail the test
To check that your test really does work, you can change the following line in the index.astro file:
src/pages/index.astro
 <body>
   <h1>Hello world from Astro</h1>
   <h1>Hello from Astro</h1>
 </body>
Then run the test again. You should see a red ‚Äúx‚Äù in the output confirming that your test failed.
Next steps
More information about Cypress can be found in the links below:
Introduction to Cypress
Testing Your App
NightwatchJS
Nightwatch.js is a test automation framework with a powerful set of tools to write, run, and debug your tests across the web with built-in support for all major browsers and their mobile equivalents, as well as native mobile applications.
Installation
You can install NightwatchJS within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and select whether or not to include component testing and testing on mobile browsers.
npm
pnpm
Yarn
Terminal window
pnpm dlx create-nightwatch
Create your first Nightwatch test
Choose a page to test. This example will test the example page index.astro below.
src/pages/index.astro
---
---
<html lang=""en"">
  <head>
    <title>Astro is awesome!</title>
    <meta name=""description"" content=""Pull content from anywhere and serve it fast with Astro's next-gen island architecture."" />
  </head>
  <body></body>
</html>
Create a new folder src/test/ and add the following test file:
src/test/index.js
describe('Astro testing with Nightwatch', function () {
    before(browser => browser.navigateTo('http://localhost:4321/'));
    it(""check that the title is correct"", function (browser) {
        browser.assert.titleEquals('Astro is awesome!')
    });
    after(browser => browser.end());
});
Set a
baseUrl
You can set ""baseURL"": ""http://localhost:4321"" in the nightwatch.conf.js configuration file to use browser.navigateTo(""/"") instead of browser.navigateTo(""http://localhost:4321/"") for a more convenient URL.
Running your NightwatchJS tests
You can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.
You can run the tests with the NightwatchJS VSCode Extension or using the CLI steps below:
To run all tests, enter the following command in the terminal. Optionally, include the file name to run just the single test:
Terminal window
npx nightwatch test/index.js
Additionally, you can run the tests against a specific browser using the --environment or -e CLI argument. If you don‚Äôt have the relevant browser installed, Nightwatch will attempt to set it up for you using Selenium Manager:
Terminal window
npx nightwatch test/index.ts -e firefox
To see the full HTML Test Report, open it using the following command:
Terminal window
npx nightwatch test/index.ts --open
Tip
Run your tests against your production code to more closely resemble your live, deployed site.
More information about NightwatchJS can be found in the links below:
Intro to Nightwatch
Testing with Nightwatch
Edit page
Translate this page
Previous
Upgrade Astro
Next
Troubleshooting
Contribute
Give us feedback
Community""""""",7603,33691,astro
https://docs.astro.build/en/guides/troubleshooting/,"""""""On this page
Overview
Tips and tricks
Debugging with console.log()
Debugging framework components
Astro <Debug /> component
Common Error Messages
Cannot use import statement outside a module
document (or window) is not defined
Expected a default export
Refused to execute inline script
Common gotchas
My component is not rendering
My component is not interactive
Cannot find package ‚ÄòX‚Äô
Astro.glob() - no matches found
Using Astro with Yarn 2+ (Berry)
Adding dependencies to Astro in a monorepo
Using <head> in a component
An unexpected <script> or <style> is included
Escaping special characters in Markdown
Creating minimal reproductions
Create a StackBlitz via astro.new
Minimal code
Create an issue
Need more?
Want to build your own Docs?
Grab this template to get started.‚Üí
Troubleshooting
Astro provides several different tools to help you troubleshoot and debug your code.
Tips and tricks
Debugging with console.log()
console.log() is a simple-but-popular method of debugging your Astro code. Where you write your console.log() statement will determine where your debugging output is printed:
---
console.log('Hi! I‚Äôm the server. This is logged in the terminal where Astro is running.');
---
<script>
console.log('Hi! I‚Äôm the client. This is logged in browser dev console.');
</script>
A console.log() statement in Astro frontmatter will always output to the terminal running the Astro CLI. This is because Astro runs on the server, and never in the browser.
Code that is written or imported inside of an Astro <script> tag is run in the browser. Any console.log() statements or other debug output will be printed to the console in your browser.
Debugging framework components
Framework components (like React and Svelte) are unique: They render server-side by default, meaning that console.log() debug output will be visible in the terminal. However, they can also be hydrated for the browser, which may cause your debug logs to also appear in the browser.
This can be useful for debugging differences between the server output and the hydrated components in the browser.
Astro <Debug /> component
To help you debug your Astro components, Astro provides a built-in <Debug /> component which renders any value directly into your component HTML template.
This component provides a way to inspect values on the client-side, without any JavaScript. It can be useful for quick debugging in the browser without having to flip back-and-forth between your terminal and your browser.
---
import { Debug } from 'astro:components';
const sum = (a, b) => a + b;
---
<!-- Example: Outputs {answer: 6} to the browser -->
<Debug answer={sum(2, 4)} />
The Debug component supports a variety of syntax options for even more flexible and concise debugging:
---
import { Debug } from 'astro:components';
const sum = (a, b) => a + b;
const answer = sum(2, 4);
---
<!-- Example: All three examples are equivalent. -->
<Debug answer={sum(2, 4)} />
<Debug {{answer: sum(2, 4)}} />
<Debug {answer} />
Common Error Messages
Here are some common error messages you might see in the terminal, what they might mean, and what to do about them. See our full error reference guide for a complete list of Astro errors you may encounter.
Cannot use import statement outside a module
In Astro components, <script> tags are hoisted and loaded as JS modules by default. If you have included the is:inline directive or any other attribute in your tag, this default behavior is removed.
Solution: If you have added any attributes to your <script> tag, you must also add the type=""module"" attribute to be able to use import statements.
Status: Expected Astro behavior, as intended.
Not sure that this is your problem?
Check to see if anyone else has reported this issue!
document (or window) is not defined
This error occurs when trying to access document or window on the server.
Astro components run on the server, so you can‚Äôt access these browser-specific objects within the frontmatter.
Framework components run on the server by default, so this error can occur when accessing document or window during rendering.
Solution: Determine the code that calls document or window. If you aren‚Äôt using document or window directly and still getting this error, check to see if any packages you‚Äôre importing are meant to run on the client.
If the code is in an Astro component, move it to a <script> tag outside of the frontmatter. This tells Astro to run this code on the client, where document and window are available.
If the code is in a framework component, try to access these objects after rendering using lifecycle methods (e.g. useEffect() in React, onMounted() in Vue, and onMount() in Svelte). Tell the framework component to hydrate client-side by using a client: directive, like client:load, to run these lifecycle methods. You can also prevent the component from rendering on the server at all by adding the client:only directive.
Status: Expected Astro behavior, as intended.
Expected a default export
This error can be thrown when trying to import or render an invalid component, or one that is not working properly. (This particular message occurs because of the way importing a UI component works in Astro.)
Solution: Try looking for errors in any component you are importing and rendering, and make sure it‚Äôs working correctly. Consider opening an Astro starter template from astro.new and troubleshooting just your component in a minimal Astro project.
Status: Expected Astro behavior, as intended.
Refused to execute inline script
You may see the following error logged in the browser console:
Refused to execute inline script because it violates the following Content Security Policy directive: ‚Ä¶
This means that your site‚Äôs Content Security Policy (CSP) disallows running inline <script> tags, which Astro outputs by default.
Solution: Update your CSP to include script-src: 'unsafe-inline' to allow inline scripts to run. Alternatively, you can use a third-party integration such as astro-shield to generate the CSP headers for you.
Common gotchas
My component is not rendering
First, check to see that you have imported the component in your .astro component script or .mdx file.
Then check your import statement:
Is your import linking to the wrong place? (Check your import path.)
Does your import have the same name as the imported component? (Check your component name and that it follows the .astro syntax.)
Have you included the extension in the import? (Check that your imported file contains an extension. e.g. .astro, .md, .vue, .svelte. Note: File extensions are not required for .js(x) and .ts(x) files only.)
My component is not interactive
If your component is rendering (see above) but is not responding to user interaction, then you may be missing a client:* directive to hydrate your component.
By default, a UI Framework component is not hydrated in the client. If no client:* directive is provided, its HTML is rendered onto the page without JavaScript.
Tip
Astro components are HTML-only templating components with no client-side runtime. But, you can use a <script> tag in your Astro component template to send JavaScript to the browser that executes in the global scope.
Cannot find package ‚ÄòX‚Äô
If you see a ""Cannot find package 'react'"" (or similar) warning when you start up Astro, that means that you need to install that package into your project. Not all package managers will install peer dependencies for you automatically. If you are on Node v16+ and using npm, you should not need to worry about this section.
React, for example, is a peer dependency of the @astrojs/react integration. That means that you should install the official react and react-dom packages alongside your integration. The integration will then pull from these packages automatically.
Terminal window
# Example: Install integrations and frameworks together
npm install @astrojs/react react react-dom
See Astro‚Äôs integration guide for instructions on adding framework renderers, CSS tools and other packages to Astro.
Astro.glob() - no matches found
When using Astro.glob() to import files, be sure to use the correct glob syntax that will match all the files you need.
Filepaths
For example, use ../components/**/*.js in src/pages/index.astro to import both of the following files:
src/components/MyComponent.js
src/components/includes/MyOtherComponent.js
Supported Values
Astro.glob() does not support dynamic variables and string interpolation.
This is not a bug in Astro. It is due to a limitation of Vite‚Äôs import.meta.glob() function which only supports static string literals.
A common workaround is to instead import a larger set of files that includes all the files you need using Astro.glob(), then filter them:
src/components/featured.astro
---
const { postSlug } = Astro.props;
const pathToMyFeaturedPost = `src/pages/blog/${postSlug}.md`;
const posts = await Astro.glob('../pages/blog/*.md');
const myFeaturedPost = posts.find(post => post.file.includes(pathToMyFeaturedPost));
---
<p>
  Take a look at my favorite post, <a href={myFeaturedPost.url}>{myFeaturedPost.frontmatter.title}</a>!
</p>
Using Astro with Yarn 2+ (Berry)
Yarn 2+, a.k.a. Berry, uses a technique called Plug‚Äôn‚ÄôPlay (PnP) to store and manage Node modules, which can cause problems while initializing a new Astro project using create astro or while working with Astro. A workaround is to set the nodeLinker property in .yarnrc.yml to node-modules:
.yarnrc.yml
nodeLinker: ""node-modules""
Adding dependencies to Astro in a monorepo
When working with Astro in a monorepo setup, project dependencies should be added in each project‚Äôs own package.json file.
However, you may also want to use Astro in the root of the monorepo (e.g. Nx projects recommend installing dependencies at the root). In this case, manually add Astro-related dependencies (e.g. @astrojs/vue, astro-component-lib) to the vite.ssr.noExternal part of Astro‚Äôs config to ensure that these dependencies are properly installed and bundled:
astro.config.mjs
import { defineConfig } from 'astro/config'
export default defineConfig({
  vite: {
    ssr: {
      noExternal: [
        '@astrojs/vue',
        'astro-component-lib',
      ]
    }
  }
})
Using <head> in a component
In Astro, using a <head> tag works like any other HTML tag: it does not get moved to the top of the page or merged with the existing <head>. Because of this, you usually only want to include one <head> tag throughout a page. We recommend writing that single <head> and its contents in a layout component.
An unexpected <script> or <style> is included
You may notice an imported component‚Äôs <script> or <style> tags included in your HTML source even if that component doesn‚Äôt appear in the final output. For example, this will occur with conditionally rendered components that are not displayed.
Astro‚Äôs build process works on the module graph: once a component is included in the template, its <script> and <style> tags are processed, optimized, and bundled, whether it appears in the final output or not. This does not apply to scripts when the is:inline directive is applied.
Escaping special characters in Markdown
Certain characters have a special meaning in Markdown. You may need to use a different syntax if you want to display them. To do this, you can use HTML entities for these characters instead.
For example, to prevent < being interpreted as the beginning of an HTML element, write &lt;.
Creating minimal reproductions
When troubleshooting your code, it can be helpful to create a minimal reproduction of the issue that you can share. This is a smaller, simplified Astro project that demonstrates your issue. Having a working reproduction in a new project helps to confirm that this is a repeatable problem, and is not caused by something else in your personal environment or existing project.
Sharing a minimal reproduction is helpful when asking for help in our support threads and is often required when filing a bug report to Astro.
Create a StackBlitz via astro.new
You can use astro.new to create a new Astro project with a single click. For minimal reproductions, we strongly recommend starting from the minimal (empty) example running in StackBlitz, with as little extra code as possible.
StackBlitz will run this Astro project in the browser, outside of your local environment. It will also provide you with a shareable link so that any Astro maintainer or support squad member can view your minimal reproduction outside of their own local environment. This means that everyone is viewing the exact same project, with the same configuration and dependencies. This makes it easy for someone else to help troubleshoot your code. If the issue is reproducible, it allows you to verify that the issue lies within the Astro code itself and you can feel confident submitting a bug report.
Note that not every issue is reproducible in StackBlitz. For example, your issue might be dependent on a specific environment or package manager, or it may involve HTML Streaming, which isn‚Äôt supported in StackBlitz. In this case, create a new minimal (empty) Astro project using the CLI, reproduce the issue, and upload it to a GitHub repository. Instead of sharing a StackBlitz URL, provide a link to the GitHub repository of your minimal reproduction.
Minimal code
Once your empty project is set up, go through the steps to reproduce the issue. This can include adding packages, changing configuration, and writing code.
You should only add the minimum amount of code necessary to reproduce the issue. Do not reproduce other elements of your existing project, and remove all code that is not directly related to the issue.
Create an issue
If your issue can be reproduced, then it is time to create an issue and file a bug report!
Go to the appropriate Astro repository on GitHub and open a new issue. Most repositories have an issue template that will ask questions or require information in order to submit. It‚Äôs important that you follow these templates because if you don‚Äôt provide the information we need, then we have to ask you for it‚Ä¶ and no one is working on your issue!
Include the link to your minimal reproduction on StackBlitz (or GitHub repository, if necessary). Start with a description of the expected versus actual behavior to provide context for the issue. Then, include clear, step-by-step instructions on how to replicate the issue in an Astro project.
Need more?
Come and chat with us on Discord and explain your issue in the #support forum channel. We‚Äôre always happy to help!
Visit the current open Issues in Astro to see if you are encountering a known problem or file a bug report.
You can also visit RFC Discussions to see whether you‚Äôve found a known limitation of Astro, and check to see whether there are current proposals related to your use case.
Edit page
Translate this page
Previous
Testing
Next
How-to Recipes
Contribute
Give us feedback
Community""""""",3151,14901,astro
https://docs.astro.build/en/recipes/,"""""""On this page
Overview
Official Recipes
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
How-to recipes
See guided examples of adding features to your Astro project.
Official Recipes
Astro‚Äôs official recipes are short, focused how-to guides that walk a reader through completing a working example of a specific task. Recipes are a great way to add new features or behavior to your Astro project by following step-by-step instructions!
Installing a Vite or Rollup plugin
Learn how you can import YAML data by adding a Rollup plugin to your project.
Analyze Bundle Size
Learn how to analyze the bundle generated by Astro using `rollup-plugin-visualizer`.
Build a custom image component
Learn how to build a custom image component that supports media queries using the getImage function.
Build forms with API routes
Learn how to use JavaScript to send form submissions to an API Route.
Build HTML forms in Astro pages
Learn how to build HTML forms and handle submissions in your frontmatter.
Use Bun with Astro
Learn how to use Bun with your Astro site.
Call endpoints from the server
Learn how to call endpoints from the server in Astro.
Verify a Captcha
Learn how to create an API route and fetch it from the client.
Build your Astro Site with Docker
Learn how to build your Astro site using Docker.
Dynamically import images
Learn how to dynamically import images using Vite's import.meta.glob function.
Add icons to external links
Learn how to install a rehype plugin to add icons to external links in your Markdown files.
Add i18n features
Use dynamic routing and content collections to add internationalization support to your Astro site.
Create a dev toolbar app
Learn how to create a dev toolbar app for your site.
Add last modified time
Build a remark plugin to add the last modified time to your Markdown and MDX.
Add reading time
Build a remark plugin to add reading time to your Markdown or MDX files.
Share state between Islands
Learn how to share state across framework components with Nano Stores.
Share state between Astro Components
Learn how to share state across Astro components with Nano Stores.
Using streaming to improve page performance
Learn how to use streaming to improve page performance.
Style rendered Markdown with Tailwind Typography
Learn how to use @tailwind/typography to style your rendered Markdown.
Community Resources
Find more recipes written and submitted by the community in our community recipes list.
Edit page
Translate this page
Previous
Troubleshooting
Next
Community Resources
Contribute
Give us feedback
Community""""""",524,2594,astro
https://docs.astro.build/en/community-resources/content/,"""""""On this page
Overview
Courses and Tutorials
Introductory Tutorials
Video Tutorials
Recipes and Guides
CSS
Authentication
RSS
Images
Editor Tooling
Markdown
Performance
Utilities
Animation
Internationalization and Localization
Astro DB
API Endpoints
Want to build your own Docs?
Grab this template to get started.‚Üí
Community Educational Content
There is so much more out there that can help you learn and build with Astro! Here is some educational content produced and maintained by the Astro community.
All links are external, and may be based on earlier versions of Astro. Be sure to check the date on any community content, and adapt to your project accordingly.
For more Astro educational content, check out the Astro Blog or sign up for the official Astro newsletter where we recap the best community content of each month.
Courses and Tutorials
Courses and tutorials are focused on teaching you new concepts, often with exercises or sample projects to build. These are a great way to learn new concepts and give you the tools you need for working on your own Astro project.
Check out the following courses and tutorials to learn more about Astro.
Introductory Tutorials
Astro Web Framework Crash Course by freeCodeCamp
Astro Crash Course in 20 minutes by Chris Pennington (full paid course: Learn Astro)
Astro 3.0 Crash Course by James Q Quick (full paid course: Build Modern Websites with Astro)
Astro Crash Course in 60 minutes by @developedbyed
Understanding Astro (ebook) by Ohans Emmanuel
The Valley of Code - Astro by Flavio Copes
Learn Astro 3 from Scratch: Course for Beginners + Astro Application (SPANISH) by @midudev
Introduction to the Astro web framework (paid) by Tech Razor on Udemy
Video Tutorials
Astro Quick Start Course: Build an SSR Blog
How I created a movie application with Astro 3.x
You may not ACTUALLY understand Content Collections‚Ä¶
Build a custom blog platform with Astro and Appwrite
Astro JS Portfolio Crash Course
Build a full stack blog with Astro
(ES) Curso de Astro, Generador de Sitios Web Est√°ticos
Recipes and Guides
Add your own!
Have you published a recipe or guide for working with Astro? Edit this page and add your link below in the appropriate section!
CSS
Use UnoCSS in Astro
Add dark mode to Astro with Tailwind CSS
Use Bootstrap with Astro
Authentication
Add Github OAuth with Lucia
Add username and password authentication with Lucia
Authenticating users in Astro with Clerk and React
RSS
Use a dynamic filename when importing images
Add an RSS feed to Astro using Storyblok‚Äôs stories
How to Send Any Data to Your RSS Feed? A Guide with Astro + RSS
Adding RSS Feed Content and Fixing Markdown Image Paths in Astro
Create a full-content RSS feed using MDX and the Container API
Images
Add blog post images to your Astro RSS Feed
Generate Open Graph images for an Astro blog
Editor Tooling
Get VSCode, ESLint & Prettier working with Astro
Integrate Prettier with Astro and Tailwind CSS
Markdown
Build a table of contents from Astro‚Äôs Markdown headings
Create a Remark plugin to remove runts from your Markdown files
Set Up Draft Pages Effectively in Astro with Config-Driven Content Authoring
Performance
Enhance your Astro builds: modify HTML files post-build
Setting up micro-frontends with Astro
How to Implement Incremental Static Regeneration (ISR) in Astro
Utilities
Using tRPC in Astro
Integrating Sentry with Astro
Generate localized sitemaps for your Astro and Storyblok project
Add searching to your site with Pagefind
Add searching to your site with Fuse.js
Add a comments section to your Astro blog using Giscus
Creating A Pagination Component With Astro
Animation
Using GreenSock Animation Platform (GSAP) in Astro
Using GreenSock Animation Platform (GSAP) in Astro with View Transitions
Using Animate On Scroll (AOS) in Astro: A Step-by-Step Guide
Internationalization and Localization
How to make your Astro website multilingual with Crowdin: Astro localization guide
Translate routes in Astro for content collections and subpages
Astro DB
Creating a Guestbook with Astro DB
How to Build a Views Counter with Astro DB
API Endpoints
Streaming a file in Astro
Edit page
Translate this page
Previous
How-to Recipes
Next
Configuration
Contribute
Give us feedback
Community""""""",933,4233,astro
https://docs.astro.build/en/reference/configuration-reference/,"""""""On this page
Overview
Top-Level Options
site
base
trailingSlash
redirects
output
adapter
integrations
root
srcDir
publicDir
outDir
cacheDir
compressHTML
scopedStyleStrategy
security
vite
Build Options
build.format
build.client
build.server
build.assets
build.assetsPrefix
build.serverEntry
build.redirects
build.inlineStylesheets
build.concurrency
Server Options
server.host
server.port
server.open
server.headers
Dev Toolbar Options
devToolbar.enabled
Prefetch Options
prefetch.prefetchAll
prefetch.defaultStrategy
Image Options
image.endpoint
image.service
image.domains
image.remotePatterns
Markdown Options
markdown.shikiConfig
markdown.syntaxHighlight
markdown.remarkPlugins
markdown.rehypePlugins
markdown.gfm
markdown.smartypants
markdown.remarkRehype
i18n
i18n.defaultLocale
i18n.locales
i18n.fallback
i18n.routing
Legacy Flags
Experimental Flags
experimental.directRenderScript
experimental.contentCollectionCache
experimental.clientPrerender
experimental.globalRoutePriority
experimental.env
experimental.serverIslands
experimental.contentIntellisense
experimental.contentLayer
Want to build your own Docs?
Grab this template to get started.‚Üí
Configuration Reference
The following reference covers all supported configuration options in Astro. To learn more about configuring Astro, read our guide on Configuring Astro.
astro.config.mjs
import { defineConfig } from 'astro/config'
export default defineConfig({
  // your configuration options here...
})
Top-Level Options
site
Type: string
Your final, deployed URL. Astro uses this full URL to generate your sitemap and canonical URLs in your final build. It is strongly recommended that you set this configuration to get the most out of Astro.
{
  site: 'https://www.my-site.dev'
}
base
Type: string
The base path to deploy to. Astro will use this path as the root for your pages and assets both in development and in production build.
In the example below, astro dev will start your server at /docs.
{
  base: '/docs'
}
When using this option, all of your static asset imports and URLs should add the base as a prefix. You can access this value via import.meta.env.BASE_URL.
The value of import.meta.env.BASE_URL will be determined by your trailingSlash config, no matter what value you have set for base.
A trailing slash is always included if trailingSlash: ""always"" is set. If trailingSlash: ""never"" is set, BASE_URL will not include a trailing slash, even if base includes one.
Additionally, Astro will internally manipulate the configured value of config.base before making it available to integrations. The value of config.base as read by integrations will also be determined by your trailingSlash configuration in the same way.
In the example below, the values of import.meta.env.BASE_URL and config.base when processed will both be /docs:
{
   base: '/docs/',
   trailingSlash: ""never""
}
In the example below, the values of import.meta.env.BASE_URL and config.base when processed will both be /docs/:
{
   base: '/docs',
   trailingSlash: ""always""
}
trailingSlash
Type: 'always' | 'never' | 'ignore'
Default: 'ignore'
Set the route matching behavior of the dev server. Choose from the following options:
'always' - Only match URLs that include a trailing slash (ex: ‚Äú/foo/‚Äú)
'never' - Never match URLs that include a trailing slash (ex: ‚Äú/foo‚Äù)
'ignore' - Match URLs regardless of whether a trailing ‚Äù/‚Äù exists
Use this configuration option if your production host has strict handling of how trailing slashes work or do not work.
You can also set this if you prefer to be more strict yourself, so that URLs with or without trailing slashes won‚Äôt work during development.
{
  // Example: Require a trailing slash during development
  trailingSlash: 'always'
}
See Also:
build.format
redirects
Type: Record.<string, RedirectConfig>
Default: {}
Added in: astro@2.9.0
Specify a mapping of redirects where the key is the route to match and the value is the path to redirect to.
You can redirect both static and dynamic routes, but only to the same kind of route. For example you cannot have a '/article': '/blog/[...slug]' redirect.
{
  redirects: {
    '/old': '/new',
    '/blog/[...slug]': '/articles/[...slug]',
  }
}
For statically-generated sites with no adapter installed, this will produce a client redirect using a <meta http-equiv=""refresh""> tag and does not support status codes.
When using SSR or with a static adapter in output: static mode, status codes are supported. Astro will serve redirected GET requests with a status of 301 and use a status of 308 for any other request method.
You can customize the redirection status code using an object in the redirect config:
{
  redirects: {
    '/other': {
      status: 302,
      destination: '/place',
    },
  }
}
output
Type: 'static' | 'server' | 'hybrid'
Default: 'static'
Specifies the output target for builds.
'static' - Building a static site to be deployed to any static host.
'server' - Building an app to be deployed to a host supporting SSR (server-side rendering).
'hybrid' - Building a static site with a few server-side rendered pages.
import { defineConfig } from 'astro/config';
export default defineConfig({
  output: 'static'
})
See Also:
adapter
adapter
Type: AstroIntegration
Deploy to your favorite server, serverless, or edge host with build adapters. Import one of our first-party adapters for Netlify, Vercel, and more to engage Astro SSR.
See our Server-side Rendering guide for more on SSR, and our deployment guides for a complete list of hosts.
import netlify from '@astrojs/netlify';
{
  // Example: Build for Netlify serverless deployment
  adapter: netlify(),
}
See Also:
output
integrations
Type: AstroIntegration[]
Extend Astro with custom integrations. Integrations are your one-stop-shop for adding framework support (like Solid.js), new features (like sitemaps), and new libraries (like Partytown).
Read our Integrations Guide for help getting started with Astro Integrations.
import react from '@astrojs/react';
import tailwind from '@astrojs/tailwind';
{
  // Example: Add React + Tailwind support to Astro
  integrations: [react(), tailwind()]
}
root
Type: string
CLI: --root
Default: ""."" (current working directory)
You should only provide this option if you run the astro CLI commands in a directory other than the project root directory. Usually, this option is provided via the CLI instead of the Astro config file, since Astro needs to know your project root before it can locate your config file.
If you provide a relative path (ex: --root: './my-project') Astro will resolve it against your current working directory.
Examples
{
  root: './my-project-directory'
}
Terminal window
$ astro build --root ./my-project-directory
srcDir
Type: string
Default: ""./src""
Set the directory that Astro will read your site from.
The value can be either an absolute file system path or a path relative to the project root.
{
  srcDir: './www'
}
publicDir
Type: string
Default: ""./public""
Set the directory for your static assets. Files in this directory are served at / during dev and copied to your build directory during build. These files are always served or copied as-is, without transform or bundling.
The value can be either an absolute file system path or a path relative to the project root.
{
  publicDir: './my-custom-publicDir-directory'
}
outDir
Type: string
Default: ""./dist""
Set the directory that astro build writes your final build to.
The value can be either an absolute file system path or a path relative to the project root.
{
  outDir: './my-custom-build-directory'
}
See Also:
build.server
cacheDir
Type: string
Default: ""./node_modules/.astro""
Set the directory for caching build artifacts. Files in this directory will be used in subsequent builds to speed up the build time.
The value can be either an absolute file system path or a path relative to the project root.
{
  cacheDir: './my-custom-cache-directory'
}
compressHTML
Type: boolean
Default: true
This is an option to minify your HTML output and reduce the size of your HTML files.
By default, Astro removes whitespace from your HTML, including line breaks, from .astro components in a lossless manner. Some whitespace may be kept as needed to preserve the visual rendering of your HTML. This occurs both in development mode and in the final build.
To disable HTML compression, set compressHTML to false.
{
  compressHTML: false
}
scopedStyleStrategy
Type: 'where' | 'class' | 'attribute'
Default: 'attribute'
Added in: astro@2.4
Specify the strategy used for scoping styles within Astro components. Choose from:
'where' - Use :where selectors, causing no specificity increase.
'class' - Use class-based selectors, causing a +1 specificity increase.
'attribute' - Use data- attributes, causing a +1 specificity increase.
Using 'class' is helpful when you want to ensure that element selectors within an Astro component override global style defaults (e.g. from a global stylesheet). Using 'where' gives you more control over specificity, but requires that you use higher-specificity selectors, layers, and other tools to control which selectors are applied. Using 'attribute' is useful when you are manipulating the class attribute of elements and need to avoid conflicts between your own styling logic and Astro‚Äôs application of styles.
security
Type: object
Default: {}
Added in: astro@4.9.0
Enables security measures for an Astro website.
These features only exist for pages rendered on demand (SSR) using server mode or pages that opt out of prerendering in hybrid mode.
astro.config.mjs
export default defineConfig({
  output: ""server"",
  security: {
    checkOrigin: true
  }
})
security.checkOrigin
Type: boolean
Default: false
Added in: astro@4.9.0
When enabled, performs a check that the ‚Äúorigin‚Äù header, automatically passed by all modern browsers, matches the URL sent by each Request. This is used to provide Cross-Site Request Forgery (CSRF) protection.
The ‚Äúorigin‚Äù check is executed only for pages rendered on demand, and only for the requests POST, PATCH, DELETE and PUT with one of the following content-type headers: 'application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain'.
If the ‚Äúorigin‚Äù header doesn‚Äôt match the pathname of the request, Astro will return a 403 status code and will not render the page.
vite
Type: ViteUserConfig
Pass additional configuration options to Vite. Useful when Astro doesn‚Äôt support some advanced configuration that you may need.
View the full vite configuration object documentation on vite.dev.
Examples
{
  vite: {
    ssr: {
      // Example: Force a broken package to skip SSR processing, if needed
      external: ['broken-npm-package'],
    }
  }
}
{
  vite: {
    // Example: Add custom vite plugins directly to your Astro project
    plugins: [myPlugin()],
  }
}
Build Options
build.format
Type: ('file' | 'directory' | 'preserve')
Default: 'directory'
Control the output file format of each page. This value may be set by an adapter for you.
'file': Astro will generate an HTML file named for each page route. (e.g. src/pages/about.astro and src/pages/about/index.astro both build the file /about.html)
'directory': Astro will generate a directory with a nested index.html file for each page. (e.g. src/pages/about.astro and src/pages/about/index.astro both build the file /about/index.html)
'preserve': Astro will generate HTML files exactly as they appear in your source folder. (e.g. src/pages/about.astro builds /about.html and src/pages/about/index.astro builds the file /about/index.html)
{
  build: {
    // Example: Generate `page.html` instead of `page/index.html` during build.
    format: 'file'
  }
}
Effect on Astro.url
Setting build.format controls what Astro.url is set to during the build. When it is:
directory - The Astro.url.pathname will include a trailing slash to mimic folder behavior; ie /foo/.
file - The Astro.url.pathname will include .html; ie /foo.html.
This means that when you create relative URLs using new URL('./relative', Astro.url), you will get consistent behavior between dev and build.
To prevent inconsistencies with trailing slash behaviour in dev, you can restrict the trailingSlash option to 'always' or 'never' depending on your build format:
directory - Set trailingSlash: 'always'
file - Set trailingSlash: 'never'
build.client
Type: string
Default: './dist/client'
Controls the output directory of your client-side CSS and JavaScript when output: 'server' or output: 'hybrid' only. outDir controls where the code is built to.
This value is relative to the outDir.
{
  output: 'server', // or 'hybrid'
  build: {
    client: './client'
  }
}
build.server
Type: string
Default: './dist/server'
Controls the output directory of server JavaScript when building to SSR.
This value is relative to the outDir.
{
  build: {
    server: './server'
  }
}
build.assets
Type: string
Default: '_astro'
Added in: astro@2.0.0
Specifies the directory in the build output where Astro-generated assets (bundled JS and CSS for example) should live.
{
  build: {
    assets: '_custom'
  }
}
See Also:
outDir
build.assetsPrefix
Type: string | Record.<string, string>
Default: undefined
Added in: astro@2.2.0
Specifies the prefix for Astro-generated asset links. This can be used if assets are served from a different domain than the current site.
This requires uploading the assets in your local ./dist/_astro folder to a corresponding /_astro/ folder on the remote domain. To rename the _astro path, specify a new directory in build.assets.
To fetch all assets uploaded to the same domain (e.g. https://cdn.example.com/_astro/...), set assetsPrefix to the root domain as a string (regardless of your base configuration):
{
  build: {
    assetsPrefix: 'https://cdn.example.com'
  }
}
Added in: astro@4.5.0
You can also pass an object to assetsPrefix to specify a different domain for each file type. In this case, a fallback property is required and will be used by default for any other files.
{
  build: {
    assetsPrefix: {
      'js': 'https://js.cdn.example.com',
      'mjs': 'https://js.cdn.example.com',
      'css': 'https://css.cdn.example.com',
      'fallback': 'https://cdn.example.com'
    }
  }
}
build.serverEntry
Type: string
Default: 'entry.mjs'
Specifies the file name of the server entrypoint when building to SSR. This entrypoint is usually dependent on which host you are deploying to and will be set by your adapter for you.
Note that it is recommended that this file ends with .mjs so that the runtime detects that the file is a JavaScript module.
{
  build: {
    serverEntry: 'main.mjs'
  }
}
build.redirects
Type: boolean
Default: true
Added in: astro@2.6.0
Specifies whether redirects will be output to HTML during the build. This option only applies to output: 'static' mode; in SSR redirects are treated the same as all responses.
This option is mostly meant to be used by adapters that have special configuration files for redirects and do not need/want HTML based redirects.
{
  build: {
    redirects: false
  }
}
build.inlineStylesheets
Type: 'always' | 'auto' | 'never'
Default: auto
Added in: astro@2.6.0
Control whether project styles are sent to the browser in a separate css file or inlined into <style> tags. Choose from the following options:
'always' - project styles are inlined into <style> tags
'auto' - only stylesheets smaller than ViteConfig.build.assetsInlineLimit (default: 4kb) are inlined. Otherwise, project styles are sent in external stylesheets.
'never' - project styles are sent in external stylesheets
{
  build: {
    inlineStylesheets: 'never',
  },
}
build.concurrency
Type: number
Default: 1
Added in: astro@4.16.0 New
The number of pages to build in parallel.
In most cases, you should not change the default value of 1.
Use this option only when other attempts to reduce the overall rendering time (e.g. batch or cache long running tasks like fetch calls or data access) are not possible or are insufficient. If the number is set too high, page rendering may slow down due to insufficient memory resources and because JS is single-threaded.
{
  build: {
    concurrency: 2
  }
}
Breaking changes possible
This feature is stable and is not considered experimental. However, this feature is only intended to address difficult performance issues, and breaking changes may occur in a minor release to keep this option as performant as possible. Please check the Astro CHANGELOG for every minor release if you are using this feature.
Server Options
Customize the Astro dev server, used by both astro dev and astro preview.
{
  server: { port: 1234, host: true }
}
To set different configuration based on the command run (‚Äúdev‚Äù, ‚Äúpreview‚Äù) a function can also be passed to this configuration option.
{
  // Example: Use the function syntax to customize based on command
  server: ({ command }) => ({ port: command === 'dev' ? 4321 : 4000 })
}
server.host
Type: string | boolean
Default: false
Added in: astro@0.24.0
Set which network IP addresses the server should listen on (i.e. non-localhost IPs).
false - do not expose on a network IP address
true - listen on all addresses, including LAN and public addresses
[custom-address] - expose on a network IP address at [custom-address] (ex: 192.168.0.1)
server.port
Type: number
Default: 4321
Set which port the server should listen on.
If the given port is already in use, Astro will automatically try the next available port.
{
  server: { port: 8080 }
}
server.open
Type: string | boolean
Default: false
Added in: astro@4.1.0
Controls whether the dev server should open in your browser window on startup.
Pass a full URL string (e.g. ‚Äùhttp://example.com‚Äù) or a pathname (e.g. ‚Äú/about‚Äù) to specify the URL to open.
{
  server: { open: ""/about"" }
}
server.headers
Type: OutgoingHttpHeaders
Default: {}
Added in: astro@1.7.0
Set custom HTTP response headers to be sent in astro dev and astro preview.
Dev Toolbar Options
devToolbar.enabled
Type: boolean
Default: true
Whether to enable the Astro Dev Toolbar. This toolbar allows you to inspect your page islands, see helpful audits on performance and accessibility, and more.
This option is scoped to the entire project, to only disable the toolbar for yourself, run npm run astro preferences disable devToolbar. To disable the toolbar for all your Astro projects, run npm run astro preferences disable devToolbar --global.
Prefetch Options
Type: boolean | object
Enable prefetching for links on your site to provide faster page transitions. (Enabled by default on pages using the <ViewTransitions /> router. Set prefetch: false to opt out of this behaviour.)
This configuration automatically adds a prefetch script to every page in the project giving you access to the data-astro-prefetch attribute. Add this attribute to any <a /> link on your page to enable prefetching for that page.
<a href=""/about"" data-astro-prefetch>About</a>
Further customize the default prefetching behavior using the prefetch.defaultStrategy and prefetch.prefetchAll options.
See the Prefetch guide for more information.
prefetch.prefetchAll
Type: boolean
Enable prefetching for all links, including those without the data-astro-prefetch attribute. This value defaults to true when using the <ViewTransitions /> router. Otherwise, the default value is false.
prefetch: {
  prefetchAll: true
}
When set to true, you can disable prefetching individually by setting data-astro-prefetch=""false"" on any individual links.
<a href=""/about"" data-astro-prefetch=""false"">About</a>
prefetch.defaultStrategy
Type: 'tap' | 'hover' | 'viewport' | 'load'
Default: 'hover'
The default prefetch strategy to use when the data-astro-prefetch attribute is set on a link with no value.
'tap': Prefetch just before you click on the link.
'hover': Prefetch when you hover over or focus on the link. (default)
'viewport': Prefetch as the links enter the viewport.
'load': Prefetch all links on the page after the page is loaded.
You can override this default value and select a different strategy for any individual link by setting a value on the attribute.
<a href=""/about"" data-astro-prefetch=""viewport"">About</a>
Image Options
image.endpoint
Type: string
Default: undefined
Added in: astro@3.1.0
Set the endpoint to use for image optimization in dev and SSR. Set to undefined to use the default endpoint.
The endpoint will always be injected at /_image.
{
  image: {
    // Example: Use a custom image endpoint
    endpoint: './src/image-endpoint.ts',
  },
}
image.service
Type: Object
Default: {entrypoint: 'astro/assets/services/sharp', config?: {}}
Added in: astro@2.1.0
Set which image service is used for Astro‚Äôs assets support.
The value should be an object with an entrypoint for the image service to use and optionally, a config object to pass to the service.
The service entrypoint can be either one of the included services, or a third-party package.
{
  image: {
    // Example: Enable the Sharp-based image service with a custom config
    service: {
       entrypoint: 'astro/assets/services/sharp',
       config: {
         limitInputPixels: false,
      },
     },
  },
}
image.service.config.limitInputPixels
Type: number | boolean
Default: true
Added in: astro@4.1.0
Whether or not to limit the size of images that the Sharp image service will process.
Set false to bypass the default image size limit for the Sharp image service and process large images.
image.domains
Type: Array.<string>
Default: []
Added in: astro@2.10.10
Defines a list of permitted image source domains for remote image optimization. No other remote images will be optimized by Astro.
This option requires an array of individual domain names as strings. Wildcards are not permitted. Instead, use image.remotePatterns to define a list of allowed source URL patterns.
astro.config.mjs
{
  image: {
    // Example: Allow remote image optimization from a single domain
    domains: ['astro.build'],
  },
}
image.remotePatterns
Type: Array.<RemotePattern>
Default: {remotePatterns: []}
Added in: astro@2.10.10
Defines a list of permitted image source URL patterns for remote image optimization.
remotePatterns can be configured with four properties:
protocol
hostname
port
pathname
{
  image: {
    // Example: allow processing all images from your aws s3 bucket
    remotePatterns: [{
      protocol: 'https',
      hostname: '**.amazonaws.com',
    }],
  },
}
You can use wildcards to define the permitted hostname and pathname values as described below. Otherwise, only the exact values provided will be configured:
hostname:
Start with ‚Äô**.‚Äô to allow all subdomains (‚ÄòendsWith‚Äô).
Start with ‚Äô*.‚Äô to allow only one level of subdomain.
pathname:
End with ‚Äô/**‚Äô to allow all sub-routes (‚ÄòstartsWith‚Äô).
End with ‚Äô/*‚Äô to allow only one level of sub-route.
Markdown Options
markdown.shikiConfig
Type: Partial<ShikiConfig>
Shiki is our default syntax highlighter. You can configure all options via the markdown.shikiConfig object:
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  markdown: {
    shikiConfig: {
      // Choose from Shiki's built-in themes (or add your own)
      // https://shiki.style/themes
      theme: 'dracula',
      // Alternatively, provide multiple themes
      // See note below for using dual light/dark themes
      themes: {
        light: 'github-light',
        dark: 'github-dark',
      },
      // Disable the default colors
      // https://shiki.style/guide/dual-themes#without-default-color
      // (Added in v4.12.0)
      defaultColor: false,
      // Add custom languages
      // Note: Shiki has countless langs built-in, including .astro!
      // https://shiki.style/languages
      langs: [],
      // Add custom aliases for languages
      // Map an alias to a Shiki language ID: https://shiki.style/languages#bundled-languages
      // https://shiki.style/guide/load-lang#custom-language-aliases
      langAlias: {
        cjs: ""javascript""
      },
      // Enable word wrap to prevent horizontal scrolling
      wrap: true,
      // Add custom transformers: https://shiki.style/guide/transformers
      // Find common transformers: https://shiki.style/packages/transformers
      transformers: [],
    },
  },
});
See the code syntax highlighting guide for usage and examples.
markdown.syntaxHighlight
Type: 'shiki' | 'prism' | false
Default: shiki
Which syntax highlighter to use for Markdown code blocks (```), if any. This determines the CSS classes that Astro will apply to your Markdown code blocks.
shiki - use the Shiki highlighter (github-dark theme configured by default)
prism - use the Prism highlighter and provide your own Prism stylesheet
false - do not apply syntax highlighting.
{
  markdown: {
    // Example: Switch to use prism for syntax highlighting in Markdown
    syntaxHighlight: 'prism',
  }
}
markdown.remarkPlugins
Type: RemarkPlugins
Pass remark plugins to customize how your Markdown is built. You can import and apply the plugin function (recommended), or pass the plugin name as a string.
import remarkToc from 'remark-toc';
{
  markdown: {
    remarkPlugins: [ [remarkToc, { heading: ""contents"" }] ]
  }
}
markdown.rehypePlugins
Type: RehypePlugins
Pass rehype plugins to customize how your Markdown‚Äôs output HTML is processed. You can import and apply the plugin function (recommended), or pass the plugin name as a string.
import { rehypeAccessibleEmojis } from 'rehype-accessible-emojis';
{
  markdown: {
    rehypePlugins: [rehypeAccessibleEmojis]
  }
}
markdown.gfm
Type: boolean
Default: true
Added in: astro@2.0.0
Astro uses GitHub-flavored Markdown by default. To disable this, set the gfm flag to false:
{
  markdown: {
    gfm: false,
  }
}
markdown.smartypants
Type: boolean
Default: true
Added in: astro@2.0.0
Astro uses the SmartyPants formatter by default. To disable this, set the smartypants flag to false:
{
  markdown: {
    smartypants: false,
  }
}
markdown.remarkRehype
Type: RemarkRehype
Pass options to remark-rehype.
{
  markdown: {
    // Example: Translate the footnotes text to another language, here are the default English values
    remarkRehype: { footnoteLabel: ""Footnotes"", footnoteBackLabel: ""Back to reference 1"" },
  },
};
i18n
Type: object
Added in: astro@3.5.0
Configures i18n routing and allows you to specify some customization options.
See our guide for more information on internationalization in Astro
i18n.defaultLocale
Type: string
Added in: astro@3.5.0
The default locale of your website/application. This is a required field.
No particular language format or syntax is enforced, but we suggest using lower-case and hyphens as needed (e.g. ‚Äúes‚Äù, ‚Äúpt-br‚Äù) for greatest compatibility.
i18n.locales
Type: Locales
Added in: astro@3.5.0
A list of all locales supported by the website, including the defaultLocale. This is a required field.
Languages can be listed either as individual codes (e.g. ['en', 'es', 'pt-br']) or mapped to a shared path of codes (e.g. { path: ""english"", codes: [""en"", ""en-US""]}). These codes will be used to determine the URL structure of your deployed site.
No particular language code format or syntax is enforced, but your project folders containing your content files must match exactly the locales items in the list. In the case of multiple codes pointing to a custom URL path prefix, store your content files in a folder with the same name as the path configured.
i18n.fallback
Type: Record.<string, string>
Added in: astro@3.5.0
The fallback strategy when navigating to pages that do not exist (e.g. a translated page has not been created).
Use this object to declare a fallback locale route for each language you support. If no fallback is specified, then unavailable pages will return a 404.
Example
The following example configures your content fallback strategy to redirect unavailable pages in /pt-br/ to their es version, and unavailable pages in /fr/ to their en version. Unavailable /es/ pages will return a 404.
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""en"", ""fr"", ""pt-br"", ""es""],
    fallback: {
      pt: ""es"",
      fr: ""en""
    }
  }
})
i18n.routing
Type: Routing
Added in: astro@3.7.0
Controls the routing strategy to determine your site URLs. Set this based on your folder/URL path configuration for your default language.
i18n.routing.prefixDefaultLocale
Type: boolean
Default: false
Added in: astro@3.7.0
When false, only non-default languages will display a language prefix. The defaultLocale will not show a language prefix and content files do not exist in a localized folder. URLs will be of the form example.com/[locale]/content/ for all non-default languages, but example.com/content/ for the default locale.
When true, all URLs will display a language prefix. URLs will be of the form example.com/[locale]/content/ for every route, including the default language. Localized folders are used for every language, including the default.
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""en"", ""fr"", ""pt-br"", ""es""],
    routing: {
      prefixDefaultLocale: true,
    }
  }
})
i18n.routing.redirectToDefaultLocale
Type: boolean
Default: true
Added in: astro@4.2.0
Configures whether or not the home URL (/) generated by src/pages/index.astro will redirect to /[defaultLocale] when prefixDefaultLocale: true is set.
Set redirectToDefaultLocale: false to disable this automatic redirection at the root of your site:
astro.config.mjs
export default defineConfig({
  i18n:{
    defaultLocale: ""en"",
    locales: [""en"", ""fr""],
    routing: {
      prefixDefaultLocale: true,
      redirectToDefaultLocale: false
    }
  }
})
i18n.routing.fallbackType
Type: ""redirect"" | ""rewrite""
Default: ""redirect""
Added in: astro@4.15.0
When i18n.fallback is configured to avoid showing a 404 page for missing page routes, this option controls whether to redirect to the fallback page, or to rewrite the fallback page‚Äôs content in place.
By default, Astro‚Äôs i18n routing creates pages that redirect your visitors to a new destination based on your fallback configuration. The browser will refresh and show the destination address in the URL bar.
When i18n.routing.fallback: ""rewrite"" is configured, Astro will create pages that render the contents of the fallback page on the original, requested URL.
With the following configuration, if you have the file src/pages/en/about.astro but not src/pages/fr/about.astro, the astro build command will generate dist/fr/about.html with the same content as the dist/en/about.html page. Your site visitor will see the English version of the page at https://example.com/fr/about/ and will not be redirected.
astro.config.mjs
export default defineConfig({
   i18n: {
    defaultLocale: ""en"",
    locales: [""en"", ""fr""],
    routing: {
      prefixDefaultLocale: false,
      fallbackType: ""rewrite"",
    },
    fallback: {
      fr: ""en"",
    }
  },
})
i18n.routing.manual
Type: string
Added in: astro@4.6.0
When this option is enabled, Astro will disable its i18n middleware so that you can implement your own custom logic. No other routing options (e.g. prefixDefaultLocale) may be configured with routing: ""manual"".
You will be responsible for writing your own routing logic, or executing Astro‚Äôs i18n middleware manually alongside your own.
export default defineConfig({
  i18n: {
    defaultLocale: ""en"",
    locales: [""en"", ""fr"", ""pt-br"", ""es""],
    routing: {
      prefixDefaultLocale: true,
    }
  }
})
Legacy Flags
To help some users migrate between versions of Astro, we occasionally introduce legacy flags. These flags allow you to opt in to some deprecated or otherwise outdated behavior of Astro in the latest version, so that you can continue to upgrade and take advantage of new Astro releases.
Experimental Flags
Astro offers experimental flags to give users early access to new features. These flags are not guaranteed to be stable.
experimental.directRenderScript
Type: boolean
Default: false
Added in: astro@4.5.0
Enables a more reliable strategy to prevent scripts from being executed in pages where they are not used.
Scripts will directly render as declared in Astro files (including existing features like TypeScript, importing node_modules, and deduplicating scripts). You can also now conditionally render scripts in your Astro file. However, this means scripts are no longer hoisted to the <head> and multiple scripts on a page are no longer bundled together. If you enable this option, you should check that all your <script> tags behave as expected.
This option will be enabled by default in Astro 5.0.
{
  experimental: {
    directRenderScript: true,
  },
}
experimental.contentCollectionCache
Type: boolean
Default: false
Added in: astro@3.5.0
Enables a persistent cache for content collections when building in static mode.
{
  experimental: {
    contentCollectionCache: true,
  },
}
experimental.clientPrerender
Type: boolean
Default: false
Added in: astro@4.2.0
Enables pre-rendering your prefetched pages on the client in supported browsers.
This feature uses the experimental Speculation Rules Web API and enhances the default prefetch behavior globally to prerender links on the client. You may wish to review the possible risks when prerendering on the client before enabling this feature.
Enable client side prerendering in your astro.config.mjs along with any desired prefetch configuration options:
astro.config.mjs
{
  prefetch: {
    prefetchAll: true,
    defaultStrategy: 'viewport',
  },
  experimental: {
    clientPrerender: true,
  },
}
Continue to use the data-astro-prefetch attribute on any <a /> link on your site to opt in to prefetching. Instead of appending a <link> tag to the head of the document or fetching the page with JavaScript, a <script> tag will be appended with the corresponding speculation rules.
Client side prerendering requires browser support. If the Speculation Rules API is not supported, prefetch will fallback to the supported strategy.
See the Prefetch Guide for more prefetch options and usage.
experimental.globalRoutePriority
Type: boolean
Default: false
Added in: astro@4.2.0
Prioritizes redirects and injected routes equally alongside file-based project routes, following the same route priority order rules for all routes.
This allows more control over routing in your project by not automatically prioritizing certain types of routes, and standardizes the route priority ordering for all routes.
The following example shows which route will build certain page URLs when file-based routes, injected routes, and redirects are combined as shown below:
File-based route: /blog/post/[pid]
File-based route: /[page]
Injected route: /blog/[...slug]
Redirect: /blog/tags/[tag] -> /[tag]
Redirect: /posts -> /blog
With experimental.globalRoutingPriority enabled (instead of Astro 4.0 default route priority order):
/blog/tags/astro is built by the redirect to /tags/[tag] (instead of the injected route /blog/[...slug])
/blog/post/0 is built by the file-based route /blog/post/[pid] (instead of the injected route /blog/[...slug])
/posts is built by the redirect to /blog (instead of the file-based route /[page])
In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.
experimental.env
Type: object
Default: undefined
Added in: astro@4.10.0
Enables experimental astro:env features.
The astro:env API lets you configure a type-safe schema for your environment variables, and indicate whether they should be available on the server or the client. Import and use your defined variables from the appropriate /client or /server module:
---
import { API_URL } from ""astro:env/client""
import { API_SECRET_TOKEN } from ""astro:env/server""
const data = await fetch(`${API_URL}/users`, {
  method: ""GET"",
  headers: {
    ""Content-Type"": ""application/json"",
    ""Authorization"": `Bearer ${API_SECRET_TOKEN}`
  },
})
---
<script>
import { API_URL } from ""astro:env/client""
fetch(`${API_URL}/ping`)
</script>
To define the data type and properties of your environment variables, declare a schema in your Astro config in experimental.env.schema. The envField helper allows you define your variable as a string, number, or boolean and pass properties in an object:
astro.config.mjs
import { defineConfig, envField } from ""astro/config""
export default defineConfig({
    experimental: {
        env: {
            schema: {
                API_URL: envField.string({ context: ""client"", access: ""public"", optional: true }),
                PORT: envField.number({ context: ""server"", access: ""public"", default: 4321 }),
                API_SECRET: envField.string({ context: ""server"", access: ""secret"" }),
            }
        }
    }
})
There are currently four data types supported: strings, numbers, booleans and enums.
There are three kinds of environment variables, determined by the combination of context (client or server) and access (secret or public) settings defined in your env.schema:
Public client variables: These variables end up in both your final client and server bundles, and can be accessed from both client and server through the astro:env/client module:
import { API_URL } from ""astro:env/client""
Public server variables: These variables end up in your final server bundle and can be accessed on the server through the astro:env/server module:
import { PORT } from ""astro:env/server""
Secret server variables: These variables are not part of your final bundle and can be accessed on the server through the astro:env/server module. The getSecret() helper function can be used to retrieve secrets not specified in the schema. Its implementation is provided by your adapter and defaults to process.env:
import { API_SECRET, getSecret } from ""astro:env/server""
const SECRET_NOT_IN_SCHEMA = getSecret(""SECRET_NOT_IN_SCHEMA"") // string | undefined
Note: Secret client variables are not supported because there is no safe way to send this data to the client. Therefore, it is not possible to configure both context: ""client"" and access: ""secret"" in your schema.
For a complete overview, and to give feedback on this experimental API, see the Astro Env RFC.
experimental.env.schema
Type: EnvSchema
Default: undefined
Added in: astro@4.10.0
An object that uses envField to define the data type (string, number, or boolean) and properties of your environment variables: context (client or server), access (public or secret), a default value to use, and whether or not this environment variable is optional (defaults to false).
astro.config.mjs
import { defineConfig, envField } from ""astro/config""
export default defineConfig({
  experimental: {
    env: {
      schema: {
        API_URL: envField.string({ context: ""client"", access: ""public"", optional: true }),
        PORT: envField.number({ context: ""server"", access: ""public"", default: 4321 }),
        API_SECRET: envField.string({ context: ""server"", access: ""secret"" }),
      }
    }
  }
})
experimental.env.validateSecrets
Type: boolean
Default: false
Added in: astro@4.11.6
Whether or not to validate secrets on the server when starting the dev server or running a build.
By default, only public variables are validated on the server when starting the dev server or a build, and private variables are validated at runtime only. If enabled, private variables will also be checked on start. This is useful in some continuous integration (CI) pipelines to make sure all your secrets are correctly set before deploying.
astro.config.mjs
import { defineConfig, envField } from ""astro/config""
export default defineConfig({
  experimental: {
    env: {
      schema: {
        // ...
      },
      validateSecrets: true
    }
  }
})
experimental.serverIslands
Type: boolean
Default: false
Added in: astro@4.12.0
Enables experimental Server Island features. Server Islands offer the ability to defer a component to render asynchronously after the page has already rendered.
To enable, configure an on-demand server rendering output mode with an adapter, and add the serverIslands flag to the experimental object:
{
  output: 'hybrid', // or 'server'
  adapter: nodejs({ mode: 'standalone' }),
  experimental: {
    serverIslands: true,
  },
}
Use the server:defer directive on any Astro component to delay initial rendering:
---
import Avatar from '~/components/Avatar.astro';
---
<Avatar server:defer />
The outer page will be rendered, either at build time (hybrid) or at runtime (server) with the island content omitted and a <script> tag included in its place.
After the page loads in the browser, the script tag will replace itself with the contents of the island by making a request.
Any Astro component can be given the server: defer attribute to delay its rendering. There is no special API and you can write .astro code as normal:
---
import { getUser } from '../api';
const user = await getUser(Astro.locals.userId);
---
<img class=""avatar"" src={user.imageUrl}>
Server island fallback content
Since your component will not render with the rest of the page, you may want to add generic content (e.g. a loading message) to temporarily show in its place. This content will be displayed when the page first renders but before the island has loaded.
Add placeholder content as a child of your Astro component with the slot=""fallback"" attribute. When your island content is available, the fallback content will be replaced.
The example below displays a generic avatar as fallback content, then animates into a personalized avatar using view transitions:
<Avatar server:defer>
  <svg slot=""fallback"" class=""generic-avatar"" transition:name=""avatar"">...</svg>
</Avatar>
For a complete overview, and to give feedback on this experimental API, see the Server Islands RFC.
experimental.contentIntellisense
Type: boolean
Default: false
Added in: astro@4.14.0
Enables Intellisense features (e.g. code completion, quick hints) for your content collection entries in compatible editors.
When enabled, this feature will generate and add JSON schemas to the .astro directory in your project. These files can be used by the Astro language server to provide Intellisense inside content files (.md, .mdx, .mdoc).
{
  experimental: {
    contentIntellisense: true,
  },
}
To use this feature with the Astro VS Code extension, you must also enable the astro.content-intellisense option in your VS Code settings. For editors using the Astro language server directly, pass the contentIntellisense: true initialization parameter to enable this feature. See the content Intellisense implementation PR for more details about this early feature.
experimental.contentLayer
Type: boolean
Default: false
Added in: astro@4.14.0
The Content Layer API is a new way to handle content and data in Astro. It is similar to and builds upon content collections, taking them beyond local files in src/content/ and allowing you to fetch content from anywhere, including remote APIs, by adding a loader to your collection.
Your existing content collections can be migrated to the Content Layer API with a few small changes. However, it is not necessary to update all your collections at once to add a new collection powered by the Content Layer API. You may have collections using both the existing and new APIs defined in src/content/config.ts at the same time.
The Content Layer API is designed to be more powerful and more performant, helping sites scale to thousands of pages. Data is cached between builds and updated incrementally. Markdown parsing is also 5-10 times faster, with similar scale reductions in memory, and MDX is 2-3 times faster.
To enable, add the contentLayer flag to the experimental object in your Astro config:
astro.config.mjs
{
  experimental: {
    contentLayer: true,
  }
}
Fetching data with a loader
The Content Layer API allows you to fetch your content from outside of the src/content/ folder (whether stored locally in your project or remotely) and uses a loader property to retrieve your data.
The loader is defined in the collection‚Äôs schema and returns an array of entries. Astro provides two built-in loader functions (glob() and file()) for fetching your local content, as well as access to the API to construct your own loader and fetch remote data.
The glob() loader creates entries from directories of Markdown, MDX, Markdoc, or JSON files from anywhere on the filesystem. It accepts a pattern of entry files to match, and a base file path of where your files are located. Use this when you have one file per entry.
The file() loader creates multiple entries from a single local file. Use this when all your entries are stored in an array of objects.
src/content/config.ts
import { defineCollection, z } from 'astro:content';
import { glob, file } from 'astro/loaders';
const blog = defineCollection({
  // By default the ID is a slug generated from
  // the path of the file relative to `base`
  loader: glob({ pattern: ""**\/*.md"", base: ""./src/data/blog"" }),
  schema: z.object({
    title: z.string(),
    description: z.string(),
    pubDate: z.coerce.date(),
    updatedDate: z.coerce.date().optional(),
  })
});
const dogs = defineCollection({
  // The path is relative to the project root, or an absolute path.
  loader: file(""src/data/dogs.json""),
  schema: z.object({
    id: z.string(),
    breed: z.string(),
    temperament: z.array(z.string()),
  }),
});
export const collections = { blog, dogs };
Note
Loaders will not automatically exclude files prefaced with an _. Use a regular expression such as pattern: '**\/[^_]*.md' in your loader to ignore these files.
Querying and rendering with the Content Layer API
The collection can be queried in the same way as content collections:
src/pages/index.astro
import { getCollection, getEntry } from 'astro:content';
// Get all entries from a collection.
// Requires the name of the collection as an argument.
const allBlogPosts = await getCollection('blog');
// Get a single entry from a collection.
// Requires the name of the collection and ID
const labradorData = await getEntry('dogs', 'labrador-retriever');
Entries generated from Markdown, MDX, or Markdoc can be rendered directly to a page using the render() function.
Note
The syntax for rendering collection entries is different from the current content collections syntax.
src/pages/[slug].astro
---
import { getEntry, render } from 'astro:content';
const post = await getEntry('blog', Astro.params.slug);
const { Content, headings } = await render(post);
---
<Content />
Creating a loader
With the Content Layer API, you can build loaders to load or generate content from anywhere.
For example, you can create a loader that fetches collection entries from a remote API.
src/content/config.ts
const countries = defineCollection({
  loader: async () => {
    const response = await fetch(""https://restcountries.com/v3.1/all"");
    const data = await response.json();
    // Must return an array of entries with an id property,
    // or an object with IDs as keys and entries as values
    return data.map((country) => ({
      id: country.cca3,
      ...country,
    }));
  },
  // optionally add a schema
  // schema: z.object...
});
export const collections = { countries };
For more advanced loading logic, you can define an object loader. This allows incremental updates and conditional loading while also giving full access to the data store. See the API in the Content Layer API RFC.
Migrating an existing content collection to use the Content Layer API
You can convert an existing content collection with Markdown, MDX, Markdoc, or JSON entries to use the Content Layer API.
Move the collection folder out of src/content/ (e.g. to src/data/). All collections located in the src/content/ folder will use the existing Content Collections API.
Do not move the existing src/content/config.ts file. This file will define all collections, using either API.
Edit the collection definition. Your updated collection requires a loader, and the option to select a collection type is no longer available.
src/content/config.ts
import { defineCollection, z } from 'astro:content';
import { glob } from 'astro/loaders';
const blog = defineCollection({
  // For content layer you no longer define a `type`
  type: 'content',
  loader: glob({ pattern: '**\/[^_]*.md', base: ""./src/data/blog"" }),
  schema: z.object({
    title: z.string(),
    description: z.string(),
    pubDate: z.coerce.date(),
    updatedDate: z.coerce.date().optional(),
  }),
});
Change references from slug to id. Content layer collections do not have a slug field. Instead, all updated collections will have an id.
src/pages/index.astro
---
export async function getStaticPaths() {
  const posts = await getCollection('blog');
  return posts.map((post) => ({
    params: { slug: post.slug },
    params: { slug: post.id },
    props: post,
  }));
}
---
Switch to the new render() function. Entries no longer have a render() method, as they are now serializable plain objects. Instead, import the render() function from astro:content.
src/pages/index.astro
---
import { getEntry } from 'astro:content';
import { getEntry, render } from 'astro:content';
const post = await getEntry('blog', params.slug);
const { Content, headings } = await post.render();
const { Content, headings } = await render(post);
---
<Content />
Learn more
For a complete overview and the full API reference, see the Content Layer API RFC and share your feedback.
Edit page
Translate this page
Previous
Community Resources
Next
Astro CLI
Contribute
Give us feedback
Community""""""",11268,49437,astro
https://docs.astro.build/en/reference/cli-reference/,"""""""On this page
Overview
astro commands
package.json scripts
astro dev
astro build
astro preview
astro check
astro sync
astro add
astro docs
astro info
astro preferences
astro telemetry
Common flags
--root <path>
--config <path>
--outDir <path>
--site <url>
--base <pathname>
--port <number>
--host [optional host address]
--verbose
--silent
--open
Global flags
--version
--help
Advanced APIs (Experimental)
AstroInlineConfig
dev()
build()
preview()
sync()
Want to build your own Docs?
Grab this template to get started.‚Üí
CLI Commands
You can use the Command-Line Interface (CLI) provided by Astro to develop, build, and preview your project from a terminal window.
astro commands
Use the CLI by running one of the commands documented on this page with your preferred package manager, optionally followed by any flags. Flags customize the behavior of a command.
One of the commands you‚Äôll use most often is astro dev. This command starts the development server and gives you a live, updating preview of your site in a browser as you work:
npm
pnpm
Yarn
Terminal window
# start the development server
yarn astro dev
You can type astro --help in your terminal to display a list of all available commands:
npm
pnpm
Yarn
Terminal window
yarn astro --help
The following message will display in your terminal:
Terminal window
astro [command] [...flags]
Commands
              add  Add an integration.
            build  Build your project and write it to disk.
            check  Check your project for errors.
       create-key  Create a cryptography key
              dev  Start the development server.
             docs  Open documentation in your web browser.
             info  List info about your current Astro setup.
          preview  Preview your build locally.
             sync  Generate TypeScript types for all Astro modules.
      preferences  Configure user preferences.
        telemetry  Configure telemetry settings.
Global Flags
  --config <path>  Specify your config file.
    --root <path>  Specify your project root folder.
     --site <url>  Specify your project site.
--base <pathname>  Specify your project base.
        --verbose  Enable verbose logging.
         --silent  Disable all logging.
        --version  Show the version number and exit.
           --help  Show this help message.
You can add the --help flag after any command to get a list of all the flags for that command.
npm
pnpm
Yarn
Terminal window
# get a list of all flags for the `dev` command
yarn dev --help
The following message will display in your terminal:
Terminal window
astro dev [...flags]
Flags
                 --port  Specify which port to run on. Defaults to 4321.
                 --host  Listen on all addresses, including LAN and public addresses.
--host <custom-address>  Expose on a network IP address at <custom-address>
                 --open  Automatically open the app in the browser on server start
                --force  Clear the content layer cache, forcing a full rebuild.
            --help (-h)  See all available flags.
Note
The extra -- before any flag is necessary for npm to pass your flags to the astro command.
package.json scripts
You can also use scripts in package.json for shorter versions of these commands. Using a script allows you to use the same commands that you may be familiar with from other projects, such as npm run build.
The following scripts for the most common astro commands (astro dev, astro build, and astro preview) are added for you automatically when you create a project using the create astro wizard.
When you follow the instructions to install Astro manually, you are instructed to add these scripts yourself. You can also add more scripts to this list manually for any commands you use frequently.
package.json
{
  ""scripts"": {
    ""dev"": ""astro dev"",
    ""start"": ""astro dev"",
    ""build"": ""astro build"",
    ""preview"": ""astro preview""
  }
}
You will often use these astro commands, or the scripts that run them, without any flags. Add flags to the command when you want to customize the command‚Äôs behavior. For example, you may wish to start the development server on a different port, or build your site with verbose logs for debugging.
npm
pnpm
Yarn
Terminal window
# run the dev server on port 8080 using the `start` script in `package.json`
yarn start --port 8080
# build your site with verbose logs using the `build` script in `package.json`
yarn build --verbose
astro dev
Runs Astro‚Äôs development server. This is a local HTTP server that doesn‚Äôt bundle assets. It uses Hot Module Replacement (HMR) to update your browser as you save changes in your editor.
astro build
Builds your site for deployment. By default, this will generate static files and place them in a dist/ directory. If SSR is enabled, this will generate the necessary server files to serve your site.
Can be combined with the common flags documented below.
astro preview
Starts a local server to serve the contents of your static directory (dist/ by default) created by running astro build.
This command allows you to preview your site locally after building to catch any errors in your build output before deploying it. It is not designed to be run in production. For help with production hosting, check out our guide on Deploying an Astro Website.
Since Astro 1.5.0, astro preview also works for SSR builds if you use an adapter that supports it. Currently, only the Node adapter supports astro preview.
Can be combined with the common flags documented below.
astro check
Runs diagnostics (such as type-checking within .astro files) against your project and reports errors to the console. If any errors are found the process will exit with a code of 1.
This command is intended to be used in CI workflows.
Flags
Use these flags to customize the behavior of the command.
--watch
The command will watch for any changes in your project, and will report any errors.
--root <path-to-dir>
Specifies a different root directory to check. Uses the current working directory by default.
--tsconfig <path-to-file>
Specifies a tsconfig.json file to use manually. If not provided, Astro will attempt to find a config, or infer the project‚Äôs config automatically.
--minimumFailingSeverity <error|warning|hint>
Specifies the minimum severity needed to exit with an error code. Defaults to error.
For example, running astro check --minimumFailingSeverity warning will cause the command to exit with an error if any warnings are detected.
--minimumSeverity <error|warning|hint>
Specifies the minimum severity to output. Defaults to hint.
For example, running astro check --minimumSeverity warning will show errors and warning, but not hints.
--preserveWatchOutput
Specifies not to clear the ouput between checks when in watch mode.
--noSync
Specifies not to run astro sync before checking the project.
Read more about type checking in Astro.
astro sync
Added in: astro@2.0.0
Tip
Running astro dev, astro build or astro check will run the sync command as well.
Generates TypeScript types for all Astro modules. This sets up a src/env.d.ts file for type inferencing, and defines modules for features that rely on generated types:
The astro:content module for the Content Collections API.
The astro:db module for Astro DB.
The astro:env module for experimental Astro Env.
The astro:actions module for Astro Actions
astro add
Adds an integration to your configuration. Read more in the integrations guide.
astro docs
Launches the Astro Docs website directly from the terminal.
astro info
Reports useful information about your current Astro environment. Useful for providing information when opening an issue.
Terminal window
astro info
Example output:
Astro                    v3.0.12
Node                     v20.5.1
System                   macOS (arm64)
Package Manager          pnpm
Output                   server
Adapter                  @astrojs/vercel/serverless
Integrations             none
astro preferences
Manage user preferences with the astro preferences command. User preferences are specific to individual Astro users, unlike the astro.config.mjs file which changes behavior for everyone working on a project.
User preferences are scoped to the current project by default, stored in a local .astro/settings.json file.
Using the --global flag, user preferences can also be applied to every Astro project on the current machine. Global user preferences are stored in an operating system-specific location.
Available preferences
devToolbar ‚Äî Enable or disable the development toolbar in the browser. (Default: true)
checkUpdates ‚Äî Enable or disable automatic update checks for the Astro CLI. (Default: true)
The list command prints the current settings of all configurable user preferences. It also supports a machine-readable --json output.
Terminal window
astro preferences list
Example terminal output:
Preference Value
devToolbar.enabled true
checkUpdates.enabled true
You can enable, disable, or reset preferences to their default.
For example, to disable the devToolbar in a specific Astro project:
Terminal window
astro preferences disable devToolbar
To disable the devToolbar in all Astro projects on the current machine:
Terminal window
astro preferences disable --global devToolbar
The devToolbar can later be enabled with:
Terminal window
astro preferences enable devToolbar
The reset command resets a preference to its default value:
Terminal window
astro preferences reset devToolbar
astro telemetry
Sets telemetry configuration for the current CLI user. Telemetry is anonymous data that provides the Astro team insights into which Astro features are most often used. For more information see Astro‚Äôs telemetry page.
Telemetry can be disabled with this CLI command:
Terminal window
astro telemetry disable
Telemetry can later be re-enabled with:
Terminal window
astro telemetry enable
The reset command resets the telemetry data:
Terminal window
astro telemetry reset
Want to disable telemetry in CI environments?
Add the astro telemetry disable command to your CI scripts or set the ASTRO_TELEMETRY_DISABLED environment variable.
Common flags
--root <path>
Specifies the path to the project root. If not specified, the current working directory is assumed to be the root.
The root is used for finding the Astro configuration file.
Terminal window
astro --root myRootFolder/myProjectFolder dev
--config <path>
Specifies the path to the config file relative to the project root. Defaults to astro.config.mjs. Use this if you use a different name for your configuration file or have your config file in another folder.
Terminal window
astro --config config/astro.config.mjs dev
--outDir <path>
Added in: astro@3.3.0
Configures the outDir for your project. Passing this flag will override the outDir value in your astro.config.mjs file, if one exists.
--site <url>
Configures the site for your project. Passing this flag will override the site value in your astro.config.mjs file, if one exists.
--base <pathname>
Added in: astro@1.4.1
Configures the base for your project. Passing this flag will override the base value in your astro.config.mjs file, if one exists.
--port <number>
Specifies which port to run the dev server and preview server on. Defaults to 4321.
--host [optional host address]
Sets which network IP addresses the dev server and preview server should listen on (i.e. non-localhost IPs). This can be useful for testing your project on local devices like a mobile phone during development.
--host ‚Äî listen on all addresses, including LAN and public addresses
--host <custom-address> ‚Äî expose on a network IP address at <custom-address>
Caution
Do not use the --host flag to expose the dev server and preview server in a production environment. The servers are designed for local use while developing your site only.
--verbose
Enables verbose logging, which is helpful when debugging an issue.
--silent
Enables silent logging, which will run the server without any console output.
--open
Automatically opens the app in the browser on server start. Can be passed a full URL string (e.g. --open http://example.com) or a pathname (e.g. --open /about) to specify the URL to open.
Global flags
Use these flags to get information about the astro CLI.
--version
Prints the Astro version number and exits.
--help
Prints the help message and exits.
Advanced APIs (Experimental)
If you need more control when running Astro, the ""astro"" package also exports APIs to programmatically run the CLI commands.
These APIs are experimental and their API signature may change. Any updates will be mentioned in the Astro changelog and the information below will always show the current, up-to-date information.
AstroInlineConfig
The AstroInlineConfig type is used by all of the command APIs below. It extends from the user Astro config type:
interface AstroInlineConfig extends AstroUserConfig {
  configFile?: string | false;
  mode?: ""development"" | ""production"";
  logLevel?: ""debug"" | ""info"" | ""warn"" | ""error"" | ""silent"";
}
configFile
Type: string | false
Default: undefined
A custom path to the Astro config file.
If this value is undefined (default) or unset, Astro will search for an astro.config.(js,mjs,ts,mts) file relative to the root and load the config file if found.
If a relative path is set, it will resolve based on the root option.
Set to false to disable loading any config files.
The inline config passed in this object will take highest priority when merging with the loaded user config.
mode
Type: ""development"" | ""production""
Default: ""development"" when running astro dev, ""production"" when running astro build
The mode used when building your site to generate either ‚Äúdevelopment‚Äù or ‚Äúproduction‚Äù code.
logLevel
Type: ""debug"" | ""info"" | ""warn"" | ""error"" | ""silent""
Default: ""info""
The logging level to filter messages logged by Astro.
""debug"": Log everything, including noisy debugging diagnostics.
""info"": Log informational messages, warnings, and errors.
""warn"": Log warnings and errors.
""error"": Log errors only.
""silent"": No logging.
dev()
Type: (inlineConfig: AstroInlineConfig) => Promise<DevServer>
Similar to astro dev, it runs Astro‚Äôs development server.
import { dev } from ""astro"";
const devServer = await dev({
  root: ""./my-project"",
});
// Stop the server if needed
await devServer.stop();
DevServer
export interface DevServer {
  address: AddressInfo;
  handle: (req: http.IncomingMessage, res: http.ServerResponse<http.IncomingMessage>) => void;
  watcher: vite.FSWatcher;
  stop(): Promise<void>;
}
address
The address the dev server is listening on.
This property contains the value returned by Node‚Äôs net.Server#address() method.
handle()
A handle for raw Node HTTP requests. You can call handle() with an http.IncomingMessage and an http.ServerResponse instead of sending a request through the network.
watcher
The Chokidar file watcher as exposed by Vite‚Äôs development server.
stop()
Stops the development server. This closes all idle connections and stops listening for new connections.
Returns a Promise that resolves once all pending requests have been fulfilled and all idle connections have been closed.
build()
Type: (inlineConfig: AstroInlineConfig) => Promise<void>
Similar to astro build, it builds your site for deployment.
import { build } from ""astro"";
await build({
  root: ""./my-project"",
});
preview()
Type: (inlineConfig: AstroInlineConfig) => Promise<PreviewServer>
Similar to astro preview, it starts a local server to serve your build output.
If no adapter is set in the configuration, the preview server will only serve the built static files. If an adapter is set in the configuration, the preview server is provided by the adapter. Adapters are not required to provide a preview server, so this feature may not be available depending on your adapter of choice.
import { preview } from ""astro"";
const previewServer = await preview({
  root: ""./my-project"",
});
// Stop the server if needed
await previewServer.stop();
PreviewServer
export interface PreviewServer {
  host?: string;
  port: number;
  closed(): Promise<void>;
  stop(): Promise<void>;
}
host
The host where the server is listening for connections.
Adapters are allowed to leave this field unset. The value of host is implementation-specific.
port
The port where the server is listening for connections.
stop()
Asks the preview server to close, stop accepting requests, and drop idle connections.
The returned Promise resolves when the close request has been sent. This does not mean that the server has closed yet. Use the closed() method if you need to ensure the server has fully closed.
closed()
Returns a Promise that will resolve once the server is closed and reject if an error happens on the server.
sync()
Type: (inlineConfig: AstroInlineConfig) => Promise<void>
Similar to astro sync, it generates TypeScript types for all Astro modules.
import { sync } from ""astro"";
await sync({
  root: ""./my-project"",
});
Edit page
Translate this page
Previous
Configuration
Next
Directives Reference
Contribute
Give us feedback
Community

On this page
Overview
astro commands
package.json scripts
astro dev
astro build
astro preview
astro check
astro sync
astro add
astro docs
astro info
astro preferences
astro telemetry
Common flags
--root <path>
--config <path>
--outDir <path>
--site <url>
--base <pathname>
--port <number>
--host [optional host address]
--verbose
--silent
--open
Global flags
--version
--help
Advanced APIs (Experimental)
AstroInlineConfig
dev()
build()
preview()
sync()
Want to build your own Docs?
Grab this template to get started.‚Üí
CLI Commands
You can use the Command-Line Interface (CLI) provided by Astro to develop, build, and preview your project from a terminal window.
astro commands
Use the CLI by running one of the commands documented on this page with your preferred package manager, optionally followed by any flags. Flags customize the behavior of a command.
One of the commands you‚Äôll use most often is astro dev. This command starts the development server and gives you a live, updating preview of your site in a browser as you work:
npm
pnpm
Yarn
Terminal window
# start the development server
npx astro dev
You can type astro --help in your terminal to display a list of all available commands:
npm
pnpm
Yarn
Terminal window
npx astro --help
The following message will display in your terminal:
Terminal window
astro [command] [...flags]
Commands
              add  Add an integration.
            build  Build your project and write it to disk.
            check  Check your project for errors.
       create-key  Create a cryptography key
              dev  Start the development server.
             docs  Open documentation in your web browser.
             info  List info about your current Astro setup.
          preview  Preview your build locally.
             sync  Generate TypeScript types for all Astro modules.
      preferences  Configure user preferences.
        telemetry  Configure telemetry settings.
Global Flags
  --config <path>  Specify your config file.
    --root <path>  Specify your project root folder.
     --site <url>  Specify your project site.
--base <pathname>  Specify your project base.
        --verbose  Enable verbose logging.
         --silent  Disable all logging.
        --version  Show the version number and exit.
           --help  Show this help message.
You can add the --help flag after any command to get a list of all the flags for that command.
npm
pnpm
Yarn
Terminal window
# get a list of all flags for the `dev` command
npm run dev -- --help
The following message will display in your terminal:
Terminal window
astro dev [...flags]
Flags
                 --port  Specify which port to run on. Defaults to 4321.
                 --host  Listen on all addresses, including LAN and public addresses.
--host <custom-address>  Expose on a network IP address at <custom-address>
                 --open  Automatically open the app in the browser on server start
                --force  Clear the content layer cache, forcing a full rebuild.
            --help (-h)  See all available flags.
Note
The extra -- before any flag is necessary for npm to pass your flags to the astro command.
package.json scripts
You can also use scripts in package.json for shorter versions of these commands. Using a script allows you to use the same commands that you may be familiar with from other projects, such as npm run build.
The following scripts for the most common astro commands (astro dev, astro build, and astro preview) are added for you automatically when you create a project using the create astro wizard.
When you follow the instructions to install Astro manually, you are instructed to add these scripts yourself. You can also add more scripts to this list manually for any commands you use frequently.
package.json
{
  ""scripts"": {
    ""dev"": ""astro dev"",
    ""start"": ""astro dev"",
    ""build"": ""astro build"",
    ""preview"": ""astro preview""
  }
}
You will often use these astro commands, or the scripts that run them, without any flags. Add flags to the command when you want to customize the command‚Äôs behavior. For example, you may wish to start the development server on a different port, or build your site with verbose logs for debugging.
npm
pnpm
Yarn
Terminal window
# run the dev server on port 8080 using the `start` script in `package.json`
npm run start -- --port 8080
# build your site with verbose logs using the `build` script in `package.json`
npm run build -- --verbose
astro dev
Runs Astro‚Äôs development server. This is a local HTTP server that doesn‚Äôt bundle assets. It uses Hot Module Replacement (HMR) to update your browser as you save changes in your editor.
astro build
Builds your site for deployment. By default, this will generate static files and place them in a dist/ directory. If SSR is enabled, this will generate the necessary server files to serve your site.
Can be combined with the common flags documented below.
astro preview
Starts a local server to serve the contents of your static directory (dist/ by default) created by running astro build.
This command allows you to preview your site locally after building to catch any errors in your build output before deploying it. It is not designed to be run in production. For help with production hosting, check out our guide on Deploying an Astro Website.
Since Astro 1.5.0, astro preview also works for SSR builds if you use an adapter that supports it. Currently, only the Node adapter supports astro preview.
Can be combined with the common flags documented below.
astro check
Runs diagnostics (such as type-checking within .astro files) against your project and reports errors to the console. If any errors are found the process will exit with a code of 1.
This command is intended to be used in CI workflows.
Flags
Use these flags to customize the behavior of the command.
--watch
The command will watch for any changes in your project, and will report any errors.
--root <path-to-dir>
Specifies a different root directory to check. Uses the current working directory by default.
--tsconfig <path-to-file>
Specifies a tsconfig.json file to use manually. If not provided, Astro will attempt to find a config, or infer the project‚Äôs config automatically.
--minimumFailingSeverity <error|warning|hint>
Specifies the minimum severity needed to exit with an error code. Defaults to error.
For example, running astro check --minimumFailingSeverity warning will cause the command to exit with an error if any warnings are detected.
--minimumSeverity <error|warning|hint>
Specifies the minimum severity to output. Defaults to hint.
For example, running astro check --minimumSeverity warning will show errors and warning, but not hints.
--preserveWatchOutput
Specifies not to clear the ouput between checks when in watch mode.
--noSync
Specifies not to run astro sync before checking the project.
Read more about type checking in Astro.
astro sync
Added in: astro@2.0.0
Tip
Running astro dev, astro build or astro check will run the sync command as well.
Generates TypeScript types for all Astro modules. This sets up a src/env.d.ts file for type inferencing, and defines modules for features that rely on generated types:
The astro:content module for the Content Collections API.
The astro:db module for Astro DB.
The astro:env module for experimental Astro Env.
The astro:actions module for Astro Actions
astro add
Adds an integration to your configuration. Read more in the integrations guide.
astro docs
Launches the Astro Docs website directly from the terminal.
astro info
Reports useful information about your current Astro environment. Useful for providing information when opening an issue.
Terminal window
astro info
Example output:
Astro                    v3.0.12
Node                     v20.5.1
System                   macOS (arm64)
Package Manager          pnpm
Output                   server
Adapter                  @astrojs/vercel/serverless
Integrations             none
astro preferences
Manage user preferences with the astro preferences command. User preferences are specific to individual Astro users, unlike the astro.config.mjs file which changes behavior for everyone working on a project.
User preferences are scoped to the current project by default, stored in a local .astro/settings.json file.
Using the --global flag, user preferences can also be applied to every Astro project on the current machine. Global user preferences are stored in an operating system-specific location.
Available preferences
devToolbar ‚Äî Enable or disable the development toolbar in the browser. (Default: true)
checkUpdates ‚Äî Enable or disable automatic update checks for the Astro CLI. (Default: true)
The list command prints the current settings of all configurable user preferences. It also supports a machine-readable --json output.
Terminal window
astro preferences list
Example terminal output:
Preference Value
devToolbar.enabled true
checkUpdates.enabled true
You can enable, disable, or reset preferences to their default.
For example, to disable the devToolbar in a specific Astro project:
Terminal window
astro preferences disable devToolbar
To disable the devToolbar in all Astro projects on the current machine:
Terminal window
astro preferences disable --global devToolbar
The devToolbar can later be enabled with:
Terminal window
astro preferences enable devToolbar
The reset command resets a preference to its default value:
Terminal window
astro preferences reset devToolbar
astro telemetry
Sets telemetry configuration for the current CLI user. Telemetry is anonymous data that provides the Astro team insights into which Astro features are most often used. For more information see Astro‚Äôs telemetry page.
Telemetry can be disabled with this CLI command:
Terminal window
astro telemetry disable
Telemetry can later be re-enabled with:
Terminal window
astro telemetry enable
The reset command resets the telemetry data:
Terminal window
astro telemetry reset
Want to disable telemetry in CI environments?
Add the astro telemetry disable command to your CI scripts or set the ASTRO_TELEMETRY_DISABLED environment variable.
Common flags
--root <path>
Specifies the path to the project root. If not specified, the current working directory is assumed to be the root.
The root is used for finding the Astro configuration file.
Terminal window
astro --root myRootFolder/myProjectFolder dev
--config <path>
Specifies the path to the config file relative to the project root. Defaults to astro.config.mjs. Use this if you use a different name for your configuration file or have your config file in another folder.
Terminal window
astro --config config/astro.config.mjs dev
--outDir <path>
Added in: astro@3.3.0
Configures the outDir for your project. Passing this flag will override the outDir value in your astro.config.mjs file, if one exists.
--site <url>
Configures the site for your project. Passing this flag will override the site value in your astro.config.mjs file, if one exists.
--base <pathname>
Added in: astro@1.4.1
Configures the base for your project. Passing this flag will override the base value in your astro.config.mjs file, if one exists.
--port <number>
Specifies which port to run the dev server and preview server on. Defaults to 4321.
--host [optional host address]
Sets which network IP addresses the dev server and preview server should listen on (i.e. non-localhost IPs). This can be useful for testing your project on local devices like a mobile phone during development.
--host ‚Äî listen on all addresses, including LAN and public addresses
--host <custom-address> ‚Äî expose on a network IP address at <custom-address>
Caution
Do not use the --host flag to expose the dev server and preview server in a production environment. The servers are designed for local use while developing your site only.
--verbose
Enables verbose logging, which is helpful when debugging an issue.
--silent
Enables silent logging, which will run the server without any console output.
--open
Automatically opens the app in the browser on server start. Can be passed a full URL string (e.g. --open http://example.com) or a pathname (e.g. --open /about) to specify the URL to open.
Global flags
Use these flags to get information about the astro CLI.
--version
Prints the Astro version number and exits.
--help
Prints the help message and exits.
Advanced APIs (Experimental)
If you need more control when running Astro, the ""astro"" package also exports APIs to programmatically run the CLI commands.
These APIs are experimental and their API signature may change. Any updates will be mentioned in the Astro changelog and the information below will always show the current, up-to-date information.
AstroInlineConfig
The AstroInlineConfig type is used by all of the command APIs below. It extends from the user Astro config type:
interface AstroInlineConfig extends AstroUserConfig {
  configFile?: string | false;
  mode?: ""development"" | ""production"";
  logLevel?: ""debug"" | ""info"" | ""warn"" | ""error"" | ""silent"";
}
configFile
Type: string | false
Default: undefined
A custom path to the Astro config file.
If this value is undefined (default) or unset, Astro will search for an astro.config.(js,mjs,ts,mts) file relative to the root and load the config file if found.
If a relative path is set, it will resolve based on the root option.
Set to false to disable loading any config files.
The inline config passed in this object will take highest priority when merging with the loaded user config.
mode
Type: ""development"" | ""production""
Default: ""development"" when running astro dev, ""production"" when running astro build
The mode used when building your site to generate either ‚Äúdevelopment‚Äù or ‚Äúproduction‚Äù code.
logLevel
Type: ""debug"" | ""info"" | ""warn"" | ""error"" | ""silent""
Default: ""info""
The logging level to filter messages logged by Astro.
""debug"": Log everything, including noisy debugging diagnostics.
""info"": Log informational messages, warnings, and errors.
""warn"": Log warnings and errors.
""error"": Log errors only.
""silent"": No logging.
dev()
Type: (inlineConfig: AstroInlineConfig) => Promise<DevServer>
Similar to astro dev, it runs Astro‚Äôs development server.
import { dev } from ""astro"";
const devServer = await dev({
  root: ""./my-project"",
});
// Stop the server if needed
await devServer.stop();
DevServer
export interface DevServer {
  address: AddressInfo;
  handle: (req: http.IncomingMessage, res: http.ServerResponse<http.IncomingMessage>) => void;
  watcher: vite.FSWatcher;
  stop(): Promise<void>;
}
address
The address the dev server is listening on.
This property contains the value returned by Node‚Äôs net.Server#address() method.
handle()
A handle for raw Node HTTP requests. You can call handle() with an http.IncomingMessage and an http.ServerResponse instead of sending a request through the network.
watcher
The Chokidar file watcher as exposed by Vite‚Äôs development server.
stop()
Stops the development server. This closes all idle connections and stops listening for new connections.
Returns a Promise that resolves once all pending requests have been fulfilled and all idle connections have been closed.
build()
Type: (inlineConfig: AstroInlineConfig) => Promise<void>
Similar to astro build, it builds your site for deployment.
import { build } from ""astro"";
await build({
  root: ""./my-project"",
});
preview()
Type: (inlineConfig: AstroInlineConfig) => Promise<PreviewServer>
Similar to astro preview, it starts a local server to serve your build output.
If no adapter is set in the configuration, the preview server will only serve the built static files. If an adapter is set in the configuration, the preview server is provided by the adapter. Adapters are not required to provide a preview server, so this feature may not be available depending on your adapter of choice.
import { preview } from ""astro"";
const previewServer = await preview({
  root: ""./my-project"",
});
// Stop the server if needed
await previewServer.stop();
PreviewServer
export interface PreviewServer {
  host?: string;
  port: number;
  closed(): Promise<void>;
  stop(): Promise<void>;
}
host
The host where the server is listening for connections.
Adapters are allowed to leave this field unset. The value of host is implementation-specific.
port
The port where the server is listening for connections.
stop()
Asks the preview server to close, stop accepting requests, and drop idle connections.
The returned Promise resolves when the close request has been sent. This does not mean that the server has closed yet. Use the closed() method if you need to ensure the server has fully closed.
closed()
Returns a Promise that will resolve once the server is closed and reject if an error happens on the server.
sync()
Type: (inlineConfig: AstroInlineConfig) => Promise<void>
Similar to astro sync, it generates TypeScript types for all Astro modules.
import { sync } from ""astro"";
await sync({
  root: ""./my-project"",
});
Edit page
Translate this page
Previous
Configuration
Next
Directives Reference
Contribute
Give us feedback
Community

On this page
Overview
astro commands
package.json scripts
astro dev
astro build
astro preview
astro check
astro sync
astro add
astro docs
astro info
astro preferences
astro telemetry
Common flags
--root <path>
--config <path>
--outDir <path>
--site <url>
--base <pathname>
--port <number>
--host [optional host address]
--verbose
--silent
--open
Global flags
--version
--help
Advanced APIs (Experimental)
AstroInlineConfig
dev()
build()
preview()
sync()
Want to build your own Docs?
Grab this template to get started.‚Üí
CLI Commands
You can use the Command-Line Interface (CLI) provided by Astro to develop, build, and preview your project from a terminal window.
astro commands
Use the CLI by running one of the commands documented on this page with your preferred package manager, optionally followed by any flags. Flags customize the behavior of a command.
One of the commands you‚Äôll use most often is astro dev. This command starts the development server and gives you a live, updating preview of your site in a browser as you work:
npm
pnpm
Yarn
Terminal window
# start the development server
pnpm astro dev
You can type astro --help in your terminal to display a list of all available commands:
npm
pnpm
Yarn
Terminal window
pnpm astro --help
The following message will display in your terminal:
Terminal window
astro [command] [...flags]
Commands
              add  Add an integration.
            build  Build your project and write it to disk.
            check  Check your project for errors.
       create-key  Create a cryptography key
              dev  Start the development server.
             docs  Open documentation in your web browser.
             info  List info about your current Astro setup.
          preview  Preview your build locally.
             sync  Generate TypeScript types for all Astro modules.
      preferences  Configure user preferences.
        telemetry  Configure telemetry settings.
Global Flags
  --config <path>  Specify your config file.
    --root <path>  Specify your project root folder.
     --site <url>  Specify your project site.
--base <pathname>  Specify your project base.
        --verbose  Enable verbose logging.
         --silent  Disable all logging.
        --version  Show the version number and exit.
           --help  Show this help message.
You can add the --help flag after any command to get a list of all the flags for that command.
npm
pnpm
Yarn
Terminal window
# get a list of all flags for the `dev` command
pnpm dev --help
The following message will display in your terminal:
Terminal window
astro dev [...flags]
Flags
                 --port  Specify which port to run on. Defaults to 4321.
                 --host  Listen on all addresses, including LAN and public addresses.
--host <custom-address>  Expose on a network IP address at <custom-address>
                 --open  Automatically open the app in the browser on server start
                --force  Clear the content layer cache, forcing a full rebuild.
            --help (-h)  See all available flags.
Note
The extra -- before any flag is necessary for npm to pass your flags to the astro command.
package.json scripts
You can also use scripts in package.json for shorter versions of these commands. Using a script allows you to use the same commands that you may be familiar with from other projects, such as npm run build.
The following scripts for the most common astro commands (astro dev, astro build, and astro preview) are added for you automatically when you create a project using the create astro wizard.
When you follow the instructions to install Astro manually, you are instructed to add these scripts yourself. You can also add more scripts to this list manually for any commands you use frequently.
package.json
{
  ""scripts"": {
    ""dev"": ""astro dev"",
    ""start"": ""astro dev"",
    ""build"": ""astro build"",
    ""preview"": ""astro preview""
  }
}
You will often use these astro commands, or the scripts that run them, without any flags. Add flags to the command when you want to customize the command‚Äôs behavior. For example, you may wish to start the development server on a different port, or build your site with verbose logs for debugging.
npm
pnpm
Yarn
Terminal window
# run the dev server on port 8080 using the `start` script in `package.json`
pnpm start --port 8080
# build your site with verbose logs using the `build` script in `package.json`
pnpm build --verbose
astro dev
Runs Astro‚Äôs development server. This is a local HTTP server that doesn‚Äôt bundle assets. It uses Hot Module Replacement (HMR) to update your browser as you save changes in your editor.
astro build
Builds your site for deployment. By default, this will generate static files and place them in a dist/ directory. If SSR is enabled, this will generate the necessary server files to serve your site.
Can be combined with the common flags documented below.
astro preview
Starts a local server to serve the contents of your static directory (dist/ by default) created by running astro build.
This command allows you to preview your site locally after building to catch any errors in your build output before deploying it. It is not designed to be run in production. For help with production hosting, check out our guide on Deploying an Astro Website.
Since Astro 1.5.0, astro preview also works for SSR builds if you use an adapter that supports it. Currently, only the Node adapter supports astro preview.
Can be combined with the common flags documented below.
astro check
Runs diagnostics (such as type-checking within .astro files) against your project and reports errors to the console. If any errors are found the process will exit with a code of 1.
This command is intended to be used in CI workflows.
Flags
Use these flags to customize the behavior of the command.
--watch
The command will watch for any changes in your project, and will report any errors.
--root <path-to-dir>
Specifies a different root directory to check. Uses the current working directory by default.
--tsconfig <path-to-file>
Specifies a tsconfig.json file to use manually. If not provided, Astro will attempt to find a config, or infer the project‚Äôs config automatically.
--minimumFailingSeverity <error|warning|hint>
Specifies the minimum severity needed to exit with an error code. Defaults to error.
For example, running astro check --minimumFailingSeverity warning will cause the command to exit with an error if any warnings are detected.
--minimumSeverity <error|warning|hint>
Specifies the minimum severity to output. Defaults to hint.
For example, running astro check --minimumSeverity warning will show errors and warning, but not hints.
--preserveWatchOutput
Specifies not to clear the ouput between checks when in watch mode.
--noSync
Specifies not to run astro sync before checking the project.
Read more about type checking in Astro.
astro sync
Added in: astro@2.0.0
Tip
Running astro dev, astro build or astro check will run the sync command as well.
Generates TypeScript types for all Astro modules. This sets up a src/env.d.ts file for type inferencing, and defines modules for features that rely on generated types:
The astro:content module for the Content Collections API.
The astro:db module for Astro DB.
The astro:env module for experimental Astro Env.
The astro:actions module for Astro Actions
astro add
Adds an integration to your configuration. Read more in the integrations guide.
astro docs
Launches the Astro Docs website directly from the terminal.
astro info
Reports useful information about your current Astro environment. Useful for providing information when opening an issue.
Terminal window
astro info
Example output:
Astro                    v3.0.12
Node                     v20.5.1
System                   macOS (arm64)
Package Manager          pnpm
Output                   server
Adapter                  @astrojs/vercel/serverless
Integrations             none
astro preferences
Manage user preferences with the astro preferences command. User preferences are specific to individual Astro users, unlike the astro.config.mjs file which changes behavior for everyone working on a project.
User preferences are scoped to the current project by default, stored in a local .astro/settings.json file.
Using the --global flag, user preferences can also be applied to every Astro project on the current machine. Global user preferences are stored in an operating system-specific location.
Available preferences
devToolbar ‚Äî Enable or disable the development toolbar in the browser. (Default: true)
checkUpdates ‚Äî Enable or disable automatic update checks for the Astro CLI. (Default: true)
The list command prints the current settings of all configurable user preferences. It also supports a machine-readable --json output.
Terminal window
astro preferences list
Example terminal output:
Preference Value
devToolbar.enabled true
checkUpdates.enabled true
You can enable, disable, or reset preferences to their default.
For example, to disable the devToolbar in a specific Astro project:
Terminal window
astro preferences disable devToolbar
To disable the devToolbar in all Astro projects on the current machine:
Terminal window
astro preferences disable --global devToolbar
The devToolbar can later be enabled with:
Terminal window
astro preferences enable devToolbar
The reset command resets a preference to its default value:
Terminal window
astro preferences reset devToolbar
astro telemetry
Sets telemetry configuration for the current CLI user. Telemetry is anonymous data that provides the Astro team insights into which Astro features are most often used. For more information see Astro‚Äôs telemetry page.
Telemetry can be disabled with this CLI command:
Terminal window
astro telemetry disable
Telemetry can later be re-enabled with:
Terminal window
astro telemetry enable
The reset command resets the telemetry data:
Terminal window
astro telemetry reset
Want to disable telemetry in CI environments?
Add the astro telemetry disable command to your CI scripts or set the ASTRO_TELEMETRY_DISABLED environment variable.
Common flags
--root <path>
Specifies the path to the project root. If not specified, the current working directory is assumed to be the root.
The root is used for finding the Astro configuration file.
Terminal window
astro --root myRootFolder/myProjectFolder dev
--config <path>
Specifies the path to the config file relative to the project root. Defaults to astro.config.mjs. Use this if you use a different name for your configuration file or have your config file in another folder.
Terminal window
astro --config config/astro.config.mjs dev
--outDir <path>
Added in: astro@3.3.0
Configures the outDir for your project. Passing this flag will override the outDir value in your astro.config.mjs file, if one exists.
--site <url>
Configures the site for your project. Passing this flag will override the site value in your astro.config.mjs file, if one exists.
--base <pathname>
Added in: astro@1.4.1
Configures the base for your project. Passing this flag will override the base value in your astro.config.mjs file, if one exists.
--port <number>
Specifies which port to run the dev server and preview server on. Defaults to 4321.
--host [optional host address]
Sets which network IP addresses the dev server and preview server should listen on (i.e. non-localhost IPs). This can be useful for testing your project on local devices like a mobile phone during development.
--host ‚Äî listen on all addresses, including LAN and public addresses
--host <custom-address> ‚Äî expose on a network IP address at <custom-address>
Caution
Do not use the --host flag to expose the dev server and preview server in a production environment. The servers are designed for local use while developing your site only.
--verbose
Enables verbose logging, which is helpful when debugging an issue.
--silent
Enables silent logging, which will run the server without any console output.
--open
Automatically opens the app in the browser on server start. Can be passed a full URL string (e.g. --open http://example.com) or a pathname (e.g. --open /about) to specify the URL to open.
Global flags
Use these flags to get information about the astro CLI.
--version
Prints the Astro version number and exits.
--help
Prints the help message and exits.
Advanced APIs (Experimental)
If you need more control when running Astro, the ""astro"" package also exports APIs to programmatically run the CLI commands.
These APIs are experimental and their API signature may change. Any updates will be mentioned in the Astro changelog and the information below will always show the current, up-to-date information.
AstroInlineConfig
The AstroInlineConfig type is used by all of the command APIs below. It extends from the user Astro config type:
interface AstroInlineConfig extends AstroUserConfig {
  configFile?: string | false;
  mode?: ""development"" | ""production"";
  logLevel?: ""debug"" | ""info"" | ""warn"" | ""error"" | ""silent"";
}
configFile
Type: string | false
Default: undefined
A custom path to the Astro config file.
If this value is undefined (default) or unset, Astro will search for an astro.config.(js,mjs,ts,mts) file relative to the root and load the config file if found.
If a relative path is set, it will resolve based on the root option.
Set to false to disable loading any config files.
The inline config passed in this object will take highest priority when merging with the loaded user config.
mode
Type: ""development"" | ""production""
Default: ""development"" when running astro dev, ""production"" when running astro build
The mode used when building your site to generate either ‚Äúdevelopment‚Äù or ‚Äúproduction‚Äù code.
logLevel
Type: ""debug"" | ""info"" | ""warn"" | ""error"" | ""silent""
Default: ""info""
The logging level to filter messages logged by Astro.
""debug"": Log everything, including noisy debugging diagnostics.
""info"": Log informational messages, warnings, and errors.
""warn"": Log warnings and errors.
""error"": Log errors only.
""silent"": No logging.
dev()
Type: (inlineConfig: AstroInlineConfig) => Promise<DevServer>
Similar to astro dev, it runs Astro‚Äôs development server.
import { dev } from ""astro"";
const devServer = await dev({
  root: ""./my-project"",
});
// Stop the server if needed
await devServer.stop();
DevServer
export interface DevServer {
  address: AddressInfo;
  handle: (req: http.IncomingMessage, res: http.ServerResponse<http.IncomingMessage>) => void;
  watcher: vite.FSWatcher;
  stop(): Promise<void>;
}
address
The address the dev server is listening on.
This property contains the value returned by Node‚Äôs net.Server#address() method.
handle()
A handle for raw Node HTTP requests. You can call handle() with an http.IncomingMessage and an http.ServerResponse instead of sending a request through the network.
watcher
The Chokidar file watcher as exposed by Vite‚Äôs development server.
stop()
Stops the development server. This closes all idle connections and stops listening for new connections.
Returns a Promise that resolves once all pending requests have been fulfilled and all idle connections have been closed.
build()
Type: (inlineConfig: AstroInlineConfig) => Promise<void>
Similar to astro build, it builds your site for deployment.
import { build } from ""astro"";
await build({
  root: ""./my-project"",
});
preview()
Type: (inlineConfig: AstroInlineConfig) => Promise<PreviewServer>
Similar to astro preview, it starts a local server to serve your build output.
If no adapter is set in the configuration, the preview server will only serve the built static files. If an adapter is set in the configuration, the preview server is provided by the adapter. Adapters are not required to provide a preview server, so this feature may not be available depending on your adapter of choice.
import { preview } from ""astro"";
const previewServer = await preview({
  root: ""./my-project"",
});
// Stop the server if needed
await previewServer.stop();
PreviewServer
export interface PreviewServer {
  host?: string;
  port: number;
  closed(): Promise<void>;
  stop(): Promise<void>;
}
host
The host where the server is listening for connections.
Adapters are allowed to leave this field unset. The value of host is implementation-specific.
port
The port where the server is listening for connections.
stop()
Asks the preview server to close, stop accepting requests, and drop idle connections.
The returned Promise resolves when the close request has been sent. This does not mean that the server has closed yet. Use the closed() method if you need to ensure the server has fully closed.
closed()
Returns a Promise that will resolve once the server is closed and reject if an error happens on the server.
sync()
Type: (inlineConfig: AstroInlineConfig) => Promise<void>
Similar to astro sync, it generates TypeScript types for all Astro modules.
import { sync } from ""astro"";
await sync({
  root: ""./my-project"",
});
Edit page
Translate this page
Previous
Configuration
Next
Directives Reference
Contribute
Give us feedback
Community""""""",10895,51017,astro
https://docs.astro.build/en/reference/directives-reference/,"""""""On this page
Overview
Rules
Common Directives
class:list
set:html
set:text
Client Directives
client:load
client:idle
timeout
client:visible
client:media
client:only
Custom Client Directives
Script & Style Directives
is:global
is:inline
define:vars
Advanced Directives
is:raw
Want to build your own Docs?
Grab this template to get started.‚Üí
Template Directives Reference
Template directives are a special kind of HTML attribute available inside of any Astro component template (.astro files), and some can also be used in .mdx files.
Template directives are used to control an element or component‚Äôs behavior in some way. A template directive could enable some compiler feature that makes your life easier (like using class:list instead of class). Or, a directive could tell the Astro compiler to do something special with that component (like hydrating with client:load).
This page describes all of the template directives available to you in Astro, and how they work.
Rules
For a template directive to be valid, it must:
Include a colon : in its name, using the form X:Y (ex: client:load).
Be visible to the compiler (ex: <X {...attr}> would not work if attr contained a directive).
Some template directives, but not all, can take a custom value:
<X client:load /> (takes no value)
<X class:list={['some-css-class']} /> (takes an array)
A template directive is never included directly in the final HTML output of a component.
Common Directives
class:list
class:list={...} takes an array of class values and converts them into a class string. This is powered by @lukeed‚Äôs popular clsx helper library.
class:list takes an array of several different possible value kinds:
string: Added to the element class
Object: All truthy keys are added to the element class
Array: flattened
false, null, or undefined: skipped
<!-- This -->
<span class:list={[ 'hello goodbye', { world: true }, [ 'friend' ] ]} />
<!-- Becomes -->
<span class=""hello goodbye world friend""></span>
set:html
set:html={string} injects an HTML string into an element, similar to setting el.innerHTML.
The value is not automatically escaped by Astro! Be sure that you trust the value, or that you have escaped it manually before passing it to the template. Forgetting to do this will open you up to Cross Site Scripting (XSS) attacks.
---
const rawHTMLString = ""Hello <strong>World</strong>""
---
<h1>{rawHTMLString}</h1>
  <!-- Output: <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->
<h1 set:html={rawHTMLString} />
  <!-- Output: <h1>Hello <strong>World</strong></h1> -->
You can also use set:html on a <Fragment> to avoid adding an unnecessary wrapper element. This can be especially useful when fetching HTML from a CMS.
---
const cmsContent = await fetchHTMLFromMyCMS();
---
<Fragment set:html={cmsContent}>
set:html={Promise<string>} injects an HTML string into an element that is wrapped in a Promise.
This can be used to inject HTML stored externally, such as in a database.
---
import api from '../db/api.js';
---
<article set:html={api.getArticle(Astro.props.id)}></article>
set:html={Promise<Response>} injects a Response into an element.
This is most helpful when using fetch(). For example, fetching old posts from a previous static-site generator.
<article set:html={fetch('http://example/old-posts/making-soup.html')}></article>
set:html can be used on any tag and does not have to include HTML. For example, use with JSON.stringify() on a <script> tag to add a JSON-LD schema to your page.
<script type=""application/ld+json"" set:html={JSON.stringify({
  ""@context"": ""https://schema.org/"",
  ""@type"": ""Person"",
  name: ""Houston"",
  hasOccupation: {
    ""@type"": ""Occupation"",
    name: ""Astronaut""
  }
})}/>
set:text
set:text={string} injects a text string into an element, similar to setting el.innerText. Unlike set:html, the string value that is passed is automatically escaped by Astro.
This is equivalent to just passing a variable into a template expression directly (ex: <div>{someText}</div>) and therefore this directive is not commonly used.
Client Directives
These directives control how UI Framework components are hydrated on the page.
By default, a UI Framework component is not hydrated in the client. If no client:* directive is provided, its HTML is rendered onto the page without JavaScript.
A client directive can only be used on a UI framework component that is directly imported into a .astro component. Hydration directives are not supported when using dynamic tags and custom components passed via the components prop.
client:load
Priority: High
Useful for: Immediately-visible UI elements that need to be interactive as soon as possible.
Load and hydrate the component JavaScript immediately on page load.
<BuyButton client:load />
client:idle
Priority: Medium
Useful for: Lower-priority UI elements that don‚Äôt need to be immediately interactive.
Load and hydrate the component JavaScript once the page is done with its initial load and the requestIdleCallback event has fired. If you are in a browser that doesn‚Äôt support requestIdleCallback, then the document load event is used.
<ShowHideButton client:idle />
timeout
Added in: astro@4.15.0
The maximum time to wait, in milliseconds, before hydrating the component, even if the page is not yet done with its initial load.
This allows you to pass a value for the timeout option from the requestIdleCallback() specification. This means you can delay hydration for lower-priority UI elements with more control to ensure your element is interactive within a specified time frame.
<ShowHideButton client:idle={{timeout: 500}} />
client:visible
Priority: Low
Useful for: Low-priority UI elements that are either far down the page (‚Äúbelow the fold‚Äù) or so resource-intensive to load that you would prefer not to load them at all if the user never saw the element.
Load and hydrate the component JavaScript once the component has entered the user‚Äôs viewport. This uses an IntersectionObserver internally to keep track of visibility.
<HeavyImageCarousel client:visible />
client:visible={{rootMargin}}
Added in: astro@4.1.0
Optionally, a value for rootMargin can be passed to the underlying IntersectionObserver. When rootMargin is specified, the component JavaScript will hydrate when a specified margin (in pixels) around the component enters the viewport, rather than the component itself.
<HeavyImageCarousel client:visible={{rootMargin: ""200px""}} />
Specifying a rootMargin value can reduce layout shifts (CLS), allow more time for a component to hydrate on slower internet connections, and make components interactive sooner, enhancing the stability and responsiveness of the page.
client:media
Priority: Low
Useful for: Sidebar toggles, or other elements that might only be visible on certain screen sizes.
client:media={string} loads and hydrates the component JavaScript once a certain CSS media query is met.
Note
If the component is already hidden and shown by a media query in your CSS, then it can be easier to just use client:visible and not pass that same media query into the directive.
<SidebarToggle client:media=""(max-width: 50em)"" />
client:only
client:only={string} skips HTML server-rendering, and renders only on the client. It acts similarly to client:load in that it loads, renders, and hydrates the component immediately on page load.
You must pass the component‚Äôs correct framework as a value! Because Astro doesn‚Äôt run the component during your build / on the server, Astro doesn‚Äôt know what framework your component uses unless you tell it explicitly.
<SomeReactComponent client:only=""react"" />
<SomePreactComponent client:only=""preact"" />
<SomeSvelteComponent client:only=""svelte"" />
<SomeVueComponent client:only=""vue"" />
<SomeSolidComponent client:only=""solid-js"" />
<SomeLitComponent client:only=""lit"" />
Display loading content
For components that render only on the client, it is also possible to display fallback content while they are loading. Use slot=""fallback"" on any child element to create content that will be displayed only until your client component is available:
<ClientComponent client:only=""vue"">
  <div slot=""fallback"">Loading</div>
</ClientComponent>
Custom Client Directives
Since Astro 2.6.0, integrations can also add custom client:* directives to change how and when components should be hydrated.
Visit the addClientDirective API page to learn more about creating a custom client directive.
Script & Style Directives
These directives can only be used on HTML <script> and <style> tags, to control how your client-side JavaScript and CSS are handled on the page.
is:global
By default, Astro automatically scopes <style> CSS rules to the component. You can opt-out of this behavior with the is:global directive.
is:global makes the contents of a <style> tag apply globally on the page when the component is included. This disables Astro‚Äôs CSS scoping system. This is equivalent to wrapping all of the selectors within a <style> tag with :global().
You can combine <style> and <style is:global> together in the same component, to create some global style rules while still scoping most of your component CSS.
See the Styling & CSS page for more details about how global styles work.
<style is:global>
  body a { color: red; }
</style>
is:inline
By default, Astro will process, optimize, and bundle any <script> and <style> tags that it sees on the page. You can opt-out of this behavior with the is:inline directive.
is:inline tells Astro to leave the <script> or <style> tag as-is in the final output HTML. The contents will not be processed, optimized, or bundled. This limits some Astro features, like importing an npm package or using a compile-to-CSS language like Sass.
The is:inline directive means that <style> and <script> tags:
Will not be bundled into an external file. This means that attributes like defer which control the loading of an external file will have no effect.
Will not be deduplicated‚Äîthe element will appear as many times as it is rendered.
Will not have its import/@import/url() references resolved relative to the .astro file.
Will be rendered in the final output HTML exactly where it is authored.
Styles will be global and not scoped to the component.
Caution
The is:inline directive is implied whenever any attribute other than src is used on a <script> or <style> tag. The one exception is using the define:vars directive on the <style> tag, which does not automatically imply is:inline.
<style is:inline>
  /* inline: relative & npm package imports are not supported. */
  @import '/assets/some-public-styles.css';
  span { color: green; }
</style>
<script is:inline>
  /* inline: relative & npm package imports are not supported. */
  console.log('I am inlined right here in the final output HTML.');
</script>
See how client-side scripts work in Astro components.
define:vars
define:vars={...} can pass server-side variables from your component frontmatter into the client <script> or <style> tags. Any JSON-serializable frontmatter variable is supported, including props passed to your component through Astro.props. Values are serialized with JSON.stringify().
---
const foregroundColor = ""rgb(221 243 228)"";
const backgroundColor = ""rgb(24 121 78)"";
const message = ""Astro is awesome!"";
---
<style define:vars={{ textColor: foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--textColor);
  }
</style>
<script define:vars={{ message }}>
  alert(message);
</script>
Caution
Using define:vars on a <script> tag implies the is:inline directive, which means your scripts won‚Äôt be bundled and will be inlined directly into the HTML.
This is because when Astro bundles a script, it includes and runs the script once even if you include the component containing the script multiple times on one page. define:vars requires a script to rerun with each set of values, so Astro creates an inline script instead.
For scripts, try passing variables to scripts manually instead.
Advanced Directives
is:raw
is:raw instructs the Astro compiler to treat any children of that element as text. This means that all special Astro templating syntax will be ignored inside of this component.
For example, if you had a custom Katex component that converted some text to HTML, you could have users do this:
---
import Katex from '../components/Katex.astro';
---
<Katex is:raw>Some conflicting {syntax} here</Katex>
Edit page
Translate this page
Previous
Astro CLI
Next
TypeScript Reference
Contribute
Give us feedback
Community""""""",2791,12499,astro
https://docs.astro.build/en/guides/typescript/,"""""""On this page
Overview
Setup
TypeScript templates
TypeScript editor plugin
UI Frameworks
Type Imports
Import Aliases
Extending window and globalThis
Component Props
Common prop type patterns
Type Utilities
Built-in HTML attributes
ComponentProps type
Polymorphic type
Infer getStaticPaths() types
Type checking
Troubleshooting
Errors typing multiple JSX frameworks at the same time
Want to build your own Docs?
Grab this template to get started.‚Üí
TypeScript
Astro ships with built-in support for TypeScript. You can import .ts and .tsx files in your Astro project, write TypeScript code directly inside your Astro component, and even use an astro.config.ts file if you like.
Using TypeScript, you can prevent errors at runtime by defining the shapes of objects and components in your code. For example, if you use TypeScript to type your component‚Äôs props, you‚Äôll get an error in your editor if you set a prop that your component doesn‚Äôt accept.
You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the Astro VSCode Extension will infer as much as it can to provide autocompletion, hints, and errors in your editor.
The Astro dev server won‚Äôt perform any type checking, but you can use a separate script to check for type errors from the command line.
Setup
Astro starter projects include a tsconfig.json file in your project. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file. If you install Astro manually, be sure to create this file yourself.
TypeScript templates
Three extensible tsconfig.json templates are included in Astro: base, strict, and strictest. The base template enables support for modern JavaScript features and is also used as a basis for the other templates. We recommend using strict or strictest if you plan to write TypeScript in your project. You can view and compare the three template configurations at astro/tsconfigs/.
To inherit from one of the templates, use the extends setting:
tsconfig.json
{
  ""extends"": ""astro/tsconfigs/base""
}
Additionally, our templates include an env.d.ts file inside the src folder to provide Vite‚Äôs client types to your project:
env.d.ts
/// <reference path=""../.astro/types.d.ts"" />
TypeScript editor plugin
The Astro TypeScript plugin can be installed separately when you are not using the official Astro VS Code extension. This plugin is automatically installed and configured by the VSCode extension, and you do not need to install both.
This plugin runs only in the editor. When running tsc in the terminal, .astro files are ignored entirely. Instead, you can use the astro check CLI command to check both .astro and .ts files. This plugin also supports importing .astro files from .ts files (which can be useful for re-exporting).
npm
pnpm
Yarn
Terminal window
yarn add @astrojs/ts-plugin
Then, add the following to your tsconfig.json:
tsconfig.json
  ""compilerOptions"": {
    ""plugins"": [
      {
        ""name"": ""@astrojs/ts-plugin""
      },
    ],
  }
To check that the plugin is working, create a .ts file and import an Astro component into it. You should have no warning messages from your editor.
UI Frameworks
If your project uses a UI framework, additional settings depending on the framework might be needed. Please see your framework‚Äôs TypeScript documentation for more information. (Vue, React, Preact, Solid)
Type Imports
Use explicit type imports and exports whenever possible.
import { SomeType } from './script';
import type { SomeType } from './script';
This way, you avoid edge cases where Astro‚Äôs bundler may try to incorrectly bundle your imported types as if they were JavaScript.
You can configure TypeScript to enforce type imports in your tsconfig.json file. Set verbatimModuleSyntax to true. TypeScript will check your imports and tell you when import type should be used. This setting is enabled by default in all our presets.
tsconfig.json
  {
    ""compilerOptions"": {
      ""verbatimModuleSyntax"": true
    }
  }
Import Aliases
Astro supports import aliases that you define in your tsconfig.json paths configuration. Read our guide to learn more.
src/pages/about/nate.astro
---
import HelloWorld from '@components/HelloWorld.astro';
import Layout from '@layouts/Layout.astro';
---
tsconfig.json
{
  ""compilerOptions"": {
    ""baseUrl"": ""."",
    ""paths"": {
      ""@components/*"": [""src/components/*""],
      ""@layouts/*"": [""src/layouts/*""]
    }
  }
}
Extending window and globalThis
You may want to add a property to the global object. You can do this by adding top-level declarations using the declare keyword to your env.d.ts file:
env.d.ts
declare var myString: string;
declare function myFunction(): boolean;
This will provide typing to globalThis.myString and globalThis.myFunction, as well as window.myString and window.myFunction.
Note that window is only available in client-side code. globalThis is available both server-side and client-side, but its server-side value won‚Äôt be shared with the client.
If you only want to type a property on the window object, provide a Window interface instead:
env.d.ts
interface Window {
  myFunction(): boolean;
}
Component Props
Astro supports typing your component props via TypeScript. To enable, add a TypeScript Props interface to your component frontmatter. An export statement may be used, but is not necessary. The Astro VSCode Extension will automatically look for the Props interface and give you proper TS support when you use that component inside another template.
src/components/HelloProps.astro
---
interface Props {
  name: string;
  greeting?: string;
}
const { greeting = 'Hello', name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
Common prop type patterns
If your component takes no props or slotted content, you can use type Props = Record<string, never>.
If your component must be passed children to its default slot, you can enforce this by using type Props = { children: any; };.
Type Utilities
Added in: astro@1.6.0
Astro comes with some built-in utility types for common prop type patterns. These are available under the astro/types entrypoint.
Built-in HTML attributes
Astro provides the HTMLAttributes type to check that your markup is using valid HTML attributes. You can use these types to help build component props.
For example, if you were building a <Link> component, you could do the following to mirror the default HTML attributes for <a> tags in your component‚Äôs prop types.
src/components/Link.astro
---
import type { HTMLAttributes } from 'astro/types';
// use a `type`
type Props = HTMLAttributes<'a'>;
// or extend with an `interface`
interface Props extends HTMLAttributes<'a'> {
  myProp?: boolean;
}
const { href, ...attrs } = Astro.props;
---
<a href={href} {...attrs}>
  <slot />
</a>
It is also possible to extend the default JSX definitions to add non-standard attributes by redeclaring the astroHTML.JSX namespace in a .d.ts file.
src/custom-attributes.d.ts
declare namespace astroHTML.JSX {
  interface HTMLAttributes {
    'data-count'?: number;
    'data-label'?: string;
  }
  // Add a CSS custom property to the style object
  interface CSSProperties {
    '--theme-color'?: 'black' | 'white';
  }
}
Note
astroHTML is injected globally inside .astro components. To use it in TypeScript files, use a triple-slash directive:
/// <reference types=""astro/astro-jsx"" />
type MyAttributes = astroHTML.JSX.ImgHTMLAttributes;
ComponentProps type
Added in: astro@4.3.0
This type export allows you to reference the Props accepted by another component, even if that component doesn‚Äôt export that Props type directly.
The following example shows using the ComponentProps utility from astro/types to reference a <Button /> component‚Äôs Props types:
src/pages/index.astro
---
import type { ComponentProps } from 'astro/types';
import Button from ""./Button.astro"";
type ButtonProps = ComponentProps<typeof Button>;
---
Polymorphic type
Added in: astro@2.5.0
Astro includes a helper to make it easier to build components that can render as different HTML elements with full type safety. This is useful for components like <Link> that can render as either <a> or <button> depending on the props passed to it.
The example below implements a fully-typed, polymorphic component that can render as any HTML element. The HTMLTag type is used to ensure that the as prop is a valid HTML element.
---
import type { HTMLTag, Polymorphic } from 'astro/types';
type Props<Tag extends HTMLTag> = Polymorphic<{ as: Tag }>;
const { as: Tag, ...props } = Astro.props;
---
<Tag {...props} />
Infer getStaticPaths() types
Added in: astro@2.1.0
Astro includes helpers for working with the types returned by your getStaticPaths() function for dynamic routes.
You can get the type of Astro.params with InferGetStaticParamsType and the type of Astro.props with InferGetStaticPropsType:
src/pages/posts/[...slug].astro
---
import type { InferGetStaticParamsType, InferGetStaticPropsType, GetStaticPaths } from 'astro';
export const getStaticPaths = (async () => {
  const posts = await getCollection('blog');
  return posts.map((post) => {
    return {
      params: { slug: post.slug },
      props: { draft: post.data.draft, title: post.data.title },
    };
  });
}) satisfies GetStaticPaths;
type Params = InferGetStaticParamsType<typeof getStaticPaths>;
type Props = InferGetStaticPropsType<typeof getStaticPaths>;
const { slug } = Astro.params as Params;
//                      ^? { slug: string; }
const { title } = Astro.props;
//                      ^? { draft: boolean; title: string; }
---
Type checking
To see type errors in your editor, please make sure that you have the Astro VS Code extension installed. Please note that the astro start and astro build commands will transpile the code with esbuild, but will not run any type checking. To prevent your code from building if it contains TypeScript errors, change your ‚Äúbuild‚Äù script in package.json to the following:
package.json
  ""scripts"": {
    ""build"": ""astro build"",
    ""build"": ""astro check && astro build"",
  },
Note
astro check checks all the files included in your TypeScript project. To check types within Svelte and Vue files, you can use the svelte-check and the vue-tsc packages respectively.
Read more about .ts file imports in Astro.
Read more about TypeScript Configuration.
Troubleshooting
Errors typing multiple JSX frameworks at the same time
An issue may arise when using multiple JSX frameworks in the same project, as each framework requires different, sometimes conflicting, settings inside tsconfig.json.
Solution: Set the jsxImportSource setting to react (default), preact or solid-js depending on your most-used framework. Then, use a pragma comment inside any conflicting file from a different framework.
For the default setting of jsxImportSource: react, you would use:
// For Preact
/** @jsxImportSource preact */
// For Solid
/** @jsxImportSource solid-js */
Edit page
Translate this page
Previous
Directives Reference
Next
Error Reference
Contribute
Give us feedback
Community

On this page
Overview
Setup
TypeScript templates
TypeScript editor plugin
UI Frameworks
Type Imports
Import Aliases
Extending window and globalThis
Component Props
Common prop type patterns
Type Utilities
Built-in HTML attributes
ComponentProps type
Polymorphic type
Infer getStaticPaths() types
Type checking
Troubleshooting
Errors typing multiple JSX frameworks at the same time
Want to build your own Docs?
Grab this template to get started.‚Üí
TypeScript
Astro ships with built-in support for TypeScript. You can import .ts and .tsx files in your Astro project, write TypeScript code directly inside your Astro component, and even use an astro.config.ts file if you like.
Using TypeScript, you can prevent errors at runtime by defining the shapes of objects and components in your code. For example, if you use TypeScript to type your component‚Äôs props, you‚Äôll get an error in your editor if you set a prop that your component doesn‚Äôt accept.
You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the Astro VSCode Extension will infer as much as it can to provide autocompletion, hints, and errors in your editor.
The Astro dev server won‚Äôt perform any type checking, but you can use a separate script to check for type errors from the command line.
Setup
Astro starter projects include a tsconfig.json file in your project. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file. If you install Astro manually, be sure to create this file yourself.
TypeScript templates
Three extensible tsconfig.json templates are included in Astro: base, strict, and strictest. The base template enables support for modern JavaScript features and is also used as a basis for the other templates. We recommend using strict or strictest if you plan to write TypeScript in your project. You can view and compare the three template configurations at astro/tsconfigs/.
To inherit from one of the templates, use the extends setting:
tsconfig.json
{
  ""extends"": ""astro/tsconfigs/base""
}
Additionally, our templates include an env.d.ts file inside the src folder to provide Vite‚Äôs client types to your project:
env.d.ts
/// <reference path=""../.astro/types.d.ts"" />
TypeScript editor plugin
The Astro TypeScript plugin can be installed separately when you are not using the official Astro VS Code extension. This plugin is automatically installed and configured by the VSCode extension, and you do not need to install both.
This plugin runs only in the editor. When running tsc in the terminal, .astro files are ignored entirely. Instead, you can use the astro check CLI command to check both .astro and .ts files. This plugin also supports importing .astro files from .ts files (which can be useful for re-exporting).
npm
pnpm
Yarn
Terminal window
npm install @astrojs/ts-plugin
Then, add the following to your tsconfig.json:
tsconfig.json
  ""compilerOptions"": {
    ""plugins"": [
      {
        ""name"": ""@astrojs/ts-plugin""
      },
    ],
  }
To check that the plugin is working, create a .ts file and import an Astro component into it. You should have no warning messages from your editor.
UI Frameworks
If your project uses a UI framework, additional settings depending on the framework might be needed. Please see your framework‚Äôs TypeScript documentation for more information. (Vue, React, Preact, Solid)
Type Imports
Use explicit type imports and exports whenever possible.
import { SomeType } from './script';
import type { SomeType } from './script';
This way, you avoid edge cases where Astro‚Äôs bundler may try to incorrectly bundle your imported types as if they were JavaScript.
You can configure TypeScript to enforce type imports in your tsconfig.json file. Set verbatimModuleSyntax to true. TypeScript will check your imports and tell you when import type should be used. This setting is enabled by default in all our presets.
tsconfig.json
  {
    ""compilerOptions"": {
      ""verbatimModuleSyntax"": true
    }
  }
Import Aliases
Astro supports import aliases that you define in your tsconfig.json paths configuration. Read our guide to learn more.
src/pages/about/nate.astro
---
import HelloWorld from '@components/HelloWorld.astro';
import Layout from '@layouts/Layout.astro';
---
tsconfig.json
{
  ""compilerOptions"": {
    ""baseUrl"": ""."",
    ""paths"": {
      ""@components/*"": [""src/components/*""],
      ""@layouts/*"": [""src/layouts/*""]
    }
  }
}
Extending window and globalThis
You may want to add a property to the global object. You can do this by adding top-level declarations using the declare keyword to your env.d.ts file:
env.d.ts
declare var myString: string;
declare function myFunction(): boolean;
This will provide typing to globalThis.myString and globalThis.myFunction, as well as window.myString and window.myFunction.
Note that window is only available in client-side code. globalThis is available both server-side and client-side, but its server-side value won‚Äôt be shared with the client.
If you only want to type a property on the window object, provide a Window interface instead:
env.d.ts
interface Window {
  myFunction(): boolean;
}
Component Props
Astro supports typing your component props via TypeScript. To enable, add a TypeScript Props interface to your component frontmatter. An export statement may be used, but is not necessary. The Astro VSCode Extension will automatically look for the Props interface and give you proper TS support when you use that component inside another template.
src/components/HelloProps.astro
---
interface Props {
  name: string;
  greeting?: string;
}
const { greeting = 'Hello', name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
Common prop type patterns
If your component takes no props or slotted content, you can use type Props = Record<string, never>.
If your component must be passed children to its default slot, you can enforce this by using type Props = { children: any; };.
Type Utilities
Added in: astro@1.6.0
Astro comes with some built-in utility types for common prop type patterns. These are available under the astro/types entrypoint.
Built-in HTML attributes
Astro provides the HTMLAttributes type to check that your markup is using valid HTML attributes. You can use these types to help build component props.
For example, if you were building a <Link> component, you could do the following to mirror the default HTML attributes for <a> tags in your component‚Äôs prop types.
src/components/Link.astro
---
import type { HTMLAttributes } from 'astro/types';
// use a `type`
type Props = HTMLAttributes<'a'>;
// or extend with an `interface`
interface Props extends HTMLAttributes<'a'> {
  myProp?: boolean;
}
const { href, ...attrs } = Astro.props;
---
<a href={href} {...attrs}>
  <slot />
</a>
It is also possible to extend the default JSX definitions to add non-standard attributes by redeclaring the astroHTML.JSX namespace in a .d.ts file.
src/custom-attributes.d.ts
declare namespace astroHTML.JSX {
  interface HTMLAttributes {
    'data-count'?: number;
    'data-label'?: string;
  }
  // Add a CSS custom property to the style object
  interface CSSProperties {
    '--theme-color'?: 'black' | 'white';
  }
}
Note
astroHTML is injected globally inside .astro components. To use it in TypeScript files, use a triple-slash directive:
/// <reference types=""astro/astro-jsx"" />
type MyAttributes = astroHTML.JSX.ImgHTMLAttributes;
ComponentProps type
Added in: astro@4.3.0
This type export allows you to reference the Props accepted by another component, even if that component doesn‚Äôt export that Props type directly.
The following example shows using the ComponentProps utility from astro/types to reference a <Button /> component‚Äôs Props types:
src/pages/index.astro
---
import type { ComponentProps } from 'astro/types';
import Button from ""./Button.astro"";
type ButtonProps = ComponentProps<typeof Button>;
---
Polymorphic type
Added in: astro@2.5.0
Astro includes a helper to make it easier to build components that can render as different HTML elements with full type safety. This is useful for components like <Link> that can render as either <a> or <button> depending on the props passed to it.
The example below implements a fully-typed, polymorphic component that can render as any HTML element. The HTMLTag type is used to ensure that the as prop is a valid HTML element.
---
import type { HTMLTag, Polymorphic } from 'astro/types';
type Props<Tag extends HTMLTag> = Polymorphic<{ as: Tag }>;
const { as: Tag, ...props } = Astro.props;
---
<Tag {...props} />
Infer getStaticPaths() types
Added in: astro@2.1.0
Astro includes helpers for working with the types returned by your getStaticPaths() function for dynamic routes.
You can get the type of Astro.params with InferGetStaticParamsType and the type of Astro.props with InferGetStaticPropsType:
src/pages/posts/[...slug].astro
---
import type { InferGetStaticParamsType, InferGetStaticPropsType, GetStaticPaths } from 'astro';
export const getStaticPaths = (async () => {
  const posts = await getCollection('blog');
  return posts.map((post) => {
    return {
      params: { slug: post.slug },
      props: { draft: post.data.draft, title: post.data.title },
    };
  });
}) satisfies GetStaticPaths;
type Params = InferGetStaticParamsType<typeof getStaticPaths>;
type Props = InferGetStaticPropsType<typeof getStaticPaths>;
const { slug } = Astro.params as Params;
//                      ^? { slug: string; }
const { title } = Astro.props;
//                      ^? { draft: boolean; title: string; }
---
Type checking
To see type errors in your editor, please make sure that you have the Astro VS Code extension installed. Please note that the astro start and astro build commands will transpile the code with esbuild, but will not run any type checking. To prevent your code from building if it contains TypeScript errors, change your ‚Äúbuild‚Äù script in package.json to the following:
package.json
  ""scripts"": {
    ""build"": ""astro build"",
    ""build"": ""astro check && astro build"",
  },
Note
astro check checks all the files included in your TypeScript project. To check types within Svelte and Vue files, you can use the svelte-check and the vue-tsc packages respectively.
Read more about .ts file imports in Astro.
Read more about TypeScript Configuration.
Troubleshooting
Errors typing multiple JSX frameworks at the same time
An issue may arise when using multiple JSX frameworks in the same project, as each framework requires different, sometimes conflicting, settings inside tsconfig.json.
Solution: Set the jsxImportSource setting to react (default), preact or solid-js depending on your most-used framework. Then, use a pragma comment inside any conflicting file from a different framework.
For the default setting of jsxImportSource: react, you would use:
// For Preact
/** @jsxImportSource preact */
// For Solid
/** @jsxImportSource solid-js */
Edit page
Translate this page
Previous
Directives Reference
Next
Error Reference
Contribute
Give us feedback
Community

On this page
Overview
Setup
TypeScript templates
TypeScript editor plugin
UI Frameworks
Type Imports
Import Aliases
Extending window and globalThis
Component Props
Common prop type patterns
Type Utilities
Built-in HTML attributes
ComponentProps type
Polymorphic type
Infer getStaticPaths() types
Type checking
Troubleshooting
Errors typing multiple JSX frameworks at the same time
Want to build your own Docs?
Grab this template to get started.‚Üí
TypeScript
Astro ships with built-in support for TypeScript. You can import .ts and .tsx files in your Astro project, write TypeScript code directly inside your Astro component, and even use an astro.config.ts file if you like.
Using TypeScript, you can prevent errors at runtime by defining the shapes of objects and components in your code. For example, if you use TypeScript to type your component‚Äôs props, you‚Äôll get an error in your editor if you set a prop that your component doesn‚Äôt accept.
You don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the Astro VSCode Extension will infer as much as it can to provide autocompletion, hints, and errors in your editor.
The Astro dev server won‚Äôt perform any type checking, but you can use a separate script to check for type errors from the command line.
Setup
Astro starter projects include a tsconfig.json file in your project. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file. If you install Astro manually, be sure to create this file yourself.
TypeScript templates
Three extensible tsconfig.json templates are included in Astro: base, strict, and strictest. The base template enables support for modern JavaScript features and is also used as a basis for the other templates. We recommend using strict or strictest if you plan to write TypeScript in your project. You can view and compare the three template configurations at astro/tsconfigs/.
To inherit from one of the templates, use the extends setting:
tsconfig.json
{
  ""extends"": ""astro/tsconfigs/base""
}
Additionally, our templates include an env.d.ts file inside the src folder to provide Vite‚Äôs client types to your project:
env.d.ts
/// <reference path=""../.astro/types.d.ts"" />
TypeScript editor plugin
The Astro TypeScript plugin can be installed separately when you are not using the official Astro VS Code extension. This plugin is automatically installed and configured by the VSCode extension, and you do not need to install both.
This plugin runs only in the editor. When running tsc in the terminal, .astro files are ignored entirely. Instead, you can use the astro check CLI command to check both .astro and .ts files. This plugin also supports importing .astro files from .ts files (which can be useful for re-exporting).
npm
pnpm
Yarn
Terminal window
pnpm add @astrojs/ts-plugin
Then, add the following to your tsconfig.json:
tsconfig.json
  ""compilerOptions"": {
    ""plugins"": [
      {
        ""name"": ""@astrojs/ts-plugin""
      },
    ],
  }
To check that the plugin is working, create a .ts file and import an Astro component into it. You should have no warning messages from your editor.
UI Frameworks
If your project uses a UI framework, additional settings depending on the framework might be needed. Please see your framework‚Äôs TypeScript documentation for more information. (Vue, React, Preact, Solid)
Type Imports
Use explicit type imports and exports whenever possible.
import { SomeType } from './script';
import type { SomeType } from './script';
This way, you avoid edge cases where Astro‚Äôs bundler may try to incorrectly bundle your imported types as if they were JavaScript.
You can configure TypeScript to enforce type imports in your tsconfig.json file. Set verbatimModuleSyntax to true. TypeScript will check your imports and tell you when import type should be used. This setting is enabled by default in all our presets.
tsconfig.json
  {
    ""compilerOptions"": {
      ""verbatimModuleSyntax"": true
    }
  }
Import Aliases
Astro supports import aliases that you define in your tsconfig.json paths configuration. Read our guide to learn more.
src/pages/about/nate.astro
---
import HelloWorld from '@components/HelloWorld.astro';
import Layout from '@layouts/Layout.astro';
---
tsconfig.json
{
  ""compilerOptions"": {
    ""baseUrl"": ""."",
    ""paths"": {
      ""@components/*"": [""src/components/*""],
      ""@layouts/*"": [""src/layouts/*""]
    }
  }
}
Extending window and globalThis
You may want to add a property to the global object. You can do this by adding top-level declarations using the declare keyword to your env.d.ts file:
env.d.ts
declare var myString: string;
declare function myFunction(): boolean;
This will provide typing to globalThis.myString and globalThis.myFunction, as well as window.myString and window.myFunction.
Note that window is only available in client-side code. globalThis is available both server-side and client-side, but its server-side value won‚Äôt be shared with the client.
If you only want to type a property on the window object, provide a Window interface instead:
env.d.ts
interface Window {
  myFunction(): boolean;
}
Component Props
Astro supports typing your component props via TypeScript. To enable, add a TypeScript Props interface to your component frontmatter. An export statement may be used, but is not necessary. The Astro VSCode Extension will automatically look for the Props interface and give you proper TS support when you use that component inside another template.
src/components/HelloProps.astro
---
interface Props {
  name: string;
  greeting?: string;
}
const { greeting = 'Hello', name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
Common prop type patterns
If your component takes no props or slotted content, you can use type Props = Record<string, never>.
If your component must be passed children to its default slot, you can enforce this by using type Props = { children: any; };.
Type Utilities
Added in: astro@1.6.0
Astro comes with some built-in utility types for common prop type patterns. These are available under the astro/types entrypoint.
Built-in HTML attributes
Astro provides the HTMLAttributes type to check that your markup is using valid HTML attributes. You can use these types to help build component props.
For example, if you were building a <Link> component, you could do the following to mirror the default HTML attributes for <a> tags in your component‚Äôs prop types.
src/components/Link.astro
---
import type { HTMLAttributes } from 'astro/types';
// use a `type`
type Props = HTMLAttributes<'a'>;
// or extend with an `interface`
interface Props extends HTMLAttributes<'a'> {
  myProp?: boolean;
}
const { href, ...attrs } = Astro.props;
---
<a href={href} {...attrs}>
  <slot />
</a>
It is also possible to extend the default JSX definitions to add non-standard attributes by redeclaring the astroHTML.JSX namespace in a .d.ts file.
src/custom-attributes.d.ts
declare namespace astroHTML.JSX {
  interface HTMLAttributes {
    'data-count'?: number;
    'data-label'?: string;
  }
  // Add a CSS custom property to the style object
  interface CSSProperties {
    '--theme-color'?: 'black' | 'white';
  }
}
Note
astroHTML is injected globally inside .astro components. To use it in TypeScript files, use a triple-slash directive:
/// <reference types=""astro/astro-jsx"" />
type MyAttributes = astroHTML.JSX.ImgHTMLAttributes;
ComponentProps type
Added in: astro@4.3.0
This type export allows you to reference the Props accepted by another component, even if that component doesn‚Äôt export that Props type directly.
The following example shows using the ComponentProps utility from astro/types to reference a <Button /> component‚Äôs Props types:
src/pages/index.astro
---
import type { ComponentProps } from 'astro/types';
import Button from ""./Button.astro"";
type ButtonProps = ComponentProps<typeof Button>;
---
Polymorphic type
Added in: astro@2.5.0
Astro includes a helper to make it easier to build components that can render as different HTML elements with full type safety. This is useful for components like <Link> that can render as either <a> or <button> depending on the props passed to it.
The example below implements a fully-typed, polymorphic component that can render as any HTML element. The HTMLTag type is used to ensure that the as prop is a valid HTML element.
---
import type { HTMLTag, Polymorphic } from 'astro/types';
type Props<Tag extends HTMLTag> = Polymorphic<{ as: Tag }>;
const { as: Tag, ...props } = Astro.props;
---
<Tag {...props} />
Infer getStaticPaths() types
Added in: astro@2.1.0
Astro includes helpers for working with the types returned by your getStaticPaths() function for dynamic routes.
You can get the type of Astro.params with InferGetStaticParamsType and the type of Astro.props with InferGetStaticPropsType:
src/pages/posts/[...slug].astro
---
import type { InferGetStaticParamsType, InferGetStaticPropsType, GetStaticPaths } from 'astro';
export const getStaticPaths = (async () => {
  const posts = await getCollection('blog');
  return posts.map((post) => {
    return {
      params: { slug: post.slug },
      props: { draft: post.data.draft, title: post.data.title },
    };
  });
}) satisfies GetStaticPaths;
type Params = InferGetStaticParamsType<typeof getStaticPaths>;
type Props = InferGetStaticPropsType<typeof getStaticPaths>;
const { slug } = Astro.params as Params;
//                      ^? { slug: string; }
const { title } = Astro.props;
//                      ^? { draft: boolean; title: string; }
---
Type checking
To see type errors in your editor, please make sure that you have the Astro VS Code extension installed. Please note that the astro start and astro build commands will transpile the code with esbuild, but will not run any type checking. To prevent your code from building if it contains TypeScript errors, change your ‚Äúbuild‚Äù script in package.json to the following:
package.json
  ""scripts"": {
    ""build"": ""astro build"",
    ""build"": ""astro check && astro build"",
  },
Note
astro check checks all the files included in your TypeScript project. To check types within Svelte and Vue files, you can use the svelte-check and the vue-tsc packages respectively.
Read more about .ts file imports in Astro.
Read more about TypeScript Configuration.
Troubleshooting
Errors typing multiple JSX frameworks at the same time
An issue may arise when using multiple JSX frameworks in the same project, as each framework requires different, sometimes conflicting, settings inside tsconfig.json.
Solution: Set the jsxImportSource setting to react (default), preact or solid-js depending on your most-used framework. Then, use a pragma comment inside any conflicting file from a different framework.
For the default setting of jsxImportSource: react, you would use:
// For Preact
/** @jsxImportSource preact */
// For Solid
/** @jsxImportSource solid-js */
Edit page
Translate this page
Previous
Directives Reference
Next
Error Reference
Contribute
Give us feedback
Community""""""",7408,33643,astro
https://docs.astro.build/en/reference/error-reference/,"""""""On this page
Overview
Astro Errors
CSS Errors
Markdown Errors
CLI Errors
Content Collection Errors
Action Errors
Want to build your own Docs?
Grab this template to get started.‚Üí
Error reference
The following reference is a complete list of the errors you may encounter while using Astro. For additional assistance, including common pitfalls, please also see our Troubleshooting Guide.
Astro Errors
UnknownCompilerError
Unknown compiler error.
ClientAddressNotAvailable
Astro.clientAddress is not available in current adapter.
PrerenderClientAddressNotAvailable
Astro.clientAddress cannot be used inside prerendered routes.
StaticClientAddressNotAvailable
Astro.clientAddress is not available in static mode.
NoMatchingStaticPathFound
No static path found for requested path.
OnlyResponseCanBeReturned
Invalid type returned by Astro page.
MissingMediaQueryDirective
Missing value for client:media directive.
NoMatchingRenderer
No matching renderer found.
NoClientEntrypoint
No client entrypoint specified in renderer.
NoClientOnlyHint
Missing hint on client:only directive.
InvalidGetStaticPathParam
Invalid value returned by a getStaticPaths path.
InvalidGetStaticPathsEntry
Invalid entry inside getStaticPath‚Äôs return value
InvalidGetStaticPathsReturn
Invalid value returned by getStaticPaths.
GetStaticPathsExpectedParams
Missing params property on getStaticPaths route.
GetStaticPathsInvalidRouteParam
Invalid value for getStaticPaths route parameter.
GetStaticPathsRequired
getStaticPaths() function required for dynamic routes.
ReservedSlotName
Invalid slot name.
NoAdapterInstalled
Cannot use Server-side Rendering without an adapter.
NoMatchingImport
No import found for component.
InvalidPrerenderExport
Invalid prerender export.
InvalidComponentArgs
Invalid component arguments.
PageNumberParamNotFound
Page number param not found.
ImageMissingAlt
Image missing required ‚Äúalt‚Äù property.
InvalidImageService
Error while loading image service.
MissingImageDimension
Missing image dimensions
FailedToFetchRemoteImageDimensions
Failed to retrieve remote image dimensions
UnsupportedImageFormat
Unsupported image format
UnsupportedImageConversion
Unsupported image conversion
PrerenderDynamicEndpointPathCollide
Prerendered dynamic endpoint has path collision.
ExpectedImage
Expected src to be an image.
ExpectedImageOptions
Expected image options.
ExpectedNotESMImage
Expected image options, not an ESM-imported image.
IncompatibleDescriptorOptions
Cannot set both densities and widths
ImageNotFound
Image not found.
NoImageMetadata
Could not process image metadata.
CouldNotTransformImage
Could not transform image.
ResponseSentError
Unable to set response.
MiddlewareNoDataOrNextCalled
The middleware didn‚Äôt return a Response.
MiddlewareNotAResponse
The middleware returned something that is not a Response object.
EndpointDidNotReturnAResponse
The endpoint did not return a Response.
LocalsNotAnObject
Value assigned to locals is not accepted.
AstroResponseHeadersReassigned
Astro.response.headers must not be reassigned.
MiddlewareCantBeLoaded
Can‚Äôt load the middleware.
LocalImageUsedWrongly
Local images must be imported.
AstroGlobUsedOutside
Astro.glob() used outside of an Astro file.
AstroGlobNoMatch
Astro.glob() did not match any files.
RedirectWithNoLocation
A redirect must be given a location with the Location header.
InvalidDynamicRoute
Invalid dynamic route.
MissingSharp
Could not find Sharp.
UnknownViteError
Unknown Vite Error.
FailedToLoadModuleSSR
Could not import file.
InvalidGlob
Invalid glob pattern.
FailedToFindPageMapSSR
Astro couldn‚Äôt find the correct page to render
MissingLocale
The provided locale does not exist.
MissingIndexForInternationalization
Index page not found.
IncorrectStrategyForI18n
You can‚Äôt use the current function with the current strategy
NoPrerenderedRoutesWithDomains
Prerendered routes aren‚Äôt supported when internationalization domains are enabled.
MissingMiddlewareForInternationalization
Enabled manual internationalization routing without having a middleware.
CantRenderPage
Astro can‚Äôt render the route.
UnhandledRejection
Unhandled rejection
i18nNotEnabled
i18n Not Enabled
i18nNoLocaleFoundInPath
The path doesn‚Äôt contain any locale
RouteNotFound
Route not found.
EnvInvalidVariables
Invalid Environment Variables
ServerOnlyModule
Module is only available server-side
RewriteWithBodyUsed
Cannot use Astro.rewrite after the request body has been read
UnknownFilesystemError
An unknown error occurred while reading or writing files to disk.
CSS Errors
UnknownCSSError
Unknown CSS Error.
CSSSyntaxError
CSS Syntax Error.
Markdown Errors
UnknownMarkdownError
Unknown Markdown Error.
MarkdownFrontmatterParseError
Failed to parse Markdown frontmatter.
InvalidFrontmatterInjectionError
Invalid frontmatter injection.
MdxIntegrationMissingError
MDX integration missing.
UnknownConfigError
Unknown configuration error.
ConfigNotFound
Specified configuration file not found.
ConfigLegacyKey
Legacy configuration detected.
CLI Errors
UnknownCLIError
Unknown CLI Error.
GenerateContentTypesError
Failed to generate content types.
Content Collection Errors
UnknownContentCollectionError
Unknown Content Collection Error.
RenderUndefinedEntryError
Attempted to render an undefined content collection entry.
GetEntryDeprecationError
Invalid use of getDataEntryById or getEntryBySlug function.
InvalidContentEntryFrontmatterError
Content entry frontmatter does not match schema.
InvalidContentEntrySlugError
Invalid content entry slug.
ContentSchemaContainsSlugError
Content Schema should not contain slug.
MixedContentDataCollectionError
Content and data cannot be in same collection.
ContentCollectionTypeMismatchError
Collection contains entries of a different type.
DataCollectionEntryParseError
Data collection entry failed to parse.
DuplicateContentEntrySlugError
Duplicate content entry slug.
UnsupportedConfigTransformError
Unsupported transform in content config.
Action Errors
ActionsWithoutServerOutputError
Actions must be used with server output.
ActionsReturnedInvalidDataError
Action handler returned invalid data.
ActionNotFoundError
Action not found.
ActionCalledFromServerError
Action unexpected called from the server.
Edit page
Translate this page
Previous
TypeScript Reference
Next
Astro Runtime API
Contribute
Give us feedback
Community""""""",1288,6310,astro
https://docs.astro.build/en/reference/api-reference/,"""""""On this page
Overview
Astro global
Astro.glob()
Markdown Files
Astro Files
Other Files
Astro.props
Astro.params
Astro.request
Astro.response
Astro.cookies
AstroCookie
AstroCookieGetOptions
AstroCookieSetOptions
Astro.redirect()
Astro.rewrite()
Astro.url
Astro.clientAddress
Astro.site
Astro.generator
Astro.slots
Astro.slots.has()
Astro.slots.render()
Astro.self
Astro.locals
Astro.preferredLocale
Astro.preferredLocaleList
Astro.currentLocale
Astro.getActionResult()
Astro.callAction()
Endpoint Context
context.params
context.props
context.request
context.cookies
context.url
context.clientAddress
context.site
context.generator
context.redirect()
context.rewrite()
context.locals
context.getActionResult()
context.callAction()
getStaticPaths()
params
Data Passing with props
paginate()
The pagination page prop
import.meta
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro Runtime API
Astro global
The Astro global is available in all contexts in .astro files. It has the following functions:
Astro.glob()
Astro.glob() is a way to load many local files into your static site setup.
src/components/my-component.astro
---
const posts = await Astro.glob('../pages/post/*.md'); // returns an array of posts that live at ./src/pages/post/*.md
---
<div>
{posts.slice(0, 3).map((post) => (
  <article>
    <h2>{post.frontmatter.title}</h2>
    <p>{post.frontmatter.description}</p>
    <a href={post.url}>Read more</a>
  </article>
))}
</div>
.glob() only takes one parameter: a relative URL glob of which local files you‚Äôd like to import. It‚Äôs asynchronous, and returns an array of the exports from matching files.
.glob() can‚Äôt take variables or strings that interpolate them, as they aren‚Äôt statically analyzable. (See the troubleshooting guide for a workaround.) This is because Astro.glob() is a wrapper of Vite‚Äôs import.meta.glob().
Note
You can also use import.meta.glob() itself in your Astro project. You may want to do this when:
You need this feature in a file that isn‚Äôt .astro, like an API route. Astro.glob() is only available in .astro files, while import.meta.glob() is available anywhere in the project.
You don‚Äôt want to load each file immediately. import.meta.glob() can return functions that import the file content, rather than returning the content itself. Note that this import includes all styles and scripts for any imported files. These will be bundled and added to the page whether or not a file is actually used, as this is decided by static analysis, not at runtime.
You want access to each file‚Äôs path. import.meta.glob() returns a map of a file‚Äôs path to its content, while Astro.glob() returns a list of content.
You want to pass multiple patterns; for example, you want to add a ‚Äúnegative pattern‚Äù that filters out certain files. import.meta.glob() can optionally take an array of glob strings, rather than a single string.
Read more in the Vite documentation.
Markdown Files
Markdown files loaded with Astro.glob() return the following MarkdownInstance interface:
export interface MarkdownInstance<T extends Record<string, any>> {
  /* Any data specified in this file's YAML frontmatter */
  frontmatter: T;
  /* The absolute file path of this file */
  file: string;
  /* The rendered path of this file */
  url: string | undefined;
  /* Astro Component that renders the contents of this file */
  Content: AstroComponentFactory;
  /** (Markdown only) Raw Markdown file content, excluding layout HTML and YAML frontmatter */
  rawContent(): string;
  /** (Markdown only) Markdown file compiled to HTML, excluding layout HTML */
  compiledContent(): string;
  /* Function that returns an array of the h1...h6 elements in this file */
  getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;
  default: AstroComponentFactory;
}
You can optionally provide a type for the frontmatter variable using a TypeScript generic.
---
interface Frontmatter {
  title: string;
  description?: string;
}
const posts = await Astro.glob<Frontmatter>('../pages/post/*.md');
---
<ul>
  {posts.map(post => <li>{post.frontmatter.title}</li>)}
</ul>
Astro Files
Astro files have the following interface:
export interface AstroInstance {
  /* The file path of this file */
  file: string;
  /* The URL for this file (if it is in the pages directory) */
  url: string | undefined;
  default: AstroComponentFactory;
}
Other Files
Other files may have various different interfaces, but Astro.glob() accepts a TypeScript generic if you know exactly what an unrecognized file type contains.
---
interface CustomDataFile {
  default: Record<string, any>;
}
const data = await Astro.glob<CustomDataFile>('../data/**/*.js');
---
Astro.props
Astro.props is an object containing any values that have been passed as component attributes. Layout components for .md and .mdx files receive frontmatter values as props.
src/components/Heading.astro
---
const { title, date } = Astro.props;
---
<div>
  <h1>{title}</h1>
  <p>{date}</p>
</div>
src/pages/index.astro
---
import Heading from '../components/Heading.astro';
---
<Heading title=""My First Post"" date=""09 Aug 2022"" />
Learn more about how Markdown and MDX Layouts handle props.
Learn how to add TypeScript type definitions for your props.
Astro.params
Astro.params is an object containing the values of dynamic route segments matched for this request.
In static builds, this will be the params returned by getStaticPaths() used for prerendering dynamic routes.
src/pages/posts/[id].astro
---
export function getStaticPaths() {
  return [
    { params: { id: '1' } },
    { params: { id: '2' } },
    { params: { id: '3' } }
  ];
}
const { id } = Astro.params;
---
<h1>{id}</h1>
In SSR builds, this can be any value matching the path segments in the dynamic route pattern.
src/pages/posts/[id].astro
---
import { getPost } from '../api';
const post = await getPost(Astro.params.id);
// No posts found with this ID
if (!post) {
  Astro.redirect(""/404"")
}
---
<html>
  <h1>{post.name}</h1>
</html>
See also: params
Astro.request
Type: Request
Astro.request is a standard Request object. It can be used to get the url, headers, method, and even body of the request.
<p>Received a {Astro.request.method} request to ""{Astro.request.url}"".</p>
<p>Received request headers: <code>{JSON.stringify(Object.fromEntries(Astro.request.headers))}</code>
See also: Astro.url
Note
With the default output: 'static' option, Astro.request.url does not contain search parameters, like ?foo=bar, as it‚Äôs not possible to determine them ahead of time during static builds. However in output: 'server' mode, Astro.request.url does contain search parameters as it can be determined from a server request.
Astro.response
Type: ResponseInit & { readonly headers: Headers }
Astro.response is a standard ResponseInit object. It has the following structure.
status: The numeric status code of the response, e.g., 200.
statusText: The status message associated with the status code, e.g., 'OK'.
headers: A Headers instance that you can use to set the HTTP headers of the response.
Astro.response is used to set the status, statusText, and headers for a page‚Äôs response.
---
if(condition) {
  Astro.response.status = 404;
  Astro.response.statusText = 'Not found';
}
---
Or to set a header:
---
Astro.response.headers.set('Set-Cookie', 'a=b; Path=/;');
---
Astro.cookies
Type: AstroCookies
Added in: astro@1.4.0
Astro.cookies contains utilities for reading and manipulating cookies in server-side rendering mode.
get
Type: (key: string, options?: AstroCookieGetOptions) => AstroCookie | undefined
Gets the cookie as an AstroCookie object, which contains the value and utility functions for converting the cookie to non-string types.
has
Type: (key: string, options?: AstroCookieGetOptions) => boolean
Whether this cookie exists. If the cookie has been set via Astro.cookies.set() this will return true, otherwise it will check cookies in the Astro.request.
set
Type: (key: string, value: string | object, options?: AstroCookieSetOptions) => void
Sets the cookie key to the given value. This will attempt to convert the cookie value to a string. Options provide ways to set cookie features, such as the maxAge or httpOnly.
delete
Type: (key: string, options?: AstroCookieDeleteOptions) => void
Invalidates a cookie by setting the expiration date in the past (0 in Unix time).
Once a cookie is ‚Äúdeleted‚Äù (expired), Astro.cookies.has() will return false and Astro.cookies.get() will return an AstroCookie with a value of undefined. Options available when deleting a cookie are: domain, path, httpOnly, sameSite, and secure.
merge
Type: (cookies: AstroCookies) => void
Merges a new AstroCookies instance into the current instance. Any new cookies will be added to the current instance and any cookies with the same name will overwrite existing values.
headers
Type: () => Iterator<string>
Gets the header values for Set-Cookie that will be sent out with the response.
AstroCookie
Getting a cookie via Astro.cookies.get() returns a AstroCookie type. It has the following structure.
value
Type: string
The raw string value of the cookie.
json
Type: () => Record<string, any>
Parses the cookie value via JSON.parse(), returning an object. Throws if the cookie value is not valid JSON.
number
Type: () => number
Parses the cookie value as a Number. Returns NaN if not a valid number.
boolean
Type: () => boolean
Converts the cookie value to a boolean.
AstroCookieGetOptions
Added in: astro@4.1.0
Getting a cookie also allows specifying options via the AstroCookieGetOptions interface:
decode
Type: (value: string) => string
Allows customization of how a cookie is deserialized into a value.
AstroCookieSetOptions
Added in: astro@4.1.0
Setting a cookie via Astro.cookies.set() allows passing in a AstroCookieSetOptions to customize how the cookie is serialized.
domain
Type: string
Specifies the domain. If no domain is set, most clients will interpret to apply to the current domain.
expires
Type: Date
Specifies the date on which the cookie will expire.
httpOnly
Type: boolean
If true, the cookie will not be accessible client-side.
maxAge
Type: number
Specifies a number, in seconds, for which the cookie is valid.
path
Type: string
Specifies a subpath of the domain in which the cookie is applied.
sameSite
Type: boolean | 'lax' | 'none' | 'strict'
Specifies the value of the SameSite cookie header.
secure
Type: boolean
If true, the cookie is only set on https sites.
encode
Type: (value: string) => string
Allows customizing how the cookie is serialized.
Astro.redirect()
Type: (path: string, status?: number) => Response
Allows you to redirect to another page, and optionally provide an HTTP response status code as a second parameter.
A page (and not a child component) must return the result of Astro.redirect() for the redirect to occur.
For statically-generated sites, this will produce a client redirect using a <meta http-equiv=""refresh""> tag and does not support status codes.
When using an on-demand rendering mode, status codes are supported. Astro will serve redirected requests with a default HTTP response status of 302 unless another code is specified.
The following example redirects a user to a login page:
src/pages/account.astro
---
import { isLoggedIn } from '../utils';
const cookie = Astro.request.headers.get('cookie');
// If the user is not logged in, redirect them to the login page
if (!isLoggedIn(cookie)) {
  return Astro.redirect('/login');
}
---
Astro.rewrite()
Type: (rewritePayload: string | URL | Request) => Promise<Response>
Added in: astro@4.13.0
Allows you to serve content from a different URL or path without redirecting the browser to a new page.
The method accepts either a string, a URL, or a Request for the location of the path.
Use a string to provide an explicit path:
src/pages/index.astro
---
return Astro.rewrite(""/login"")
---
Use a URL type when you need to construct the URL path for the rewrite. The following example renders a page‚Äôs parent path by creating a new URL from the relative ""../"" path:
src/pages/blog/index.astro
---
return Astro.rewrite(new URL(""../"", Astro.url))
---
Use a Request type for complete control of the Request sent to the server for the new path. The following example sends a request to render the parent page while also providing headers:
src/pages/blog/index.astro
---
return Astro.rewrite(new Request(new URL(""../"", Astro.url), {
  headers: {
    ""x-custom-header"": JSON.stringify(Astro.locals.someValue)
  }
}))
---
Astro.url
Type: URL
Added in: astro@1.0.0-rc
A URL object constructed from the current Astro.request.url URL string value. Useful for interacting with individual properties of the request URL, like pathname and origin.
Equivalent to doing new URL(Astro.request.url).
Astro.url will be localhost in dev mode if site is not configured for static sites, and for on-demand rendered sites using server or hybrid output.
<h1>The current URL is: {Astro.url}</h1>
<h1>The current URL pathname is: {Astro.url.pathname}</h1>
<h1>The current URL origin is: {Astro.url.origin}</h1>
You can also use Astro.url to create new URLs by passing it as an argument to new URL().
src/pages/index.astro
---
// Example: Construct a canonical URL using your production domain
const canonicalURL = new URL(Astro.url.pathname, Astro.site);
// Example: Construct a URL for SEO meta tags using your current domain
const socialImageURL = new URL('/images/preview.png', Astro.url);
---
<link rel=""canonical"" href={canonicalURL} />
<meta property=""og:image"" content={socialImageURL} />
Astro.clientAddress
Type: string
Added in: astro@1.0.0-rc
Specifies the IP address of the request. This property is only available when building for SSR (server-side rendering) and should not be used for static sites.
---
const ip = Astro.clientAddress;
---
<div>Your IP address is: <span class=""address"">{ ip }</span></div>
Astro.site
Type: URL | undefined
Astro.site returns a URL made from site in your Astro config. If site in your Astro config isn‚Äôt defined, Astro.site won‚Äôt be defined.
Astro.generator
Type: string
Added in: astro@1.0.0
Astro.generator is a convenient way to add a <meta name=""generator""> tag with your current version of Astro. It follows the format ""Astro v1.x.x"".
<html>
  <head>
    <meta name=""generator"" content={Astro.generator} />
  </head>
  <body>
    <footer>
      <p>Built with <a href=""https://astro.build"">{Astro.generator}</a></p>
    </footer>
  </body>
</html>
Astro.slots
Astro.slots contains utility functions for modifying an Astro component‚Äôs slotted children.
Astro.slots.has()
Type: (slotName: string) => boolean
You can check whether content for a specific slot name exists with Astro.slots.has(). This can be useful when you want to wrap slot contents, but only want to render the wrapper elements when the slot is being used.
src/pages/index.astro
---
---
<slot />
{Astro.slots.has('more') && (
  <aside>
    <h2>More</h2>
    <slot name=""more"" />
  </aside>
)}
Astro.slots.render()
Type: (slotName: string, args?: any[]) => Promise<string>
You can asynchronously render the contents of a slot to a string of HTML using Astro.slots.render().
---
const html = await Astro.slots.render('default');
---
<Fragment set:html={html} />
Note
This is for advanced use cases! In most circumstances, it is simpler to render slot contents with the <slot /> element.
Astro.slots.render() optionally accepts a second argument: an array of parameters that will be forwarded to any function children. This can be useful for custom utility components.
For example, this <Shout /> component converts its message prop to uppercase and passes it to the default slot:
src/components/Shout.astro
---
const message = Astro.props.message.toUpperCase();
let html = '';
if (Astro.slots.has('default')) {
  html = await Astro.slots.render('default', [message]);
}
---
<Fragment set:html={html} />
A callback function passed as <Shout />‚Äôs child will receive the all-caps message parameter:
src/pages/index.astro
---
import Shout from ""../components/Shout.astro"";
---
<Shout message=""slots!"">
  {(message) => <div>{message}</div>}
</Shout>
<!-- renders as <div>SLOTS!</div> -->
Callback functions can be passed to named slots inside a wrapping HTML element tag with a slot attribute. This element is only used to transfer the callback to a named slot and will not be rendered onto the page.
<Shout message=""slots!"">
  <fragment slot=""message"">
    {(message) => <div>{message}</div>}
  </fragment>
</Shout>
Use a standard HTML element for the wrapping tag, or any lower case tag (e.g. <fragment> instead of <Fragment />) that will not be interpreted as a component. Do not use the HTML <slot> element as this will be interpreted as an Astro slot.
Astro.self
Astro.self allows Astro components to be recursively called. This behaviour lets you render an Astro component from within itself by using <Astro.self> in the component template. This can be helpful for iterating over large data stores and nested data-structures.
NestedList.astro
---
const { items } = Astro.props;
---
<ul class=""nested-list"">
  {items.map((item) => (
    <li>
      <!-- If there is a nested data-structure we render `<Astro.self>` -->
      <!-- and can pass props through with the recursive call -->
      {Array.isArray(item) ? (
        <Astro.self items={item} />
      ) : (
        item
      )}
    </li>
  ))}
</ul>
This component could then be used like this:
---
import NestedList from './NestedList.astro';
---
<NestedList items={['A', ['B', 'C'], 'D']} />
And would render HTML like this:
<ul class=""nested-list"">
  <li>A</li>
  <li>
    <ul class=""nested-list"">
      <li>B</li>
      <li>C</li>
    </ul>
  </li>
  <li>D</li>
</ul>
Astro.locals
Added in: astro@2.4.0
Astro.locals is an object containing any values from the context.locals object from a middleware. Use this to access data returned by middleware in your .astro files.
src/pages/Orders.astro
---
const title = Astro.locals.welcomeTitle();
const orders = Array.from(Astro.locals.orders.entries());
---
<h1>{title}</h1>
<ul>
    {orders.map(order => {
        return <li>{/* do something with each order */}</li>
    })}
</ul>
Astro.preferredLocale
Type: string | undefined
Added in: astro@3.5.0
Astro.preferredLocale is a computed value that represents the preferred locale of the user.
It is computed by checking the configured locales in your i18n.locales array and locales supported by the users‚Äôs browser via the header Accept-Language. This value is undefined if no such match exists.
This property is only available when building for SSR (server-side rendering) and should not be used for static sites.
Astro.preferredLocaleList
Type: string[] | undefined
Added in: astro@3.5.0
Astro.preferredLocaleList represents the array of all locales that are both requested by the browser and supported by your website. This produces a list of all compatible languages between your site and your visitor.
If none of the browser‚Äôs requested languages are found in your locales array, then the value is []: you do not support any of your visitor‚Äôs preferred locales.
If the browser does not specify any preferred languages, then this value will be i18n.locales: all of your supported locales will be considered equally preferred by a visitor with no preferences.
This property is only available when building for SSR (server-side rendering) and should not be used for static sites.
Astro.currentLocale
Type: string | undefined
Added in: astro@3.5.6
The locale computed from the current URL, using the syntax specified in your locales configuration. If the URL does not contain a /[locale]/ prefix, then the value will default to i18n.defaultLocale.
Astro.getActionResult()
Type: (action: TAction) => ActionReturnType<TAction> | undefined
Added in: astro@4.15.0
Astro.getActionResult() is a function that returns the result of an Action submission. This accepts an action function as an argument (e.g. actions.logout) and returns a data or error object when a submission is received. Otherwise, it will return undefined.
src/pages/index.astro
---
import { actions } from 'astro:actions';
const result = Astro.getActionResult(actions.logout);
---
<form action={actions.logout}>
  <button type=""submit"">Log out</button>
</form>
{result?.error && <p>Failed to log out. Please try again.</p>}
Astro.callAction()
Added in: astro@4.15.0
Astro.callAction() is a function used to call an Action handler directly from your Astro component. This function accepts an Action function as the first argument (e.g. actions.logout) and any input that action receives as the second argument. It returns the result of the action as a promise.
src/pages/index.astro
---
import { actions } from 'astro:actions';
const { data, error } = await Astro.callAction(actions.logout, { userId: '123' });
---
Endpoint Context
Endpoint functions receive a context object as the first parameter. It mirrors many of the Astro global properties.
endpoint.json.ts
import type { APIContext } from 'astro';
export function GET(context: APIContext) {
  // ...
}
context.params
context.params is an object containing the values of dynamic route segments matched for this request.
In static builds, this will be the params returned by getStaticPaths() used for prerendering dynamic routes.
In SSR builds, this can be any value matching the path segments in the dynamic route pattern.
src/pages/posts/[id].json.ts
import type { APIContext } from 'astro';
export function getStaticPaths() {
  return [
    { params: { id: '1' } },
    { params: { id: '2' } },
    { params: { id: '3' } }
  ];
}
export function GET({ params }: APIContext) {
  return new Response(
    JSON.stringify({ id: params.id }),
  );
}
See also: params
context.props
Added in: astro@1.5.0
context.props is an object containing any props passed from getStaticPaths(). Because getStaticPaths() is not used when building for SSR (server-side rendering), context.props is only available in static builds.
src/pages/posts/[id].json.ts
import type { APIContext } from 'astro';
export function getStaticPaths() {
  return [
    { params: { id: '1' }, props: { author: 'Blu' } },
    { params: { id: '2' }, props: { author: 'Erika' } },
    { params: { id: '3' }, props: { author: 'Matthew' } }
  ];
}
export function GET({ props }: APIContext) {
  return new Response(
    JSON.stringify({ author: props.author }),
  );
}
See also: Data Passing with props
context.request
Type: Request
A standard Request object. It can be used to get the url, headers, method, and even body of the request.
import type { APIContext } from 'astro';
export function GET({ request }: APIContext) {
  return new Response(`Hello ${request.url}`);
}
See also: Astro.request
context.cookies
Type: AstroCookies
context.cookies contains utilities for reading and manipulating cookies.
See also: Astro.cookies
context.url
Type: URL
Added in: astro@1.5.0
A URL object constructed from the current context.request.url URL string value.
See also: Astro.url
context.clientAddress
Type: string
Added in: astro@1.5.0
Specifies the IP address of the request. This property is only available when building for SSR (server-side rendering) and should not be used for static sites.
import type { APIContext } from 'astro';
export function GET({ clientAddress }: APIContext) {
  return new Response(`Your IP address is: ${clientAddress}`);
}
See also: Astro.clientAddress
context.site
Type: URL | undefined
Added in: astro@1.5.0
context.site returns a URL made from site in your Astro config. If undefined, this will return a URL generated from localhost.
See also: Astro.site
context.generator
Type: string
Added in: astro@1.5.0
context.generator is a convenient way to indicate the version of Astro your project is running. It follows the format ""Astro v1.x.x"".
src/pages/site-info.json.ts
import type { APIContext } from 'astro';
export function GET({ generator, site }: APIContext) {
  const body = JSON.stringify({ generator, site });
  return new Response(body);
}
See also: Astro.generator
context.redirect()
Type: (path: string, status?: number) => Response
Added in: astro@1.5.0
context.redirect() returns a Response object that allows you to redirect to another page. This function is only available when building for SSR (server-side rendering) and should not be used for static sites.
import type { APIContext } from 'astro';
export function GET({ redirect }: APIContext) {
  return redirect('/login', 302);
}
See also: Astro.redirect()
context.rewrite()
Type: (rewritePayload: string | URL | Request) => Promise<Response>
Added in: astro@4.13.0
Allows you to serve content from a different URL or path without redirecting the browser to a new page.
The method accepts either a string, a URL, or a Request for the location of the path.
Use a string to provide an explicit path:
import type { APIContext } from 'astro';
export function GET({ rewrite }: APIContext) {
  return rewrite('/login');
}
Use a URL type when you need to construct the URL path for the rewrite. The following example renders a page‚Äôs parent path by creating a new URL from the relative ""../"" path:
import type { APIContext } from 'astro';
export function GET({ rewrite }: APIContext) {
  return rewrite(new URL(""../"", Astro.url));
}
Use a Request type for complete control of the Request sent to the server for the new path. The following example sends a request to render the parent page while also providing headers:
import type { APIContext } from 'astro';
export function GET({ rewrite }: APIContext) {
  return rewrite(new Request(new URL(""../"", Astro.url), {
   headers: {
     ""x-custom-header"": JSON.stringify(Astro.locals.someValue)
   }
 }));
}
See also: Astro.rewrite()
context.locals
Added in: astro@2.4.0
context.locals is an object used to store and access arbitrary information during the lifecycle of a request.
Middleware functions can read and write the values of context.locals:
src/middleware.ts
import type { MiddlewareHandler } from 'astro';
export const onRequest: MiddlewareHandler = ({ locals }, next) => {
  if (!locals.title) {
    locals.title = ""Default Title"";
  }
  return next();
}
API endpoints can only read information from context.locals:
src/pages/hello.ts
import type { APIContext } from 'astro';
export function GET({ locals }: APIContext) {
  return new Response(locals.title); // ""Default Title""
}
See also: Astro.locals
context.getActionResult()
Type: (action: TAction) => ActionReturnType<TAction> | undefined
Added in: astro@4.15.0
context.getActionResult() is a function that returns the result of an Action submission. This accepts an action function as an argument (e.g. actions.logout), and returns a data or error object when a submission is received. Otherwise, it will return undefined.
See also Astro.getActionResult()
context.callAction()
Added in: astro@4.15.0
context.callAction() is a function used to call an Action handler directly from your Astro component. This function accepts an Action function as the first argument (e.g. actions.logout) and any input that action receives as the second argument. It returns the result of the action as a promise.
See also Astro.callAction()
getStaticPaths()
Type: (options: GetStaticPathsOptions) => Promise<GetStaticPathsResult> | GetStaticPathsResult
If a page uses dynamic params in the filename, that component will need to export a getStaticPaths() function.
This function is required because Astro is a static site builder. That means that your entire site is built ahead of time. If Astro doesn‚Äôt know to generate a page at build time, your users won‚Äôt see it when they visit your site.
---
export async function getStaticPaths() {
  return [
    { params: { /* required */ }, props: { /* optional */ } },
    { params: { ... } },
    { params: { ... } },
    // ...
  ];
}
---
<!-- Your HTML template here. -->
The getStaticPaths() function should return an array of objects to determine which paths will be pre-rendered by Astro.
It can also be used in static file endpoints for dynamic routing.
Tip
When using TypeScript, use the GetStaticPaths type utility to ensure type-safe access of your params and props.
Caution
The getStaticPaths() function executes in its own isolated scope once, before any page loads. Therefore you can‚Äôt reference anything from its parent scope, other than file imports. The compiler will warn if you break this requirement.
params
The params key of every returned object tells Astro what routes to build. The returned params must map back to the dynamic parameters and rest parameters defined in your component filepath.
params are encoded into the URL, so only strings are supported as values. The value for each params object must match the parameters used in the page name.
For example, suppose that you have a page at src/pages/posts/[id].astro. If you export getStaticPaths from this page and return the following for paths:
---
export async function getStaticPaths() {
  return [
    { params: { id: '1' } },
    { params: { id: '2' } },
    { params: { id: '3' } }
  ];
}
const { id } = Astro.params;
---
<h1>{id}</h1>
Then Astro will statically generate posts/1, posts/2, and posts/3 at build time.
Data Passing with props
To pass additional data to each generated page, you can also set a props value on every returned path object. Unlike params, props are not encoded into the URL and so aren‚Äôt limited to only strings.
For example, suppose that you generate pages based off of data fetched from a remote API. You can pass the full data object to the page component inside of getStaticPaths:
---
export async function getStaticPaths() {
  const data = await fetch('...').then(response => response.json());
  return data.map((post) => {
    return {
      params: { id: post.id },
      props: { post },
    };
  });
}
const { id } = Astro.params;
const { post } = Astro.props;
---
<h1>{id}: {post.name}</h1>
You can also pass a regular array, which may be helpful when generating or stubbing a known list of routes.
---
export async function getStaticPaths() {
  const posts = [
    {id: '1', category: ""astro"", title: ""API Reference""},
    {id: '2', category: ""react"", title: ""Creating a React Counter!""}
  ];
  return posts.map((post) => {
    return {
      params: { id: post.id },
      props: { post }
    };
  });
}
const {id} = Astro.params;
const {post} = Astro.props;
---
<body>
  <h1>{id}: {post.title}</h1>
  <h2>Category: {post.category}</h2>
</body>
Then Astro will statically generate posts/1 and posts/2 at build time using the page component in pages/posts/[id].astro. The page can reference this data using Astro.props:
paginate()
Pagination is a common use-case for websites that Astro natively supports via the paginate() function. paginate() will automatically generate the array to return from getStaticPaths() that creates one URL for every page of the paginated collection. The page number will be passed as a param, and the page data will be passed as a page prop.
export async function getStaticPaths({ paginate }) {
  // Load your data with fetch(), Astro.glob(), etc.
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=150`);
  const result = await response.json();
  const allPokemon = result.results;
  // Return a paginated collection of paths for all posts
  return paginate(allPokemon, { pageSize: 10 });
}
// If set up correctly, The page prop now has everything that
// you need to render a single page (see next section).
const { page } = Astro.props;
paginate() has the following arguments:
data - array containing the page‚Äôs data passed to the paginate() function
options - Optional object with the following properties:
pageSize - The number of items shown per page (10 by default)
params - Send additional parameters for creating dynamic routes
props - Send additional props to be available on each page
paginate() assumes a file name of [page].astro or [...page].astro. The page param becomes the page number in your URL:
/posts/[page].astro would generate the URLs /posts/1, /posts/2, /posts/3, etc.
/posts/[...page].astro would generate the URLs /posts, /posts/2, /posts/3, etc.
The pagination page prop
Type: Page<TData>
Pagination will pass a page prop to every rendered page that represents a single page of data in the paginated collection. This includes the data that you‚Äôve paginated (page.data) as well as metadata for the page (page.url, page.start, page.end, page.total, etc). This metadata is useful for things like a ‚ÄúNext Page‚Äù button or a ‚ÄúShowing 1-10 of 100‚Äù message.
page.data
Type: Array<TData>
Array of data returned from the paginate() function for the current page.
page.start
Type: number
Index of first item on current page, starting at 0. (e.g. if pageSize: 25, this would be 0 on page 1, 25 on page 2, etc.)
page.end
Type: number
Index of last item on current page.
page.size
Type: number
Default: 10
How many items per-page.
page.total
Type: number
The total number of items across all pages.
page.currentPage
Type: number
The current page number, starting with 1.
page.lastPage
Type: number
The total number of pages.
page.url.current
Type: string
Get the URL of the current page (useful for canonical URLs).
page.url.prev
Type: string | undefined
Get the URL of the previous page (will be undefined if on page 1). If a value is set for base, prepend the base path to the URL.
page.url.next
Type: string | undefined
Get the URL of the next page (will be undefined if no more pages). If a value is set for base, prepend the base path to the URL.
page.url.first
Type: string | undefined
Added in: astro@4.12.0
Get the URL of the first page (will be undefined if on page 1). If a value is set for base, prepend the base path to the URL.
page.url.last
Type: string | undefined
Added in: astro@4.12.0
Get the URL of the last page (will be undefined if no more pages). If a value is set for base, prepend the base path to the URL.
import.meta
All ESM modules include a import.meta property. Astro adds import.meta.env through Vite.
import.meta.env.SSR can be used to know when rendering on the server. Sometimes you might want different logic, like a component that should only be rendered in the client:
export default function () {
  return import.meta.env.SSR ? <div class=""spinner""></div> : <FancyComponent />;
}
Edit page
Translate this page
Previous
Error Reference
Next
astro:actions
Contribute
Give us feedback
Community""""""",8093,34311,astro
https://docs.astro.build/en/reference/modules/astro-actions/,"""""""On this page
Overview
Imports from astro:actions
defineAction()
handler() property
input validator
Use with accept: 'form'
isInputError()
isActionError()
ActionError
code
message
Want to build your own Docs?
Grab this template to get started.‚Üí
Actions API Reference
Added in: astro@4.15.0
Actions help you build a type-safe backend you can call from client code and HTML forms. All utilities to define and call actions are exposed by the astro:actions module. For examples and usage instructions, see the Actions guide.
Imports from astro:actions
Section titled Imports from astro:actions
import {
  actions,
  defineAction,
  isInputError,
  isActionError,
  ActionError,
 } from 'astro:actions';
defineAction()
Added in: astro@4.15.0
The defineAction() utility is used to define new actions from the src/actions/index.ts file. This accepts a handler() function containing the server logic to run, and an optional input property to validate input parameters at runtime.
src/actions/index.ts
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  getGreeting: defineAction({
    input: z.object({
      name: z.string(),
    }),
    handler: async (input, context) => {
      return `Hello, ${input.name}!`
    }
  })
}
handler() property
Type: (input, context) => any
defineAction() requires a handler() function containing the server logic to run when the action is called. Data returned from the handler is automatically serialized and sent to the caller.
The handler() is called with user input as its first argument. If an input validator is set, the user input will be validated before being passed to the handler. The second argument is a context object containing most of Astro‚Äôs standard endpoint context, excluding getActionResult(), callAction(), and redirect().
Return values are parsed using the devalue library. This supports JSON values and instances of Date(), Map(), Set(), and URL().
input validator
Type: ZodType | undefined
The optional input property accepts a Zod validator to validate handler inputs at runtime. If the action fails to validate, a BAD_REQUEST error is returned and the handler is not called.
If input is omitted, the handler will receive an input of type unknown for JSON requests and type FormData for form requests.
Use with accept: 'form'
If your action accepts form inputs, use the z.object() validator to automatically parse form data to a typed object. The following validators are supported for form data fields:
Inputs of type number can be validated using z.number()
Inputs of type checkbox can be validated using z.boolean()
Inputs of type file can be validated using z.instanceof(File)
Multiple inputs of the same name can be validated using z.array(/* validator */)
All other inputs can be validated using z.string()
Extension functions including .refine(), .transform(), and .pipe() are also supported on the z.object() validator.
To apply a union of different validators, use the z.discriminatedUnion() wrapper to narrow the type based on a specific form field. This example accepts a form submission to either ‚Äúcreate‚Äù or ‚Äúupdate‚Äù a user, using the form field with the name type to determine which object to validate against:
import { defineAction } from 'astro:actions';
import { z } from 'astro:schema';
export const server = {
  changeUser: defineAction({
    accept: 'form',
    input: z.discriminatedUnion('type', [
      z.object({
        // Matches when the `type` field has the value `create`
        type: z.literal('create'),
        name: z.string(),
        email: z.string().email(),
      }),
      z.object({
        // Matches when the `type` field has the value `update`
        type: z.literal('update'),
        id: z.number(),
        name: z.string(),
        email: z.string().email(),
      }),
    ]),
    async handler(input) {
      if (input.type === 'create') {
        // input is { type: 'create', name: string, email: string }
      } else {
        // input is { type: 'update', id: number, name: string, email: string }
      }
    },
  }),
};
isInputError()
Type: (error?: unknown | ActionError) => boolean
Added in: astro@4.15.0
The isInputError() utility is used to check whether an ActionError is an input validation error. When the input validator is a z.object(), input errors include a fields object with error messages grouped by name.
See the form input errors guide for more on using isInputError().
isActionError()
Type: (error?: unknown | ActionError) => boolean
Added in: astro@4.15.0
The isActionError() utility is used to check whether your action raised an ActionError within the handler property. This is useful when narrowing the type of a generic error in a try / catch block.
ActionError
Added in: astro@4.15.0
The ActionError() constructor is used to create errors thrown by an action handler. This accepts a code property describing the error that occurred (example: ""UNAUTHORIZED""), and an optional message property with further details.
code
Added in: astro@4.15.0
The code property accepts human-readable versions of all HTTP status codes. The following codes are supported:
BAD_REQUEST (400): The client sent invalid input. This error is thrown when an action input validator fails to validate.
UNAUTHORIZED (401): The client lacks valid authentication credentials.
FORBIDDEN (403): The client is not authorized to access a resource.
NOT_FOUND (404): The server cannot find the requested resource.
METHOD_NOT_SUPPORTED (405): The server does not support the requested method.
TIMEOUT (408): The server timed out while processing the request.
CONFLICT (409): The server cannot update a resource due to a conflict.
PRECONDITION_FAILED (412): The server does not meet a precondition of the request.
PAYLOAD_TOO_LARGE (413): The server cannot process the request because the payload is too large.
UNSUPPORTED_MEDIA_TYPE (415): The server does not support the request‚Äôs media type. Note: Actions already check the Content-Type header for JSON and form requests, so you likely won‚Äôt need to raise this code manually.
UNPROCESSABLE_CONTENT (422): The server cannot process the request due to semantic errors.
TOO_MANY_REQUESTS (429): The server has exceeded a specified rate limit.
CLIENT_CLOSED_REQUEST (499): The client closed the request before the server could respond.
INTERNAL_SERVER_ERROR (500): The server failed unexpectedly.
NOT_IMPLEMENTED (501): The server does not support the requested feature.
BAD_GATEWAY (502): The server received an invalid response from an upstream server.
SERVICE_UNAVAILABLE (503): The server is temporarily unavailable.
GATEWAY_TIMEOUT (504): The server received a timeout from an upstream server.
message
Added in: astro@4.15.0
The message property accepts a string. (e.g. ‚ÄúUser must be logged in.‚Äú)
Edit page
Translate this page
Previous
Astro Runtime API
Next
astro:assets
Contribute
Give us feedback
Community""""""",1521,6910,astro
https://docs.astro.build/en/reference/modules/astro-assets/,"""""""On this page
Overview
Imports from astro:assets
<Image />
Image properties
src (required)
alt (required)
width and height (required for images in public/)
densities
widths
format
quality
inferSize
<Picture />
Picture properties
formats
fallbackFormat
pictureAttributes
getImage()
inferRemoteSize()
Want to build your own Docs?
Grab this template to get started.‚Üí
Assets API Reference
Added in: astro@3.0.0
Astro provides built-in components and helper functions for optimizing and displaying your images. For features and usage examples, see our image guide.
Imports from astro:assets
import {
  Image,
  Picture,
  getImage,
  inferRemoteSize,
 } from 'astro:assets';
<Image />
src/components/MyComponent.astro
---
// import the Image component and the image
import { Image } from 'astro:assets';
import myImage from ""../assets/my_image.png""; // Image is 1600x900
---
<!-- `alt` is mandatory on the Image component -->
<Image src={myImage} alt=""A description of my image."" />
<!-- Output -->
<!-- Image is optimized, proper attributes are enforced -->
<img
  src=""/_astro/my_image.hash.webp""
  width=""1600""
  height=""900""
  decoding=""async""
  loading=""lazy""
  alt=""A description of my image.""
/>
Image properties
The <Image /> component accepts all properties accepted by the HTML <img> tag in addition to the properties described below.
src (required)
Type: ImageMetadata | string | Promise<{ default: ImageMetadata }>
The format of the src value of your image file depends on where your image file is located:
Local images in src/ - you must also import the image using a relative file path or configure and use an import alias. Then use the import name as the src value:
src/pages/index.astro
---
import { Image } from 'astro:assets';
import myImportedImage from '../assets/my-local-image.png';
---
<Image src={myImportedImage} alt=""descriptive text"" />
Images in the public/ folder - use the image‚Äôs file path relative to the public folder:
src/pages/index.astro
---
import { Image } from 'astro:assets';
---
<Image
  src=""/images/my-public-image.png""
  alt=""descriptive text""
  width=""200""
  height=""150""
/>
Remote images - use the image‚Äôs full URL as the property value:
src/pages/index.astro
---
import { Image } from 'astro:assets';
---
<Image
  src=""https://example.com/remote-image.jpg""
  alt=""descriptive text""
  width=""200""
  height=""150""
/>
alt (required)
Type: string
Use the required alt attribute to provide a string of descriptive alt text for images.
If an image is merely decorative (i.e. doesn‚Äôt contribute to the understanding of the page), set alt="""" so that screen readers and other assistive technologies know to ignore the image.
width and height (required for images in public/)
Type: number | undefined
These properties define the dimensions to use for the image.
When using images in their original aspect ratio, width and height are optional. These dimensions can be automatically inferred from image files located in src/. For remote images, add the inferSize attribute set to true on the <Image /> or <Picture /> component or use inferRemoteSize() function.
However, both of these properties are required for images stored in your public/ folder as Astro is unable to analyze these files.
densities
Type: (number | `${number}x`)[] | undefined
Added in: astro@3.3.0
A list of pixel densities to generate for the image.
If provided, this value will be used to generate a srcset attribute on the <img> tag. Do not provide a value for widths when using this value.
Densities that are equal to widths larger than the original image will be ignored to avoid upscaling the image.
src/components/MyComponent.astro
---
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png';
---
<Image
  src={myImage}
  width={myImage.width / 2}
  densities={[1.5, 2]}
  alt=""A description of my image.""
/>
<!-- Output -->
<img
  src=""/_astro/my_image.hash.webp""
  srcset=""
    /_astro/my_image.hash.webp 1.5x
    /_astro/my_image.hash.webp 2x
  ""
  alt=""A description of my image.""
  width=""800""
  height=""450""
  loading=""lazy""
  decoding=""async""
/>
widths
Type: number[] | undefined
Added in: astro@3.3.0
A list of widths to generate for the image.
If provided, this value will be used to generate a srcset attribute on the <img> tag. A sizes property must also be provided.
Do not provide a value for densities when using this value. Only one of these two values can be used to generate a srcset.
Widths that are larger than the original image will be ignored to avoid upscaling the image.
---
import { Image } from 'astro:assets';
import myImage from '../assets/my_image.png'; // Image is 1600x900
---
<Image
  src={myImage}
  widths={[240, 540, 720, myImage.width]}
  sizes={`(max-width: 360px) 240px, (max-width: 720px) 540px, (max-width: 1600px) 720px, ${myImage.width}px`}
  alt=""A description of my image.""
/>
<!-- Output -->
<img
  src=""/_astro/my_image.hash.webp""
  srcset=""
    /_astro/my_image.hash.webp 240w,
    /_astro/my_image.hash.webp 540w,
    /_astro/my_image.hash.webp 720w,
    /_astro/my_image.hash.webp 1600w
  ""
  sizes=""
    (max-width: 360px) 240px,
    (max-width: 720px) 540px,
    (max-width: 1600px) 720px,
    1600px
  ""
  alt=""A description of my image.""
  width=""1600""
  height=""900""
  loading=""lazy""
  decoding=""async""
/>
format
Type: ImageOutputFormat | undefined
You can optionally state the image file type output to be used.
By default, the <Image /> component will produce a .webp file.
quality
Type: ImageQuality | undefined
quality is an optional property that can either be:
a preset (low, mid, high, max) that is automatically normalized between formats.
a number from 0 to 100 (interpreted differently between formats).
inferSize
Type: boolean
Added in: astro@4.4.0
Allows you to set the original width and height of a remote image automatically.
By default, this value is set to false and you must manually specify both dimensions for your remote image.
Add inferSize to the <Image /> component (or inferSize: true to getImage()) to infer these values from the image content when fetched. This is helpful if you don‚Äôt know the dimensions of the remote image, or if they might change:
---
import { Image } from 'astro:assets';
---
<Image src=""https://example.com/cat.png"" inferSize alt=""A cat sleeping in the sun."" />
inferSize can fetch the dimensions of a remote image from a domain that has not been authorized, however the image itself will remain unprocessed.
<Picture />
Added in: astro@3.3.0
Use the built-in <Picture /> Astro component to display a responsive image with multiple formats and/or sizes.
src/pages/index.astro
---
import { Picture } from 'astro:assets';
import myImage from ""../assets/my_image.png""; // Image is 1600x900
---
<!-- `alt` is mandatory on the Picture component -->
<Picture src={myImage} formats={['avif', 'webp']} alt=""A description of my image."" />
<!-- Output -->
<picture>
  <source srcset=""/_astro/my_image.hash.avif"" type=""image/avif"" />
  <source srcset=""/_astro/my_image.hash.webp"" type=""image/webp"" />
  <img
    src=""/_astro/my_image.hash.png""
    width=""1600""
    height=""900""
    decoding=""async""
    loading=""lazy""
    alt=""A description of my image.""
  />
</picture>
Picture properties
<Picture /> accepts all the properties of the <Image /> component, plus the following:
formats
Type: ImageOutputFormat[]
An array of image formats to use for the <source> tags. Entries will be added as <source> elements in the order they are listed, and this order determines which format is displayed. For the best performance, list the most modern format first (e.g. webp or avif). By default, this is set to ['webp'].
fallbackFormat
Type: ImageOutputFormat
Format to use as a fallback value for the <img> tag. Defaults to .png for static images (or .jpg if the image is a JPG), .gif for animated images, and .svg for SVG files.
pictureAttributes
Type: HTMLAttributes<'picture'>
An object of attributes to be added to the <picture> tag.
Use this property to apply attributes to the outer <picture> element itself. Attributes applied to the <Picture /> component directly will apply to the inner <img> element, except for those used for image transformation.
src/components/MyComponent.astro
---
import { Picture } from ""astro:assets"";
import myImage from ""../my_image.png""; // Image is 1600x900
---
<Picture
  src={myImage}
  alt=""A description of my image.""
  pictureAttributes={{ style: ""background-color: red;"" }}
/>
<!-- Output -->
<picture style=""background-color: red;"">
  <source srcset=""/_astro/my_image.hash.webp"" type=""image/webp"" />
  <img
    src=""/_astro/my_image.hash.png""
    alt=""A description of my image.""
    width=""1600""
    height=""900""
    loading=""lazy""
    decoding=""async""
  />
</picture>
getImage()
Type: (options: UnresolvedImageTransform) => Promise<GetImageResult>
Caution
getImage() relies on server-only APIs and breaks the build when used on the client.
The getImage() function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an API Route. It also allows you to create your own custom <Image /> component.
getImage() takes an options object with the same properties as the Image component (except alt).
---
import { getImage } from ""astro:assets"";
import myBackground from ""../background.png""
const optimizedBackground = await getImage({src: myBackground, format: 'avif'})
---
<div style={`background-image: url(${optimizedBackground.src});`}></div>
It returns an object with the following type:
type GetImageResult = {
  /* Additional HTML attributes needed to render the image (width, height, style, etc..) */
  attributes: Record<string, any>;
  /* Validated parameters passed */
  options: ImageTransform;
  /* Original parameters passed */
  rawOptions: ImageTransform;
  /* Path to the generated image */
  src: string;
  srcSet: {
    /* Generated values for srcset, every entry has a url and a size descriptor */
    values: SrcSetValue[];
    /* A value ready to use in`srcset` attribute */
    attribute: string;
  };
}
inferRemoteSize()
Type: (url: string) => Promise<Omit<ImageMetadata, 'src' | 'fsPath'>>
Added in: astro@4.12.0
A function to infer the dimensions of remote images. This can be used as an alternative to passing the inferSize property.
import { inferRemoteSize } from 'astro:assets';
const {width, height} = await inferRemoteSize(""https://example.com/cat.png"");
Edit page
Translate this page
Previous
astro:actions
Next
astro:content
Contribute
Give us feedback
Community""""""",2590,10508,astro
https://docs.astro.build/en/reference/modules/astro-content/,"""""""On this page
Overview
Imports from astro:content
defineCollection()
type
schema
reference()
getCollection()
getEntry()
getEntries()
getEntryBySlug()
getDataEntryById()
astro:content types
CollectionEntry
id
collection
data
slug
body
render()
CollectionKey
ContentCollectionKey
DataCollectionKey
SchemaContext
Want to build your own Docs?
Grab this template to get started.‚Üí
Content Collections API Reference
Added in: astro@2.0.0
Content collections offer APIs to configure and query your Markdown or MDX documents in src/content/. For features and usage examples, see our content collections guide.
Imports from astro:content
import {
  z,
  defineCollection,
  getCollection,
  getEntry,
  getEntries,
  reference,
 } from 'astro:content';
defineCollection()
Type: (input: CollectionConfig) => CollectionConfig
defineCollection() is a utility to configure a collection in a src/content/config.* file.
src/content/config.ts
import { z, defineCollection } from 'astro:content';
const blog = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string(),
    permalink: z.string().optional(),
  }),
});
// Expose your defined collection to Astro
// with the `collections` export
export const collections = { blog };
This function accepts the following properties:
type
Type: 'content' | 'data'
Default: 'content'
Added in: astro@2.5.0
type is a string that defines the type of entries stored within a collection:
'content' - for content-authoring formats like Markdown (.md), MDX (.mdx), or Markdoc (.mdoc)
'data' - for data-only formats like JSON (.json) or YAML (.yaml)
Tip
This means collections cannot store a mix of content and data formats. You must split these entries into separate collections by type.
schema
Type: ZodType | (context: SchemaContext) => ZodType
schema is an optional Zod object to configure the type and shape of document frontmatter for a collection. Each value must use a Zod validator.
See the Content Collection guide for example usage.
reference()
Type: (collection: string) => ZodEffects<ZodString, { collection, id: string } | { collection, slug: string }>
Added in: astro@2.5.0
The reference() function is used in the content config to define a relationship, or ‚Äúreference,‚Äù from one collection to another. This accepts a collection name and validates the entry identifier(s) specified in your content frontmatter or data file.
This example defines references from a blog author to the authors collection and an array of related posts to the same blog collection:
import { defineCollection, reference, z } from 'astro:content';
const blog = defineCollection({
  type: 'content',
  schema: z.object({
    // Reference a single author from the `authors` collection by `id`
    author: reference('authors'),
    // Reference an array of related posts from the `blog` collection by `slug`
    relatedPosts: z.array(reference('blog')),
  })
});
const authors = defineCollection({
  type: 'data',
  schema: z.object({ /* ... */ })
});
export const collections = { blog, authors };
See the Content Collection guide for example usage.
getCollection()
Type: (collection: string, filter?: (entry: CollectionEntry<TCollectionName>) => boolean) => CollectionEntry<TCollectionName>[]
getCollection() is a function that retrieves a list of content collection entries by collection name.
It returns all items in the collection by default, and accepts an optional filter function to narrow by entry properties. This allows you to query for only some items in a collection based on id, slug, or frontmatter values via the data object.
---
import { getCollection } from 'astro:content';
// Get all `src/content/blog/` entries
const allBlogPosts = await getCollection('blog');
// Only return posts with `draft: true` in the frontmatter
const draftBlogPosts = await getCollection('blog', ({ data }) => {
  return data.draft === true;
});
---
See the Content Collection guide for example usage.
getEntry()
Added in: astro@2.5.0
Types:
(collection: string, contentSlugOrDataId: string) => CollectionEntry<TCollectionName>
({ collection: string, id: string }) => CollectionEntry<TCollectionName>
({ collection: string, slug: string }) => CollectionEntry<TCollectionName>
getEntry() is a function that retrieves a single collection entry by collection name and either the entry id (for type: 'data' collections) or entry slug (for type: 'content' collections). getEntry() can also be used to get referenced entries to access the data, body, or render() properties:
---
import { getEntry } from 'astro:content';
// Get `src/content/blog/enterprise.md`
const enterprisePost = await getEntry('blog', 'enterprise');
// Get `src/content/captains/picard.yaml`
const picardProfile = await getEntry('captains', 'picard');
// Get the profile referenced by `data.captain`
const enterpriseCaptainProfile = await getEntry(enterprisePost.data.captain);
---
See the Content Collections guide for examples of querying collection entries.
getEntries()
Added in: astro@2.5.0
Types:
(Array<{ collection: string, id: string }>) => CollectionEntry<TCollectionName>[]
(Array<{ collection: string, slug: string }>) => CollectionEntry<TCollectionName>[]
getEntries() is a function that retrieves multiple collection entries from the same collection. This is useful for returning an array of referenced entries to access their associated data, body, and render() properties.
---
import { getEntries } from 'astro:content';
const enterprisePost = await getEntry('blog', 'enterprise');
// Get related posts referenced by `data.relatedPosts`
const enterpriseRelatedPosts = await getEntries(enterprisePost.data.relatedPosts);
---
getEntryBySlug()
Type: (collection: string, slug: string) => Promise<CollectionEntry<TCollectionName>>
Deprecated
Use the getEntry() function to query content entries. This accepts the same arguments as getEntryBySlug(), and supports querying by id for JSON or YAML collections.
getEntryBySlug() is a function that retrieves a single collection entry by collection name and entry slug.
---
import { getEntryBySlug } from 'astro:content';
const enterprise = await getEntryBySlug('blog', 'enterprise');
---
See the Content Collection guide for example usage.
getDataEntryById()
Type: (collection: string, id: string) => Promise<CollectionEntry<TCollectionName>>
Added in: astro@2.5.0
Deprecated
Use the getEntry() function to query data entries. This accepts the same arguments as getDataEntryById(), and supports querying by slug for content authoring formats like Markdown.
getDataEntryById() is a function that retrieves a single collection entry by collection name and entry id.
---
import { getDataEntryById } from 'astro:content';
const picardProfile = await getDataEntryById('captains', 'picard');
---
astro:content types
import type {
  CollectionEntry,
  CollectionKey,
  ContentCollectionKey,
  DataCollectionKey,
  SchemaContext,
 } from 'astro:content';
CollectionEntry
Query functions including getCollection(), getEntry(), and getEntries() each return entries with the CollectionEntry type. This type is available as a utility from astro:content:
import type { CollectionEntry } from 'astro:content';
CollectionEntry is a generic type. Use it with the name of the collection you‚Äôre querying. For example, an entry in your blog collection would have the type CollectionEntry<'blog'>.
Each CollectionEntry is an object with the following values:
id
Available for: type: 'content' and type: 'data' collections
Example Types:
content collections: 'entry-1.md' | 'entry-2.md' | ...
data collections: 'author-1' | 'author-2' | ...
A unique ID using the file path relative to src/content/[collection]. Enumerates all possible string values based on the collection entry file paths. Note that collections defined as type: 'content' include the file extension in their ID, while collections defined as type: 'data' do not.
collection
Available for: type: 'content' and type: 'data' collections
Example Type: 'blog' | 'authors' | ...
The name of a top-level folder under src/content/ in which entries are located. This is the name used to reference the collection in your schema, and in querying functions.
data
Available for: type: 'content' and type: 'data' collections
Type: CollectionSchema<TCollectionName>
An object of frontmatter properties inferred from your collection schema (see defineCollection() reference). Defaults to any if no schema is configured.
slug
Available for: type: 'content' collections only
Example Type: 'entry-1' | 'entry-2' | ...
A URL-ready slug for Markdown or MDX documents. Defaults to the id without the file extension, but can be overridden by setting the slug property in a file‚Äôs frontmatter.
body
Available for: type: 'content' collections only
Type: string
A string containing the raw, uncompiled body of the Markdown or MDX document.
render()
Available for: type: 'content' collections only
Type: () => Promise<RenderedEntry>
A function to compile a given Markdown or MDX document for rendering. This returns the following properties:
<Content /> - A component used to render the document‚Äôs contents in an Astro file.
headings - A generated list of headings, mirroring Astro‚Äôs getHeadings() utility on Markdown and MDX imports.
remarkPluginFrontmatter - The modified frontmatter object after any remark or rehype plugins have been applied. Set to type any.
---
import { getEntryBySlug } from 'astro:content';
const entry = await getEntryBySlug('blog', 'entry-1');
const { Content, headings, remarkPluginFrontmatter } = await entry.render();
---
See the Content Collection guide for example usage.
CollectionKey
Added in: astro@3.1.0
A string union of all collection names defined in your src/content/config.* file. This type can be useful when defining a generic function that accepts any collection name.
import { type CollectionKey, getCollection } from 'astro:content';
async function getCollection(collection: CollectionKey) {
  return getCollection(collection);
}
ContentCollectionKey
Added in: astro@3.1.0
A string union of all the names of type: 'content' collections defined in your src/content/config.* file.
DataCollectionKey
Added in: astro@3.1.0
A string union of all the names of type: 'data' collection defined in your src/content/config.* file.
SchemaContext
The context object that defineCollection uses for the function shape of schema. This type can be useful when building reusable schemas for multiple collections.
This includes the following property:
image - The image() schema helper that allows you to use local images in Content Collections
import type { SchemaContext } from 'astro:content';
export const imageSchema = ({ image }: SchemaContext) =>
    z.object({
        image: image(),
        description: z.string().optional(),
    });
const blog = defineCollection({
  type: 'content',
  schema: ({ image }) => z.object({
    title: z.string(),
    permalink: z.string().optional(),
    image: imageSchema({ image })
  }),
});
Edit page
Translate this page
Previous
astro:assets
Next
astro:i18n
Contribute
Give us feedback
Community""""""",2469,11035,astro
https://docs.astro.build/en/reference/modules/astro-i18n/,"""""""On this page
Overview
Imports from astro:i18n
getRelativeLocaleUrl()
getAbsoluteLocaleUrl()
getRelativeLocaleUrlList()
getAbsoluteLocaleUrlList()
getPathByLocale()
getLocaleByPath()
redirectToDefaultLocale()
redirectToFallback()
notFound()
middleware()
requestHasLocale()
Want to build your own Docs?
Grab this template to get started.‚Üí
Internationalization API Reference
Added in: astro@3.5.0
This module provides functions to help you create URLs using your project‚Äôs configured locales.
Creating routes for your project with the i18n router will depend on certain configuration values you have set that affect your page routes. When creating routes with these functions, be sure to take into account your individual settings for:
base
trailingSlash
build.format
site
Also, note that the returned URLs created by these functions for your defaultLocale will reflect your i18n.routing configuration.
For features and usage examples, see our i18n routing guide.
Imports from astro:i18n
import {
  getRelativeLocaleUrl,
  getAbsoluteLocaleUrl,
  getRelativeLocaleUrlList,
  getAbsoluteLocaleUrlList,
  getPathByLocale,
  getLocaleByPath,
  redirectToDefaultLocale,
  redirectToFallback,
  notFound,
  middleware,
  requestHasLocale,
 } from 'astro:i18n';
getRelativeLocaleUrl()
Type: (locale: string, path?: string, options?: GetLocaleOptions) => string
Use this function to retrieve a relative path for a locale. If the locale doesn‚Äôt exist, Astro throws an error.
---
import { getRelativeLocaleUrl } from 'astro:i18n';
getRelativeLocaleUrl(""fr"");
// returns /fr
getRelativeLocaleUrl(""fr"", """");
// returns /fr
getRelativeLocaleUrl(""fr"", ""getting-started"");
// returns /fr/getting-started
getRelativeLocaleUrl(""fr_CA"", ""getting-started"", {
  prependWith: ""blog""
});
// returns /blog/fr-ca/getting-started
getRelativeLocaleUrl(""fr_CA"", ""getting-started"", {
  prependWith: ""blog"",
  normalizeLocale: false
});
// returns /blog/fr_CA/getting-started
---
getAbsoluteLocaleUrl()
Type: (locale: string, path: string, options?: GetLocaleOptions) => string
Use this function to retrieve an absolute path for a locale when [site] has a value. If [site] isn‚Äôt configured, the function returns a relative URL. If the locale doesn‚Äôt exist, Astro throws an error.
src/pages/index.astro
---
import { getAbsoluteLocaleUrl } from 'astro:i18n';
// If `site` is set to be `https://example.com`
getAbsoluteLocaleUrl(""fr"");
// returns https://example.com/fr
getAbsoluteLocaleUrl(""fr"", """");
// returns https://example.com/fr
getAbsoluteLocaleUrl(""fr"", ""getting-started"");
// returns https://example.com/fr/getting-started
getAbsoluteLocaleUrl(""fr_CA"", ""getting-started"", {
  prependWith: ""blog""
});
// returns https://example.com/blog/fr-ca/getting-started
getAbsoluteLocaleUrl(""fr_CA"", ""getting-started"", {
  prependWith: ""blog"",
  normalizeLocale: false
});
// returns https://example.com/blog/fr_CA/getting-started
---
getRelativeLocaleUrlList()
Type: (path?: string, options?: GetLocaleOptions) => string[]
Use this like getRelativeLocaleUrl to return a list of relative paths for all the locales.
getAbsoluteLocaleUrlList()
Type: (path?: string, options?: GetLocaleOptions) => string[]
Use this like getAbsoluteLocaleUrl to return a list of absolute paths for all the locales.
getPathByLocale()
Type: (locale: string) => string
A function that returns the path associated to one or more codes when custom locale paths are configured.
astro.config.mjs
export default defineConfig({
  i18n: {
    locales: [""es"", ""en"", {
      path: ""french"",
      codes: [""fr"", ""fr-BR"", ""fr-CA""]
    }]
  }
})
src/pages/index.astro
---
import { getPathByLocale } from 'astro:i18n';
getPathByLocale(""fr""); // returns ""french""
getPathByLocale(""fr-CA""); // returns ""french""
---
getLocaleByPath()
Type: (path: string) => string
A function that returns the code associated to a locale path.
astro.config.mjs
export default defineConfig({
  i18n: {
    locales: [""es"", ""en"", {
      path: ""french"",
      codes: [""fr"", ""fr-BR"", ""fr-CA""]
    }]
  }
})
src/pages/index.astro
---
import { getLocaleByPath } from 'astro:i18n';
getLocaleByPath(""french""); // returns ""fr"" because that's the first code configured
---
redirectToDefaultLocale()
Type: (context: APIContext, statusCode?: ValidRedirectStatus) => Promise<Response>
Added in: astro@4.6.0
Note
Available only when i18n.routing is set to ""manual""
A function that returns a Response that redirects to the defaultLocale configured. It accepts an optional valid redirect status code.
middleware.js
import { defineMiddleware } from ""astro:middleware"";
import { redirectToDefaultLocale } from ""astro:i18n"";
export const onRequest = defineMiddleware((context, next) => {
  if (context.url.pathname.startsWith(""/about"")) {
    return next();
  } else {
    return redirectToDefaultLocale(context, 302);
  }
})
redirectToFallback()
Type: (context: APIContext, response: Response) => Promise<Response>
Added in: astro@4.6.0
Note
Available only when i18n.routing is set to ""manual""
A function that allows you to use your i18n.fallback configuration in your own middleware.
middleware.js
import { defineMiddleware } from ""astro:middleware"";
import { redirectToFallback } from ""astro:i18n"";
export const onRequest = defineMiddleware(async (context, next) => {
  const response = await next();
  if (response.status >= 300) {
    return redirectToFallback(context, response)
  }
  return response;
})
notFound()
Type: (context: APIContext, response?: Response) => Promise<Response> | undefined
Added in: astro@4.6.0
Note
Available only when i18n.routing is set to ""manual""
Use this function in your routing middleware to return a 404 when:
the current path isn‚Äôt a root. e.g. / or /<base>
the URL doesn‚Äôt contain a locale
When a Response is passed, the new Response emitted by this function will contain the same headers of the original response.
middleware.js
import { defineMiddleware } from ""astro:middleware"";
import { notFound } from ""astro:i18n"";
export const onRequest = defineMiddleware((context, next) => {
  const pathNotFound = notFound(context);
  if (pathNotFound) {
    return pathNotFound;
  }
  return next();
})
middleware()
Type: (options: { prefixDefaultLocale: boolean, redirectToDefaultLocale: boolean }) => MiddlewareHandler
Added in: astro@4.6.0
Note
Available only when i18n.routing is set to ""manual""
A function that allows you to programmatically create the Astro i18n middleware.
This is useful when you still want to use the default i18n logic, but add only a few exceptions to your website.
middleware.js
import { middleware } from ""astro:i18n"";
import { sequence, defineMiddleware } from ""astro:middleware"";
const customLogic = defineMiddleware(async (context, next) => {
  const response = await next();
  // Custom logic after resolving the response.
  // It's possible to catch the response coming from Astro i18n middleware.
  return response;
});
export const onRequest = sequence(customLogic, middleware({
  prefixDefaultLocale: true,
  redirectToDefaultLocale: false
}))
requestHasLocale()
Type: (context: APIContext) => boolean
Added in: astro@4.6.0
Note
Available only when i18n.routing is set to ""manual""
Checks whether the current URL contains a configured locale. Internally, this function will use APIContext#url.pathname.
middleware.js
import { defineMiddleware } from ""astro:middleware"";
import { requestHasLocale } from ""astro:i18n"";
export const onRequest = defineMiddleware(async (context, next) => {
  if (requestHasLocale(context)) {
    return next();
  }
  return new Response(""Not found"", { status: 404 });
})
Edit page
Translate this page
Previous
astro:content
Next
astro:middleware
Contribute
Give us feedback
Community""""""",1851,7673,astro
https://docs.astro.build/en/reference/modules/astro-middleware/,"""""""On this page
Overview
Imports from astro:middleware
defineMiddleware()
sequence()
createContext()
trySerializeLocals()
Middleware exports
onRequest()
context
next()
Want to build your own Docs?
Grab this template to get started.‚Üí
Middleware API Reference
Added in: astro@2.6.0
Middleware allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. For features and usage examples, see our middleware guide.
Imports from astro:middleware
import {
  sequence,
  createContext,
  trySerializeLocals,
  defineMiddleware,
 } from 'astro:middleware';
defineMiddleware()
You can import and use the utility function defineMiddleware() to take advantage of type safety:
src/middleware.ts
import { defineMiddleware } from ""astro:middleware"";
// `context` and `next` are automatically typed
export const onRequest = defineMiddleware((context, next) => {
});
sequence()
Type: (...handlers: MiddlewareHandler[]) => MiddlewareHandler
A function that accepts middleware functions as arguments, and will execute them in the order in which they are passed.
src/middleware.js
import { sequence } from ""astro:middleware"";
async function validation(_, next) {...}
async function auth(_, next) {...}
async function greeting(_, next) {...}
export const onRequest = sequence(validation, auth, greeting);
createContext()
Type: (context: CreateContext) => APIContext
Added in: astro@2.8.0
A low-level API to create an APIContextto be passed to an Astro middleware onRequest() function.
This function can be used by integrations/adapters to programmatically execute the Astro middleware.
trySerializeLocals()
Type: (value: unknown) => string
Added in: astro@2.8.0
A low-level API that takes in any value and tries to return a serialized version (a string) of it. If the value cannot be serialized, the function will throw a runtime error.
Middleware exports
When defining your project‚Äôs middleware in src/middleware.js, export the following user-defined functions:
onRequest()
Type: (context: APIContext, next: MiddlewareNext) => Promise<Response> | Response | Promise<void> | void
A required exported function from src/middleware.js that will be called before rendering every page or API route. It receives two arguments: context and next(). onRequest() must return a Response: either directly, or by calling next().
src/middleware.js
export function onRequest (context, next) {
    // intercept response data from a request
    // optionally, transform the response
    // return a Response directly, or the result of calling `next()`
    return next();
};
Your onRequest() function will be called with the following arguments:
context
Type: APIContext
The first argument of onRequest() is a context object. It mirrors many of the Astro global properties.
See Endpoint contexts for more information about the context object.
next()
Type: (rewritePayload?: string | URL | Request) => Promise<Response>
The second argument of onRequest() is a function that calls all the subsequent middleware in the chain and returns a Response. For example, other middleware could modify the HTML body of a response and awaiting the result of next() would allow your middleware to respond to those changes.
Since Astro v4.13.0, next() accepts an optional URL path parameter in the form of a string, URL, or Request to rewrite the current request without retriggering a new rendering phase.
Edit page
Translate this page
Previous
astro:i18n
Next
astro:transitions
Contribute
Give us feedback
Community""""""",749,3534,astro
https://docs.astro.build/en/reference/modules/astro-transitions/,"""""""On this page
Overview
Imports from astro:transitions
<ViewTransitions />
fade
slide
Imports from astro:transitions/client
navigate()
history option
formData option
info option
state option
sourceElement option
supportsViewTransitions
transitionEnabledOnThisPage
getFallback()
swapFunctions
deselectScripts()
swapRootAttributes()
swapHeadElements()
saveFocus()
swapBodyElement()
Lifecycle events
astro:before-preparation event
astro:after-preparation event
astro:before-swap event
astro:after-swap event
astro:page-load event
Lifecycle events attributes
info
sourceElement
newDocument
navigationType
direction
from
to
formData
loader()
viewTransition
swap()
Want to build your own Docs?
Grab this template to get started.‚Üí
View Transitions API Reference
Added in: astro@3.0.0
These modules provide functions to control and interact with the View Transitions API and client-side router.
For features and usage examples, see our View Transitions guide.
Imports from astro:transitions
import { ViewTransitions, fade, slide } from 'astro:transitions';
<ViewTransitions />
Added in: astro@3.0.0
Opt in to using view transitions on individual pages by importing and adding the <ViewTransitions /> routing component to <head> on every desired page.
src/pages/index.astro
---
import { ViewTransitions } from 'astro:transitions';
---
<html lang=""en"">
  <head>
    <title>My Homepage</title>
    <ViewTransitions />
  </head>
  <body>
    <h1>Welcome to my website!</h1>
  </body>
</html>
See more about how to control the router and add transition directives to page elements and components.
fade
Type: (opts: { duration?: string | number }) => TransitionDirectionalAnimations
Added in: astro@3.0.0
Utility function to support customizing the duration of the built-in fade animation.
---
import { fade } from 'astro:transitions';
---
<!-- Fade transition with the default duration -->
<div transition:animate=""fade"" />
<!-- Fade transition with a duration of 400 milliseconds -->
<div transition:animate={fade({ duration: '0.4s' })} />
slide
Type: (opts: { duration?: string | number }) => TransitionDirectionalAnimations
Added in: astro@3.0.0
Utility function to support customizing the duration of the built-in slide animation.
---
import { slide } from 'astro:transitions';
---
<!-- Slide transition with the default duration -->
<div transition:animate=""slide"" />
<!-- Slide transition with a duration of 400 milliseconds -->
<div transition:animate={slide({ duration: '0.4s' })} />
Imports from astro:transitions/client
<script>
  import {
    navigate,
    supportsViewTransitions,
    transitionEnabledOnThisPage,
    getFallback,
    swapFunctions,
  } from 'astro:transitions/client';
</script>
navigate()
Type: (href: string, options?: Options) => void
Added in: astro@3.2.0
A function that executes a navigation to the given href using the View Transitions API.
This function signature is based on the navigate function from the browser Navigation API. Although based on the Navigation API, this function is implemented on top of the History API to allow for navigation without reloading the page.
history option
Type: 'auto' | 'push' | 'replace'
Default: 'auto'
Added in: astro@3.2.0
Defines how this navigation should be added to the browser history.
'push': the router will use history.pushState to create a new entry in the browser history.
'replace': the router will use history.replaceState to update the URL without adding a new entry into navigation.
'auto' (default): the router will attempt history.pushState, but if the URL cannot be transitioned to, the current URL will remain with no changes to the browser history.
This option follows the history option from the browser Navigation API but simplified for the cases that can happen on an Astro project.
formData option
Type: FormData
Added in: astro@3.5.0
A FormData object for POST requests.
When this option is provided, the requests to the navigation target page will be sent as a POST request with the form data object as the content.
Submitting an HTML form with view transitions enabled will use this method instead of the default navigation with page reload. Calling this method allows triggering the same behavior programmatically.
info option
Type: any
Added in: astro@3.6.0
Arbitrary data to be included in the astro:before-preparation and astro:before-swap events caused by this navigation.
This option mimics the info option from the browser Navigation API.
state option
Type: any
Added in: astro@3.6.0
Arbitrary data to be associated with the NavitationHistoryEntry object created by this navigation. This data can then be retrieved using the history.getState function from the History API.
This option mimics the state option from the browser Navigation API.
sourceElement option
Type: Element
Added in: astro@3.6.0
The element that triggered this navigation, if any. This element will be available in the following events:
astro:before-preparation
astro:before-swap
supportsViewTransitions
Type: boolean
Added in: astro@3.2.0
Whether or not view transitions are supported and enabled in the current browser.
transitionEnabledOnThisPage
Type: boolean
Added in: astro@3.2.0
Whether or not the current page has view transitions enabled for client-side navigation. This can be used to make components that behave differently when they are used on pages with view transitions.
getFallback()
Type: () => 'none' | 'animate' | 'swap'
Added in: astro@3.6.0
Returns the fallback strategy to use in browsers that do not support view transitions.
See the guide on Fallback control for how to choose and configure the fallback behavior.
swapFunctions
Added in: astro@4.15.0
An object containing the utility functions used to build Astro‚Äôs default swap function. These can be useful when building a custom swap function.
swapFunctions provides the following methods:
deselectScripts()
Type: (newDocument: Document) => void
Marks scripts in the new document that should not be executed. Those scripts are already in the current document and are not flagged for re-execution using data-astro-rerun.
swapRootAttributes()
Type: (newDocument: Document) => void
Swaps the attributes between the document roots, like the lang attribute. This also includes Astro-injected internal attributes like data-astro-transition, which makes the transition direction available to Astro-generated CSS rules.
When making a custom swap function, it is important to call this function so as not to break the view transition‚Äôs animations.
swapHeadElements()
Type: (newDocument: Document) => void
Removes every element from the current document‚Äôs <head> that is not persisted to the new document. Then appends all new elements from the new document‚Äôs <head> to the current document‚Äôs <head>.
saveFocus()
Type: () => () => void
Stores the element in focus on the current page and returns a function that when called, if the focused element was persisted, returns the focus to it.
swapBodyElement()
Type: (newBody: Element, oldBody: Element) => void
Replaces the old body with the new body. Then, goes through every element in the old body that should be persisted and have a matching element in the new body and swaps the old element back in place.
Lifecycle events
astro:before-preparation event
An event dispatched at the beginning of a navigation using View Transitions. This event happens before any request is made and any browser state is changed.
This event has the attributes:
info
sourceElement
navigationType
direction
from
to
formData
loader()
Read more about how to use this event on the View Transitions guide.
astro:after-preparation event
An event dispatched after the next page in a navigation using View Transitions is loaded.
This event has no attributes.
Read more about how to use this event on the View Transitions guide.
astro:before-swap event
An event dispatched after the next page is parsed, prepared, and linked into a document in preparation for the transition but before any content is swapped between the documents.
This event can‚Äôt be canceled. Calling preventDefault() is a no-op.
This event has the attributes:
info
sourceElement
navigationType
direction
from
to
viewTransition
swap()
Read more about how to use this event on the View Transitions guide.
astro:after-swap event
An event dispatched after the contents of the page have been swapped but before the view transition ends.
The history entry and scroll position have already been updated when this event is triggered.
astro:page-load event
An event dispatched after a page completes loading, whether from a navigation using view transitions or native to the browser.
When view transitions is enabled on the page, code that would normally execute on DOMContentLoaded should be changed to execute on this event.
Lifecycle events attributes
Added in: astro@3.6.0
info
Type: URL
Arbitrary data defined during navigation.
This is the literal value passed on the info option of the navigate() function.
sourceElement
Type: Element | undefined
The element that triggered the navigation. This can be, for example, an <a> element that was clicked.
When using the navigate() function, this will be the element specified in the call.
newDocument
Type: Document
The document for the next page in the navigation. The contents of this document will be swapped in place of the contents of the current document.
navigationType
Type: 'push' | 'replace' | 'traverse'
Which kind of history navigation is happening.
push: a new NavigationHistoryEntry is being created for the new page.
replace: the current NavigationHistoryEntry is being replaced with an entry for the new page.
traverse: no NavigationHistoryEntry is created. The position in the history is changing. The direction of the traversal is given on the direction attribute
direction
Type: Direction
The direction of the transition.
forward: navigating to the next page in the history or to a new page.
back: navigating to the previous page in the history.
Anything else some other listener might have set.
from
Type: URL
The URL of the page initiating the navigation.
to
Type: URL
The URL of the page being navigated to. This property can be modified, the value at the end of the lifecycle will be used in the NavigationHistoryEntry for the next page.
formData
Type: FormData | undefined
A FormData object for POST requests.
When this attribute is set, a POST request will be sent to the to URL with the given form data object as the content instead of the normal GET request.
When submitting an HTML form with view transitions enabled, this field is automatically set to the data in the form. When using the navigate() function, this value is the same as given in the options.
loader()
Type: () => Promise<void>
Implementation of the following phase in the navigation (loading the next page). This implementation can be overridden to add extra behavior.
viewTransition
Type: ViewTransition
The view transition object used in this navigation. On browsers that do not support the View Transitions API, this is an object implementing the same API for convenience but without the DOM integration.
swap()
Type: () => void
Implementation of the document swap logic.
Read more about building a custom swap function in the View Transitions guide.
By default, this implementation will call the following functions in order:
deselectScripts()
swapRootAttributes()
swapHeadElements()
saveFocus()
swapBodyElement()
Edit page
Translate this page
Previous
astro:middleware
Next
Integrations API
Contribute
Give us feedback
Community""""""",2495,11495,astro
https://docs.astro.build/en/reference/integrations-reference/,"""""""On this page
Overview
Examples
Quick API Reference
Hooks
astro:config:setup
astro:config:done
astro:server:setup
astro:server:start
astro:server:done
astro:build:start
astro:build:setup
astro:build:generated
astro:build:ssr
astro:build:done
astro:route:setup
Custom hooks
HookParameters
Allow installation with astro add
AstroIntegrationLogger
Integration Ordering
Combine integrations into presets
Community Resources
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro Integration API
Astro Integrations add new functionality and behaviors for your project with only a few lines of code.
This reference page is for anyone writing their own integration. To learn how to use an integration in your project, check out our Using Integrations guide instead.
Examples
The official Astro integrations can act as reference for you as you go to build your own integrations.
Renderers: lit, svelte, react, preact, vue, solid
Libraries: tailwind, partytown
Features: sitemap
Quick API Reference
interface AstroIntegration {
  name: string;
  hooks: {
    'astro:config:setup'?: (options: {
      config: AstroConfig;
      command: 'dev' | 'build' | 'preview' | 'sync';
      isRestart: boolean;
      updateConfig: (newConfig: DeepPartial<AstroConfig>) => AstroConfig;
      addRenderer: (renderer: AstroRenderer) => void;
      addWatchFile: (path: URL | string) => void;
      addClientDirective: (directive: ClientDirectiveConfig) => void;
      addMiddleware: (middleware: AstroIntegrationMiddleware) => void;
      addDevToolbarApp: (pluginEntrypoint: string) => void;
      injectScript: (stage: InjectedScriptStage, content: string) => void;
      injectRoute: (injectedRoute: { pattern: string, entrypoint: string }) => void;
      logger: AstroIntegrationLogger;
    }) => void | Promise<void>;
    'astro:config:done'?: (options: {
      config: AstroConfig;
      setAdapter: (adapter: AstroAdapter) => void;
      injectTypes: (injectedType: { filename: string; content: string }) => URL;
      logger: AstroIntegrationLogger;
      }) => void | Promise<void>;
    'astro:route:setup'?: (options: { route: RouteOptions; logger: AstroIntegrationLogger; }) => void | Promise<void>;
    'astro:server:setup'?: (options: { server: vite.ViteDevServer; logger: AstroIntegrationLogger; }) => void | Promise<void>;
    'astro:server:start'?: (options: { address: AddressInfo; logger: AstroIntegrationLogger; }) => void | Promise<void>;
    'astro:server:done'?: (options: { logger: AstroIntegrationLogger; }) => void | Promise<void>;
    'astro:build:start'?: (options: { logger: AstroIntegrationLogger; }) => void | Promise<void>;
    'astro:build:setup'?: (options: {
      vite: ViteConfigWithSSR;
      pages: Map<string, PageBuildData>;
      target: 'client' | 'server';
      logger: AstroIntegrationLogger;
    }) => void | Promise<void>;
    'astro:build:generated'?: (options: { dir: URL; logger: AstroIntegrationLogger; }) => void | Promise<void>;
    'astro:build:ssr'?: (options: {
        manifest: SerializedSSRManifest;
        entryPoints: Map<RouteData, URL>;
        logger: AstroIntegrationLogger;
    }) => void | Promise<void>;
    'astro:build:done'?: (options: { dir: URL; routes: RouteData[]; logger: AstroIntegrationLogger; }) => void | Promise<void>;
    // ... any custom hooks from integrations
  };
}
Hooks
Astro provides hooks that integrations can implement to execute during certain parts of Astro‚Äôs lifecycle. Astro hooks are defined in the IntegrationHooks interface, which is part of the global Astro namespace.
The following hooks are built in to Astro:
astro:config:setup
Next hook: astro:config:done
When: On initialization, before either the Vite or Astro config have resolved.
Why: To extend the project config. This includes updating the Astro config, applying Vite plugins, adding component renderers, and injecting scripts onto the page.
'astro:config:setup'?: (options: {
  config: AstroConfig;
  command: 'dev' | 'build' | 'preview' | 'sync';
  isRestart: boolean;
  updateConfig: (newConfig: DeepPartial<AstroConfig>) => AstroConfig;
  addRenderer: (renderer: AstroRenderer) => void;
  addClientDirective: (directive: ClientDirectiveConfig) => void;
  addMiddleware: (middleware: AstroIntegrationMiddleware) => void;
  addDevToolbarApp: (pluginEntrypoint: string) => void;
  addWatchFile: (path: URL | string) => void;
  injectScript: (stage: InjectedScriptStage, content: string) => void;
  injectRoute: ({ pattern: string, entrypoint: string }) => void;
  logger: AstroIntegrationLogger;
}) => void | Promise<void>;
config option
Type: AstroConfig
A read-only copy of the user-supplied Astro config. This is resolved before any other integrations have run. If you need a copy of the config after all integrations have completed their config updates, see the astro:config:done hook.
command option
Type: 'dev' | 'build' | 'preview' | 'sync'
dev - Project is executed with astro dev
build - Project is executed with astro build
preview - Project is executed with astro preview
sync - Project is executed with astro sync
isRestart option
Type: boolean
false when the dev server starts, true when a reload is triggered. Useful to detect when this function is called more than once.
updateConfig option
Type: (newConfig: DeepPartial<AstroConfig>) => AstroConfig;
A callback function to update the user-supplied Astro config. Any config you provide will be merged with the user config + other integration config updates, so you are free to omit keys!
For example, say you need to supply a Vite plugin to the user‚Äôs project:
import bananaCSS from '@vitejs/official-banana-css-plugin';
export default {
  name: 'banana-css-integration',
  hooks: {
    'astro:config:setup': ({ updateConfig }) => {
      updateConfig({
        vite: {
          plugins: [bananaCSS()],
        }
      })
    }
  }
}
addRenderer option
Type: (renderer: AstroRenderer ) => void; Examples: lit, svelte, react, preact, vue, solid
A callback function to add a component framework renderer (i.e. React, Vue, Svelte, etc). You can browse the examples and type definition above for more advanced options, but here are the 2 main options to be aware of:
clientEntrypoint - path to a file that executes on the client whenever your component is used. This is mainly for rendering or hydrating your component with JS.
serverEntrypoint - path to a file that executes during server-side requests or static builds whenever your component is used. These should render components to static markup, with hooks for hydration where applicable. React‚Äôs renderToString callback is a classic example.
addWatchFile option
Type: URL | string
If your integration depends on some configuration file that Vite doesn‚Äôt watch and/or needs a full dev server restart to take effect, add it with addWatchFile. Whenever that file changes, the Astro dev server will be reloaded (you can check when a reload happens with isRestart).
Example usage:
// Must be an absolute path!
addWatchFile('/home/user/.../my-config.json');
addWatchFile(new URL('./tailwind.config.js', config.root));
addClientDirective option
Added in: astro@2.6.0
Type: (directive: ClientDirectiveConfig ) => void;
Adds a custom client directive to be used in .astro files.
Note that directive entrypoints are only bundled through esbuild and should be kept small so they don‚Äôt slow down component hydration.
Example usage:
astro.config.mjs
import { defineConfig } from 'astro/config';
import clickDirective from './astro-click-directive/register.js'
// https://astro.build/config
export default defineConfig({
  integrations: [
    clickDirective()
  ],
});
astro-click-directive/register.js
/**
 * @type {() => import('astro').AstroIntegration}
 */
export default () => ({
  name: ""client:click"",
  hooks: {
    ""astro:config:setup"": ({ addClientDirective }) => {
      addClientDirective({
        name: ""click"",
        entrypoint: ""./astro-click-directive/click.js"",
      });
    },
  },
});
astro-click-directive/click.js
/**
 * Hydrate on first click on the window
 * @type {import('astro').ClientDirective}
 */
export default (load, opts, el) => {
  window.addEventListener('click', async () => {
    const hydrate = await load()
    await hydrate()
  }, { once: true })
}
You can also add types for the directives in your library‚Äôs type definition file:
astro-click-directive/index.d.ts
import 'astro'
declare module 'astro' {
  interface AstroClientDirectives {
    'client:click'?: boolean
  }
}
addDevToolbarApp option
Added in: astro@3.4.0
Type: (pluginEntrypoint: string) => void;
Adds a custom dev toolbar app.
Example usage:
astro.config.mjs
import { defineConfig } from 'astro/config';
import devToolbarIntegration from './astro-dev-toolbar-app/integration.js'
// https://astro.build/config
export default defineConfig({
  integrations: [
    devToolbarIntegration()
  ],
});
astro-dev-toolbar-app/integration.js
/**
 * @type {() => import('astro').AstroIntegration}
 */
export default () => ({
  name: ""dev-toolbar-app"",
  hooks: {
    ""astro:config:setup"": ({ addDevToolbarApp }) => {
      addDevToolbarApp(""./astro-dev-toolbar-app/plugin.js"");
    },
  },
});
astro-dev-toolbar-app/plugin.js
/**
 * @type {import('astro').DevToolbarApp}
 */
export default {
  id: ""my-plugin"",
  name: ""My Plugin"",
  icon: ""<svg>...</svg>"",
  init() {
    console.log(""I'm a dev toolbar app!"")
  },
};
addMiddleware option
Added in: astro@3.5.0
Type: (middleware: AstroIntegrationMiddleware ) => void;
Adds middleware to run on each request. Takes the entrypoint module that contains the middleware, and an order to specify whether it should run before (pre) other middleware or after (post).
@my-package/integration.js
/**
 * @type {() => import('astro').AstroIntegration}
 */
export default () => ({
  name: ""my-middleware-package"",
  hooks: {
    ""astro:config:setup"": ({ addMiddleware }) => {
        addMiddleware({
          entrypoint: '@my-package/middleware',
          order: 'pre'
        });
    },
  },
});
Middleware is defined in a package with an onRequest function, as with user-defined middleware.
@my-package/middleware.js
import { defineMiddleware } from 'astro:middleware';
export const onRequest = defineMiddleware(async (context, next) => {
  if(context.url.pathname === '/some-test-path') {
    return Response.json({
      ok: true
    });
  }
  return next();
});
injectRoute option
Type: ({ pattern: string, entrypoint: string }) => void;
A callback function to inject routes into an Astro project. Injected routes can be .astro pages or .js and .ts route handlers.
injectRoute takes an object with a pattern and an entrypoint.
pattern - where the route should be output in the browser, for example /foo/bar. A pattern can use Astro‚Äôs filepath syntax for denoting dynamic routes, for example /foo/[bar] or /foo/[...bar]. Note that a file extension is not needed in the pattern.
entrypoint - a bare module specifier pointing towards the .astro page or .js/.ts route handler that handles the route denoted in the pattern.
Example usage
injectRoute({
  // Use Astro‚Äôs pattern syntax for dynamic routes.
  pattern: '/subfolder/[dynamic]',
  // Use relative path syntax for a local route.
  entrypoint: './src/dynamic-page.astro'
});
For an integration designed to be installed in other projects, use its package name to refer to the route entrypoint. The following example shows a package published to npm as @fancy/dashboard injecting a dashboard route:
injectRoute({
  pattern: '/fancy-dashboard',
  entrypoint: '@fancy/dashboard/dashboard.astro'
});
When publishing your package (@fancy/dashboard, in this case) to npm, you must export dashboard.astro in your package.json:
package.json
{
  ""name"": ""@fancy/dashboard"",
  // ...
  ""exports"": { ""./dashboard.astro"": ""./dashboard.astro"" }
}
injectScript option
Type: (stage: InjectedScriptStage, content: string) => void;
A callback function to inject a string of JavaScript content onto every page.
The stage denotes how this script (the content) should be inserted. Some stages allow inserting scripts without modification, while others allow optimization during Vite‚Äôs bundling step:
""head-inline"": Injected into a script tag in the <head> of every page. Not optimized or resolved by Vite.
""before-hydration"": Imported client-side, before the hydration script runs. Optimized and resolved by Vite.
""page"": Similar to head-inline, except that the injected snippet is handled by Vite and bundled with any other <script> tags defined inside of Astro components on the page. The script will be loaded with a <script type=""module""> in the final page output, optimized and resolved by Vite.
""page-ssr"": Imported as a separate module in the frontmatter of every Astro page component. Because this stage imports your script, the Astro global is not available and your script will only be run once when the import is first evaluated.
The main use for the page-ssr stage is injecting a CSS import into every page to be optimized and resolved by Vite:
injectScript('page-ssr', 'import ""global-styles.css"";');
astro:config:done
Previous hook: astro:config:setup
Next hook: astro:server:setup when running in ‚Äúdev‚Äù mode, or astro:build:start during production builds
When: After the Astro config has resolved and other integrations have run their astro:config:setup hooks.
Why: To retrieve the final config for use in other hooks.
'astro:config:done'?: (options: {
  config: AstroConfig;
  setAdapter: (adapter: AstroAdapter) => void;
  injectTypes: (injectedType: { filename: string; content: string }) => URL;
  logger: AstroIntegrationLogger;
}) => void | Promise<void>;
config option
Type: AstroConfig
A read-only copy of the user-supplied Astro config. This is resolved after other integrations have run.
setAdapter option
Type: (adapter: AstroAdapter) => void;
Makes the integration an adapter. Read more in the adapter API.
injectTypes options
Added in: astro@4.14.0
Type: (injectedType: { filename: string; content: string }) => URL
Allows you to inject types into your user‚Äôs project by adding a new *.d.ts file.
The filename property will be used to generate a file at /.astro/integrations/<normalized_integration_name>/<normalized_filename>.d.ts and must end with "".d.ts"".
The content property will create the body of the file and must be valid TypeScript.
Additionally, injectTypes() returns a URL to the normalized path so you can overwrite its content later on, or manipulate it in any way you want.
const path = injectTypes({
  filename: ""types.d.ts"",
  content: ""declare module 'virtual:integration' {}""
})
console.log(path) // URL
astro:server:setup
Previous hook: astro:config:done
Next hook: astro:server:start
When: Just after the Vite server is created in ‚Äúdev‚Äù mode, but before the listen() event is fired. See Vite‚Äôs createServer API for more.
Why: To update Vite server options and middleware.
'astro:server:setup'?: (options: { server: vite.ViteDevServer }) => void | Promise<void>;
server option
Type: ViteDevServer
A mutable instance of the Vite server used in ‚Äúdev‚Äù mode. For instance, this is used by our Partytown integration to inject the Partytown server as middleware:
export default {
  name: 'partytown',
  hooks: {
    'astro:server:setup': ({ server }) => {
      server.middlewares.use(
        function middleware(req, res, next) {
          // handle requests
        }
      );
    }
  }
}
astro:server:start
Previous hook: astro:server:setup
Next hook: astro:server:done
When: Just after the server‚Äôs listen() event has fired.
Why: To intercept network requests at the specified address. If you intend to use this address for middleware, consider using astro:server:setup instead.
'astro:server:start'?: (options: { address: AddressInfo }) => void | Promise<void>;
address option
Type: AddressInfo
The address, family and port number supplied by the Node.js Net module.
astro:server:done
Previous hook: astro:server:start
When: Just after the dev server is closed.
Why: To run any cleanup events you may trigger during the astro:server:setup or astro:server:start hooks.
'astro:server:done'?: () => void | Promise<void>;
astro:build:start
Previous hook: astro:config:done
Next hook: astro:build:setup
When: After the astro:config:done event, but before the production build begins.
Why: To set up any global objects or clients needed during a production build. This can also extend the build configuration options in the adapter API.
'astro:build:start'?: () => void | Promise<void>;
astro:build:setup
Previous hook: astro:build:start
Next hook: astro:build:ssr
When: After the astro:build:start hook, runs immediately before the build.
Why: At this point, the Vite config for the build has been completely constructed, this is your final chance to modify it. This can be useful for example to overwrite some defaults. If you‚Äôre not sure whether you should use this hook or astro:build:start, use astro:build:start instead.
'astro:build:setup'?: (options: {
  vite: ViteConfigWithSSR;
  pages: Map<string, PageBuildData>;
  target: 'client' | 'server';
}) => void | Promise<void>;
astro:build:generated
Previous hook: astro:build:setup
When: After a static production build has finished generating routes and assets.
Why: To access generated routes and assets before build artifacts are cleaned up. This is a very uncommon use case. We recommend using astro:build:done unless you really need to access the generated files before cleanup.
'astro:build:generated'?: (options: { dir: URL }) => void | Promise<void>;
astro:build:ssr
Previous hook: astro:build:setup
When: After a production SSR build has completed.
Why: To access the SSR manifest and map of the emitted entry points. This is useful when creating custom SSR builds in plugins or integrations.
entryPoints maps a page route to the physical file emitted after the build;
middlewareEntryPoint is the file system path of the middleware file;
'astro:build:ssr'?: (options: {
    manifest: SerializedSSRManifest,
    entryPoints: Map<RouteData, URL>,
    middlewareEntryPoint: URL
}) => void | Promise<void>;
astro:build:done
Previous hook: astro:build:ssr
When: After a production build (SSG or SSR) has completed.
Why: To access generated routes and assets for extension (ex. copy content into the generated /assets directory). If you plan to transform generated assets, we recommend exploring the Vite Plugin API and configuring via astro:config:setup instead.
'astro:build:done'?: (options: { dir: URL; routes: RouteData[], pages: { pathname: string }[] }) => void | Promise<void>;
dir option
Type: URL
A URL path to the build output directory. Note that if you need a valid absolute path string, you should use Node‚Äôs built-in fileURLToPath utility.
import { writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
export default function myIntegration() {
  return {
    hooks: {
      'astro:build:done': async ({ dir }) => {
        const metadata = await getIntegrationMetadata();
        // Use fileURLToPath to get a valid, cross-platform absolute path string
        const outFile = fileURLToPath(new URL('./my-integration.json', dir));
        await writeFile(outFile, JSON.stringify(metadata));
      }
    }
  }
}
routes option
Type: RouteData[]
A list of all generated routes alongside their associated metadata.
You can reference the full RouteData type below, but the most common properties are:
component - the input file path relative to the project root
pathname - the output file URL (undefined for routes using [dynamic] and [...spread] params)
RouteData type reference
interface RouteData {
  /** Whether a given route is an HTML page or non-HTML endpoint */
  type: 'page' | 'endpoint';
  /** Source component URL */
  component: string;
  /**
   * Output URL pathname where this route will be served
   * note: will be undefined for [dynamic] and [...spread] routes
   */
  pathname?: string;
  /**
   * regex used for matching an input URL against a requested route
   * ex. ""[fruit]/about.astro"" will generate the pattern: /^\/([^/]+?)\/about\/?$/
   * where pattern.test(""banana/about"") is ""true""
   */
  pattern: RegExp;
  /**
   * Dynamic and spread route params
   * ex. ""/pages/[lang]/[..slug].astro"" will output the params ['lang', '...slug']
   */
  params: string[];
  /**
   * Similar to the ""params"" field, but with more associated metadata
   * ex. ""/pages/[lang]/index.astro"" will output the segments
   * [[ { content: 'lang', dynamic: true, spread: false } ]]
   */
  segments: { content: string; dynamic: boolean; spread: boolean; }[][];
  /**
   * Function to render component in-place from a set of input data.
   * This is typically for internal use, so call with caution!
   */
  generate: (data?: any) => string;
}
pages option
Type: { pathname: string }[]
A list of all generated pages. It is an object with one property.
pathname - the finalized path of the page.
astro:route:setup
Added in: astro@4.14.0
When: In astro dev, whenever a route is requested. In astro build, while bundling and transforming a route file.
Why: To set options for a route at build or request time, such as enabling on-demand server rendering.
'astro:route:setup'?: (options: { route: RouteOptions }) => void | Promise<void>;
route option
Type: RouteOptions
An object with a component property to identify the route and the following additional values to allow you to configure the generated route: prerender.
The component property is a readonly string path relative to the project root, e.g ""src/pages/blog/[slug].astro"".
route.prerender
Type: boolean
Default: undefined
Added in: astro@4.14.0
The prerender property is used to configure on-demand server rendering for a route. If the route file contains an explicit export const prerender value, the value will be used as the default instead of undefined.
astro.config.mjs
import { defineConfig } from 'astro/config';
export default defineConfig({
  integrations: [setPrerender()],
});
function setPrerender() {
  return {
    name: 'set-prerender',
    hooks: {
      'astro:route:setup': ({ route }) => {
        if (route.component.endsWith('/blog/[slug].astro')) {
          route.prerender = true;
        }
      },
    },
  };
}
If the final value after running all the hooks is undefined, the route will fall back to a prerender default based on the output option: prerendered for hybrid mode, and on-demand rendered for server mode.
Custom hooks
Custom hooks can be added to integrations by extending the IntegrationHooks interface through global augmentation.
declare global {
  namespace Astro {
    export interface IntegrationHook {
      'your:hook': (params: YourHookParameters) => Promise<void>
    }
  }
}
Astro reserves the astro: prefix for future built-in hooks. Please choose a different prefix when naming your custom hook.
HookParameters
You can get the type of a hook‚Äôs arguments by passing the hook‚Äôs name to the HookParameters utility type. In the following example, a function‚Äôs options argument is typed to match the parameters of the astro:config:setup hook:
import type { HookParameters } from 'astro';
function mySetup(options: HookParameters<'astro:config:setup'>) {
  options.updateConfig({ /* ... */ });
}
Allow installation with astro add
The astro add command allows users to easily add integrations and adapters to their project. If you want your integration to be installable with this tool, add astro-integration to the keywords field in your package.json:
{
  ""name"": ""example"",
  ""keywords"": [""astro-integration""],
}
Once you publish your integration to npm, running astro add example will install your package with any peer dependencies specified in your package.json. This will also apply your integration to the user‚Äôs astro.config like so:
astro.config.mjs
import { defineConfig } from 'astro/config';
 import example from 'example';
export default defineConfig({
  integrations: [example()],
})
Caution
This assumes your integration definition is 1) a default export and 2) a function. Ensure this is true before adding the astro-integration keyword!
AstroIntegrationLogger
An instance of the Astro logger, useful to write logs. This logger uses the same log level configured via CLI.
Methods available to write to terminal:
logger.info(""Message"");
logger.warn(""Message"");
logger.error(""Message"");
logger.debug(""Message"");
All the messages are prepended with a label that has the same value of the integration.
integration.ts
import type { AstroIntegration } from ""astro"";
export function formatIntegration(): AstroIntegration {
    return {
        name: ""astro-format"",
        hooks: {
            ""astro:build:done"": ({ logger }) => {
                // do something
                logger.info(""Integration ready."");
            }
        }
    }
}
The example above will log a message that includes the provided info message:
Terminal window
[astro-format] Integration ready.
To log some messages with a different label, use the .fork method to specify an alternative to the default name:
integration.ts
import type { AstroIntegration } from ""astro"";
export function formatIntegration(): AstroIntegration {
    return {
        name: ""astro-format"",
        hooks: {
            ""astro:config:done"": ({ logger }) => {
                // do something
                logger.info(""Integration ready."");
            },
            ""astro:build:done"": ({ logger }) => {
                const buildLogger = logger.fork(""astro-format/build"");
                // do something
                buildLogger.info(""Build finished."")
            }
        }
    }
}
The example above will produce logs with [astro-format] by default, and [astro-format/build] when specified:
Terminal window
[astro-format] Integration ready.
[astro-format/build] Build finished.
Integration Ordering
All integrations are run in the order that they are configured. For instance, for the array [react(), svelte()] in a user‚Äôs astro.config.*, react will run before svelte.
Your integration should ideally run in any order. If this isn‚Äôt possible, we recommend documenting that your integration needs to come first or last in your user‚Äôs integrations configuration array.
Combine integrations into presets
An integration can also be written as a collection of multiple, smaller integrations. We call these collections presets. Instead of creating a factory function that returns a single integration object, a preset returns an array of integration objects. This is useful for building complex features out of multiple integrations.
integrations: [
  // Example: where examplePreset() returns: [integrationOne, integrationTwo, ...etc]
  examplePreset()
]
Community Resources
Build your own Astro Integrations - by Emmanuel Ohans on FreeCodeCamp
Astro Integration Template - by Florian Lefebvre on GitHub
Edit page
Translate this page
Previous
astro:transitions
Next
Adapter API
Contribute
Give us feedback
Community""""""",6223,26875,astro
https://docs.astro.build/en/reference/adapter-reference/,"""""""On this page
Overview
What is an adapter
Building an Adapter
Server Entrypoint
Allow installation via astro add
Astro features
Adapter features
functionPerRoute
edgeMiddleware
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro Adapter API
Astro is designed to make it easy to deploy to any cloud provider for SSR (server-side rendering). This ability is provided by adapters, which are integrations. See the SSR guide to learn how to use an existing adapter.
What is an adapter
An adapter is a special kind of integration that provides an entrypoint for server-side rendering. An adapter does two things:
Implements host-specific APIs for handling requests.
Configures the build according to host conventions.
Building an Adapter
An adapter is an integration and can do anything that an integration can do.
An adapter must call the setAdapter API in the astro:config:done hook like so:
my-adapter.mjs
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          supportedAstroFeatures: {
              staticOutput: 'stable'
          }
        });
      },
    },
  };
}
The object passed into setAdapter is defined as:
interface AstroAdapter {
  name: string;
  serverEntrypoint?: string;
  previewEntrypoint?: string;
  exports?: string[];
  args?: any;
  adapterFeatures?: AstroAdapterFeatures;
  supportedAstroFeatures?: AstroFeatureMap;
}
export interface AstroAdapterFeatures {
  /**
   * Creates an edge function that will communicate with the Astro middleware.
   */
  edgeMiddleware: boolean;
  /**
   * SSR only. Each route becomes its own function/file.
   */
  functionPerRoute: boolean;
}
export type SupportsKind = 'unsupported' | 'stable' | 'experimental' | 'deprecated';
export type AstroFeatureMap = {
  /**
   * The adapter is able to serve static pages
   */
  staticOutput?: SupportsKind;
  /**
   * The adapter is able to serve pages that are static or rendered via server
   */
  hybridOutput?: SupportsKind;
  /**
   * The adapter is able to serve SSR pages
   */
  serverOutput?: SupportsKind;
  /**
   * The adapter can emit static assets
   */
  assets?: AstroAssetsFeature;
};
export interface AstroAssetsFeature {
  supportKind?: SupportsKind;
  /**
   * Whether this adapter deploys files in an environment that is compatible with the library `sharp`
   */
  isSharpCompatible?: boolean;
  /**
   * Whether this adapter deploys files in an environment that is compatible with the library `squoosh`
   */
  isSquooshCompatible?: boolean;
}
The properties are:
name: A unique name for your adapter, used for logging.
serverEntrypoint: The entrypoint for server-side rendering.
exports: An array of named exports when used in conjunction with createExports (explained below).
adapterFeatures: An object that enables specific features that must be supported by the adapter. These features will change the built output, and the adapter must implement the proper logic to handle the different output.
supportedAstroFeatures: A map of Astro built-in features. This allows Astro to determine which features an adapter is unable or unwilling to support so appropriate error messages can be provided.
Server Entrypoint
Astro‚Äôs adapter API attempts to work with any type of host, and gives a flexible way to conform to the host APIs.
Exports
Some serverless hosts expect you to export a function, such as handler:
export function handler(event, context) {
  // ...
}
With the adapter API you achieve this by implementing createExports in your serverEntrypoint:
import { App } from 'astro/app';
export function createExports(manifest) {
  const app = new App(manifest);
  const handler = (event, context) => {
    // ...
  };
  return { handler };
}
And then in your integration, where you call setAdapter, provide this name in exports:
my-adapter.mjs
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          exports: ['handler'],
        });
      },
    },
  };
}
Start
Some hosts expect you to start the server yourselves, for example by listening to a port. For these types of hosts, the adapter API allows you to export a start function which will be called when the bundle script is run.
import { App } from 'astro/app';
export function start(manifest) {
  const app = new App(manifest);
  addEventListener('fetch', event => {
    // ...
  });
}
astro/app
This module is used for rendering pages that have been prebuilt through astro build. Astro uses the standard Request and Response objects. Hosts that have a different API for request/response should convert to these types in their adapter.
import { App } from 'astro/app';
import http from 'http';
export function start(manifest) {
  const app = new App(manifest);
  addEventListener('fetch', event => {
    event.respondWith(
      app.render(event.request)
    );
  });
}
The following methods are provided:
app.render(request: Request, options?: RenderOptions)
This method calls the Astro page that matches the request, renders it, and returns a Promise to a Response object. This also works for API routes that do not render pages.
const response = await app.render(request);
RenderOptions
The app.render() method accepts a mandatory request argument, and an optional RenderOptions object for addCookieHeader, clientAddress, locals, and routeData.
addCookieHeader
Whether or not to automatically add all cookies written by Astro.cookie.set() to the response headers.
When set to true, they will be added to the Set-Cookie header of the response as comma separated key-value pairs. You can use the standard response.headers.getSetCookie() API to read them individually. When set to false(default), the cookies will only be available from App.getSetCookieFromResponse(response).
const response = await app.render(request, { addCookieHeader: true });
clientAddress
The client IP address that will be made available as Astro.clientAddress in pages, and as ctx.clientAddress in API routes and middleware.
The example below reads the x-forwarded-for header and passes it as clientAddress. This value becomes available to the user as Astro.clientAddress.
const clientAddress = request.headers.get(""x-forwarded-for"");
const response = await app.render(request, { clientAddress });
locals
The context.locals object used to store and access information during the lifecycle of a request.
The example below reads a header named x-private-header, attempts to parse it as an object and pass it to locals, which can then be passed to any middleware function.
const privateHeader = request.headers.get(""x-private-header"");
let locals = {};
try {
    if (privateHeader) {
        locals = JSON.parse(privateHeader);
    }
} finally {
    const response = await app.render(request, { locals });
}
routeData
Provide a value for routeData if you already know the route to render. Doing so will bypass the internal call to app.match to determine the route to render.
const routeData = app.match(request);
if (routeData) {
    return app.render(request, { routeData });
} else {
    /* adapter-specific 404 response */
    return new Response(..., { status: 404 });
}
app.match(request)
This method is used to determine if a request is matched by the Astro app‚Äôs routing rules.
if(app.match(request)) {
  const response = await app.render(request);
}
You can usually call app.render(request) without using .match because Astro handles 404s if you provide a 404.astro file. Use app.match(request) if you want to handle 404s in a different way.
Allow installation via astro add
The astro add command allows users to easily add integrations and adapters to their project. If you want your adapter to be installable with this tool, add astro-adapter to the keywords field in your package.json:
{
  ""name"": ""example"",
  ""keywords"": [""astro-adapter""],
}
Once you publish your adapter to npm, running astro add example will install your package with any peer dependencies specified in your package.json. We will also instruct users to update their project config manually.
Astro features
Added in: astro@3.0.0
Astro features are a way for an adapter to tell Astro whether they are able to support a feature, and also the adapter‚Äôs level of support.
When using these properties, Astro will:
run specific validation;
emit contextual to the logs;
These operations are run based on the features supported or not supported, their level of support, and the configuration that the user uses.
The following configuration tells Astro that this adapter has experimental support for assets, but the adapter is not compatible with the built-in services Sharp and Squoosh:
my-adapter.mjs
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          supportedAstroFeatures: {
            assets: {
              supportKind: ""experimental"",
              isSharpCompatible: false,
              isSquooshCompatible: false
            }
          }
        });
      },
    },
  };
}
Astro will log a warning to the terminal:
[@matthewp/my-adapter] The feature is experimental and subject to issues or changes.
and an error if the service used for assets is not compatible with the adapter:
[@matthewp/my-adapter] The currently selected adapter `@matthewp/my-adapter` is not compatible with the service ""Sharp"". Your project will NOT be able to build.
Adapter features
A set of features that changes the output of the emitted files. When an adapter opts in to these features, they will get additional information inside specific hooks.
functionPerRoute
This is a feature that is enabled when using SSR only. By default, Astro emits a single entry.mjs file, which is responsible for emitting the rendered page on each request.
When functionPerRoute is true, Astro will instead create a separate file for each route defined in the project.
Each file emitted will only render one page. The pages will be emitted inside a dist/pages/ directory (or under a /pages/ directory in the directory specified for outDir), and the emitted files will keep the same file paths of the src/pages/ directory.
The files inside the pages/ directory of the build will mirror the directory structure of your page files in src/pages/, for example:
Directory
dist/
Directory
pages/
Directory
blog/
entry._slug_.astro.mjs
entry.about.astro.mjs
entry.index.astro.mjs
Enable the feature by passing true to the adapter.
my-adapter.mjs
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}
Then, consume the hook astro:build:ssr, which will give you an entryPoints object that maps a page route to the physical file emitted after the build.
my-adapter.mjs
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
      'astro:build:ssr': ({ entryPoints }) => {
          for (const [route, entryFile] of entryPoints) {
              // do something with route and entryFile
          }
      }
    },
  };
}
Caution
The entryFile is of type URL and represents the physical path of the file in the file system. This means that the paths change based on the OS where the code runs.
Serverless environments
Setting functionPerRoute: true in a serverless environment creates a JavaScript file (handler) for each route. A handler might have different names based on your hosting platform: lambda, function, page, etc.
Each of these routes is subject to a cold start when the handler runs, which may cause some delay. This delay is influenced by different factors.
With functionPerRoute: false, there is only one single handler in charge of rendering all your routes. When this handler is first triggered, you will be subject to a cold start. Then, all other routes should function without delay. However, you will lose the benefit of code splitting that functionPerRoute: true provides.
Note
It‚Äôs important that you understand your hosting platform, and how it works, in order to choose the appropriate functionPerRoute configuration for your project.
edgeMiddleware
Defines whether any SSR middleware code will be bundled when built.
When enabled, this prevents middleware code from being bundled and imported by all pages during the build:
my-adapter.mjs
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              edgeMiddleware: true
          }
        });
      },
    },
  };
}
Then, consume the hook astro:build:ssr, which will give you a middlewareEntryPoint, an URL to the physical file on the file system.
my-adapter.mjs
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              edgeMiddleware: true
          }
        });
      },
      'astro:build:ssr': ({ middlewareEntryPoint }) => {
          // remember to check if this property exits, it will be `undefined` if the adapter doesn't opt in to the feature
          if (middlewareEntryPoint) {
             createEdgeMiddleware(middlewareEntryPoint)
          }
      }
    },
  };
}
function createEdgeMiddleware(middlewareEntryPoint) {
    // emit a new physical file using your bundler
}
Edit page
Translate this page
Previous
Integrations API
Next
Image Service API
Contribute
Give us feedback
Community""""""",3215,14754,astro
https://docs.astro.build/en/reference/image-service-reference/,"""""""On this page
Overview
What is an Image Service?
Building using the Image Services API
External Services
Local Services
Hooks
getURL()
parseURL()
transform()
getHTMLAttributes()
getSrcSet()
validateOptions()
User configuration
Want to build your own Docs?
Grab this template to get started.‚Üí
Image Service API
astro:assets was designed to make it easy for any image optimization service to build a service on top of Astro.
What is an Image Service?
Astro provides two types of image services: Local and External.
Local services handle image transformations directly at build for static sites, or at runtime both in development mode and SSR. These are often wrappers around libraries like Sharp, ImageMagick, or Squoosh. In dev mode and in SSR, local services use an API endpoint to do the transformation.
External services point to URLs and can add support for services such as Cloudinary, Vercel, or any RIAPI-compliant server.
Building using the Image Services API
Service definitions take the shape of an exported default object with various required methods (‚Äúhooks‚Äù).
External services provide a getURL() that points to the src of the output <img> tag.
Local services provide a transform() method to perform transformations on your image, and getURL() and parseURL() methods to use an endpoint for dev mode and SSR.
Both types of services can provide getHTMLAttributes() to determine the other attributes of the output <img> and validateOptions() to validate and augment the passed options.
External Services
An external service points to a remote URL to be used as the src attribute of the final <img> tag. This remote URL is responsible for downloading, transforming, and returning the image.
import type { ExternalImageService, ImageTransform, AstroConfig } from ""astro"";
const service: ExternalImageService = {
  validateOptions(options: ImageTransform, imageConfig: AstroConfig['image']) {
    const serviceConfig = imageConfig.service.config;
    // Enforce the user set max width.
    if (options.width > serviceConfig.maxWidth) {
      console.warn(`Image width ${options.width} exceeds max width ${serviceConfig.maxWidth}. Falling back to max width.`);
      options.width = serviceConfig.maxWidth;
    }
    return options;
  },
  getURL(options, imageConfig) {
    return `https://mysupercdn.com/${options.src}?q=${options.quality}&w=${options.width}&h=${options.height}`;
  },
  getHTMLAttributes(options, imageConfig) {
    const { src, format, quality, ...attributes } = options;
    return {
      ...attributes,
      loading: options.loading ?? 'lazy',
      decoding: options.decoding ?? 'async',
    };
  }
};
export default service;
Local Services
To create your own local service, you can point to the built-in endpoint (/_image), or you can additionally create your own endpoint that can call the service‚Äôs methods.
import type { LocalImageService, AstroConfig } from ""astro"";
const service: LocalImageService = {
  getURL(options: ImageTransform, imageConfig: AstroConfig['image']) {
    const searchParams = new URLSearchParams();
    searchParams.append('href', typeof options.src === ""string"" ? options.src : options.src.src);
    options.width && searchParams.append('w', options.width.toString());
    options.height && searchParams.append('h', options.height.toString());
    options.quality && searchParams.append('q', options.quality.toString());
    options.format && searchParams.append('f', options.format);
    return `/my_custom_endpoint_that_transforms_images?${searchParams}`;
    // Or use the built-in endpoint, which will call your parseURL and transform functions:
    // return `/_image?${searchParams}`;
  },
  parseURL(url: URL, imageConfig) {
    return {
      src: params.get('href')!,
      width: params.has('w') ? parseInt(params.get('w')!) : undefined,
      height: params.has('h') ? parseInt(params.get('h')!) : undefined,
      format: params.get('f'),
      quality: params.get('q'),
    };
  },
  transform(buffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig): { data: Uint8Array, format: OutputFormat } {
    const { buffer } = mySuperLibraryThatEncodesImages(options);
    return {
      data: buffer,
      format: options.format,
    };
  },
  getHTMLAttributes(options, imageConfig) {
    let targetWidth = options.width;
    let targetHeight = options.height;
    if (typeof options.src === ""object"") {
      const aspectRatio = options.src.width / options.src.height;
      if (targetHeight && !targetWidth) {
        targetWidth = Math.round(targetHeight * aspectRatio);
      } else if (targetWidth && !targetHeight) {
        targetHeight = Math.round(targetWidth / aspectRatio);
      }
    }
    const { src, width, height, format, quality, ...attributes } = options;
    return {
      ...attributes,
      width: targetWidth,
      height: targetHeight,
      loading: attributes.loading ?? 'lazy',
      decoding: attributes.decoding ?? 'async',
    };
  },
  propertiesToHash: ['src', 'width', 'height', 'format', 'quality'],
};
export default service;
At build time for static sites and pre-rendered routes, both <Image /> and getImage(options) call the transform() function. They pass options either through component attributes or an options argument, respectively. The transformed images will be built to a dist/_astro folder. Their file names will contain a hash of the properties passed to propertiesToHash. This property is optional and will default to ['src', 'width', 'height', 'format', 'quality']. If your custom image service has more options that change the generated images, add these to the array.
In dev mode and SSR mode, Astro doesn‚Äôt know ahead of time which images need to be optimized. Astro uses a GET endpoint (by default, /_image) to process the images at runtime. <Image /> and getImage() pass their options to getURL(), which will return the endpoint URL. Then, the endpoint calls parseURL() and passes the resulting properties to transform().
getConfiguredImageService & imageConfig
If you implement your own endpoint as an Astro endpoint, you can use getConfiguredImageService and imageConfig to call your service‚Äôs parseURL and transform methods and provide the image config.
To access the image service config (image.service.config), you can use imageConfig.service.config.
src/api/my_custom_endpoint_that_transforms_images.ts
import type { APIRoute } from ""astro"";
import { getConfiguredImageService, imageConfig } from 'astro:assets';
export const GET: APIRoute = async ({ request }) => {
  const imageService = await getConfiguredImageService();
  const imageTransform = imageService.parseURL(new URL(request.url), imageConfig);
  // ... fetch the image from imageTransform.src and store it in inputBuffer
  const { data, format } = await imageService.transform(inputBuffer, imageTransform, imageConfig);
  return new Response(data, {
      status: 200,
      headers: {
        'Content-Type': mime.getType(format) || ''
      }
    }
  );
}
See the built-in endpoint for a full example.
Hooks
getURL()
Required for local and external services
getURL(options: ImageTransform, imageConfig: AstroConfig['image']): string
For local services, this hook returns the URL of the endpoint that generates your image (in SSR and dev mode). It is unused during build. The local endpoint that getURL() points to may call both parseURL() and transform().
For external services, this hook returns the final URL of the image.
For both types of services, options are the properties passed by the user as attributes of the <Image /> component or as options to getImage(). They are of the following type:
export type ImageTransform = {
    // ESM imported images | remote/public image paths
    src: ImageMetadata | string;
    width?: number;
    height?: number;
    widths?: number[] | undefined;
    densities?: (number | `${number}x`)[] | undefined;
    quality?: ImageQuality;
    format?: OutputFormat;
    alt?: string;
    [key: string]: any;
};
parseURL()
Required for local services; unavailable for external services
parseURL(url: URL, imageConfig: AstroConfig['image']): { src: string, [key: string]: any}
This hook parses the generated URLs by getURL() back into an object with the different properties to be used by transform (in SSR and dev mode). It is unused during build.
transform()
Required for local services only; unavailable for external services
transform(buffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig: AstroConfig['image']): { data: Uint8Array, format: OutputFormat }
This hook transforms and returns the image and is called during the build to create the final asset files.
You must return a format to ensure that the proper MIME type is served to users in SSR and development mode.
getHTMLAttributes()
Optional for both local and external services
getHTMLAttributes(options: ImageTransform, imageConfig: AstroConfig['image']): Record<string, any>
This hook returns all additional attributes used to render the image as HTML, based on the parameters passed by the user (options).
getSrcSet()
Added in: astro@3.3.0
Optional for both local and external services.
getSrcSet?: (options: ImageTransform, imageConfig: AstroConfig['image']): SrcSetValue[] | Promise<SrcSetValue[]>;
This hook generates multiple variants of the specified image, for example, to generate a srcset attribute on an <img> or <picture>‚Äôs source.
This hook returns an array of objects with the following properties:
export type SrcSetValue = {
  transform: ImageTransform;
  descriptor?: string;
  attributes?: Record<string, any>;
};
validateOptions()
Optional for both local and external services
validateOptions(options: ImageTransform, imageConfig: AstroConfig['image']): ImageTransform
This hook allows you to validate and augment the options passed by the user. This is useful for setting default options, or telling the user that a parameter is required.
See how validateOptions() is used in Astro built-in services.
User configuration
Configure the image service to use in astro.config.mjs. The config takes the following form:
astro.config.mjs
import { defineConfig } from ""astro/config"";
export default defineConfig({
  image: {
    service: {
      entrypoint: ""your-entrypoint"", // 'astro/assets/services/squoosh' | 'astro/assets/services/sharp' | string,
      config: {
        // ... service-specific config. Optional.
      }
    }
  },
});
Edit page
Translate this page
Previous
Adapter API
Next
Dev Toolbar App API
Contribute
Give us feedback
Community""""""",2291,10517,astro
https://docs.astro.build/en/reference/dev-toolbar-app-reference/,"""""""On this page
Overview
Toolbar app integration setup
addDevToolbarApp()
id
name
icon
entrypoint
Structure of a Dev Toolbar App
defineToolbarApp()
init()
beforeTogglingOff()
Client-side Events
onToggled()
onToolbarPlacementUpdated()
toggleState()
toggleNotification()
Client-Server Communication
On the client
On the server
Component Library
astro-dev-toolbar-window
astro-dev-toolbar-button
astro-dev-toolbar-badge
astro-dev-toolbar-card
astro-dev-toolbar-toggle
astro-dev-toolbar-radio-checkbox
astro-dev-toolbar-highlight
astro-dev-toolbar-tooltip
astro-dev-toolbar-icon
Want to build your own Docs?
Grab this template to get started.‚Üí
Dev Toolbar App API
The Astro Dev Toolbar App API allows you to create Astro Integrations that add apps to the Astro Dev Toolbar. This allows you to add new features and integrations with third-party services.
Related recipe:
Create a dev toolbar app
Toolbar app integration setup
Integrations can add apps to the dev toolbar in the astro:config:setup hook.
my-integration.js
/**
 * @type {() => import('astro').AstroIntegration}
 */
export default () => ({
  name: ""my-integration"",
  hooks: {
    ""astro:config:setup"": ({ addDevToolbarApp }) => {
      addDevToolbarApp({
        id: ""my-app"",
        name: ""My App"",
        icon: ""<svg>...</svg>"",
        entrypoint: ""./my-app.js"",
      });
    },
  },
});
addDevToolbarApp()
A function available to the astro:config:setup hook that adds dev toolbar apps. It takes an object with the following required properties to define the toolbar app: id, name, icon, and entrypoint.
id
A unique identifier for the app. This will be used to uniquely identify the app in hooks and events.
my-integration.js
{
  id: 'my-app',
  // ...
}
name
The name of the app. This will be shown to users whenever the app needs to be referenced using a human-readable name.
my-integration.js
{
  // ...
  name: 'My App',
  // ...
}
icon
The icon used to display the app in the toolbar. This can either be an icon from the icon list, or a string containing the SVG markup of the icon.
my-integration.js
{
  // ...
  icon: '<svg>...</svg>', // or, e.g. 'astro:logo'
  // ...
}
entrypoint
The path to the file that exports the dev toolbar app.
my-integration.js
{
  // ...
  entrypoint: './my-app.js',
}
Structure of a Dev Toolbar App
A Dev Toolbar App is a .js or .ts file that default exports an object using the defineToolbarApp() function available from the astro/toolbar module.
src/my-app.js
import { defineToolbarApp } from ""astro/toolbar"";
export default defineToolbarApp({
  init(canvas) {
    const text = document.createTextNode('Hello World!');
    canvas.appendChild(text);
  },
  beforeTogglingOff() {
    const confirmation = window.confirm('Really exit?');
    return confirmation;
  }
});
defineToolbarApp()
Added in: astro@4.7.0
A function that defines the logic of your toolbar app when it is loaded and toggled off.
This function takes an object with an init() function that will be called when the dev toolbar app is loaded. It can also take a beforeTogglingOff() function that will run when the toolbar app is clicked to toggle off its active status.
init()
Signature: init(canvas: ShadowRoot, app: ToolbarAppEventTarget, server: ToolbarServerHelpers) => void
Although not required, most apps will use this function to define the core behavior of the app. This function will be called only once when the app is loaded, which will either be when the browser is idle or when the user clicks on the app in the UI, depending on which one comes first.
The function receives three arguments to define your app logic: canvas (to render elements to the screen), app (to send and receive client-side events from the dev toolbar), and server (to communicate with the server).
canvas
A standard ShadowRoot that the app can use to render its UI. Elements can be created and added to the ShadowRoot using the standard DOM APIs.
Every app receives its own dedicated ShadowRoot for rendering its UI. Additionally, the parent element is positioned using position: absolute; so the app UI will not affect the layout of an Astro page.
src/my-app.js
export default defineToolbarApp({
  init(canvas) {
    canvas.appendChild(document.createTextNode('Hello World!'))
  }
});
app
Added in: astro@4.7.0
A standard EventTarget with a few additional helpers for client-side events that can be used to send and receive events from the Dev toolbar.
src/my-app.js
export default defineToolbarApp({
  init(canvas, app) {
    app.onToggled(({ state }) => {
      const text = document.createTextNode(
        `The app is now ${state ? ""enabled"" : ""disabled""}!`,
      );
      canvas.appendChild(text);
    });
  },
});
server
Added in: astro@4.7.0
An object that can be used to communicate with the server.
src/my-app.js
export default defineToolbarApp({
  init(canvas, app, server) {
    server.send('my-message', { message: 'Hello!' });
    server.on('server-message', (data) => {
      console.log(data.message);
    });
  },
});
beforeTogglingOff()
Signature: beforeTogglingOff(canvas: ShadowRoot): boolean | void
Added in: astro@4.7.0
This optional function will be called when the user clicks on the app icon in the UI to toggle off the app. This function can be used, for example, to perform cleanup operations, or to ask the user for confirmation before toggling off the app.
If a falsy value is returned, the toggling off will be cancelled and the app will stay enabled.
src/my-app.js
export default defineToolbarApp({
  // ...
  beforeTogglingOff() {
    const confirmation = window.confirm('Are you sure you want to disable this app?');
    return confirmation;
  }
});
canvas
The ShadowRoot of the app, can be used to render any UI needed before closing. Same as the canvas argument of the init function.
Client-side Events
In addition to the standard methods of an EventTarget (addEventListener, dispatchEvent, removeEventListeneretc.), the app object also has the following methods:
onToggled()
Signature: onToggled(callback: (options: {state: boolean})) => void
Added in: astro@4.7.0
Registers a callback to be called when the user clicks on the app icon in the UI to toggle the app on or off.
src/my-app.js
app.onToggled((options) => {
  console.log(`The app is now ${options.state ? 'enabled' : 'disabled'}!`);
});
onToolbarPlacementUpdated()
Signature: onToolbarPlacementUpdated(callback: (options: {placement: 'bottom-left' | 'bottom-center' | 'bottom-right'})) => void
Added in: astro@4.7.0
This event is fired when the user changes the placement of the Dev Toolbar. This can, for example, be used to reposition the app‚Äôs UI when the toolbar is moved.
src/my-app.js
app.onToolbarPlacementUpdated((options) => {
  console.log(`The toolbar is now placed at ${options.placement}!`);
});
toggleState()
Signature: toggleState(options: {state: boolean}) => void
Added in: astro@4.7.0
Changes the state of the app. This can be used to enable or disable the app programmatically, for example, when the user clicks on a button in the app‚Äôs UI.
src/my-app.js
app.toggleState({ state: false });
toggleNotification()
Signature: toggleNotification(options: {state?: boolean, level?: 'error' | 'warning' | 'info'}) => void
Added in: astro@4.7.0
Toggles a notification on the app icon. This can be used to inform the user that the app requires attention, or remove the current notification.
src/my-app.js
app.toggleNotification({
  state: true,
  level: 'warning',
});
state: boolean
Indicates whether or not the app has a notification for the user. When true, the app icon will be highlighted. Conversely, when false, the highlight will be removed. If this property is not specified, true will be assumed.
level: 'error' | 'warning' | 'info'
Indicates the level of the notification. This will be used to determine the color and shape (dark pink circle, gold triangle, or blue square) of the highlight on the app icon. If this property is not specified, 'error' will be assumed.
Client-Server Communication
Using Vite‚Äôs methods for client-server communication, Dev Toolbar Apps and the server can communicate with each other. In order to facilitate sending and receiving custom messages, helper methods are provided for use both in your toolbar app (on the client) and in your integration (on the server).
On the client
In your app, use the server object on the init() hook to send and receive messages to and from the server.
src/my-app.js
export default defineToolbarApp({
  init(canvas, app, server) {
    server.send('my-message', { message: 'Hello!' });
    server.on('server-message', (data) => {
      console.log(data.message);
    });
  },
});
send()
Signature: send<T>(event: stringify, data: T) => void
Added in: astro@4.7.0
Sends data to the server from logic defined in your toolbar app.
src/my-app.js
init(canvas, app, server) {
  server.send('my-app:my-message', { message: 'Hello!' });
}
When sending messages from the client to the server, it is good practice to prefix the event name with the app ID or other namespaces to avoid conflicts with other apps or other integrations that may be listening for messages.
on()
Signature: on<T>(event: string, callback: (data: T) => void) => void
Added in: astro@4.7.0
Registers a callback to be called when the server sends a message with the specified event.
src/my-app.js
init(canvas, app, server) {
  server.on('server-message', (data) => {
    console.log(data.message);
  });
}
On the server
In an integration, such as the integration that adds your toolbar app, use the astro:server:setup hook to access the toolbar object to send and receive messages to and from your apps.
my-integration.js
export default () => ({
  name: ""my-integration"",
  hooks: {
    ""astro:config:setup"": ({ addDevToolbarApp }) => {},
    ""astro:server:setup"": ({ toolbar }) => {},
  },
});
send()
Signature: send<T>(event: string, data: T) => void
Added in: astro@4.7.0
Sends data to the client.
my-integration.js
'astro:server:setup': ({ toolbar }) => {
  toolbar.send('server-message', { message: 'Hello!' });
},
on()
Signature: on<T>(event: string, callback: (data: T) => void) => void
Added in: astro@4.7.0
Registers a callback to be called when the client sends a message with the specified event.
my-integration.js
'astro:server:setup': ({ toolbar }) => {
  toolbar.on('my-app:my-message', (data) => {
    console.log(data.message);
  });
},
onInitialized()
Signature: onInitialized(appId: string, callback: () => void) => void
Added in: astro@4.7.0
Registers a callback to be called when the app is initialized.
my-integration.js
'astro:server:setup': ({ toolbar }) => {
  toolbar.onInitialized('my-app', () => {
    console.log('The app is now initialized!');
  });
},
Note
The built-in connection event from Vite fires before Dev Toolbar apps are initialized and therefore cannot be used directly by apps. Use the onInitialized method to ensure that the app is fully initialized before sending messages to it.
onAppToggled()
Signature: onAppToggled(appId: string, callback: (options: {state: boolean}) => void) => void
Added in: astro@4.7.0
Registers a callback to be called when the user clicks on the app icon in the UI to toggle the app on or off.
my-integration.js
'astro:server:setup': ({ toolbar }) => {
  toolbar.onAppToggled('my-app', ({ state }) => {
    console.log(`The app is now ${state ? 'enabled' : 'disabled'}!`);
  });
},
Component Library
The Dev Toolbar includes a set of web components that can be used to build apps with a consistent look and feel.
astro-dev-toolbar-window
Shows a window.
The slot of the component will be used as the content of the window.
<astro-dev-toolbar-window>
  <p>My content</p>
</astro-dev-toolbar-window>
When building a window using JavaScript, slotted content must go inside the light DOM of the component.
const myWindow = document.createElement('astro-dev-toolbar-window');
const myContent = document.createElement('p');
myContent.textContent = 'My content';
// use appendChild directly on `window`, not `myWindow.shadowRoot`
myWindow.appendChild(myContent);
astro-dev-toolbar-button
Shows a button.
The slot of the component will be used as the content of the button.
const myButton = document.createElement('astro-dev-toolbar-button');
myButton.textContent = 'Click me!';
myButton.buttonStyle = ""purple"";
myButton.size = ""medium"";
myButton.addEventListener('click', () => {
  console.log('Clicked!');
});
size
The size of the button (small, medium, large).
button-style
The style of the button (ghost, outline, purple, gray, red, green, yellow, blue). When using ghost, the button itself is invisible and only the content of the button will be shown.
In JavaScript, set this property using the buttonStyle property to avoid conflict with the native style property.
button-border-radius
Added in: astro@4.8.0
The border radius of the button (normal, rounded). When using rounded, the button will have rounded corners and uniform padding on all sides.
In JavaScript, set this property using the buttonBorderRadius property.
astro-dev-toolbar-badge
Shows a badge.
The slot of the component will be used as the content of the badge.
<astro-dev-toolbar-badge>My badge</astro-dev-toolbar-badge>
size
The size of the badge (small, large).
badge-style
The style (color) of the badge (purple, gray, red, green, yellow, blue).
In JavaScript, set this property using the badgeStyle property to avoid conflict with the native style property.
astro-dev-toolbar-card
Shows a card. Specify an optional link attribute to make the card act like an <a> element.
When making a card using JavaScript, a clickAction property can be specified to make the card act like a <button> element.
The slot of the component will be used as the content of the card.
<astro-dev-toolbar-card icon=""astro:logo"" link=""https://github.com/withastro/astro/issues/new/choose"">Report an issue</astro-dev-toolbar-card>
card-style
The style of the card (purple, gray, red, green, yellow, blue). The color is only applied to the border of the card on hover.
In JavaScript, set this property using the cardStyle.
astro-dev-toolbar-toggle
Shows a toggle element, acting as a checkbox. This element internally is a simple wrapper around a native <input type=""checkbox""> element. The checkbox element can be accessed using the input property.
const toggle = document.createElement('astro-dev-toolbar-toggle');
toggle.input.addEventListener('change', (evt) => {
  console.log(`The toggle is now ${evt.currentTarget.checked ? 'enabled' : 'disabled'}!`);
});
astro-dev-toolbar-radio-checkbox
Added in: astro@4.8.0
Shows a radio checkbox. Similar to the astro-dev-toolbar-toggle component, this element is a simple wrapper around a native <input type=""radio""> element. The radio element can be accessed using the input property.
const radio = document.createElement('astro-dev-toolbar-radio-checkbox');
radio.input.addEventListener('change', (evt) => {
  console.log(`The radio is now ${evt.currentTarget.checked ? 'enabled' : 'disabled'}!`);
});
toggle-style
The style of the toggle (purple, gray, red, green, yellow, blue).
In JavaScript, set this property using the toggleStyle property.
astro-dev-toolbar-highlight
Can be used to highlight an element on the page. In most cases, you‚Äôll want to position and resize this element using the top, left, width and height CSS properties to match the element you want to highlight.
<!-- Highlight the entire page -->
<astro-dev-toolbar-highlight style=""top: 0; left: 0; width: 100%; height: 100%;""></astro-dev-toolbar-highlight>
const elementToHighlight = document.querySelector('h1');
const rect = elementToHighlight.getBoundingClientRect();
const highlight = document.createElement('astro-dev-toolbar-highlight');
highlight.style.top = `${Math.max(rect.top + window.scrollY - 10, 0)}px`;
highlight.style.left = `${Math.max(rect.left + window.scrollX - 10, 0)}px`;
highlight.style.width = `${rect.width + 15}px`;
highlight.style.height = `${rect.height + 15}px`;
highlight.icon = 'astro:logo';
style
The style of the highlight (purple, gray, red, green, yellow, blue).
icon
An icon to show in the top right corner of the highlight.
astro-dev-toolbar-tooltip
Shows a tooltip with different sections. This component is set to display: none; by default and can be made visible using a data-show=""true"" attribute.
Sections are defined using the sections property. This property is an array of objects with the following shape:
{
  title?: string; // Title of the section
  inlineTitle?: string; // Title of the section, shown inline next to the title
  icon?: Icon; // Icon of the section
  content?: string; // Content of the section
  clickAction?: () => void | Promise<void>; // Action to perform when clicking on the section
  clickDescription?: string; // Description of the action to perform when clicking on the section
}
const tooltip = document.createElement('astro-dev-toolbar-tooltip');
tooltip.sections = [{
  title: 'My section',
  icon: 'astro:logo',
  content: 'My content',
  clickAction: () => {
    console.log('Clicked!')
  },
  clickDescription: 'Click me!'
}]
This component is often combined with the astro-dev-toolbar-highlight component to show a tooltip when hovering a highlighted element:
const highlight = document.createElement('astro-dev-toolbar-highlight');
// Position the highlight...
const tooltip = document.createElement('astro-dev-toolbar-tooltip');
// Add sections to the tooltip...
highlight.addEventListener('mouseover', () => {
  tooltip.dataset.show = 'true';
});
highlight.addEventListener('mouseout', () => {
  tooltip.dataset.show = 'false';
});
astro-dev-toolbar-icon
Shows an icon. An icon from the icon list can be specified using the icon attribute, or the SVG markup of an icon can be passed as a slot.
<astro-dev-toolbar-icon icon=""astro:logo"" />
<astro-dev-toolbar-icon>
  <svg>...</svg>
</astro-dev-toolbar-icon>
Icons
Currently, the following icons are available and can be used in any component that accepts an icon:
astro:logo
warning
arrow-down
bug
file-search
check-circle
gear
lightbulb
checkmark
dots-three
copy
All of the above icons have fill=""currentColor"" set by default and will inherit their color from the parent element.
Edit page
Translate this page
Previous
Image Service API
Next
Container API (Experimental)
Contribute
Give us feedback
Community""""""",4256,18275,astro
https://docs.astro.build/en/reference/container-reference/,"""""""On this page
Overview
create()
streaming option
renderers option
renderToString()
renderToResponse()
Rendering options
slots
props option
request option
params option
locals options
routeType option
partial option
Want to build your own Docs?
Grab this template to get started.‚Üí
Astro Container API (experimental)
Added in: astro@4.9.0
The Container API allows you to render Astro components in isolation.
This experimental server-side API unlocks a variety of potential future uses, but is currently scoped to allow testing of .astro component output in vite environments such as vitest.
It also allows you to manually load rendering scripts for creating containers in pages rendered on demand or other ‚Äúshell‚Äù environments outside of vite (e.g. inside a PHP or Elixir application).
This API allows you to create a new container, and render an Astro component returning a string or a Response.
This API is experimental and subject to breaking changes, even in minor or patch releases. Please consult the Astro CHANGELOG for changes as they occur. This page will always be updated with the most current information for the latest version of Astro.
create()
Creates a new instance of the container.
import { experimental_AstroContainer } from ""astro/container"";
const container = await experimental_AstroContainer.create();
It accepts an object with the following options:
export type AstroContainerOptions = {
  streaming?: boolean;
  renderers?: AddServerRenderer[];
};
export type AddServerRenderer =
  | {
      renderer: NamedSSRLoadedRendererValue;
      name: never;
    }
  | {
      renderer: SSRLoadedRendererValue;
      name: string;
    };
streaming option
Type: boolean
Enables rendering components using HTML streaming.
renderers option
Type: AddServerRenderer[]
A list of loaded client renderers required by the component. Use this if your .astro component renders any UI framework components or MDX using an official Astro integration (e.g. React, Vue, etc.).
Renderers can be added through the Container API automatically for static applications, or cases where the container isn‚Äôt called at runtime (e.g. testing with vitest).
For on-demand rendered applications, or cases where the container is called at runtime or inside other ‚Äúshells‚Äù (e.g. PHP, Ruby, Java, etc.), renderers must be manually imported.
Adding a renderer through the Container API
For each official Astro integration, import and use the getContainerRenderer() helper function to expose its client and server rendering scripts. These are available for @astrojs/react, @astrojs/preact, @astrojs/solid-js, @astrojs/svelte, @astrojs/vue, @astrojs/lit, and @astrojs/mdx.
For renderer packages outside the @astrojs npm org, look in their documentation for getContainerRenderer() or a similar function provided.
When using vite (vitest, Astro integrations, etc.), the renderers are loaded with the function loadRenderers() from the virtual module astro:container.
Caution
Outside vite or for on-demand usage, you‚Äôll have to load the renderers manually.
The following example provides the necessary object to render an Astro component that renders a React component and a Svelte component:
import { getContainerRenderer as reactContainerRenderer } from ""@astrojs/react"";
import { getContainerRenderer as svelteContainerRenderer } from ""@astrojs/svelte"";
import { loadRenderers } from ""astro:container"";
const renderers = await loadRenderers([reactContainerRenderer(), svelteContainerRenderer()]);
const container = await experimental_AstroContainer.create({
    renderers
})
const result = await container.renderToString(ReactWrapper);
Adding a renderer manually
When the container is called at runtime, or inside other ‚Äúshells‚Äù, the astro:container virtual module‚Äôs helper functions are not available. You must import the necessary server and client renderers manually and store them inside the container using addServerRenderer and addClientRenderer.
Server renderers are required to build your project, and must be stored in the container for every framework used. Client renderers are additionally needed to any hydrate client-side components using client:* directives.
Only one import statement is needed per framework. Importing a renderer makes both the server and client renderers available to your container. However, server renderers must be added to your container before client renderers. This allows your entire container to render first, and then hydrate any interactive components.
The following example manually imports the necessary server renderers to be able to display static Vue components and .mdx pages. It additionally adds both server and client renderers for interactive React components.
import reactRenderer from ""@astrojs/react/server.js"";
import vueRenderer from ""@astrojs/vue/server.js"";
import mdxRenderer from ""astro/jsx/server.js"";
const container = await experimental_AstroContainer.create();
container.addServerRenderer({renderer: vueRenderer});
container.addServerRenderer({renderer: mdxRenderer});
container.addServerRenderer({ renderer: reactRenderer });
container.addClientRenderer({ name: ""@astrojs/react"", entrypoint: ""@astrojs/react/client.js"" });
renderToString()
This function renders a specified component inside a container. It takes an Astro component as an argument and it returns a string that represents the HTML/content rendered by the Astro component.
import { experimental_AstroContainer } from ""astro/container"";
import Card from ""../src/components/Card.astro"";
const container = await experimental_AstroContainer.create();
const result = await container.renderToString(Card);
Under the hood, this function calls renderToResponse and calls Response.text().
It also accepts an object as a second argument that can contain a number of options.
renderToResponse()
It renders a component, and it returns a Response object.
import { experimental_AstroContainer } from ""astro/container"";
import Card from ""../src/components/Card.astro"";
const container = await experimental_AstroContainer.create();
const result = await container.renderToResponse(Card);
It also accepts an object as a second argument that can contain a number of options.
Rendering options
Both renderToResponse and renderToString accept an object as their second argument:
export type ContainerRenderOptions = {
  slots?: Record<string, any>;
  props?: Record<string, unknown>;
  request?: Request;
  params?: Record<string, string | undefined>;
  locals?: App.Locals;
  routeType?: ""page"" | ""endpoint"";
};
These optional values can be passed to the rendering function in order to provide additional information necessary for an Astro component to properly render.
slots
Type: Record<string, any>;
An option to pass content to be rendered with <slots>.
If your Astro component renders one default slot, pass an object with default as the key:
import Card from ""../src/components/Card.astro"";
const result = await container.renderToString(Card, {
  slots: { default: ""Some value"" }
});
If your component renders named slots, use the slot names as the object keys:
---
---
<div>
  <slot name=""header"" />
  <slot name=""footer"" />
</div>
import Card from ""../src/components/Card.astro"";
const result = await container.renderToString(Card, {
  slots: {
    header: ""Header content"",
    footer: ""Footer""
  }
});
You can also render components in cascade:
---
---
<div>
  <slot name=""header"" />
  <slot name=""footer"" />
</div>
import Card from ""../src/components/Card.astro"";
import CardHeader from ""../src/components/CardHeader.astro"";
import CardFooter from ""../src/components/CardFooter.astro"";
const result = await container.renderToString(Card, {
  slots: {
    header: await container.renderToString(CardHeader),
    footer:  await container.renderToString(CardFooter)
  }
});
props option
Type: Record<string, unknown>
An option to pass properties for Astro components.
import Card from ""../src/components/Card.astro"";
const result = await container.renderToString(Card, {
  props: { name: ""Hello, world!"" }
});
---
// For TypeScript support
interface Props {
  name: string;
};
const { name } = Astro.props;
---
<div>
  {name}
</div>
request option
Type: Request
An option to pass a Request with information about the path/URL the component will render.
Use this option when your component needs to read information like Astro.url or Astro.request.
You can also inject possible headers or cookies.
import Card from ""../src/components/Card.astro"";
const result = await container.renderToString(Card, {
  request: new Request(""https://example.com/blog"", {
    headers: {
      ""x-some-secret-header"": ""test-value""
    }
  })
});
params option
Type: Record<string, string | undefined>;
An object to pass information about the path parameter to an Astro component responsible for generating dynamic routes.
Use this option when your component needs a value for Astro.params in order to generate a single route dynamically.
---
const { locale, slug } = Astro.params;
---
<div></div>
import LocaleSlug from ""../src/components/[locale]/[slug].astro"";
const result = await container.renderToString(LocaleSlug, {
  params: {
    locale: ""en"",
    slug: ""getting-started""
  }
});
locals options
Type: App.Locals
An option to pass information from Astro.locals for rendering your component.
Use this option to when your component needs information stored during the lifecycle of a request in order to render, such as logged in status.
---
const { checkAuth } = Astro.locals;
const isAuthenticated = checkAuth();
---
{isAuthenticated ? <span>You're in</span> : <span>You're out</span> }
import Card from ""../src/components/Card.astro"";
test(""User is in"", async () => {
  const result = await container.renderToString(Card, {
    locals: {
      checkAuth() { return true; }
    }
  });
  // assert result contains ""You're in""
});
test(""User is out"", async () => {
  const result = await container.renderToString(Card, {
    locals: {
      checkAuth() { return false; }
    }
  });
  // assert result contains ""You're out""
});
routeType option
Type: ""page"" | ""endpoint""
An option available when using renderToResponse to specify that you are rendering an endpoint:
container.renderToString(Endpoint, { routeType: ""endpoint"" });
import * as Endpoint from ""../src/pages/api/endpoint.js"";
const response = await container.renderToResponse(Endpoint, {
  routeType: ""endpoint""
});
const json = await response.json();
To test your endpoint on methods such as POST, PATCH, etc., use the request option to call the correct function:
export function GET() {}
// need to test this
export function POST() {}
import * as Endpoint from ""../src/pages/api/endpoint.js"";
const response = await container.renderToResponse(Endpoint, {
    routeType: ""endpoint"",
    request: new Request(""https://example.com"", {
      method: ""POST"" // Specify POST method for testing
    })
});
const json = await response.json();
partial option
Type: boolean
Default: true
Added in: astro@4.16.6 New
Whether or not the Container API renders components as if they were page partials. This is usually the behavior you want when rendering components.boolean so you can render components without a full page shell.
To render a component as a full Astro page, including <!DOCTYPE html>, you can opt-out of this behavior by setting partial to false:
import Blog from ""../src/pages/Blog.astro"";
const result = await container.renderToString(Card, {
    partial: false
});
console.log(result) // includes `<!DOCTYPE html>` at the beginning of the HTML
Edit page
Translate this page
Previous
Dev Toolbar App API
Contribute
Give us feedback
Community""""""",2439,11593,astro
