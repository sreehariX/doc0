url,content,token_count,char_count,techStackName
https://redux.js.org/introduction/getting-started,"""""""IntroductionGetting Started with Redux
Getting Started with Redux
Redux is a JS library for predictable and maintainable global state management.
It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as live code editing combined with a time traveling debugger.
You can use Redux together with React, or with any other view library. It is tiny (2kB, including dependencies), but has a large ecosystem of addons available.
Redux Toolkit is our official recommended approach for writing Redux logic. It wraps around the Redux core, and contains packages and functions that we think are essential for building a Redux app. Redux Toolkit builds in our suggested best practices, simplifies most Redux tasks, prevents common mistakes, and makes it easier to write Redux applications.
RTK includes utilities that help simplify many common use cases, including store setup, creating reducers and writing immutable update logic, and even creating entire ""slices"" of state at once.
Whether you're a brand new Redux user setting up your first project, or an experienced user who wants to simplify an existing application, Redux Toolkit can help you make your Redux code better.
Installation
Redux Toolkit
Redux Toolkit is available as a package on NPM for use with a module bundler or in a Node application:
# NPM
npm install @reduxjs/toolkit

# Yarn
yarn add @reduxjs/toolkit
Create a React Redux App
The recommended way to start new apps with React and Redux is by using our official Redux+TS template for Vite, or by creating a new Next.js project using Next's with-redux template.
Both of these already have Redux Toolkit and React-Redux configured appropriately for that build tool, and come with a small example app that demonstrates how to use several of Redux Toolkit's features.
# Vite with our Redux+TS template
# (using the `degit` tool to clone and extract the template)
npx degit reduxjs/redux-templates/packages/vite-template-redux my-app

# Next.js using the `with-redux` template
npx create-next-app --example with-redux my-app
We do not currently have official React Native templates, but recommend these templates for standard React Native and for Expo:
https://github.com/rahsheen/react-native-template-redux-typescript
https://github.com/rahsheen/expo-template-redux-typescript
Redux Core
The Redux core library is available as a package on NPM for use with a module bundler or in a Node application:
# NPM
npm install redux

# Yarn
yarn add redux
The package includes a precompiled ESM build that can be used as a <script type=""module""> tag directly in the browser.
For more details, see the Installation page.
Basic Example
The whole global state of your app is stored in an object tree inside a single store. The only way to change the state tree is to create an action, an object describing what happened, and dispatch it to the store. To specify how state gets updated in response to an action, you write pure reducer functions that calculate a new state based on the old state and the action.
Redux Toolkit simplifies the process of writing Redux logic and setting up the store. With Redux Toolkit, the basic app logic looks like:
import { createSlice, configureStore } from '@reduxjs/toolkit'

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0
  },
  reducers: {
    incremented: state => {
      // Redux Toolkit allows us to write ""mutating"" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a ""draft state"" and produces a brand new
      // immutable state based off those changes
      state.value += 1
    },
    decremented: state => {
      state.value -= 1
    }
  }
})

export const { incremented, decremented } = counterSlice.actions

const store = configureStore({
  reducer: counterSlice.reducer
})

// Can still subscribe to the store
store.subscribe(() => console.log(store.getState()))

// Still pass action objects to `dispatch`, but they're created for us
store.dispatch(incremented())
// {value: 1}
store.dispatch(incremented())
// {value: 2}
store.dispatch(decremented())
// {value: 1}
Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called actions. Then you write a special function called a reducer to decide how every action transforms the entire application's state.
In a typical Redux app, there is just a single store with a single root reducer function. As your app grows, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.
This architecture might seem like a lot for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.
Redux Toolkit allows us to write shorter logic that's easier to read, while still following the same Redux behavior and data flow.
Legacy Example
For comparison, the original Redux legacy syntax (with no abstractions) looks like this:
import { createStore } from 'redux'

/**
 * This is a reducer - a function that takes a current state value and an
 * action object describing ""what happened"", and returns a new state value.
 * A reducer's function signature is: (state, action) => newState
 *
 * The Redux state should contain only plain JS objects, arrays, and primitives.
 * The root state value is usually an object. It's important that you should
 * not mutate the state object, but return a new object if the state changes.
 *
 * You can use any conditional logic you want in a reducer. In this example,
 * we use a switch statement, but it's not required.
 */
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'counter/incremented':
      return { value: state.value + 1 }
    case 'counter/decremented':
      return { value: state.value - 1 }
    default:
      return state
  }
}

// Create a Redux store holding the state of your app.
// Its API is { subscribe, dispatch, getState }.
let store = createStore(counterReducer)

// You can use subscribe() to update the UI in response to state changes.
// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.
// There may be additional use cases where it's helpful to subscribe as well.

store.subscribe(() => console.log(store.getState()))

// The only way to mutate the internal state is to dispatch an action.
// The actions can be serialized, logged or stored and later replayed.
store.dispatch({ type: 'counter/incremented' })
// {value: 1}
store.dispatch({ type: 'counter/incremented' })
// {value: 2}
store.dispatch({ type: 'counter/decremented' })
// {value: 1}
Learn Redux
We have a variety of resources available to help you learn Redux.
Redux Essentials Tutorial
The Redux Essentials tutorial is a ""top-down"" tutorial that teaches ""how to use Redux the right way"", using our latest recommended APIs and best practices. We recommend starting there.
Redux Fundamentals Tutorial
The Redux Fundamentals tutorial is a ""bottom-up"" tutorial that teaches ""how Redux works"" from first principles and without any abstractions, and why standard Redux usage patterns exist.
Learn Modern Redux Livestream
Redux maintainer Mark Erikson appeared on the ""Learn with Jason"" show to explain how we recommend using Redux today. The show includes a live-coded example app that shows how to use Redux Toolkit and React-Redux hooks with TypeScript, as well as the new RTK Query data fetching APIs.
See the ""Learn Modern Redux"" show notes page for a transcript and links to the example app source.
Additional Tutorials
The Redux repository contains several example projects demonstrating various aspects of how to use Redux. Almost all examples have a corresponding CodeSandbox sandbox. This is an interactive version of the code that you can play with online. See the complete list of examples in the Examples page.
Redux creator Dan Abramov's free ""Getting Started with Redux"" video series and Building React Applications with Idiomatic Redux video courses on Egghead.io
Redux maintainer Mark Erikson's ""Redux Fundamentals"" conference talk and ""Redux Fundamentals"" workshop slides
Dave Ceddia's post A Complete React Redux Tutorial for Beginners
Other Resources
The Redux FAQ answers many common questions about how to use Redux, and the ""Using Redux"" docs section has information on handling derived data, testing, structuring reducer logic, and reducing boilerplate.
Redux maintainer Mark Erikson's ""Practical Redux"" tutorial series demonstrates real-world intermediate and advanced techniques for working with React and Redux (also available as an interactive course on Educative.io).
The React/Redux links list has categorized articles on working with reducers and selectors, managing side effects, Redux architecture and best practices, and more.
Our community has created thousands of Redux-related libraries, addons, and tools. The ""Ecosystem"" docs page lists our recommendations, and there's a complete listing available in the Redux addons catalog.
Help and Discussion
The #redux channel of the Reactiflux Discord community is our official resource for all questions related to learning and using Redux. Reactiflux is a great place to hang out, ask questions, and learn - come join us!
You can also ask questions on Stack Overflow using the #redux tag.
If you have a bug report or need to leave other feedback, please file an issue on the Github repo
Should You Use Redux?
Redux is a valuable tool for organizing your state, but you should also consider whether it's appropriate for your situation. Don't use Redux just because someone said you should - take some time to understand the potential benefits and tradeoffs of using it.
Here are some suggestions on when it makes sense to use Redux:
You have reasonable amounts of data changing over time
You need a single source of truth for your state
You find that keeping all your state in a top-level component is no longer sufficient
For more thoughts on how Redux is meant to be used, see:
Redux FAQ: When should I use Redux?
You Might Not Need Redux
The Tao of Redux, Part 1 - Implementation and Intent
The Tao of Redux, Part 2 - Practice and Philosophy
Redux FAQ
Edit this page
Last updated on Mar 31, 2024""""""",2262,10720,redux
https://redux.js.org/introduction/installation,"""""""IntroductionInstallation
Installation
Redux Toolkit
Redux Toolkit includes the Redux core, as well as other key packages we feel are essential for building Redux applications (such as Redux Thunk and Reselect).
It's available as a package on NPM for use with a module bundler or in a Node application:
# NPM
npm install @reduxjs/toolkit

# Yarn
yarn add @reduxjs/toolkit
The package includes a precompiled ESM build that can be used as a <script type=""module""> tag directly in the browser.
Complementary Packages
React-Redux
Most likely, you'll also need the react-redux bindings for use with React
npm install react-redux
Note that unlike Redux itself, many packages in the Redux ecosystem don't provide UMD builds, so we recommend using module bundlers like Vite and Webpack for the most comfortable development experience.
Redux DevTools Extension
Redux Toolkit's configureStore automatically sets up integration with the Redux DevTools. You'll want to install the browser extensions to view the store state and actions:
Redux DevTools Extension:
Redux DevTools Extension for Chrome
Redux DevTools Extension for Firefox
If you're using React, you'll want the React DevTools extension as well:
React DevTools Extension:
React DevTools Extension for Chrome
React DevTools Extension for Firefox
Create a React Redux App
The recommended way to start new apps with React and Redux is by using our official Redux+TS template for Vite, or by creating a new Next.js project using Next's with-redux template.
Both of these already have Redux Toolkit and React-Redux configured appropriately for that build tool, and come with a small example app that demonstrates how to use several of Redux Toolkit's features.
# Vite with our Redux+TS template
# (using the `degit` tool to clone and extract the template)
npx degit reduxjs/redux-templates/packages/vite-template-redux my-app

# Next.js using the `with-redux` template
npx create-next-app --example with-redux my-app
We do not currently have official React Native templates, but recommend these templates for standard React Native and for Expo:
https://github.com/rahsheen/react-native-template-redux-typescript
https://github.com/rahsheen/expo-template-redux-typescript
Redux Core
To install the redux core package by itself:
# NPM
npm install redux

# Yarn
yarn add redux
If you're not using a bundler, you can access these files on unpkg, download them, or point your package manager to them.
Edit this page
Last updated on Nov 25, 2023""""""",547,2484,redux
https://redux.js.org/introduction/why-rtk-is-redux-today,"""""""IntroductionWhy Redux Toolkit is How To Use Redux Today
Why Redux Toolkit is How To Use Redux Today
What is Redux Toolkit?
Redux Toolkit (also known as ""RTK"" for short) is our official recommended approach for writing Redux logic. The @reduxjs/toolkit package wraps around the core redux package, and contains API methods and common dependencies that we think are essential for building a Redux app. Redux Toolkit builds in our suggested best practices, simplifies most Redux tasks, prevents common mistakes, and makes it easier to write Redux applications.
If you are writing any Redux logic today, you should be using Redux Toolkit to write that code!
RTK includes utilities that help simplify many common use cases, including store setup, creating reducers and writing immutable update logic, and even creating entire ""slices"" of state at once.
Whether you're a brand new Redux user setting up your first project, or an experienced user who wants to simplify an existing application, Redux Toolkit can help you make your Redux code better.
TIP
See these pages to learn how to use ""modern Redux"" with Redux Toolkit:
The ""Redux Essentials"" tutorial, which teaches ""how to use Redux, the right way"" with Redux Toolkit for real-world apps,
Redux Fundamentals, Part 8: Modern Redux with Redux Toolkit, which shows how to convert the low-level examples from earlier sections of the tutorial into modern Redux Toolkit equivalents
Using Redux: Migrating to Modern Redux, which covers how to migrate different kinds of legacy Redux logic into modern Redux equivalents
How Redux Toolkit Is Different Than the Redux Core
What Is ""Redux""?
The first thing to ask is, ""what is Redux?""
Redux is really:
A single store containing ""global"" state
Dispatching plain object actions to the store when something happens in the app
Pure reducer functions looking at those actions and returning immutably updated state
While it's not required, your Redux code also normally includes:
Action creators that generate those action objects
Middleware to enable side effects
Thunk functions that contain sync or async logic with side effects
Normalized state to enable looking up items by ID
Memoized selector functions with the Reselect library for optimizing derived data
The Redux DevTools Extension to view your action history and state changes
TypeScript types for actions, state, and other functions
Additionally, Redux is normally used with the React-Redux library to let your React components talk to a Redux store.
What Does the Redux Core Do?
The Redux core is a very small and deliberately unopinionated library. It provides a few small API primitives:
createStore to actually create a Redux store
combineReducers to combine multiple slice reducers into a single larger reducer
applyMiddleware to combine multiple middleware into a store enhancer
compose to combine multiple store enhancers into a single store enhancer
Other than that, all the other Redux-related logic in your app has to be written entirely by you.
The good news is that this means Redux can be used in many different ways. The bad news is that there are no helpers to make any of your code easier to write.
For example, a reducer function is just a function. Prior to Redux Toolkit, you'd typically write that reducer with a switch statement and manual updates. You'd also probably have hand-written action creators and action type constants along with it:
Legacy hand-written Redux usage
const ADD_TODO = 'ADD_TODO'
const TODO_TOGGLED = 'TODO_TOGGLED'

export const addTodo = text => ({
  type: ADD_TODO,
  payload: { text, id: nanoid() }
})

export const todoToggled = id => ({
  type: TODO_TOGGLED,
  payload: id
})

export const todosReducer = (state = [], action) => {
  switch (action.type) {
    case ADD_TODO:
      return state.concat({
        id: action.payload.id,
        text: action.payload.text,
        completed: false
      })
    case TODO_TOGGLED:
      return state.map(todo => {
        if (todo.id !== action.payload) return todo

        return {
          ...todo,
          completed: !todo.completed
        }
      })
    default:
      return state
  }
}
None of this code specifically depends on any API from the redux core library. But, this is a lot of code to write. Immutable updates required a lot of hand-written object spreads and array operations, and it was very easy to make mistakes and accidentally mutate state in the process (always the #1 cause of Redux bugs!). It was also common, though not strictly required, to spread the code for one feature across multiple files like actions/todos.js, constants/todos.js, and reducers/todos.js.
Additionally, store setup usually required a series of steps to add commonly used middleware like thunks and enable Redux DevTools Extension support, even though these are standard tools used in almost every Redux app.
What Does Redux Toolkit Do?
While these were the patterns originally shown in the Redux docs, they unfortunately require a lot of very verbose and repetitive code. Most of this boilerplate isn't necessary to use Redux. On top of that, the boilerplate-y code lead to more opportunities to make mistakes.
We specifically created Redux Toolkit to eliminate the ""boilerplate"" from hand-written Redux logic, prevent common mistakes, and provide APIs that simplify standard Redux tasks.
Redux Toolkit starts with two key APIs that simplify the most common things you do in every Redux app:
configureStore sets up a well-configured Redux store with a single function call, including combining reducers, adding the thunk middleware, and setting up the Redux DevTools integration. It also is easier to configure than createStore, because it takes named options parameters.
createSlice lets you write reducers that use the Immer library to enable writing immutable updates using ""mutating"" JS syntax like state.value = 123, with no spreads needed. It also automatically generates action creator functions for each reducer, and generates action type strings internally based on your reducer's names. Finally, it works great with TypeScript.
That means that the code you write can be drastically simpler. For example, that same todos reducer could just be:
features/todos/todosSlice.js
import { createSlice } from '@reduxjs/toolkit'

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    todoAdded(state, action) {
      state.push({
        id: action.payload.id,
        text: action.payload.text,
        completed: false
      })
    },
    todoToggled(state, action) {
      const todo = state.find(todo => todo.id === action.payload)
      todo.completed = !todo.completed
    }
  }
})

export const { todoAdded, todoToggled } = todosSlice.actions
export default todosSlice.reducer
All of the action creators and action types are generated automatically, and the reducer code is shorter and easier to understand. It's also much more clear what's actually being updated in each case.
With configureStore, the store setup can be simplified down to:
app/store.js
import { configureStore } from '@reduxjs/toolkit'
import todosReducer from '../features/todos/todosSlice'
import filtersReducer from '../features/filters/filtersSlice'

export const store = configureStore({
  reducer: {
    todos: todosReducer,
    filters: filtersReducer
  }
})
Note that this one configureStore call automatically does all the usual setup work you'd have done manually:
The slice reducers were automatically passed to combineReducers()
The redux-thunk middleware was automatically added
Dev-mode middleware was added to catch accidental mutations
The Redux DevTools Extension was automatically set up
The middleware and DevTools enhancers were composed together and added to the store
At the same time, configureStore provides the options to let users modify any of those default behaviors (like turning off thunks and adding sagas, or disabling the DevTools in production),
From there, Redux Toolkit includes other APIs for common Redux tasks:
createAsyncThunk: abstracts the standard ""dispatch actions before/after an async request"" pattern
createEntityAdapter: prebuilt reducers and selectors for CRUD operations on normalized state
createSelector: a re-export of the standard Reselect API for memoized selectors
createListenerMiddleware: a side effects middleware for running logic in response to dispatched actions
Finally, the RTK package also includes ""RTK Query"", a full data fetching and caching solution for Redux apps, as a separate optional @reduxjs/toolkit/query entry point. It lets you define endpoints (REST, GraphQL, or any async function), and generates a reducer and middleware that fully manage fetching data, updating loading state, and caching results. It also automatically generates React hooks that can be used in components to fetch data, like const { data, isFetching } = useGetPokemonQuery('pikachu')
Each of these APIs is completely optional and designed for specific use cases, and you can pick and choose which APIs you actually use in your app. But, all of them are highly recommended to help with those tasks.
Note that Redux Toolkit is still ""Redux""! There's still a single store, with dispatched action objects for updates, and reducers that immutably update state, plus the ability to write thunks for async logic, manage normalized state, type your code with TypeScript, and use the DevTools. There's just way less code you have to write for the same results!
Why We Want You To Use Redux Toolkit
As Redux maintainers, our opinion is:
TIP
We want all Redux users to write their Redux code with Redux Toolkit, because it simplifies your code and eliminates many common Redux mistakes and bugs!
The ""boilerplate"" and complexity of the early Redux patterns was never a necessary part of Redux. Those patterns only existed because:
The original ""Flux Architecture"" used some of those same approaches
The early Redux docs showed things like action type constants to enable separating code into different files by type
JavaScript is a mutable language by default, and writing immutable updates required manual object spreads and array updates
Redux was originally built in just a few weeks and intentionally designed to be just a few API primitives
Additionally, the Redux community has adopted some specific approaches that add additional boilerplate:
Emphasizing use of the redux-saga middleware as a common approach for writing side effects
Insisting on hand-writing TS types for Redux action objects and creating union types to limit what actions can be dispatched at the type level
Over the years, we've seen how people actually used Redux in practice. We've seen how the community wrote hundreds of add-on libraries for tasks like generating action types and creators, async logic and side effects, and data fetching. We've also seen the problems that have consistently caused pain for our users, like accidentally mutating state, writing dozens of lines of code just to make one simple state update, and having trouble tracing how a codebase fits together. We've helped thousands of users who were trying to learn and use Redux and struggling to understand how all the pieces fit together, and were confused by the number of concepts and amount of extra code they had to write. We know what problems our users are facing.
We specifically designed Redux Toolkit to solve those problems!
Redux Toolkit simplifies store setup down to a single clear function call, while retaining the ability to fully configure the store's options if you need to
Redux Toolkit eliminates accidental mutations, which have always been the #1 cause of Redux bugs
Redux Toolkit eliminates the need to write any action creators or action types by hand
Redux Toolkit eliminates the need to write manual and error-prone immutable update logic
Redux Toolkit makes it easy to write a Redux feature's code in one file, instead of spreading it across multiple separate files
Redux Toolkit offers excellent TS support, with APIs that are designed to give you excellent type safety and minimize the number of types you have to define in your code
RTK Query can eliminate the need to write any thunks, reducers, action creators, or effect hooks to manage fetching data and tracking loading state
Because of this:
TIP
We specifically recommend that our users should use Redux Toolkit (the @reduxjs/toolkit package), and should not use the legacy redux core package for any new Redux code today!
Even for existing applications, we recommend at least switching out createStore for configureStore as the dev-mode middleware will also help you catch accidental mutation and serializability errors in existing code bases. We also want to encourage you to switch the reducers you are using most (and any ones you write in the future) over to createSlice - the code will be shorter and easier to understand, and the safety improvements will save you time and effort going forward.
The redux core package still works, but today we consider it to be obsolete. All of its APIs are also re-exported from @reduxjs/toolkit, and configureStore does everything createStore does but with better default behavior and configurability.
It is useful to understand the lower-level concepts, so that you have a better understanding of what Redux Toolkit is doing for you. That's why the ""Redux Fundamentals"" tutorial shows how Redux works, with no abstractions. But, it shows those examples solely as a learning tool, and finishes by showing you how Redux Toolkit simplifies the older hand-written Redux code.
If you are using the redux core package by itself, your code will continue to work. But, we strongly encourage you to switch over to @reduxjs/toolkit, and update your code to use the Redux Toolkit APIs instead!
Further Information
See these docs pages and blog posts for more details
Redux Essentials: Redux Toolkit App Structure
Redux Fundamentals: Modern Redux with Redux Toolkit
Redux Style Guide: Best Practices and Recommendations
Presentation: Modern Redux with Redux Toolkit
Mark Erikson: Redux Toolkit 1.0 Announcement and development history
Edit this page
Last updated on Jul 18, 2024""""""",2829,14146,redux
https://redux.js.org/introduction/core-concepts,"""""""IntroductionCore Concepts
Core Concepts
Imagine your app’s state is described as a plain object. For example, the state of a todo app might look like this:
{
  todos: [{
    text: 'Eat food',
    completed: true
  }, {
    text: 'Exercise',
    completed: false
  }],
  visibilityFilter: 'SHOW_COMPLETED'
}
This object is like a “model” except that there are no setters. This is so that different parts of the code can’t change the state arbitrarily, causing hard-to-reproduce bugs.
To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don’t introduce any magic?) that describes what happened. Here are a few example actions:
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
Enforcing that every change is described as an action lets us have a clear understanding of what’s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about it — it’s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:
function visibilityFilter(state = 'SHOW_ALL', action) {
  if (action.type === 'SET_VISIBILITY_FILTER') {
    return action.filter
  } else {
    return state
  }
}

function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return state.concat([{ text: action.text, completed: false }])
    case 'TOGGLE_TODO':
      return state.map((todo, index) =>
        action.index === index
          ? { text: todo.text, completed: !todo.completed }
          : todo
      )
    default:
      return state
  }
}
And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:
function todoApp(state = {}, action) {
  return {
    todos: todos(state.todos, action),
    visibilityFilter: visibilityFilter(state.visibilityFilter, action)
  }
}
This is basically the whole idea of Redux. Note that we haven’t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.
Edit this page
Last updated on May 20, 2023""""""",598,2620,redux
https://redux.js.org/introduction/learning-resources,"""""""IntroductionLearning Resources
Learning Resources
The Redux docs are intended to teach the basic concepts of Redux, as well as explain key concepts for use in real-world applications. However, the docs can't cover everything. Happily, there are many other great resources available for learning Redux. We encourage you to check them out. Many of them cover topics that are beyond the scope of the docs, or describe the same topics in other ways that may work better for your learning style.
This page includes our recommendations for some of the best external resources available to learn Redux. For an additional extensive list of tutorials, articles, and other resources on React, Redux, Javascript, and related topics, see the React/Redux Links list.
Basic Introductions
Tutorials that teach the basic concepts of Redux and how to use it
Intro to React, Redux, and TypeScript
https://blog.isquaredsoftware.com/2020/12/presentations-react-redux-ts-intro/
Redux maintainer Mark Erikson's slideset that covers the basics of React, Redux, and TypeScript. Redux topics include stores, reducers, middleware, React-Redux, and Redux Toolkit.
Learn Modern Redux - Redux Toolkit, React-Redux Hooks, and RTK Query
https://www.learnwithjason.dev/let-s-learn-modern-redux
An episode of the ""Learn with Jason"" show, with Redux maintainer Mark Erikson as guest. The episode features a live-coded app, and shows how to create a new React+TS project, add the Redux packages, and set up Redux Toolkit and React-Redux from scratch (including our recommended TS hooks configuration). It also shows how to use the upcoming RTK Query data fetching API and display that data in a UI.
Redux Tutorial: An Overview and Walkthrough
https://www.taniarascia.com/redux-react-guide/
A well-written tutorial from Tania Rascia that quickly explains key Redux concepts, and shows how to put together a basic Redux + React app using vanilla Redux and Redux Toolkit.
Redux for Beginners - The Brain-Friendly Guide to Learning Redux
https://www.freecodecamp.org/news/redux-for-beginners-the-brain-friendly-guide-to-redux/
An easy-to-follow tutorial that builds a small todo app with Redux Toolkit and React-Redux, including data fetching.
Redux made easy with Redux Toolkit and TypeScript
https://www.mattbutton.com/redux-made-easy-with-redux-toolkit-and-typescript/
A helpful tutorial that shows how to use Redux Toolkit and TypeScript together to write Redux applications, and how RTK simplifies typical Redux usage.
Redux: From Twitter Hype to Production
https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/
A well-produced slideshow that visually steps through core Redux concepts, usage with React, project organization, and side effects with thunks and sagas. Has some good animated diagrams demonstrating how data flows through a React+Redux architecture.
Using Redux With React
Explanations of the React-Redux bindings library
Modernizing a Legacy Redux Application with React-Redux Hooks
https://app.egghead.io/playlists/modernizing-a-legacy-redux-application-with-react-hooks-c528
A video series that shows the differences between the earlier connect API and the newer React-Redux hooks API, and how to use those hooks in your components.
Why Redux is Useful in React Apps
https://www.fullstackreact.com/articles/redux-with-mark-erikson/
An explanation of some of the benefits of using Redux with React, including sharing data between components and hot module reloading.
Project-Based Tutorials
Tutorials that teach Redux concepts by building projects, including larger ""real-world""-type applications
Practical Redux
https://blog.isquaredsoftware.com/2016/10/practical-redux-part-0-introduction/
https://blog.isquaredsoftware.com/series/practical-redux/
An ongoing series of posts intended to demonstrate a number of specific Redux techniques by building a sample application, based on the MekHQ application for managing Battletech campaigns. Written by Redux co-maintainer Mark Erikson. Covers topics like managing relational data, connecting multiple components and lists, complex reducer logic for features, handling forms, showing modal dialogs, and much more. (Note: this is an older series, and today we recommend newer patterns for writing Redux code. However, many of the principles in this series are still valuable.)
Redux Implementation
Explanations of how Redux works internally, by writing miniature reimplementations
Getting Started with Redux - Video Series
https://egghead.io/courses/fundamentals-of-redux-course-from-dan-abramov-bd5cc867
https://github.com/tayiorbeii/egghead.io_redux_course_notes
Dan Abramov, the creator of Redux, demonstrates various concepts in 30 short (2-5 minute) videos. The linked Github repo contains notes and transcriptions of the videos.
Building React Applications with Idiomatic Redux - Video Series
https://egghead.io/courses/building-react-applications-with-idiomatic-redux
https://github.com/tayiorbeii/egghead.io_idiomatic_redux_course_notes
Dan Abramov's second video tutorial series, continuing directly after the first. Includes lessons on store initial state, using Redux with React Router, using ""selector"" functions, normalizing state, use of Redux middleware, async action creators, and more. The linked Github repo contains notes and transcriptions of the videos.
Live React: Hot Reloading and Time Travel
https://youtube.com/watch?v=xsSnOQynTHs
Dan Abramov's original conference talk that introduced Redux. See how constraints enforced by Redux make hot reloading with time travel easy
Build Yourself a Redux
https://zapier.com/engineering/how-to-build-redux/
An excellent in-depth ""build a mini-Redux"" article, which covers not only Redux's core, but also connect and middleware as well.
Connect.js explained
https://gist.github.com/gaearon/1d19088790e70ac32ea636c025ba424e
A very simplified version of React Redux's connect() function that illustrates the basic implementation
Let's Write Redux!
https://www.jamasoftware.com/blog/lets-write-redux/
Walks through writing a miniature version of Redux step-by-step, to help explain the concepts and implementation.
Reducers
Articles discussing ways to write reducer functions
Taking Advantage of combineReducers
https://randycoulman.com/blog/2016/11/22/taking-advantage-of-combinereducers/
Examples of using combineReducers multiple times to produce a state tree, and some thoughts on tradeoffs in various approaches to reducer logic.
The Power of Higher-Order Reducers
https://slides.com/omnidan/hor#/
A slideshow from the author of redux-undo and other libraries, explaining the concept of higher-order reducers and how they can be used
Reducer composition with Higher Order Reducers
https://medium.com/@mange_vibration/reducer-composition-with-higher-order-reducers-35c3977ed08f
Some great examples of writing small functions that can be composed together to perform larger specific reducer tasks, such as providing initial state, filtering, updating specific keys, and more.
Higher Order Reducers - It just sounds scary
https://medium.com/@danielkagan/high-order-reducers-it-just-sounds-scary-2b9e5dbfc705
Explains how reducers can be composed like Lego bricks to create reusable and testable reducer logic.
Selectors
Explanations of how and why to use selector functions to read values from state
Idiomatic Redux: Using Reselect Selectors for Encapsulation and Performance
https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/
A complete guide to why you should use selector functions with Redux, how to use the Reselect library to write optimized selectors, and advanced tips for improving performance.
ReactCasts #8: Selectors in Redux
https://www.youtube.com/watch?v=frT3to2ACCw
A great overview of why and how to use selector functions to retrieve data from the store, and derive additional data from store values
Optimizing React Redux Application Development with Reselect
https://codebrahma.com/reselect-tutorial-optimizing-react-redux-application-development-with-reselect/
A good tutorial on Reselect. Covers the concept of ""selector functions"", how to use Reselect's API, and how to use memoized selectors to improve performance.
Usage of Reselect in a React-Redux Application
https://dashbouquet.com/blog/frontend-development/usage-of-reselect-in-a-react-redux-application
Discusses the importance of memoized selectors for performance, and good practices for using Reselect.
React, Reselect, and Redux
https://medium.com/@parkerdan/react-reselect-and-redux-b34017f8194c
An explanation of how Reselect's memoized selector functions are useful in Redux apps, and how to create unique selector instances for each component instance.
Normalization
How to structure the Redux store like a database for best performance
Querying a Redux Store
https://medium.com/@adamrackis/querying-a-redux-store-37db8c7f3b0f
A look at best practices for organizing and storing data in Redux, including normalizing data and use of selector functions.
Normalizing Redux Stores for Maximum Code Reuse
https://medium.com/@adamrackis/normalizing-redux-stores-for-maximum-code-reuse-ae6e3844ae95
Thoughts on how normalized Redux stores enable some useful data handling approaches, with examples of using selector functions to denormalize hierarchical data.
Advanced Redux Entity Normalization
https://medium.com/@dcousineau/advanced-redux-entity-normalization-f5f1fe2aefc5
Describes a ""keyWindow"" concept for tracking subsets of entities in state, similar to an SQL ""view"". A useful extension to the idea of normalized data.
Middleware
Explanations and examples of how middleware work and how to write them
Exploring Redux Middlewares
https://blog.krawaller.se/posts/exploring-redux-middleware/
Understanding middlewares through a series of small experiments
Redux Middleware Tutorial
https://github.com/pshrmn/notes/blob/master/redux/redux-middleware.md
An overview of what middleware is, how applyMiddleware works, and how to write middleware.
ReactCasts #6: Redux Middleware
https://www.youtube.com/watch?v=T-qtHI1qHIg
A screencast that describes how middleware fit into Redux, their uses, and how to implement a custom middleware
A Beginner's Guide to Redux Middleware
https://www.codementor.io/reactjs/tutorial/beginner-s-guide-to-redux-middleware
A useful explanation of middleware use cases, with numerous examples
Functional Composition in Javascript
https://joecortopassi.com/articles/functional-composition-in-javascript/
Breaking down how the compose function works
Side Effects - Basics
Introductions to handling async behavior in Redux
Stack Overflow: Dispatching Redux Actions with a Timeout
https://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559#35415559
Dan Abramov explains the basics of managing async behavior in Redux, walking through a progressive series of approaches (inline async calls, async action creators, thunk middleware).
Stack Overflow: Why do we need middleware for async flow in Redux?
https://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux/34599594#34599594
Dan Abramov gives reasons for using thunks and async middleware, and some useful patterns for using thunks.
What the heck is a ""thunk""?
https://daveceddia.com/what-is-a-thunk/
A quick explanation for what the word ""thunk"" means in general, and for Redux specifically.
Thunks in Redux: The Basics
https://medium.com/fullstack-academy/thunks-in-redux-the-basics-85e538a3fe60
A detailed look at what thunks are, what they solve, and how to use them.
Side Effects - Advanced
Advanced tools and techniques for managing async behavior
What is the right way to do asynchronous operations in Redux?
https://decembersoft.com/posts/what-is-the-right-way-to-do-asynchronous-operations-in-redux/
An excellent look at the most popular libraries for Redux side effects, with comparisons of how each one works.
Redux 4 Ways
https://medium.com/react-native-training/redux-4-ways-95a130da0cdc
Side-by-side comparisons of implementing some basic data fetching using thunks, sagas, observables, and a promise middleware
Idiomatic Redux: Thoughts on Thunks, Sagas, Abstractions, and Reusability
https://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/
A response to several ""thunks are bad"" concerns, arguing that thunks (and sagas) are still a valid approach for managing complex sync logic and async side effects.
Javascript Power Tools: Redux-Saga
https://formidable.com/blog/2017/javascript-power-tools-redux-saga/
https://formidable.com/blog/2017/composition-patterns-in-redux-saga/
https://formidable.com/blog/2017/real-world-redux-saga-patterns/
A fantastic series that teaches the concepts, implementation, and benefits behind Redux-Saga, including how ES6 generators are used to control function flow, how sagas can be composed together to accomplish concurrency, and practical use cases for sagas.
Exploring Redux Sagas
https://medium.com/onfido-tech/exploring-redux-sagas-cc1fca2015ee
An excellent article that explores how to use sagas to provide a glue layer to implement decoupled business logic in a Redux application.
Taming Redux with Sagas
https://objectpartners.com/2017/11/20/taming-redux-with-sagas/
A good overview of Redux-Saga, including info on generator functions, use cases for sagas, using sagas to deal with promises, and testing sagas.
Reactive Redux State with RxJS
https://ivanjov.com/reactive-redux-state-with-rxjs/
Describes the concept of ""Reactive Programming"" and the RxJS library, and shows how to use redux-observable to fetch data, along with examples of testing.
Using redux-observable to handle asynchronous logic in Redux
https://medium.com/dailyjs/using-redux-observable-to-handle-asynchronous-logic-in-redux-d49194742522
An extended post that compares a thunk-based implementation of handling a line-drawing example vs an observable-based implementation.
Thinking in Redux
Deeper looks at how Redux is meant to be used, and why it works the way it does
When (and when not) to reach for Redux
https://changelog.com/posts/when-and-when-not-to-reach-for-redux
Redux maintainer Mark Erikson describes the problems Redux was created to solve, and how it compares to other commonly used tools.
You Might Not Need Redux
https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367
Dan Abramov discusses the tradeoffs involved in using Redux.
Idiomatic Redux: The Tao of Redux, Part 1 - Implementation and Intent
https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/
A deep dive into how Redux actually works, the constraints it asks you to follow, and the intent behind its design and usage.
Idiomatic Redux: The Tao of Redux, Part 2 - Practice and Philosophy
https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/
A follow-up look at why common Redux usage patterns exist, other ways that Redux can be used, and thoughts on the pros and cons of those different patterns and approaches.
What's So Great About Redux?
https://medium.freecodecamp.org/whats-so-great-about-redux-ac16f1cc0f8b
Deep and fascinating analysis of how Redux compares to OOP and message-passing, how typical Redux usage can devolve towards Java-like ""setter"" functions with more boilerplate, and something of a plea for a higher-level ""blessed"" abstraction on top of Redux to make it easier to work with and learn for newbies. Very worth reading.
Redux Architecture
Patterns and practices for structuring larger Redux applications
Avoiding Accidental Complexity When Structuring Your App State
https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a
An excellent set of guidelines for organizing your Redux store structure.
Redux Step by Step: A Simple and Robust Workflow for Real Life Apps
https://hackernoon.com/redux-step-by-step-a-simple-and-robust-workflow-for-real-life-apps-1fdf7df46092
A follow-up to the ""Accidental Complexity"" article, discussing principle
Things I Wish I Knew About Redux
https://medium.com/horrible-hacks/things-i-wish-i-knew-about-redux-9924abf2f9e0
https://www.reddit.com/r/javascript/comments/4taau2/things_i_wish_i_knew_about_redux/
A number of excellent tips and lessons learned after building an app with Redux. Includes info on connecting components, selecting data, and app/project structure. Additional discussion on Reddit.
React+Redux: Tips and Best Practices for Clean, Reliable, & Maintainable Code
https://speakerdeck.com/goopscoop/react-plus-redux-tips-and-best-practices-for-clean-reliable-and-scalable-code
An excellent slideshow with a wide variety of tips and suggestions, including keeping action creators simple and data manipulation in reducers, abstracting away API calls, avoiding spreading props, and more.
Redux for state management in large web apps
https://blog.mapbox.com/redux-for-state-management-in-large-web-apps-c7f3fab3ce9b
Excellent discussion and examples of idiomatic Redux architecture, and how Mapbox applies those approaches to their Mapbox Studio application.
Apps and Examples
React-Redux RealWorld Example: TodoMVC for the Real World
https://github.com/GoThinkster/redux-review
An example full-stack ""real world"" application built with Redux. Demos a Medium-like social blogging site that includes JWT authentication, CRUD, favoriting articles, following users, routing, and more. The RealWorld project also includes many other implementations of the front and back ends of the site, specifically intended to show how different server and client implementations of the same project and API spec compare with each other.
Project Mini-Mek
https://github.com/markerikson/project-minimek
A sample app to demonstrate various useful Redux techniques, accompanying the ""Practical Redux"" blog series at https://blog.isquaredsoftware.com/series/practical-redux
react-redux-yelp-clone
https://github.com/mohamed-ismat/react-redux-yelp-clone
An adaptation of the ""Yelp Clone"" app by FullStackReact. It extends the original by using Redux and Redux Saga instead of local state, as well as React Router v4, styled-components, and other modern standards. Based on the React-Boilerplate starter kit.
WordPress-Calypso
https://github.com/Automattic/wp-calypso
The new JavaScript- and API-powered WordPress.com
Sound-Redux
https://github.com/andrewngu/sound-redux
A Soundcloud client built with React / Redux
Webamp
https://webamp.org
https://github.com/captbaritone/webamp
An in-browser recreation of Winamp2, built with React and Redux. Actually plays MP3s, and lets you load in local MP3 files.
Tello
https://github.com/joshwcomeau/Tello
A simple and delightful way to track and manage TV shows
io-808
https://github.com/vincentriemer/io-808
An attempt at a fully recreated web-based TR-808 drum machine
Redux Docs Translations
中文文档 — Chinese
繁體中文文件 — Traditional Chinese
Redux in Russian — Russian
Redux en Español - Spanish
Redux in Korean - Korean
Books
Redux in Action
https://www.manning.com/books/redux-in-action
A comprehensive book that covers many key aspects of using Redux, including the basics of reducers and actions and use with React, complex middlewares and side effects, application structure, performance, testing, and much more. Does a great job of explaining the pros, cons, and tradeoffs of many approaches to using Redux. Personally recommended by Redux co-maintainer Mark Erikson.
The Complete Redux Book
https://leanpub.com/redux-book
How do I manage a large state in production? Why do I need store enhancers? What is the best way to handle form validations? Get the answers to all these questions and many more using simple terms and sample code. Learn everything you need to use Redux to build complex and production-ready web applications. (Note: now permanently free!)
Taming the State in React
https://www.robinwieruch.de/learn-react-redux-mobx-state-management/
If you have learned React with the previous book of the author called The Road to learn React, Taming the State in React will be the perfect blend to learn about basic and advanced state management in React. You will start out with learning only Redux without React. Afterward, the book shows you how to connect Redux to your React application. The advanced chapters will teach you about normalization, naming, selectors and asynchronous actions. In the end, you will set up and build a real world application with React and Redux.
Courses
Modern React with Redux, by Stephen Grider (paid)
https://www.udemy.com/react-redux/
Master the fundamentals of React and Redux with this tutorial as you develop apps with React Router, Webpack, and ES2015. This course will get you up and running quickly, and teach you the core knowledge you need to deeply understand and build React components and structure applications with Redux.
Redux, by Tyler McGinnis (paid)
https://tylermcginnis.com/courses/redux/
When learning Redux, you need to learn it in the context of an app big enough to see the benefits. That's why this course is huge. A better name might be ""Real World Redux"". If you're sick of ""todo list"" Redux tutorials, you've come to the right place. In this course we'll talk all about what makes Redux special for managing state in your application. We'll build an actual ""real world"" application so you can see how Redux handles edge cases like optimistic updates and error handling. We'll also cover many other technologies that work well with Redux, Firebase, and CSS Modules.
Learn Redux, by Wes Bos (free)
https://learnredux.com/
A video course that walks through building 'Reduxstagram' — a simple photo app that will simplify the core ideas behind Redux, React Router and React.js
More Resources
React-Redux Links is a curated list of high-quality articles, tutorials, and related content for React, Redux, ES2015, and more.
Redux Ecosystem Links is a categorized collection of Redux-related libraries, addons, and utilities.
Awesome Redux is an extensive list of Redux-related repositories.
DEV Community is a place to share Redux projects, articles and tutorials as well as start discussions and ask for feedback on Redux-related topics. Developers of all skill-levels are welcome to take part.
Edit this page
Last updated on Jan 3, 2024""""""",4958,22251,redux
https://redux.js.org/introduction/ecosystem,"""""""IntroductionEcosystem
Ecosystem
Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions, and the community has created a wide variety of helpful addons, libraries, and tools. You don't need to use any of these addons to use Redux, but they can help make it easier to implement features and solve problems in your application.
For an extensive catalog of libraries, addons, and tools related to Redux, check out the Redux Ecosystem Links list. Also, the React/Redux Links list contains tutorials and other useful resources for anyone learning React or Redux.
This page lists some of the Redux-related addons that the Redux maintainers have vetted personally, or that have shown widespread adoption in the community. Don't let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the “staff picks”, and don't hesitate to submit a PR if you've built something wonderful with Redux.
Table of Contents
Ecosystem
Table of Contents
Library Integration and Bindings
Reducers
Reducer Combination
Reducer Composition
Higher-Order Reducers
Actions
Utilities
Store
Change Subscriptions
Batching
Persistence
Immutable Data
Data Structures
Immutable Update Utilities
Immutable/Redux Interop
Side Effects
Widely Used
Promises
Middleware
Networks and Sockets
Async Behavior
Analytics
Entities and Collections
Component State and Encapsulation
Dev Tools
Debuggers and Viewers
DevTools Monitors
Logging
Mutation Detection
Testing
Routing
Forms
Higher-Level Abstractions
Community Conventions
Library Integration and Bindings
reduxjs/react-redux
The official React bindings for Redux, maintained by the Redux team
angular-redux/ng-redux
Angular 1 bindings for Redux
ember-redux/ember-redux
Ember bindings for Redux
glimmer-redux/glimmer-redux
Redux bindings for Ember's Glimmer component engine
tur-nr/polymer-redux
Redux bindings for Polymer
lastmjs/redux-store-element Redux bindings for custom elements
Reducers
Reducer Combination
ryo33/combineSectionReducers
An expanded version of combineReducers, which allows passing state as a third argument to all slice reducers.
KodersLab/topologically-combine-reducers
A combineReducers variation that allows defining cross-slice dependencies for ordering and data passing
var masterReducer = topologicallyCombineReducers(
  { auth, users, todos },
  // define the dependency tree
  { auth: ['users'], todos: ['auth'] }
)
Reducer Composition
acdlite/reduce-reducers
Provides sequential composition of reducers at the same level
const combinedReducer = combineReducers({ users, posts, comments })
const rootReducer = reduceReducers(combinedReducer, otherTopLevelFeatureReducer)
mhelmer/redux-xforms
A collection of composable reducer transformers
const createByFilter = (predicate, mapActionToKey) =>
  compose(
    withInitialState({}), // inject initial state as {}
    withFilter(predicate), // let through if action has filterName
    updateSlice(mapActionToKey), // update a single key in the state
    isolateSlice(mapActionToKey) // run the reducer on a single state slice
  )
adrienjt/redux-data-structures
Reducer factory functions for common data structures: counters, maps, lists (queues, stacks), sets
const myCounter = counter({
  incrementActionTypes: ['INCREMENT'],
  decrementActionTypes: ['DECREMENT']
})
Higher-Order Reducers
omnidan/redux-undo
Effortless undo/redo and action history for your reducers
omnidan/redux-ignore
Ignore redux actions by array or filter function
omnidan/redux-recycle
Reset the redux state on certain actions
ForbesLindesay/redux-optimist
A reducer enhancer to enable type-agnostic optimistic updates
Utilities
reduxjs/reselect
Creates composable memoized selector functions for efficiently deriving data from the store state
const taxSelector = createSelector(
  [subtotalSelector, taxPercentSelector],
  (subtotal, taxPercent) => subtotal * (taxPercent / 100)
)
paularmstrong/normalizr
Normalizes nested JSON according to a schema
const user = new schema.Entity('users')
const comment = new schema.Entity('comments', { commenter: user })
const article = new schema.Entity('articles', {
  author: user,
  comments: [comment]
})
const normalizedData = normalize(originalData, article)
planttheidea/selectorator
Abstractions over Reselect for common selector use cases
const getBarBaz = createSelector(
  ['foo.bar', 'baz'],
  (bar, baz) => `${bar} ${baz}`
)
getBarBaz({ foo: { bar: 'a' }, baz: 'b' }) // ""a b""
Store
Change Subscriptions
jprichardson/redux-watch
Watch for state changes based on key paths or selectors
let w = watch(() => mySelector(store.getState()))
store.subscribe(
  w((newVal, oldVal) => {
    console.log(newval, oldVal)
  })
)
ashaffer/redux-subscribe
Centralized subscriptions to state changes based on paths
store.dispatch( subscribe(""users.byId.abcd"", ""subscription1"", () => {} );
Batching
tappleby/redux-batched-subscribe
Store enhancer that can debounce subscription notifications
const debounceNotify = _.debounce(notify => notify())
const store = configureStore({
  reducer,
  enhancers: [batchedSubscribe(debounceNotify)]
})
manaflair/redux-batch
Store enhancer that allows dispatching arrays of actions
const store = configureStore({
  reducer,
  enhancers: existingEnhancersArray => [
    reduxBatch,
    ...existingEnhancersArray,
    reduxBatch
  ]
})
store.dispatch([{ type: 'INCREMENT' }, { type: 'INCREMENT' }])
laysent/redux-batch-actions-enhancer
Store enhancer that accepts batched actions
const store = configureStore({ reducer, enhancers: [batch().enhancer] })
store.dispatch(createAction({ type: 'INCREMENT' }, { type: 'INCREMENT' }))
tshelburne/redux-batched-actions
Higher-order reducer that handles batched actions
const store = configureStore({ reducer: enableBatching(rootReducer) })
store.dispatch(batchActions([{ type: 'INCREMENT' }, { type: 'INCREMENT' }]))
Persistence
rt2zz/redux-persist
Persist and rehydrate a Redux store, with many extensible options
const persistConfig = { key: 'root', version: 1, storage }
const persistedReducer = persistReducer(persistConfig, rootReducer)
export const store = configureStore({
  reducer: persistedReducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER]
      }
    })
})
export const persistor = persistStore(store)
react-stack/redux-storage
Persistence layer for Redux with flexible backends
const reducer = storage.reducer(combineReducers(reducers))
const engine = createEngineLocalStorage('my-save-key')
const storageMiddleware = storage.createMiddleware(engine)
const store = configureStore({
  reducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware.concat(storageMiddleware)
})
redux-offline/redux-offline
Persistent store for Offline-First apps, with support for optimistic UIs
const store = configureStore({ reducer, enhancer: [offline(offlineConfig)] })
store.dispatch({
  type: 'FOLLOW_USER_REQUEST',
  meta: { offline: { effect: {}, commit: {}, rollback: {} } }
})
Immutable Data
ImmerJS/immer
Immutable updates with normal mutative code, using Proxies
const nextState = produce(baseState, draftState => {
  draftState.push({ todo: 'Tweet about it' })
  draftState[1].done = true
})
Side Effects
Widely Used
reduxjs/redux-thunk
Dispatch functions, which are called and given dispatch and getState as parameters. This acts as a loophole for AJAX calls and other async behavior.
Best for: getting started, simple async and complex synchronous logic.
function fetchData(someValue) {
    return (dispatch, getState) => {
        dispatch({type : ""REQUEST_STARTED""});

        myAjaxLib.post(""/someEndpoint"", {data : someValue})
            .then(response => dispatch({type : ""REQUEST_SUCCEEDED"", payload : response})
            .catch(error => dispatch({type : ""REQUEST_FAILED"", error : error});
    };
}

function addTodosIfAllowed(todoText) {
    return (dispatch, getState) => {
        const state = getState();

        if(state.todos.length < MAX_TODOS) {
            dispatch({type : ""ADD_TODO"", text : todoText});
        }
    }
}
listenerMiddleware (Redux Toolkit)
listenerMiddleware is intended to be a lightweight alternative to more widely used Redux async middleware like sagas and observables. While similar to thunks in level of complexity and concept, it can be used to replicate some common saga usage patterns.
listenerMiddleware.startListening({
  matcher: isAnyOf(action1, action2, action3),
  effect: (action, listenerApi) => {
    const user = selectUserDetails(listenerApi.getState())

    const { specialData } = action.meta

    analyticsApi.trackUsage(action.type, user, specialData)
  }
})
redux-saga/redux-saga
Handle async logic using synchronous-looking generator functions. Sagas return descriptions of effects, which are executed by the saga middleware, and act like ""background threads"" for JS applications.
Best for: complex async logic, decoupled workflows
function* fetchData(action) {
  const { someValue } = action
  try {
    const response = yield call(myAjaxLib.post, '/someEndpoint', {
      data: someValue
    })
    yield put({ type: 'REQUEST_SUCCEEDED', payload: response })
  } catch (error) {
    yield put({ type: 'REQUEST_FAILED', error: error })
  }
}

function* addTodosIfAllowed(action) {
  const { todoText } = action
  const todos = yield select(state => state.todos)

  if (todos.length < MAX_TODOS) {
    yield put({ type: 'ADD_TODO', text: todoText })
  }
}
redux-observable/redux-observable
Handle async logic using RxJS observable chains called ""epics"". Compose and cancel async actions to create side effects and more.
Best for: complex async logic, decoupled workflows
const loginRequestEpic = action$ =>
  action$
    .ofType(LOGIN_REQUEST)
    .mergeMap(({ payload: { username, password } }) =>
      Observable.from(postLogin(username, password))
        .map(loginSuccess)
        .catch(loginFailure)
    )

const loginSuccessfulEpic = action$ =>
  action$
    .ofType(LOGIN_SUCCESS)
    .delay(2000)
    .mergeMap(({ payload: { msg } }) => showMessage(msg))

const rootEpic = combineEpics(loginRequestEpic, loginSuccessfulEpic)
redux-loop/redux-loop
A port of the Elm Architecture to Redux that allows you to sequence your effects naturally and purely by returning them from your reducers. Reducers now return both a state value and a side effect description.
Best for: trying to be as much like Elm as possible in Redux+JS
export const reducer = (state = {}, action) => {
  switch (action.type) {
    case ActionType.LOGIN_REQUEST:
      const { username, password } = action.payload
      return loop(
        { pending: true },
        Effect.promise(loginPromise, username, password)
      )
    case ActionType.LOGIN_SUCCESS:
      const { user, msg } = action.payload
      return loop(
        { pending: false, user },
        Effect.promise(delayMessagePromise, msg, 2000)
      )
    case ActionType.LOGIN_FAILURE:
      return { pending: false, err: action.payload }
    default:
      return state
  }
}
jeffbski/redux-logic
Side effects lib built with observables, but allows use of callbacks, promises, async/await, or observables. Provides declarative processing of actions.
Best for: very decoupled async logic
const loginLogic = createLogic({
  type: Actions.LOGIN_REQUEST,

  process({ getState, action }, dispatch, done) {
    const { username, password } = action.payload

    postLogin(username, password)
      .then(
        ({ user, msg }) => {
          dispatch(loginSucceeded(user))

          setTimeout(() => dispatch(showMessage(msg)), 2000)
        },
        err => dispatch(loginFailure(err))
      )
      .then(done)
  }
})
Promises
acdlite/redux-promise
Dispatch promises as action payloads, and have FSA-compliant actions dispatched as the promise resolves or rejects.
dispatch({ type: 'FETCH_DATA', payload: myAjaxLib.get('/data') })
// will dispatch either {type : ""FETCH_DATA"", payload : response} if resolved,
// or dispatch {type : ""FETCH_DATA"", payload : error, error : true} if rejected
lelandrichardson/redux-pack
Sensible, declarative, convention-based promise handling that guides users in a good direction without exposing the full power of dispatch.
dispatch({type : ""FETCH_DATA"", payload : myAjaxLib.get(""/data"") });

// in a reducer:
        case ""FETCH_DATA"": =
            return handle(state, action, {
                start: prevState => ({
                  ...prevState,
                  isLoading: true,
                  fooError: null
                }),
                finish: prevState => ({ ...prevState, isLoading: false }),
                failure: prevState => ({ ...prevState, fooError: payload }),
                success: prevState => ({ ...prevState, foo: payload }),
            });
Middleware
Networks and Sockets
svrcekmichal/redux-axios-middleware
Fetches data with Axios and dispatches start/success/fail actions
export const loadCategories() => ({ type: 'LOAD', payload: { request : { url: '/categories'} } });
agraboso/redux-api-middleware
Reads API call actions, fetches, and dispatches FSAs
const fetchUsers = () => ({
  [CALL_API]: {
    endpoint: 'http://www.example.com/api/users',
    method: 'GET',
    types: ['REQUEST', 'SUCCESS', 'FAILURE']
  }
})
itaylor/redux-socket.io
An opinionated connector between socket.io and redux.
const store = configureStore({
  reducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware.concat(socketIoMiddleware)
})
store.dispatch({ type: 'server/hello', data: 'Hello!' })
tiberiuc/redux-react-firebase
Integration between Firebase, React, and Redux
Async Behavior
rt2zz/redux-action-buffer
Buffers all actions into a queue until a breaker condition is met, at which point the queue is released
wyze/redux-debounce
FSA-compliant middleware for Redux to debounce actions.
mathieudutour/redux-queue-offline
Queue actions when offline and dispatch them when getting back online.
Analytics
rangle/redux-beacon
Integrates with any analytics services, can track while offline, and decouples analytics logic from app logic
markdalgleish/redux-analytics
Watches for Flux Standard Actions with meta analytics values and processes them
Entities and Collections
tommikaikkonen/redux-orm
A simple immutable ORM to manage relational data in your Redux store.
Versent/redux-crud
Convention-based actions and reducers for CRUD logic
kwelch/entities-reducer
A higher-order reducer that handles data from Normalizr
amplitude/redux-query
Declare colocated data dependencies with your components, run queries when components mount, perform optimistic updates, and trigger server changes with Redux actions.
cantierecreativo/redux-bees
Declarative JSON-API interaction that normalizes data, with a React HOC that can run queries
GetAmbassador/redux-clerk
Async CRUD handling with normalization, optimistic updates, sync/async action creators, selectors, and an extendable reducer.
shoutem/redux-io
JSON-API abstraction with async CRUD, normalization, optimistic updates, caching, data status, and error handling.
jmeas/redux-resource
A tiny but powerful system for managing 'resources': data that is persisted to remote servers.
Component State and Encapsulation
threepointone/redux-react-local
Local component state in Redux, with handling for component actions
@local({
  ident: 'counter', initial: 0, reducer : (state, action) => action.me ? state + 1 : state }
})
class Counter extends React.Component {
epeli/lean-redux
Makes component state in Redux as easy as setState
const DynamicCounters = connectLean(
    scope: ""dynamicCounters"",
    getInitialState() => ({counterCount : 1}),
    addCounter, removeCounter
)(CounterList);
DataDog/redux-doghouse
Aims to make reusable components easier to build with Redux by scoping actions and reducers to a particular instance of a component.
const scopeableActions = new ScopedActionFactory(actionCreators)
const actionCreatorsScopedToA = scopeableActions.scope('a')
actionCreatorsScopedToA.foo('bar') //{ type: SET_FOO, value: 'bar', scopeID: 'a' }

const boundScopeableActions = bindScopedActionFactories(
  scopeableActions,
  store.dispatch
)
const scopedReducers = scopeReducers(reducers)
Dev Tools
Debuggers and Viewers
reduxjs/redux-devtools
Dan Abramov's original Redux DevTools implementation, built for in-app display of state and time-travel debugging
zalmoxisus/redux-devtools-extension
Mihail Diordiev's browser extension, which bundles multiple state monitor views and adds integration with the browser's own dev tools
infinitered/reactotron
A cross-platform Electron app for inspecting React and React Native apps, including app state, API requests, perf, errors, sagas, and action dispatching.
DevTools Monitors
Log Monitor
The default monitor for Redux DevTools with a tree view
Dock Monitor
A resizable and movable dock for Redux DevTools monitors
Slider Monitor
A custom monitor for Redux DevTools to replay recorded Redux actions
Diff Monitor
A monitor for Redux DevTools that diffs the Redux store mutations between actions
Filterable Log Monitor
Filterable tree view monitor for Redux DevTools
Filter Actions
Redux DevTools composable monitor with the ability to filter actions
Logging
evgenyrodionov/redux-logger
Logging middleware that shows actions, states, and diffs
inakianduaga/redux-state-history
Enhancer that provides time-travel and efficient action recording capabilities, including import/export of action logs and action playback.
joshwcomeau/redux-vcr
Record and replay user sessions in real-time
socialtables/redux-unhandled-action
Warns about actions that produced no state changes in development
Mutation Detection
leoasis/redux-immutable-state-invariant
Middleware that throws an error when you try to mutate your state either inside a dispatch or between dispatches.
flexport/mutation-sentinel
Helps you deeply detect mutations at runtime and enforce immutability in your codebase.
mmahalwy/redux-pure-connect
Check and log whether react-redux's connect method is passed mapState functions that create impure props.
Testing
arnaudbenard/redux-mock-store
A mock store that saves dispatched actions in an array for assertions
Workable/redux-test-belt
Extends the store API to make it easier assert, isolate, and manipulate the store
conorhastings/redux-test-recorder
Middleware to automatically generate reducers tests based on actions in the app
wix/redux-testkit
Complete and opinionated testkit for testing Redux projects (reducers, selectors, actions, thunks)
jfairbank/redux-saga-test-plan
Makes integration and unit testing of sagas a breeze
Routing
supasate/connected-react-router Synchronize React Router v4+ state with your Redux store.
faceyspacey/redux-first-router
Seamless Redux-first routing. Think of your app in states, not routes, not components, while keeping the address bar in sync. Everything is state. Connect your components and just dispatch flux standard actions.
Forms
erikras/redux-form
A full-featured library to enable a React HTML form to store its state in Redux.
davidkpiano/react-redux-form
React Redux Form is a collection of reducer creators and action creators that make implementing even the most complex and custom forms with React and Redux simple and performant.
Higher-Level Abstractions
keajs/kea
An abstraction over Redux, Redux-Saga and Reselect. Provides a framework for your app’s actions, reducers, selectors and sagas. It empowers Redux, making it as simple to use as setState. It reduces boilerplate and redundancy, while retaining composability.
TheComfyChair/redux-scc
Takes a defined structure and uses 'behaviors' to create a set of actions, reducer responses and selectors.
Bloomca/redux-tiles
Provides minimal abstraction on top of Redux, to allow easy composability, easy async requests, and sane testability.
Community Conventions
Flux Standard Action
A human-friendly standard for Flux action objects
Canonical Reducer Composition
An opinionated standard for nested reducer composition
Ducks: Redux Reducer Bundles
A proposal for bundling reducers, action types and actions
Edit this page
Last updated on Jun 26, 2022""""""",4534,20219,redux
https://redux.js.org/introduction/examples,"""""""IntroductionExamples
Examples
Redux is distributed with a few examples in its source code. Most of these examples are also on CodeSandbox, an online editor that lets you play with the examples online.
Counter Vanilla
Run the Counter Vanilla example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/counter-vanilla
open index.html
Or check out the sandbox:
It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.
Counter
Run the Counter example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/counter
npm install
npm start
Or check out the sandbox:
This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant React Redux bindings instead.
This example includes tests.
Todos
Run the Todos example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/todos
npm install
npm start
Or check out the sandbox:
This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use React Redux to generate container components from your presentational components.
This example includes tests.
Todos with Undo
Run the Todos with Undo example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/todos-with-undo
npm install
npm start
Or check out the sandbox:
This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with Redux Undo lets you add a Undo/Redo functionality to your app with a few lines of code.
TodoMVC
Run the TodoMVC example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/todomvc
npm install
npm start
Or check out the sandbox:
This is the classical TodoMVC example. It's here for the sake of comparison, but it covers the same points as the Todos example.
This example includes tests.
Shopping Cart
Run the Shopping Cart example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/shopping-cart
npm install
npm start
Or check out the sandbox:
This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with Redux Logger and conditional dispatching of actions with Redux Thunk middleware.
Tree View
Run the Tree View example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/tree-view
npm install
npm start
Or check out the sandbox:
This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.
This example includes tests.
Async
Run the Async example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/async
npm install
npm start
Or check out the sandbox:
This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses Redux Thunk middleware to encapsulate asynchronous side effects.
Universal
Run the Universal example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/universal
npm install
npm start
This is a basic demonstration of server rendering with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.
Real World
Run the Real World example:
git clone https://github.com/reduxjs/redux.git

cd redux/examples/real-world
npm install
npm start
Or check out the sandbox:
This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.
More Examples
You can find more examples in the Redux Apps and Examples page of the Redux Addons Catalog.
Edit this page
Last updated on Nov 12, 2022""""""",961,4547,redux
https://redux.js.org/tutorials/index,"""""""TutorialsTutorials Index
Redux Tutorials Index
Redux Official Tutorials
The Quick Start page briefly shows the basics of setting up a Redux Toolkit + React application, and the TypeScript Quick Start page shows how to set up Redux Toolkit and React for use with TypeScript.
We have two different full-size tutorials:
The Redux Essentials tutorial is a ""top-down"" tutorial that teaches ""how to use Redux the right way"", using our latest recommended APIs and best practices (Redux Toolkit for the logic, React-Redux hooks for the UI, and ""RTK Query"" for fetching and caching data).
The Redux Fundamentals tutorial is a ""bottom-up"" tutorial that teaches ""how Redux works"" from first principles and without any abstractions, and why standard Redux usage patterns exist.
TIP
We recommend starting with the Redux Essentials tutorial, since it covers the key points you need to know about how to get started using our modern Redux Toolkit package to write actual applications.
Additional Resources
Learn Modern Redux Livestream
Redux maintainer Mark Erikson appeared on the ""Learn with Jason"" show to explain how we recommend using Redux today. The show includes a live-coded example app that shows how to use Redux Toolkit and React-Redux hooks with TypeScript, as well as the new RTK Query data fetching APIs:
Edit this page
Last updated on Mar 6, 2023""""""",276,1347,redux
https://redux.js.org/tutorials/quick-start,"""""""TutorialsQuick Start
Redux Toolkit Quick Start
WHAT YOU'LL LEARN
How to set up and use Redux Toolkit with React-Redux
PREREQUISITES
Familiarity with ES6 syntax and features
Knowledge of React terminology: JSX, State, Function Components, Props, and Hooks
Understanding of Redux terms and concepts
Introduction
Welcome to the Redux Toolkit Quick Start tutorial! This tutorial will briefly introduce you to Redux Toolkit and teach you how to start using it correctly.
How to Read This Tutorial
This page will focus on just how to set up a Redux application with Redux Toolkit and the main APIs you'll use. For explanations of what Redux is, how it works, and full examples of how to use Redux Toolkit, see the tutorials linked in the ""Tutorials Index"" page.
For this tutorial, we assume that you're using Redux Toolkit with React, but you can also use it with other UI layers as well. The examples are based on a typical Create-React-App folder structure where all the application code is in a src folder, but the patterns can be adapted to whatever project or folder setup you're using.
The Redux+JS template for Create-React-App comes with this same project setup already configured.
Usage Summary
Install Redux Toolkit and React-Redux
Add the Redux Toolkit and React-Redux packages to your project:
npm install @reduxjs/toolkit react-redux
Create a Redux Store
Create a file named src/app/store.js. Import the configureStore API from Redux Toolkit. We'll start by creating an empty Redux store, and exporting it:
app/store.js
import { configureStore } from '@reduxjs/toolkit'

export default configureStore({
  reducer: {}
})
This creates a Redux store, and also automatically configure the Redux DevTools extension so that you can inspect the store while developing.
Provide the Redux Store to React
Once the store is created, we can make it available to our React components by putting a React-Redux <Provider> around our application in src/index.js. Import the Redux store we just created, put a <Provider> around your <App>, and pass the store as a prop:
index.js
import React from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App'
import store from './app/store'
import { Provider } from 'react-redux'

const root = createRoot(document.getElementById('root')!)

root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
)
Create a Redux State Slice
Add a new file named src/features/counter/counterSlice.js. In that file, import the createSlice API from Redux Toolkit.
Creating a slice requires a string name to identify the slice, an initial state value, and one or more reducer functions to define how the state can be updated. Once a slice is created, we can export the generated Redux action creators and the reducer function for the whole slice.
Redux requires that we write all state updates immutably, by making copies of data and updating the copies. However, Redux Toolkit's createSlice and createReducer APIs use Immer inside to allow us to write ""mutating"" update logic that becomes correct immutable updates.
features/counter/counterSlice.js
import { createSlice } from '@reduxjs/toolkit'

export const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0
  },
  reducers: {
    increment: state => {
      // Redux Toolkit allows us to write ""mutating"" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a ""draft state"" and produces a brand new
      // immutable state based off those changes
      state.value += 1
    },
    decrement: state => {
      state.value -= 1
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload
    }
  }
})

// Action creators are generated for each case reducer function
export const { increment, decrement, incrementByAmount } = counterSlice.actions

export default counterSlice.reducer
Add Slice Reducers to the Store
Next, we need to import the reducer function from the counter slice and add it to our store. By defining a field inside the reducer parameter, we tell the store to use this slice reducer function to handle all updates to that state.
app/store.js
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from '../features/counter/counterSlice'

export default configureStore({
  reducer: {
    counter: counterReducer
  }
})
Use Redux State and Actions in React Components
Now we can use the React-Redux hooks to let React components interact with the Redux store. We can read data from the store with useSelector, and dispatch actions using useDispatch. Create a src/features/counter/Counter.js file with a <Counter> component inside, then import that component into App.js and render it inside of <App>.
features/counter/Counter.js
import React from 'react'
import { useSelector, useDispatch } from 'react-redux'
import { decrement, increment } from './counterSlice'
import styles from './Counter.module.css'

export function Counter() {
  const count = useSelector(state => state.counter.value)
  const dispatch = useDispatch()

  return (
    <div>
      <div>
        <button
          aria-label=""Increment value""
          onClick={() => dispatch(increment())}
        >
          Increment
        </button>
        <span>{count}</span>
        <button
          aria-label=""Decrement value""
          onClick={() => dispatch(decrement())}
        >
          Decrement
        </button>
      </div>
    </div>
  )
}
Now, any time you click the ""Increment"" and ""Decrement"" buttons:
The corresponding Redux action will be dispatched to the store
The counter slice reducer will see the actions and update its state
The <Counter> component will see the new state value from the store and re-render itself with the new data
What You've Learned
That was a brief overview of how to set up and use Redux Toolkit with React. Recapping the details:
SUMMARY
Create a Redux store with configureStore
configureStore accepts a reducer function as a named argument
configureStore automatically sets up the store with good default settings
Provide the Redux store to the React application components
Put a React-Redux <Provider> component around your <App />
Pass the Redux store as <Provider store={store}>
Create a Redux ""slice"" reducer with createSlice
Call createSlice with a string name, an initial state, and named reducer functions
Reducer functions may ""mutate"" the state using Immer
Export the generated slice reducer and action creators
Use the React-Redux useSelector/useDispatch hooks in React components
Read data from the store with the useSelector hook
Get the dispatch function with the useDispatch hook, and dispatch actions as needed
Full Counter App Example
Here's the complete counter application as a running CodeSandbox:
What's Next?
We recommend going through the full ""Redux Essentials"" tutorial, which covers all of the key pieces included in Redux Toolkit, what problems they solve, and how to use them to build real-world applications.
You may also want to read through the ""Redux Fundamentals"" tutorial, which will give you a complete understanding of how Redux works, what Redux Toolkit does, and how to use it correctly.
Edit this page
Last updated on Jul 28, 2024""""""",1565,7324,redux
https://redux.js.org/tutorials/typescript-quick-start,"""""""TutorialsTypeScript Quick Start
Redux Toolkit TypeScript Quick Start
WHAT YOU'LL LEARN
How to set up and use Redux Toolkit and React-Redux with TypeScript
PREREQUISITES
Knowledge of React Hooks
Understanding of Redux terms and concepts
Understanding of TypeScript syntax and concepts
Introduction
Welcome to the Redux Toolkit TypeScript Quick Start tutorial! This tutorial will briefly show how to use TypeScript with Redux Toolkit and React-Redux.
This page focuses on just how to set up the TypeScript aspects . For explanations of what Redux is, how it works, and full examples of how to use Redux Toolkit, see the tutorials linked in the ""Tutorials Index"" page.
Redux Toolkit is already written in TypeScript, so its TS type definitions are built in.
React Redux is also written in TypeScript as of version 8, and also includes its own type definitions.
The Redux+TS template for Create-React-App comes with a working example of these patterns already configured.
Project Setup
Define Root State and Dispatch Types
Redux Toolkit's configureStore API should not need any additional typings. You will, however, want to extract the RootState type and the Dispatch type so that they can be referenced as needed. Inferring these types from the store itself means that they correctly update as you add more state slices or modify middleware settings.
Since those are types, it's safe to export them directly from your store setup file such as app/store.ts and import them directly into other files.
app/store.ts
import { configureStore } from '@reduxjs/toolkit'
// ...

export const store = configureStore({
  reducer: {
    posts: postsReducer,
    comments: commentsReducer,
    users: usersReducer
  }
})

// Infer the `RootState`,  `AppDispatch`, and `AppStore` types from the store itself
export type RootState = ReturnType<typeof store.getState>
// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = typeof store.dispatch
export type AppStore = typeof store
Define Typed Hooks
While it's possible to import the RootState and AppDispatch types into each component, it's better to create typed versions of the useDispatch and useSelector hooks for usage in your application. This is important for a couple reasons:
For useSelector, it saves you the need to type (state: RootState) every time
For useDispatch, the default Dispatch type does not know about thunks. In order to correctly dispatch thunks, you need to use the specific customized AppDispatch type from the store that includes the thunk middleware types, and use that with useDispatch. Adding a pre-typed useDispatch hook keeps you from forgetting to import AppDispatch where it's needed.
Since these are actual variables, not types, it's important to define them in a separate file such as app/hooks.ts, not the store setup file. This allows you to import them into any component file that needs to use the hooks, and avoids potential circular import dependency issues.
app/hooks.ts
import { useDispatch, useSelector } from 'react-redux'
import type { AppDispatch, RootState } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()
Application Usage
Define Slice State and Action Types
Each slice file should define a type for its initial state value, so that createSlice can correctly infer the type of state in each case reducer.
All generated actions should be defined using the PayloadAction<T> type from Redux Toolkit, which takes the type of the action.payload field as its generic argument.
You can safely import the RootState type from the store file here. It's a circular import, but the TypeScript compiler can correctly handle that for types. This may be needed for use cases like writing selector functions.
features/counter/counterSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import type { RootState } from '../../app/store'

// Define a type for the slice state
export interface CounterState {
  value: number
}

// Define the initial state using that type
const initialState: CounterState = {
  value: 0
}

export const counterSlice = createSlice({
  name: 'counter',
  // `createSlice` will infer the state type from the `initialState` argument
  initialState,
  reducers: {
    increment: state => {
      state.value += 1
    },
    decrement: state => {
      state.value -= 1
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload
    }
  }
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions

// Other code such as selectors can use the imported `RootState` type
export const selectCount = (state: RootState) => state.counter.value

export default counterSlice.reducer
The generated action creators will be correctly typed to accept a payload argument based on the PayloadAction<T> type you provided for the reducer. For example, incrementByAmount requires a number as its argument.
In some cases, TypeScript may unnecessarily tighten the type of the initial state. If that happens, you can work around it by casting the initial state using as, instead of declaring the type of the variable:
// Workaround: cast state instead of declaring variable type
const initialState = {
  value: 0
} as CounterState
Use Typed Hooks in Components
In component files, import the pre-typed hooks instead of the standard hooks from React-Redux.
features/counter/Counter.tsx
import React from 'react'

import { useAppSelector, useAppDispatch } from 'app/hooks'

import { decrement, increment } from './counterSlice'

export function Counter() {
  // The `state` arg is correctly typed as `RootState` already
  const count = useAppSelector(state => state.counter.value)
  const dispatch = useAppDispatch()

  // omit rendering logic
}
Full Counter App Example
Here's the complete TS counter application as a running CodeSandbox:
What's Next?
We recommend going through the full ""Redux Essentials"" tutorial, which covers all of the key pieces included in Redux Toolkit, what problems they solve, and how to use them to build real-world applications.
You may also want to read through the ""Redux Fundamentals"" tutorial, which will give you a complete understanding of how Redux works, what Redux Toolkit does, and how to use it correctly.
Finally, see the ""Usage with TypeScript"" page for extended details on how to use Redux Toolkit's APIs with TypeScript.
Edit this page
Last updated on May 12, 2024""""""",1394,6681,redux
https://redux.js.org/tutorials/videos,"""""""TutorialsVideos
Recommended Videos
Here are some excellent video tutorials that we can recommend. These videos show the same ""modern Redux"" approaches that we teach in our docs.
Learn Modern Redux Livestream
Redux maintainer Mark Erikson appeared on the ""Learn with Jason"" show to explain how we recommend using Redux today. The show includes a live-coded example app that shows how to use Redux Toolkit and React-Redux hooks with TypeScript, as well as the new RTK Query data fetching APIs:
RTK Query Basics: Query Endpoints, Data Flow and TypeScript
A video course on RTK Query basics by Lenz Weber-Tronic, the creator of RTK Query.
You can watch this RTK Query video course for free at Egghead or take a look at the first lesson right here:
Redux Toolkit Complete Tutorial with Dave Gray
This 4-hour tutorial video teaches how to use Redux Toolkit by showing how to build the same example app that's covered in the ""Redux Essentials"" tutorial, and walks through how each piece of the app works.
Egghead Courses with Jamund Ferguson
Jamund Ferguson has created several excellent ""modern Redux"" courses on Egghead.
Modern Redux with Redux Toolkit (RTK) and TypeScript
Egghead course: Modern Redux with Redux Toolkit and TypeScript
This course takes a basic shopping cart application built with React and fully power it with Redux and RTK using TypeScript. It covers how Redux Toolkit simplifies the process of setting up your Redux application, including building slices, reducers, selectors and thunks, and all typed with TypeScript.
Modernizing a Legacy Redux Application with React Hooks
Egghead course: Modernizing a Legacy Redux Application with React Hooks
A course that covers how to modernize existing React+Redux applications from older-style patterns like React class components and the React-Redux connect API, to modern patterns with React function components and the React-Redux useSelector/useDispatch hooks.
Confidently Testing Redux Applications with Jest & TypeScript
Egghead course: Confidently Testing Redux Applications with Jest & TypeScript
Best practices for building & testing Redux applications have changed dramatically over time. This course aims to be a comprehensive and up-to-date resource for those seeking to confidently test their Redux apps.
Edit this page
Last updated on Nov 16, 2023""""""",467,2320,redux
https://redux.js.org/usage/,"""""""Using ReduxUsage Guides Index
Usage Guides
The Usage Guides section provides practical guidance on how to correctly use Redux in real-world applications, including project setup and architecture, patterns, practices, and techniques.
PREREQUISITES
The pages in this category assume you understand the core Redux terms and concepts explained in the ""Redux Fundamentals"" tutorial, including actions, reducers, stores, immutability, React-Redux, and async logic.
Setup and Organization
This section covers information on how to set up and organize Redux-based projects.
Configuring Your Store
Code Splitting
Server Rendering
Isolating Redux Sub-Apps
Code Quality
This section provides information on tools and techniques used to improve the quality of your Redux code.
Usage with TypeScript
Writing Tests
Troubleshooting
Redux Logic and Patterns
This section provides information about typical Redux patterns and approaches for writing different kinds of Redux logic.
Structuring Reducers
Reducing Boilerplate
Deriving Data with Selectors
Implementing Undo History
Edit this page
Last updated on Jun 30, 2022""""""",220,1104,redux
https://redux.js.org/usage/configuring-your-store,"""""""Using ReduxSetup and OrganizationConfiguring Your Store
Configuring Your Store
In the ""Redux Fundamentals"" tutorial, we introduced the fundamental Redux concepts by building an example Todo list app. As part of that, we talked about how to create and configure a Redux store.
We will now explore how to customise the store to add extra functionality. We'll start with the source code from ""Redux Fundamentals"" part 5: UI and React. You can view the source from this stage of the tutorial in the example app repository on Github, or in your browser via CodeSandbox.
Creating the store
First, let's look at the original index.js file in which we created our store:
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import rootReducer from './reducers'
import App from './components/App'

const store = createStore(rootReducer)

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
In this code, we pass our reducers to the Redux createStore function, which returns a store object. We then pass this object to the react-redux Provider component, which is rendered at the top of our component tree.
This ensures that any time we connect to Redux in our app via react-redux connect, the store is available to our components.
Extending Redux functionality
Most apps extend the functionality of their Redux store by adding middleware or store enhancers (note: middleware is common, enhancers are less common). Middleware adds extra functionality to the Redux dispatch function; enhancers add extra functionality to the Redux store.
We will add two middlewares and one enhancer:
The redux-thunk middleware, which allows simple asynchronous use of dispatch.
A middleware which logs dispatched actions and the resulting new state.
An enhancer which logs the time taken for the reducers to process each action.
Install redux-thunk
npm install redux-thunk
middleware/logger.js
const logger = store => next => action => {
  console.group(action.type)
  console.info('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  console.groupEnd()
  return result
}

export default logger
enhancers/monitorReducer.js
const round = number => Math.round(number * 100) / 100

const monitorReducerEnhancer =
  createStore => (reducer, initialState, enhancer) => {
    const monitoredReducer = (state, action) => {
      const start = performance.now()
      const newState = reducer(state, action)
      const end = performance.now()
      const diff = round(end - start)

      console.log('reducer process time:', diff)

      return newState
    }

    return createStore(monitoredReducer, initialState, enhancer)
  }

export default monitorReducerEnhancer
Let's add these to our existing index.js.
First, we need to import redux-thunk plus our loggerMiddleware and monitorReducerEnhancer, plus two extra functions provided by Redux: applyMiddleware and compose.
We then use applyMiddleware to create a store enhancer which will apply our loggerMiddleware and the thunkMiddleware to the store's dispatch function.
Next, we use compose to compose our new middlewareEnhancer and our monitorReducerEnhancer into one function.
This is needed because you can only pass one enhancer into createStore. To use multiple enhancers, you must first compose them into a single larger enhancer, as shown in this example.
Finally, we pass this new composedEnhancers function into createStore as its third argument. Note: the second argument, which we will ignore, lets you preloaded state into the store.
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { applyMiddleware, createStore, compose } from 'redux'
import thunkMiddleware from 'redux-thunk'
import rootReducer from './reducers'
import loggerMiddleware from './middleware/logger'
import monitorReducerEnhancer from './enhancers/monitorReducer'
import App from './components/App'

const middlewareEnhancer = applyMiddleware(loggerMiddleware, thunkMiddleware)
const composedEnhancers = compose(middlewareEnhancer, monitorReducerEnhancer)

const store = createStore(rootReducer, undefined, composedEnhancers)

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
Problems with this approach
While this code works, for a typical app it is not ideal.
Most apps use more than one middleware, and each middleware often requires some initial setup. The extra noise added to the index.js can quickly make it hard to maintain, because the logic is not cleanly organised.
The solution: configureStore
The solution to this problem is to create a new configureStore function which encapsulates our store creation logic, which can then be located in its own file to ease extensibility.
The end goal is for our index.js to look like this:
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import App from './components/App'
import configureStore from './configureStore'

const store = configureStore()

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
All the logic related to configuring the store - including importing reducers, middleware, and enhancers - is handled in a dedicated file.
To achieve this, configureStore function looks like this:
import { applyMiddleware, compose, createStore } from 'redux'
import thunkMiddleware from 'redux-thunk'

import monitorReducersEnhancer from './enhancers/monitorReducers'
import loggerMiddleware from './middleware/logger'
import rootReducer from './reducers'

export default function configureStore(preloadedState) {
  const middlewares = [loggerMiddleware, thunkMiddleware]
  const middlewareEnhancer = applyMiddleware(...middlewares)

  const enhancers = [middlewareEnhancer, monitorReducersEnhancer]
  const composedEnhancers = compose(...enhancers)

  const store = createStore(rootReducer, preloadedState, composedEnhancers)

  return store
}
This function follows the same steps outlined above, with some of the logic split out to prepare for extension, which will make it easier to add more in future:
Both middlewares and enhancers are defined as arrays, separate from the functions which consume them.
This allows us to easily add more middleware or enhancers based on different conditions.
For example, it is common to add some middleware only when in development mode, which is easily achieved by pushing to the middlewares array inside an if statement:
if (process.env.NODE_ENV === 'development') {
  middlewares.push(secretMiddleware)
}
A preloadedState variable is passed through to createStore in case we want to add this later.
This also makes our createStore function easier to reason about - each step is clearly separated, which makes it more obvious what exactly is happening.
Integrating the devtools extension
Another common feature which you may wish to add to your app is the redux-devtools-extension integration.
The extension is a suite of tools which give you absolute control over your Redux store - it allows you to inspect and replay actions, explore your state at different times, dispatch actions directly to the store, and much more. Click here to read more about the available features.
There are several ways to integrate the extension, but we will use the most convenient option.
First, we install the package via npm:
npm install --save-dev redux-devtools-extension
Next, we remove the compose function which we imported from redux, and replace it with a new composeWithDevTools function imported from redux-devtools-extension.
The final code looks like this:
import { applyMiddleware, createStore } from 'redux'
import thunkMiddleware from 'redux-thunk'
import { composeWithDevTools } from 'redux-devtools-extension'

import monitorReducersEnhancer from './enhancers/monitorReducers'
import loggerMiddleware from './middleware/logger'
import rootReducer from './reducers'

export default function configureStore(preloadedState) {
  const middlewares = [loggerMiddleware, thunkMiddleware]
  const middlewareEnhancer = applyMiddleware(...middlewares)

  const enhancers = [middlewareEnhancer, monitorReducersEnhancer]
  const composedEnhancers = composeWithDevTools(...enhancers)

  const store = createStore(rootReducer, preloadedState, composedEnhancers)

  return store
}
And that's it!
If we now visit our app via a browser with the devtools extension installed, we can explore and debug using a powerful new tool.
Hot reloading
Another powerful tool which can make the development process a lot more intuitive is hot reloading, which means replacing pieces of code without restarting your whole app.
For example, consider what happens when you run your app, interact with it for a while, and then decide to make changes to one of your reducers. Normally, when you make those changes your app will restart, reverting your Redux state to its initial value.
With hot module reloading enabled, only the reducer you changed would be reloaded, allowing you to change your code without resetting the state every time. This makes for a much faster development process.
We'll add hot reloading both to our Redux reducers and to our React components.
First, let's add it to our configureStore function:
import { applyMiddleware, compose, createStore } from 'redux'
import thunkMiddleware from 'redux-thunk'

import monitorReducersEnhancer from './enhancers/monitorReducers'
import loggerMiddleware from './middleware/logger'
import rootReducer from './reducers'

export default function configureStore(preloadedState) {
  const middlewares = [loggerMiddleware, thunkMiddleware]
  const middlewareEnhancer = applyMiddleware(...middlewares)

  const enhancers = [middlewareEnhancer, monitorReducersEnhancer]
  const composedEnhancers = compose(...enhancers)

  const store = createStore(rootReducer, preloadedState, composedEnhancers)

  if (process.env.NODE_ENV !== 'production' && module.hot) {
    module.hot.accept('./reducers', () => store.replaceReducer(rootReducer))
  }

  return store
}
The new code is wrapped in an if statement, so it only runs when our app is not in production mode, and only if the module.hot feature is available.
Bundlers like Webpack and Parcel support a module.hot.accept method to specify which module should be hot reloaded, and what should happen when the module changes. In this case, we're watching the ./reducers module, and passing the updated rootReducer to the store.replaceReducer method when it changes.
We'll also use the same pattern in our index.js to hot reload any changes to our React components:
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import App from './components/App'
import configureStore from './configureStore'

const store = configureStore()

const renderApp = () =>
  render(
    <Provider store={store}>
      <App />
    </Provider>,
    document.getElementById('root')
  )

if (process.env.NODE_ENV !== 'production' && module.hot) {
  module.hot.accept('./components/App', renderApp)
}

renderApp()
The only extra change here is that we have encapsulated our app's rendering into a new renderApp function, which we now call to re-render the app.
Simplifying Setup with Redux Toolkit
The Redux core library is deliberately unopinionated. It lets you decide how you want to handle everything, like store setup, what your state contains, and how you want to build your reducers.
This is good in some cases, because it gives you flexibility, but that flexibility isn't always needed. Sometimes we just want the simplest possible way to get started, with some good default behavior out of the box.
The Redux Toolkit package is designed to help simplify several common Redux use cases, including store setup. Let's see how it can help improve the store setup process.
Redux Toolkit includes a prebuilt configureStore function like the one shown in the earlier examples.
The fastest way to use is it is to just pass the root reducer function:
import { configureStore } from '@reduxjs/toolkit'
import rootReducer from './reducers'

const store = configureStore({
  reducer: rootReducer
})

export default store
Note that it accepts an object with named parameters, to make it clearer what you're passing in.
By default, configureStore from Redux Toolkit will:
Call applyMiddleware with a default list of middleware, including redux-thunk, and some development-only middleware that catch common mistakes like mutating state
Call composeWithDevTools to set up the Redux DevTools Extension
Here's what the hot reloading example might look like using Redux Toolkit:
import { configureStore } from '@reduxjs/toolkit'

import monitorReducersEnhancer from './enhancers/monitorReducers'
import loggerMiddleware from './middleware/logger'
import rootReducer from './reducers'

export default function configureAppStore(preloadedState) {
  const store = configureStore({
    reducer: rootReducer,
    middleware: getDefaultMiddleware =>
      getDefaultMiddleware().prepend(loggerMiddleware),
    preloadedState,
    enhancers: [monitorReducersEnhancer]
  })

  if (process.env.NODE_ENV !== 'production' && module.hot) {
    module.hot.accept('./reducers', () => store.replaceReducer(rootReducer))
  }

  return store
}
That definitely simplifies some of the setup process.
Next Steps
Now that you know how to encapsulate your store configuration to make it easier to maintain, you can look at the Redux Toolkit configureStore API, or take a closer look at some of the extensions available in the Redux ecosystem.
Edit this page
Last updated on Nov 16, 2023""""""",2784,13724,redux
https://redux.js.org/usage/nextjs,"""""""Using ReduxSetup and OrganizationSetup with Next.js
Redux Toolkit Setup with Next.js
WHAT YOU'LL LEARN
How to set up and use Redux Toolkit with the Next.js framework
PREREQUISITES
Familiarity with ES2015 syntax and features
Knowledge of React terminology: JSX, State, Function Components, Props, and Hooks
Understanding of Redux terms and concepts
Working through the Quick Start tutorial and TypeScript Quick Start tutorial is recommended, and ideally the full Redux Essentials tutorial as well
Introduction
Next.js is a popular server side rendering framework for React that presents some unique challenges for using Redux properly. These challenges include:
Per-request safe Redux store creation: A Next.js server can handle multiple requests simultaneously. This means that the Redux store should be created per request and that the store should not be shared across requests.
SSR-friendly store hydration: Next.js applications are rendered twice, first on the server and again on the client. Failure to render the same page contents on both the client and the server will result in a ""hydration error"". So the Redux store will have to be initialized on the server and then re-initialized on the client with the same data in order to avoid hydration issues.
SPA routing support: Next.js supports a hybrid model for client side routing. A customer's first page load will get an SSR result from the server. Subsequent page navigation will be handled by the client. This means that with a singleton store defined in the layout, route-specific data will need to be selectively reset on route navigation, while non-route-specific data will need to be retained in the store.
Server caching friendly: Recent versions of Next.js (specifically applications using the App Router architecture) support aggressive server caching. The ideal store architecture should be compatible with this caching.
There are two architectures for a Next.js application: the Pages Router and the App Router.
The Pages Router is the original architecture for Next.js. If you're using the Pages Router, Redux setup is primarily handled by using the next-redux-wrapper library, which integrates a Redux store with the Pages Router data fetching methods like getServerSideProps.
This guide will focus on the App Router architecture, as it is the new default architecture option for Next.js.
How to Read This Guide
This page assumes that you already have an existing Next.js application based on the App Router architecture.
If you want to follow along, you can create a new empty Next project with npx create-next-app my-app - the default prompts will set up a new project with the App Router enabled. Then, add @reduxjs/toolkit and react-redux as dependencies.
You can also create a new Next+Redux project with npx create-next-app --example with-redux my-app, which includes the initial setup pieces described in this page.
The App Router Architecture and Redux
The primary new feature of the Next.js App Router is the addition of support for React Server Components (RSCs). RSCs are a special type of React component that only renders on the server, as opposed to ""client"" components that render on both the client and the server. RSCs can be defined as async functions and return promises during rendering as they make async requests for data to render.
RSCs ability to block for data requests means that with the App Router you no longer have getServerSideProps to fetch data for rendering. Any component in the tree can make asynchronous requests for data. While this is very convenient it also means thats if you define global variables (like the Redux store) they will be shared across requests. This is a problem because the Redux store could be contaminated with data from other requests.
Based on the architecture of the App Router we have these general recommendations for appropriate use of Redux:
No global stores - Because the Redux store is shared across requests, it should not be defined as a global variable. Instead, the store should be created per request.
RSCs should not read or write the Redux store - RSCs cannot use hooks or context. They aren't meant to be stateful. Having an RSC read or write values from a global store violates the architecture of the Next.js App Router.
The store should only contain mutable data - We recommend that you use your Redux sparingly for data intended to be global and mutable.
These recommendations are specific to applications written with the Next.js App Router. Single Page Applications (SPAs) don't execute on the server and therefore can define stores as global variables. SPAs don't need to worry about RSCs since they don't exist in SPAs. And singleton stores can store whatever data you want.
Folder Structure
Next apps can be created to have the /app folder either at the root, or nested under /src/app. Your Redux logic should go in a separate folder, alongside the /app folder. It's common to put the Redux logic in a folder named /lib, but not required.
The file and folder structure inside of that /lib folder is up to you, but we generally recommend a ""feature folder""-based structure for the Redux logic.
A typical example might look like:
/app
  layout.tsx
  page.tsx
  StoreProvider.tsx
/lib
  store.ts
  /features
    /todos
      todosSlice.ts
We'll use that approach for this guide.
Initial Setup
Similar to the the RTK TypeScript Tutorial, we need to create a file for the Redux store, as well as the inferred RootState and AppDispatch types.
However, Next's multi-page architecture requires some differences from that single-page app setup.
Creating a Redux Store per Request
The first change is to move from defining store as a global or module-singleton variable, to defining a makeStore function that returns a new store for each request:
TypeScript
JavaScript
lib/store.ts
import { configureStore } from '@reduxjs/toolkit'

export const makeStore = () => {
  return configureStore({
    reducer: {}
  })
}

// Infer the type of makeStore
export type AppStore = ReturnType<typeof makeStore>
// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<AppStore['getState']>
export type AppDispatch = AppStore['dispatch']







Now we have a function, makeStore, that we can use to create a store instance per-request while retaining the strong type safety (if you choose to use TypeScript) that Redux Toolkit provides.
We don't have a store variable exported, but we can infer the RootState and AppDispatch types from the return type of makeStore.
You'll also want to create and export pre-typed versions of the React-Redux hooks as well, to simplify usage later:
TypeScript
JavaScript
lib/hooks.ts
import { useDispatch, useSelector, useStore } from 'react-redux'
import type { AppDispatch, AppStore, RootState } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()
export const useAppStore = useStore.withTypes<AppStore>()






Providing the Store
To use this new makeStore function we need to create a new ""client"" component that will create the store and share it using the React-Redux Provider component.
TypeScript
JavaScript
app/StoreProvider.tsx
'use client'
import { useRef } from 'react'
import { Provider } from 'react-redux'
import { makeStore, AppStore } from '../lib/store'

export default function StoreProvider({
  children
}: {
  children: React.ReactNode
}) {
  const storeRef = useRef<AppStore>()
  if (!storeRef.current) {
    // Create the store instance the first time this renders
    storeRef.current = makeStore()
  }

  return <Provider store={storeRef.current}>{children}</Provider>
}














In this example code we are ensuring that this client component is re-render safe by checking the value of the reference to ensure that the store is only created once. This component will only be rendered once per request on the server, but might be re-rendered multiple times on the client if there are stateful client components located above this component in the tree, or if this component also contains other mutable state that causes a re-render.
WHY CLIENT COMPONENTS?
Any component that interacts with the Redux store (creating it, providing it, reading from it, or writing to it) needs to be a client component. This is because accessing the store requires React context, and context is only available in client components.
The next step is to include the StoreProvider anywhere in the tree above where the store is used. You can locate the store in the layout component if all the routes using that layout need the store. Or if the store is only used in a specific route you can create and provide the store in that route handler. In all client components further down the tree, you can use the store exactly as you would normally using the hooks provided by react-redux.
Loading Initial Data
If you need to initialize the store with data from the parent component, then define that data as a prop on the client StoreProvider component and use a Redux action on the slice to set the data in the store as shown below.
TypeScript
JavaScript
app/StoreProvider.tsx
'use client'
import { useRef } from 'react'
import { Provider } from 'react-redux'
import { makeStore, AppStore } from '../lib/store'
import { initializeCount } from '../lib/features/counter/counterSlice'

export default function StoreProvider({
  count,
  children
}: {
  count: number
  children: React.ReactNode
}) {
  const storeRef = useRef<AppStore | null>(null)
  if (!storeRef.current) {
    storeRef.current = makeStore()
    storeRef.current.dispatch(initializeCount(count))
  }

  return <Provider store={storeRef.current}>{children}</Provider>
}















Additional Configuration
Per-route state
If you use Next.js's support for client side SPA-style navigation by using next/navigation, then when customers navigate from page to page only the route component will be re-rendered. This means that if you have a Redux store created and provided in the layout component it will be preserved across route changes. This is not a problem if you are only using the store for global, mutable data. However, if you are using the store for per-route data then you will need to reset the route-specific data in the store when the route changes.
Shown below is a ProductName example component that uses the Redux store to manage the mutable name of a product. The ProductName component part of a product detail route. In order to ensure that we have the correct name in the store we need to set the value in the store any time the ProductName component is initially rendered, which happens on any route change to the product detail route.
TypeScript
JavaScript
app/ProductName.tsx
'use client'
import { useRef } from 'react'
import { useAppSelector, useAppDispatch, useAppStore } from '../lib/hooks'
import {
  initializeProduct,
  setProductName,
  Product
} from '../lib/features/product/productSlice'

export default function ProductName({ product }: { product: Product }) {
  // Initialize the store with the product information
  const store = useAppStore()
  const initialized = useRef(false)
  if (!initialized.current) {
    store.dispatch(initializeProduct(product))
    initialized.current = true
  }
  const name = useAppSelector(state => state.product.name)
  const dispatch = useAppDispatch()

  return (
    <input
      value={name}
      onChange={e => dispatch(setProductName(e.target.value))}
    />
  )
}


























Here we are using the same initialization pattern as before, of dispatching actions to the store, to set the route-specific data. The initialized ref is used to ensure that the store is only initialized once per route change.
It is worth noting that initializing the store with a useEffect would not work because useEffect only runs on the client. This would result in hydration errors or flicker because the result from a server side render would not match the result from the client side render.
Caching
The App Router has four separate caches including fetch request and route caches. The most likely cache to cause issues is the route cache. If you have an application that accepts login you may have routes (e.g. the home route, /) that render different data based on the user you will need to disable the route cache by using the dynamic export from the route handler:
TypeScript
JavaScript
export const dynamic = 'force-dynamic'

After a mutation you should also invalidate the cache by calling revalidatePath or revalidateTag as appropriate.
RTK Query
We recommend using RTK Query for data fetching on the client only. Data fetching on the server should use fetch requests from async RSCs.
You can learn more about Redux Toolkit Query in the Redux Toolkit Query tutorial.
NOTE
In the future, RTK Query may be able to receive data fetched on the server via React Server Components, but that is a future capability that will require changes to both React and RTK Query.
Checking Your Work
There are three key areas that you should check to ensure that you have set up Redux Toolkit correctly:
Server Side Rendering - Check the HTML output of the server to ensure that the data in the Redux store is present in the server side rendered output.
Route Change - Navigate between pages on the same route as well as between different routes to ensure that route-specific data is initialized properly.
Mutations - Check that the store is compatible with the Next.js App Router caches by performing a mutation and then navigating away from the route and back to the original route to ensure that the data is updated.
Overall Recommendations
The App Router presents a dramatically different architecture for React applications from either the Pages Router or a SPA application. We recommend rethinking your approach to state management in the light of this new architecture. In SPA applications it's not unusual to have a large store that contains all the data, both mutable and immutable, required to drive the application. For App Router applications we recommend that you should:
only use Redux for globally shared, mutable data
use a combination of Next.js state (search params, route parameters, form state, etc.), React context and React hooks for all other state management.
What You've Learned
That was a brief overview of how to set up and use Redux Toolkit with the App Router:
SUMMARY
Create a Redux store per request by using configureStore wrapped in a makeStore function
Provide the Redux store to the React application components using a ""client"" component
Only interact with the Redux store in client components because only client components have access to React context
Use the store as you normally would using the hooks provided in React-Redux
You need to account for the case where you have per-route state in a global store located in the layout
What's Next?
We recommend going through the ""Redux Essentials"" and ""Redux Fundamentals"" tutorials in the Redux core docs, which will give you a complete understanding of how Redux works, what Redux Toolkit does, and how to use it correctly.
Edit this page
Last updated on May 3, 2024""""""",3123,15275,redux
https://redux.js.org/usage/code-splitting,"""""""Using ReduxSetup and OrganizationCode Splitting
Code Splitting
In large web applications, it is often desirable to split up the app code into multiple JS bundles that can be loaded on-demand. This strategy, called 'code splitting', helps to increase performance of your application by reducing the size of the initial JS payload that must be fetched.
To code split with Redux, we want to be able to dynamically add reducers to the store. However, Redux really only has a single root reducer function. This root reducer is normally generated by calling combineReducers() or a similar function when the application is initialized. In order to dynamically add more reducers, we need to call that function again to re-generate the root reducer. Below, we discuss some approaches to solving this problem and reference two libraries that provide this functionality.
Basic Principle
Using replaceReducer
The Redux store exposes a replaceReducer function, which replaces the current active root reducer function with a new root reducer function. Calling it will swap the internal reducer function reference, and dispatch an action to help any newly-added slice reducers initialize themselves:
const newRootReducer = combineReducers({
  existingSlice: existingSliceReducer,
  newSlice: newSliceReducer
})

store.replaceReducer(newRootReducer)
Reducer Injection Approaches
This section will cover some handwritten recipes used to inject reducers.
Defining an injectReducer function
We will likely want to call store.replaceReducer() from anywhere in the application. Because of that, it's helpful to define a reusable injectReducer() function that keeps references to all of the existing slice reducers, and attach that to the store instance.
import { createStore } from 'redux'

// Define the Reducers that will always be present in the application
const staticReducers = {
  users: usersReducer,
  posts: postsReducer
}

// Configure the store
export default function configureStore(initialState) {
  const store = createStore(createReducer(), initialState)

  // Add a dictionary to keep track of the registered async reducers
  store.asyncReducers = {}

  // Create an inject reducer function
  // This function adds the async reducer, and creates a new combined reducer
  store.injectReducer = (key, asyncReducer) => {
    store.asyncReducers[key] = asyncReducer
    store.replaceReducer(createReducer(store.asyncReducers))
  }

  // Return the modified store
  return store
}

function createReducer(asyncReducers) {
  return combineReducers({
    ...staticReducers,
    ...asyncReducers
  })
}
Now, one just needs to call store.injectReducer to add a new reducer to the store.
Using a 'Reducer Manager'
Another approach is to create a 'Reducer Manager' object, which keeps track of all the registered reducers and exposes a reduce() function. Consider the following example:
export function createReducerManager(initialReducers) {
  // Create an object which maps keys to reducers
  const reducers = { ...initialReducers }

  // Create the initial combinedReducer
  let combinedReducer = combineReducers(reducers)

  // An array which is used to delete state keys when reducers are removed
  let keysToRemove = []

  return {
    getReducerMap: () => reducers,

    // The root reducer function exposed by this object
    // This will be passed to the store
    reduce: (state, action) => {
      // If any reducers have been removed, clean up their state first
      if (keysToRemove.length > 0) {
        state = { ...state }
        for (let key of keysToRemove) {
          delete state[key]
        }
        keysToRemove = []
      }

      // Delegate to the combined reducer
      return combinedReducer(state, action)
    },

    // Adds a new reducer with the specified key
    add: (key, reducer) => {
      if (!key || reducers[key]) {
        return
      }

      // Add the reducer to the reducer mapping
      reducers[key] = reducer

      // Generate a new combined reducer
      combinedReducer = combineReducers(reducers)
    },

    // Removes a reducer with the specified key
    remove: key => {
      if (!key || !reducers[key]) {
        return
      }

      // Remove it from the reducer mapping
      delete reducers[key]

      // Add the key to the list of keys to clean up
      keysToRemove.push(key)

      // Generate a new combined reducer
      combinedReducer = combineReducers(reducers)
    }
  }
}

const staticReducers = {
  users: usersReducer,
  posts: postsReducer
}

export function configureStore(initialState) {
  const reducerManager = createReducerManager(staticReducers)

  // Create a store with the root reducer function being the one exposed by the manager.
  const store = createStore(reducerManager.reduce, initialState)

  // Optional: Put the reducer manager on the store so it is easily accessible
  store.reducerManager = reducerManager
}
To add a new reducer, one can now call store.reducerManager.add(""asyncState"", asyncReducer).
To remove a reducer, one can now call store.reducerManager.remove(""asyncState"")
Redux Toolkit
Redux Toolkit 2.0 includes some utilities designed to simplify code splitting with reducers and middleware, including solid Typescript support (a common challenge with lazy loaded reducers and middleware).
combineSlices
The combineSlices utility is designed to allow for easy reducer injection. It also supercedes combineReducers, in that it can be used to combine multiple slices and reducers into one root reducer.
At setup it accepts a set of slices and reducer maps, and returns a reducer instance with attached methods for injection.
NOTE
A ""slice"" for combineSlices is typically created with createSlice, but can be any ""slice-like"" object with reducerPath and reducer properties (meaning RTK Query API instances are also compatible).
const withUserReducer = rootReducer.inject({
  reducerPath: 'user',
  reducer: userReducer
})

const withApiReducer = rootReducer.inject(fooApi)
For simplicity, this { reducerPath, reducer } shape will be described in these docs as a ""slice"".
Slices will be mounted at their reducerPath, and items from reducer map objects will be mounted under their respective key.
const rootReducer = combineSlices(counterSlice, baseApi, {
  user: userSlice.reducer,
  auth: authSlice.reducer
})
// is like
const rootReducer = combineReducers({
  [counterSlice.reducerPath]: counterSlice.reducer,
  [baseApi.reducerPath]: baseApi.reducer,
  user: userSlice.reducer,
  auth: authSlice.reducer
})
CAUTION
Be careful to avoid naming collision - later keys will overwrite earlier ones, but Typescript won't be able to account for this.
Slice injection
To inject a slice, you should call rootReducer.inject(slice) on the reducer instance returned from combineSlices. This will inject the slice under its reducerPath into the set of reducers, and return an instance of the combined reducer typed to know that the slice has been injected.
Alternatively, you can call slice.injectInto(rootReducer), which returns an instance of the slice which is aware it's been injected. You may even want to do both, as each call returns something useful, and combineSlices allows injection of the same reducer instance at the same reducerPath without issue.
const withCounterSlice = rootReducer.inject(counterSlice)
const injectedCounterSlice = counterSlice.injectInto(rootReducer)
One key difference between typical reducer injection and combineSlice's ""meta-reducer"" approach is that replaceReducer is never called for combineSlice. The reducer instance passed to the store doesn't change.
A consequence of this is that no action is dispatched when a slice is injected, and therefore the injected slice's state doesn't show in state immediately. The state will only show in the store's state when an action is dispatched.
However, to avoid selectors having to account for possibly undefined state, combineSlices includes some useful selector utilities.
Declaring lazy loaded slices
In order for lazy loaded slices to show up in the inferred state type, a withLazyLoadedSlices helper is provided. This allows you to declare slices you intend to later inject, so they can show up as optional in the state type.
To completely avoid importing the lazy slice into the combined reducer's file, module augmentation can be used.
// file: reducer.ts
import { combineSlices } from '@reduxjs/toolkit'
import { staticSlice } from './staticSlice'

export interface LazyLoadedSlices {}

export const rootReducer =
  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()

// file: counterSlice.ts
import type { WithSlice } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'
import { rootReducer } from './reducer'

interface CounterState {
  value: number
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: state => void state.value++
  },
  selectors: {
    selectValue: state => state.value
  }
})

declare module './reducer' {
  // WithSlice utility assumes reducer is under slice.reducerPath
  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}

  // if it's not, just use a normal key
  export interface LazyLoadedSlices {
    aCounter: CounterState
  }
}

const injectedCounterSlice = counterSlice.injectInto(rootReducer)
const injectedACounterSlice = counterSlice.injectInto(rootReducer, {
  reducerPath: 'aCounter'
})
Selector utilities
As well as inject, the combined reducer instance has a .selector method which can be used to wrap selectors. It wraps the state object in a Proxy, and provides an initial state for any reducers which have been injected but haven't appeared in state yet.
The result of calling inject is typed to know that the injected slice will always be defined when the selector is called.
const selectCounterValue = (state: RootState) => state.counter?.value // number | undefined

const withCounterSlice = rootReducer.inject(counterSlice)
const selectCounterValue = withCounterSlice.selector(
  state => state.counter.value // number - initial state used if not in store
)
An ""injected"" instance of a slice will do the same thing for slice selectors - initial state will be provided if not present in the state passed.
const injectedCounterSlice = counterSlice.injectInto(rootReducer)

console.log(counterSlice.selectors.selectValue({})) // runtime error
console.log(injectedCounterSlice.selectors.selectValue({})) // 0
Typical usage
combineSlices is designed so that the slice is injected as soon as it's needed (i.e. a selector or action is imported from a component that's been loaded in).
This means that the typical usage will look something along the lines of the below.
// file: reducer.ts
import { combineSlices } from '@reduxjs/toolkit'
import { staticSlice } from './staticSlice'

export interface LazyLoadedSlices {}

export const rootReducer =
  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()

// file: store.ts
import { configureStore } from '@reduxjs/toolkit'
import { rootReducer } from './reducer'

export const store = configureStore({ reducer: rootReducer })

// file: counterSlice.ts
import type { WithSlice } from '@reduxjs/toolkit'
import { createSlice } from '@reduxjs/toolkit'
import { rootReducer } from './reducer'

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: state => void state.value++
  },
  selectors: {
    selectValue: state => state.value
  }
})

export const { increment } = counterSlice.actions

declare module './reducer' {
  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}
}

const injectedCounterSlice = counterSlice.injectInto(rootReducer)

export const { selectValue } = injectedCounterSlice.selectors

// file: Counter.tsx
// by importing from counterSlice we guarantee
// the injection happens before this component is defined
import { increment, selectValue } from './counterSlice'
import { useAppDispatch, useAppSelector } from './hooks'

export default function Counter() {
  const dispatch = usAppDispatch()
  const value = useAppSelector(selectValue)
  return (
    <>
      <p>{value}</p>
      <button onClick={() => dispatch(increment())}>Increment</button>
    </>
  )
}

// file: App.tsx
import { Provider } from 'react-redux'
import { store } from './store'

// lazily importing the component means that the code
// doesn't actually get pulled in and executed until the component is rendered.
// this means that the inject call only happens once Counter renders
const Counter = React.lazy(() => import('./Counter'))

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  )
}
createDynamicMiddleware
The createDynamicMiddleware utility creates a ""meta-middleware"" which allows for injection of middleware after store initialisation.
import { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'
import logger from 'redux-logger'
import reducer from './reducer'

const dynamicMiddleware = createDynamicMiddleware()

const store = configureStore({
  reducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().concat(dynamicMiddleware.middleware)
})

dynamicMiddleware.addMiddleware(logger)
addMiddleware
addMiddleware appends the middleware instance to the chain of middlewares handled by the dynamic middleware instance. Middleware is applied in injection order, and stored by function reference (so the same middleware is only applied once regardless of how many times it's injected).
NOTE
It's important to remember that all middlewares injected will be contained within the original dynamic middleware instance.
import { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'
import logger from 'redux-logger'
import reducer from './reducer'

const dynamicMiddleware = createDynamicMiddleware()

const store = configureStore({
  reducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().concat(dynamicMiddleware.middleware)
})

dynamicMiddleware.addMiddleware(logger)

// middleware chain is now [thunk, logger]
If it's desired to have more control over the order, multiple instances can be used.
import { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'
import logger from 'redux-logger'
import reducer from './reducer'

const beforeMiddleware = createDynamicMiddleware()
const afterMiddleware = createDynamicMiddleware()

const store = configureStore({
  reducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware()
      .prepend(beforeMiddleware.middleware)
      .concat(afterMiddleware.middleware)
})

beforeMiddleware.addMiddleware(logger)
afterMiddleware.addMiddleware(logger)

// middleware chain is now [logger, thunk, logger]
withMiddleware
withMiddleware is an action creator which, when dispatched, causes the middleware to add any middlewares included and returns a pre-typed version of dispatch with any added extensions.
const listenerDispatch = store.dispatch(
  withMiddleware(listenerMiddleware.middleware)
)

const unsubscribe = listenerDispatch(addListener({ actionCreator, effect }))
//    ^? () => void
This is mainly useful in a non-React context. With React it's more useful to use the react integration.
React integration
When imported from the @reduxjs/toolkit/react entry point, the instance of dynamic middleware will have a couple of additional methods attached.
createDispatchWithMiddlewareHook
This method calls addMiddleware and returns a version of useDispatch typed to know about the injected middleware.
import { createDynamicMiddleware } from '@reduxjs/toolkit/react'

const dynamicMiddleware = createDynamicMiddleware()

const useListenerDispatch = dynamicMiddleware.createDispatchWithMiddlewareHook(
  listenerMiddleware.middleware
)

function Component() {
  const dispatch = useListenerDispatch()

  useEffect(() => {
    const unsubscribe = dispatch(addListener({ actionCreator, effect }))
    return unsubscribe
  }, [dispatch])
}
CAUTION
Middleware is injected when createDispatchWithMiddlewareHook is called, not when the useDispatch hook is called.
createDispatchWithMiddlewareHookFactory
This method take a React context instance and creates an instance of createDispatchWithMiddlewareHook which uses that context. (see Providing custom context)
import { createContext } from 'react'
import { createDynamicMiddleware } from '@reduxjs/toolkit/react'
import type { ReactReduxContextValue } from 'react-redux'

const context = createContext<ReactReduxContextValue | null>(null)

const dynamicMiddleware = createDynamicMiddleware()

const createDispatchWithMiddlewareHook =
  dynamicMiddleware.createDispatchWithMiddlewareHookFactory(context)

const useListenerDispatch = createDispatchWithMiddlewareHook(
  listenerMiddleware.middleware
)

function Component() {
  const dispatch = useListenerDispatch()

  useEffect(() => {
    const unsubscribe = dispatch(addListener({ actionCreator, effect }))
    return unsubscribe
  }, [dispatch])
}
Third-party Libraries and Frameworks
There are a few good external libraries out there that can help you add the above functionality automatically:
Redux Ecosystem Links: Reducers - Dynamic Reducer Injection
Edit this page
Last updated on Apr 20, 2024""""""",3518,17277,redux
https://redux.js.org/usage/server-rendering,"""""""Using ReduxSetup and OrganizationServer Rendering
Server Rendering
The most common use case for server-side rendering is to handle the initial render when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.
We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.
Redux on the Server
When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won't match the server markup, and the client would have to load the data again.
To send the data down to the client, we need to:
create a fresh, new Redux store instance on every request;
optionally dispatch some actions;
pull the state out of store;
and then pass the state along to the client.
On the client side, a new Redux store will be created and initialized with the state provided from the server. Redux's only job on the server side is to provide the initial state of our app.
Setting Up
In the following recipe, we are going to look at how to set up server-side rendering. We'll use the simplistic Counter app as a guide and show how the server can render state ahead of time based on the request.
Install Packages
For this example, we'll be using Express as a simple web server. We also need to install the React bindings for Redux, since they are not included in Redux by default.
npm install express react-redux
The Server Side
The following is the outline for what our server side is going to look like. We are going to set up an Express middleware using app.use to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.
Additionally, as we are using modern JS and JSX syntax, we will need to compile with Babel (see this example of a Node Server with Babel) and the React preset.
server.js
import path from 'path'
import Express from 'express'
import React from 'react'
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import counterApp from './reducers'
import App from './containers/App'

const app = Express()
const port = 3000

//Serve static files
app.use('/static', Express.static('static'))

// This is fired every time the server side receives a request
app.use(handleRender)

// We are going to fill these out in the sections to follow
function handleRender(req, res) {
  /* ... */
}
function renderFullPage(html, preloadedState) {
  /* ... */
}

app.listen(port)
Handling the Request
The first thing that we need to do on every request is to create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.
When rendering, we will wrap <App />, our root component, inside a <Provider> to make the store available to all components in the component tree, as we saw in ""Redux Fundamentals"" Part 5: UI and React.
The key step in server side rendering is to render the initial HTML of our component before we send it to the client side. To do this, we use ReactDOMServer.renderToString().
We then get the initial state from our Redux store using store.getState(). We will see how this is passed along in our renderFullPage function.
import { renderToString } from 'react-dom/server'

function handleRender(req, res) {
  // Create a new Redux store instance
  const store = createStore(counterApp)

  // Render the component to a string
  const html = renderToString(
    <Provider store={store}>
      <App />
    </Provider>
  )

  // Grab the initial state from our Redux store
  const preloadedState = store.getState()

  // Send the rendered page back to the client
  res.send(renderFullPage(html, preloadedState))
}
Inject Initial Component HTML and State
The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a <script> tag that will attach preloadedState to window.__PRELOADED_STATE__.
The preloadedState will then be available on the client side by accessing window.__PRELOADED_STATE__.
We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.
function renderFullPage(html, preloadedState) {
  return `
    <!doctype html>
    <html>
      <head>
        <title>Redux Universal Example</title>
      </head>
      <body>
        <div id=""root"">${html}</div>
        <script>
          // WARNING: See the following for security issues around embedding JSON in HTML:
          // https://redux.js.org/usage/server-rendering#security-considerations
          window.__PRELOADED_STATE__ = ${JSON.stringify(preloadedState).replace(
            /</g,
            '\\u003c'
          )}
        </script>
        <script src=""/static/bundle.js""></script>
      </body>
    </html>
    `
}
The Client Side
The client side is very straightforward. All we need to do is grab the initial state from window.__PRELOADED_STATE__, and pass it to our createStore() function as the initial state.
Let's take a look at our new client file:
client.js
import React from 'react'
import { hydrate } from 'react-dom'
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import App from './containers/App'
import counterApp from './reducers'

// Create Redux store with state injected by the server
const store = createStore(counterApp, window.__PRELOADED_STATE__)

// Allow the passed state to be garbage-collected
delete window.__PRELOADED_STATE__

hydrate(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into static/bundle.js.
When the page loads, the bundle file will be started up and ReactDOM.hydrate() will reuse the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.
And that's it! That is all we need to do to implement server side rendering.
But the result is pretty vanilla. It essentially renders a static view from dynamic code. What we need to do next is build an initial state dynamically to allow that rendered view to be dynamic.
INFO
We recommend passing window.__PRELOADED_STATE__ directly to createStore and avoid creating additional references to the preloaded state (e.g. const preloadedState = window.__PRELOADED_STATE__) so that it can be garbage collected.
Preparing the Initial State
Because the client side executes ongoing code, it can start with an empty initial state and obtain any necessary state on demand and over time. On the server side, rendering is synchronous and we only get one shot to render our view. We need to be able to compile our initial state during the request, which will have to react to input and obtain external state (such as that from an API or database).
Processing Request Parameters
The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.
The request contains information about the URL requested, including any query parameters, which will be useful when using something like React Router. It can also contain headers with inputs like cookies or authorization, or POST body data. Let's see how we can set the initial counter state based on a query parameter.
server.js
import qs from 'qs' // Add this at the top of the file
import { renderToString } from 'react-dom/server'

function handleRender(req, res) {
  // Read the counter from the request, if provided
  const params = qs.parse(req.query)
  const counter = parseInt(params.counter, 10) || 0

  // Compile an initial state
  let preloadedState = { counter }

  // Create a new Redux store instance
  const store = createStore(counterApp, preloadedState)

  // Render the component to a string
  const html = renderToString(
    <Provider store={store}>
      <App />
    </Provider>
  )

  // Grab the initial state from our Redux store
  const finalState = store.getState()

  // Send the rendered page back to the client
  res.send(renderFullPage(html, finalState))
}
The code reads from the Express Request object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit http://localhost:3000/?counter=100 in your browser, you'll see the counter starts at 100. In the rendered HTML, you'll see the counter output as 100 and the __PRELOADED_STATE__ variable has the counter set in it.
Async State Fetching
The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it's necessary to map any asynchronous fetches into a synchronous operation.
The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don't worry, it's not as hard as it may sound.
For our example, we'll imagine there is an external datastore that contains the counter's initial value (Counter As A Service, or CaaS). We'll make a mock call over to them and build our initial state from the result. We'll start by building out our API call:
api/counter.js
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min
}

export function fetchCounter(callback) {
  setTimeout(() => {
    callback(getRandomInt(1, 100))
  }, 500)
}
Again, this is just a mock API, so we use setTimeout to simulate a network request that takes 500 milliseconds to respond (this should be much faster with a real world API). We pass in a callback that returns a random number asynchronously. If you're using a Promise-based API client, then you would issue this callback in your then handler.
On the server side, we simply wrap our existing code in the fetchCounter and receive the result in the callback:
server.js
// Add this to our imports
import { fetchCounter } from './api/counter'
import { renderToString } from 'react-dom/server'

function handleRender(req, res) {
  // Query our mock API asynchronously
  fetchCounter(apiResult => {
    // Read the counter from the request, if provided
    const params = qs.parse(req.query)
    const counter = parseInt(params.counter, 10) || apiResult || 0

    // Compile an initial state
    let preloadedState = { counter }

    // Create a new Redux store instance
    const store = createStore(counterApp, preloadedState)

    // Render the component to a string
    const html = renderToString(
      <Provider store={store}>
        <App />
      </Provider>
    )

    // Grab the initial state from our Redux store
    const finalState = store.getState()

    // Send the rendered page back to the client
    res.send(renderFullPage(html, finalState))
  })
}
Because we call res.send() inside of the callback, the server will hold open the connection and won't send any data until that callback executes. You'll notice a 500ms delay is now added to each server request as a result of our new API call. A more advanced usage would handle errors in the API gracefully, such as a bad response or timeout.
Security Considerations
Because we have introduced more code that relies on user generated content (UGC) and input, we have increased our attack surface area for our application. It is important for any application that you ensure your input is properly sanitized to prevent things like cross-site scripting (XSS) attacks or code injections.
In our example, we take a rudimentary approach to security. When we obtain the parameters from the request, we use parseInt on the counter parameter to ensure this value is a number. If we did not do this, you could easily get dangerous data into the rendered HTML by providing a script tag in the request. That might look like this: ?counter=</script><script>doSomethingBad();</script>
For our simplistic example, coercing our input into a number is sufficiently secure. If you're handling more complex input, such as freeform text, then you should run that input through an appropriate sanitization function, such as xss-filters.
Furthermore, you can add additional layers of security by sanitizing your state output. JSON.stringify can be subject to script injections. To counter this, you can scrub the JSON string of HTML tags and other dangerous characters. This can be done with either a simple text replacement on the string, e.g. JSON.stringify(state).replace(/</g, '\\u003c'), or via more sophisticated libraries such as serialize-javascript.
Next Steps
You may want to read Redux Fundamentals Part 6: Async Logic and Data Fetching to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.
If you use something like React Router, you might also want to express your data fetching dependencies as static fetchData() methods on your route handler components. They may return thunks, so that your handleRender function can match the route to the route handler component classes, dispatch fetchData() result for each of them, and render only after the Promises have resolved. This way the specific API calls required for different routes are colocated with the route handler component definitions. You can also use the same technique on the client side to prevent the router from switching the page until its data has been loaded.
Edit this page
Last updated on Jun 24, 2024""""""",3099,14440,redux
https://redux.js.org/usage/isolating-redux-sub-apps,"""""""Using ReduxSetup and OrganizationIsolating Redux Sub-Apps
Isolating Redux Sub-Apps
Consider the case of a “big” app (contained in a <BigApp> component) that embeds smaller “sub-apps” (contained in <SubApp> components):
import React, { Component } from 'react'
import SubApp from './subapp'

class BigApp extends Component {
  render() {
    return (
      <div>
        <SubApp />
        <SubApp />
        <SubApp />
      </div>
    )
  }
}
These <SubApp>s will be completely independent. They won't share data or actions, and won't see or communicate with each other.
It's best not to mix this approach with standard Redux reducer composition. For typical web apps, stick with reducer composition. For “product hubs”, “dashboards”, or enterprise software that groups disparate tools into a unified package, give the sub-app approach a try.
The sub-app approach is also useful for large teams that are divided by product or feature verticals. These teams can ship sub-apps independently or in combination with an enclosing “app shell”.
Below is a sub-app's root connected component. As usual, it can render more components, connected or not, as children. Usually we'd render it in <Provider> and be done with it.
class App extends Component { ... }
export default connect(mapStateToProps)(App)
However, we don't have to call ReactDOM.render(<Provider><App /></Provider>) if we're interested in hiding the fact that the sub-app component is a Redux app.
Maybe we want to be able to run multiple instances of it in the same “bigger” app and keep it as a complete black box, with Redux being an implementation detail.
To hide Redux behind a React API, we can wrap it in a special component that initializes the store in the constructor:
import React, { Component } from 'react'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import reducer from './reducers'
import App from './App'

class SubApp extends Component {
  constructor(props) {
    super(props)
    this.store = createStore(reducer)
  }

  render() {
    return (
      <Provider store={this.store}>
        <App />
      </Provider>
    )
  }
}
This way every instance will be independent.
This pattern is not recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps' internals, and we'd like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won't “know” about each other.
Edit this page
Last updated on Jun 26, 2021""""""",575,2577,redux
https://redux.js.org/usage/migrating-to-modern-redux,"""""""Using ReduxMigrationsMigrating to Modern Redux
Migrating to Modern Redux
WHAT YOU'LL LEARN
How to modernize legacy ""hand-written"" Redux logic to use Redux Toolkit
How to modernize legacy React-Redux connect components to use the hooks API
How to modernize Redux logic and React-Redux components that use TypeScript
Overview
Redux has been around since 2015, and our recommended patterns for writing Redux code have changed significantly over the years. In the same way that React has evolved from createClass to React.Component to function components with hooks, Redux has evolved from manual store setup + hand-written reducers with object spreads + React-Redux's connect, to Redux Toolkit's configureStore + createSlice + React-Redux's hooks API.
Many users are working on older Redux codebases that have been around since before these ""modern Redux"" patterns existed. Migrating those codebases to today's recommended modern Redux patterns will result in codebases that are much smaller and easier to maintain.
The good news is that you can migrate your code to modern Redux incrementally, piece by piece, with old and new Redux code coexisting and working together!
This page covers the general approaches and techniques you can use to modernize an existing legacy Redux codebase.
INFO
For more details on how ""modern Redux"" with Redux Toolkit + React-Redux hooks simplifies using Redux, see these additional resources:
Why Redux Toolkit is How to use Redux Today
Redux Essentials: Redux Toolkit App Structure
Redux Fundamentals: Modern Redux with Redux Toolkit
Presentation: Modern Redux with Redux Toolkit
Modernizing Redux Logic with Redux Toolkit
The general approach to migrating Redux logic is:
Replace the existing manual Redux store setup with Redux Toolkit's configureStore
Pick an existing slice reducer and its associated actions. Replace those with RTK's createSlice. Repeat for one reducer at a time.
As needed, replace existing data fetching logic with RTK Query or createAsyncThunk
Use RTK's other APIs like createListenerMiddleware or createEntityAdapter as needed
You should always start by replacing the legacy createStore call with configureStore. This is a one-time step, and all of the existing reducers and middleware will continue to work as-is. configureStore includes development-mode checks for common mistakes like accidental mutations and non-serializable values, so having those in place will help identify any areas of the codebase where those mistakes are happening.
INFO
You can see this general approach in action in Redux Fundamentals, Part 8: Modern Redux with Redux Toolkit.
Store Setup with configureStore
A typical legacy Redux store setup file does several different steps:
Combining the slice reducers into the root reducer
Creating the middleware enhancer, usually with the thunk middleware, and possibly other middleware in development mode such as redux-logger
Adding the Redux DevTools enhancer, and composing the enhancers together
Calling createStore
Here's what those steps might look like in an existing application:
src/app/store.js
import { createStore, applyMiddleware, combineReducers, compose } from 'redux'
import thunk from 'redux-thunk'

import postsReducer from '../reducers/postsReducer'
import usersReducer from '../reducers/usersReducer'

const rootReducer = combineReducers({
  posts: postsReducer,
  users: usersReducer
})

const middlewareEnhancer = applyMiddleware(thunk)

const composeWithDevTools =
  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose

const composedEnhancers = composeWithDevTools(middlewareEnhancer)

const store = createStore(rootReducer, composedEnhancers)
All of those steps can be replaced with a single call to Redux Toolkit's configureStore API.
RTK's configureStore wraps around the original createStore method, and handles most of the store setup for us automatically. In fact, we can cut it down to effectively one step:
Basic Store Setup: src/app/store.js
import { configureStore } from '@reduxjs/toolkit'

import postsReducer from '../reducers/postsReducer'
import usersReducer from '../reducers/usersReducer'

// Automatically adds the thunk middleware and the Redux DevTools extension
const store = configureStore({
  // Automatically calls `combineReducers`
  reducer: {
    posts: postsReducer,
    users: usersReducer
  }
})
That one call to configureStore did all the work for us:
It called combineReducers to combine postsReducer and usersReducer into the root reducer function, which will handle a root state that looks like {posts, users}
It called createStore to create a Redux store using that root reducer
It automatically added the thunk middleware and called applyMiddleware
It automatically added more middleware to check for common mistakes like accidentally mutating the state
It automatically set up the Redux DevTools Extension connection
If your store setup requires additional steps, such as adding additional middleware, passing in an extra argument to the thunk middleware, or creating a persisted root reducer, you can do that as well. Here's a larger example that shows customizing the built-in middleware and turning on Redux-Persist, which demonstrates some of the options for working with configureStore:
Detailed Example: Custom Store Setup with Persistence and Middleware




































































Reducers and Actions with createSlice
A typical legacy Redux codebase has its reducer logic, action creators, and action types spread across separate files, and those files are often in separate folders by type. The reducer logic is written using switch statements and hand-written immutable update logic with object spreads and array mapping:
src/constants/todos.js
export const ADD_TODO = 'ADD_TODO'
export const TOGGLE_TODO = 'TOGGLE_TODO'
src/actions/todos.js
import { ADD_TODO, TOGGLE_TODO } from '../constants/todos'

export const addTodo = (id, text) => ({
  type: ADD_TODO,
  text,
  id
})

export const toggleTodo = id => ({
  type: TOGGLE_TODO,
  id
})
src/reducers/todos.js
import { ADD_TODO, TOGGLE_TODO } from '../constants/todos'

const initialState = []

export default function todosReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TODO: {
      return state.concat({
        id: action.id,
        text: action.text,
        completed: false
      })
    }
    case TOGGLE_TODO: {
      return state.map(todo => {
        if (todo.id !== action.id) {
          return todo
        }

        return {
          ...todo,
          completed: !todo.completed
        }
      })
    }
    default:
      return state
  }
}
Redux Toolkit's createSlice API was designed to eliminate all the ""boilerplate"" with writing reducers, actions, and immutable updates!
With Redux Toolkit, there's multiple changes to that legacy code:
createSlice will eliminate the hand-written action creators and action types entirely
All of the uniquely-named fields like action.text and action.id get replaced by action.payload, either as an individual value or an object containing those fields
The hand-written immutable updates are replaced by ""mutating"" logic in reducers thanks to Immer
There's no need for separate files for each type of code
We teach having all logic for a given reducer in a single ""slice"" file
Instead of having separate folders by ""type of code"", we recommend organizing files by ""features"", with related code living in the same folder
Ideally, the naming of the reducers and actions should use the past tense and describe ""a thing that happened"", rather than an imperative ""do this thing now"", such as todoAdded instead of ADD_TODO
Those separate files for constants, actions, and reducers, would all be replaced by a single ""slice"" file. The modernized slice file would look like this:
src/features/todos/todosSlice.js
import { createSlice } from '@reduxjs/toolkit'

const initialState = []

const todosSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    // Give case reducers meaningful past-tense ""event""-style names
    todoAdded(state, action) {
      const { id, text } = action.payload
      // ""Mutating"" update syntax thanks to Immer, and no `return` needed
      state.todos.push({
        id,
        text,
        completed: false
      })
    },
    todoToggled(state, action) {
      // Look for the specific nested object to update.
      // In this case, `action.payload` is the default field in the action,
      // and can hold the `id` value - no need for `action.id` separately
      const matchingTodo = state.todos.find(todo => todo.id === action.payload)

      if (matchingTodo) {
        // Can directly ""mutate"" the nested object
        matchingTodo.completed = !matchingTodo.completed
      }
    }
  }
})

// `createSlice` automatically generated action creators with these names.
// export them as named exports from this ""slice"" file
export const { todoAdded, todoToggled } = todosSlice.actions

// Export the slice reducer as the default export
export default todosSlice.reducer
When you call dispatch(todoAdded('Buy milk')), whatever single value you pass to the todoAdded action creator will automatically get used as the action.payload field. If you need to pass in multiple values, do so as an object, like dispatch(todoAdded({id, text})). Alternately, you can use the ""prepare"" notation inside of a createSlice reducer to accept multiple separate arguments and create the payload field. The prepare notation is also useful for cases where the action creators were doing additional work, such as generating unique IDs for each item.
While Redux Toolkit does not specifically care about your folder and file structures or action naming, these are the best practices we recommend because we've found they lead to more maintainable and understandable code.
Data Fetching with RTK Query
Typical legacy data fetching in a React+Redux app requires many moving pieces and types of code:
Action creators and action types that represent ""request starting"", ""request succeeded"", and ""request failed"" actions
Thunks to dispatch the actions and make the async request
Reducers that track loading status and store the cached data
Selectors to read those values from the store
Dispatching the thunk in a component after mounting, either via componentDidMount in a class component or useEffect in a function component
These typically would be split across many different files:
src/constants/todos.js
export const FETCH_TODOS_STARTED = 'FETCH_TODOS_STARTED'
export const FETCH_TODOS_SUCCEEDED = 'FETCH_TODOS_SUCCEEDED'
export const FETCH_TODOS_FAILED = 'FETCH_TODOS_FAILED'
src/actions/todos.js
import axios from 'axios'
import {
  FETCH_TODOS_STARTED,
  FETCH_TODOS_SUCCEEDED,
  FETCH_TODOS_FAILED
} from '../constants/todos'

export const fetchTodosStarted = () => ({
  type: FETCH_TODOS_STARTED
})

export const fetchTodosSucceeded = todos => ({
  type: FETCH_TODOS_SUCCEEDED,
  todos
})

export const fetchTodosFailed = error => ({
  type: FETCH_TODOS_FAILED,
  error
})

export const fetchTodos = () => {
  return async dispatch => {
    dispatch(fetchTodosStarted())

    try {
      // Axios is common, but also `fetch`, or your own ""API service"" layer
      const res = await axios.get('/todos')
      dispatch(fetchTodosSucceeded(res.data))
    } catch (err) {
      dispatch(fetchTodosFailed(err))
    }
  }
}
src/reducers/todos.js
import {
  FETCH_TODOS_STARTED,
  FETCH_TODOS_SUCCEEDED,
  FETCH_TODOS_FAILED
} from '../constants/todos'

const initialState = {
  status: 'uninitialized',
  todos: [],
  error: null
}

export default function todosReducer(state = initialState, action) {
  switch (action.type) {
    case FETCH_TODOS_STARTED: {
      return {
        ...state,
        status: 'loading'
      }
    }
    case FETCH_TODOS_SUCCEEDED: {
      return {
        ...state,
        status: 'succeeded',
        todos: action.todos
      }
    }
    case FETCH_TODOS_FAILED: {
      return {
        ...state,
        status: 'failed',
        todos: [],
        error: action.error
      }
    }
    default:
      return state
  }
}
src/selectors/todos.js
export const selectTodosStatus = state => state.todos.status
export const selectTodos = state => state.todos.todos
src/components/TodosList.js
import { useEffect } from 'react'
import { useSelector, useDispatch } from 'react-redux'
import { fetchTodos } from '../actions/todos'
import { selectTodosStatus, selectTodos } from '../selectors/todos'

export function TodosList() {
  const dispatch = useDispatch()
  const status = useSelector(selectTodosStatus)
  const todos = useSelector(selectTodos)

  useEffect(() => {
    dispatch(fetchTodos())
  }, [dispatch])

  // omit rendering logic here
}
Many users may be using the redux-saga library to manage data fetching, in which case they might have additional ""signal"" action types used to trigger the sagas, and this saga file instead of thunks:
src/sagas/todos.js
import { put, takeEvery, call } from 'redux-saga/effects'
import {
  FETCH_TODOS_BEGIN,
  fetchTodosStarted,
  fetchTodosSucceeded,
  fetchTodosFailed
} from '../actions/todos'

// Saga to actually fetch data
export function* fetchTodos() {
  yield put(fetchTodosStarted())

  try {
    const res = yield call(axios.get, '/todos')
    yield put(fetchTodosSucceeded(res.data))
  } catch (err) {
    yield put(fetchTodosFailed(err))
  }
}

// ""Watcher"" saga that waits for a ""signal"" action, which is
// dispatched only to kick off logic, not to update state
export function* fetchTodosSaga() {
  yield takeEvery(FETCH_TODOS_BEGIN, fetchTodos)
}
All of that code can be replaced with Redux Toolkit's ""RTK Query"" data fetching and caching layer!
RTK Query replaces the need to write any actions, thunks, reducers, selectors, or effects to manage data fetching. (In fact, it actually uses all those same tools internally.) Additionally, RTK Query takes care of tracking loading state, deduplicating requests, and managing cache data lifecycles (including removing expired data that is no longer needed).
To migrate, set up a single RTK Query ""API slice"" definition and add the generated reducer + middleware to your store:
src/features/api/apiSlice.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const api = createApi({
  baseQuery: fetchBaseQuery({
    // Fill in your own server starting URL here
    baseUrl: '/'
  }),
  endpoints: build => ({})
})
src/app/store.js
import { configureStore } from '@reduxjs/toolkit'

// Import the API object
import { api } from '../features/api/apiSlice'
// Import any other slice reducers as usual here
import usersReducer from '../features/users/usersSlice'

export const store = configureStore({
  reducer: {
    // Add the generated RTK Query ""API slice"" caching reducer
    [api.reducerPath]: api.reducer,
    // Add any other reducers
    users: usersReducer
  },
  // Add the RTK Query API middleware
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().concat(api.middleware)
})
Then, add ""endpoints"" that represents the specific data you want to fetch and cache, and export the auto-generated React hooks for each endpoint:
src/features/api/apiSlice.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const api = createApi({
  baseQuery: fetchBaseQuery({
    // Fill in your own server starting URL here
    baseUrl: '/'
  }),
  endpoints: build => ({
    // A query endpoint with no arguments
    getTodos: build.query({
      query: () => '/todos'
    }),
    // A query endpoint with an argument
    userById: build.query({
      query: userId => `/users/${userId}`
    }),
    // A mutation endpoint
    updateTodo: build.mutation({
      query: updatedTodo => ({
        url: `/todos/${updatedTodo.id}`,
        method: 'POST',
        body: updatedTodo
      })
    })
  })
})

export const { useGetTodosQuery, useUserByIdQuery, useUpdateTodoMutation } = api
Finally, use the hooks in your components:
src/features/todos/TodoList.js
import { useGetTodosQuery } from '../api/apiSlice'

export function TodoList() {
  const { data: todos, isFetching, isSuccess } = useGetTodosQuery()

  // omit rendering logic here
}
Data Fetching with createAsyncThunk
We specifically recommend using RTK Query for data fetching. However, some users have told us they aren't ready to make that step yet. In that case, you can at least cut down on some of the boilerplate of hand-written thunks and reducers using RTK's createAsyncThunk. It automatically generates the action creators and action types for you, calls the async function you provide to make the request, and dispatches those actions based on the promise lifecycle. The same example with createAsyncThunk might look like this:
src/features/todos/todosSlice
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import axios from 'axios'

const initialState = {
  status: 'uninitialized',
  todos: [],
  error: null
}

const fetchTodos = createAsyncThunk('todos/fetchTodos', async () => {
  // Just make the async request here, and return the response.
  // This will automatically dispatch a `pending` action first,
  // and then `fulfilled` or `rejected` actions based on the promise.
  // as needed based on the
  const res = await axios.get('/todos')
  return res.data
})

export const todosSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    // any additional ""normal"" case reducers here.
    // these will generate new action creators
  },
  extraReducers: builder => {
    // Use `extraReducers` to handle actions that were generated
    // _outside_ of the slice, such as thunks or in other slices
    builder
      .addCase(fetchTodos.pending, (state, action) => {
        state.status = 'loading'
      })
      // Pass the generated action creators to `.addCase()`
      .addCase(fetchTodos.fulfilled, (state, action) => {
        // Same ""mutating"" update syntax thanks to Immer
        state.status = 'succeeded'
        state.todos = action.payload
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.status = 'failed'
        state.todos = []
        state.error = action.error
      })
  }
})

export default todosSlice.reducer
You'd also still need to write any selectors, and dispatch the fetchTodos thunk yourself in a useEffect hook.
Reactive Logic with createListenerMiddleware
Many Redux apps have ""reactive""-style logic that listens for specific actions or state changes, and runs additional logic in response. These behaviors are often implemented using the redux-saga or redux-observable libraries.
These libraries are used for a wide variety of tasks. As a basic example, a saga and an epic that listen for an action, wait one second, and then dispatch an additional action might look like this:
src/sagas/ping.js
import { delay, put, takeEvery } from 'redux-saga/effects'

export function* ping() {
  yield delay(1000)
  yield put({ type: 'PONG' })
}

// ""Watcher"" saga that waits for a ""signal"" action, which is
// dispatched only to kick off logic, not to update state
export function* pingSaga() {
  yield takeEvery('PING', ping)
}
src/epics/ping.js
import { filter, mapTo } from 'rxjs/operators'
import { ofType } from 'redux-observable'

const pingEpic = action$ =>
  action$.pipe(ofType('PING'), delay(1000), mapTo({ type: 'PONG' }))
src/app/store.js
import { createStore, applyMiddleware } from 'redux'
import createSagaMiddleware from 'redux-saga'
import { combineEpics, createEpicMiddleware  } from 'redux-observable';

// skip reducers

import { pingEpic } from '../sagas/ping'
import { pingSaga } from '../epics/ping

function* rootSaga() {
  yield pingSaga()
}

const rootEpic = combineEpics(
  pingEpic
);

const sagaMiddleware = createSagaMiddleware()
const epicMiddleware = createEpicMiddleware()

const middlewareEnhancer = applyMiddleware(sagaMiddleware, epicMiddleware)

const store = createStore(rootReducer, middlewareEnhancer)

sagaMiddleware.run(rootSaga)
epicMiddleware.run(rootEpic)
The RTK ""listener"" middleware is designed to replace sagas and observables, with a simpler API, smaller bundle size, and better TS support.
The saga and epic examples could be replaced with the listener middleware, like this:
src/app/listenerMiddleware.js
import { createListenerMiddleware } from '@reduxjs/toolkit'

// Best to define this in a separate file, to avoid importing
// from the store file into the rest of the codebase
export const listenerMiddleware = createListenerMiddleware()

export const { startListening, stopListening } = listenerMiddleware
src/features/ping/pingSlice.js
import { createSlice } from '@reduxjs/toolkit'
import { startListening } from '../../app/listenerMiddleware'

const pingSlice = createSlice({
  name: 'ping',
  initialState,
  reducers: {
    pong(state, action) {
      // state update here
    }
  }
})

export const { pong } = pingSlice.actions
export default pingSlice.reducer

// The `startListening()` call could go in different files,
// depending on your preferred app setup. Here, we just add
// it directly in a slice file.
startListening({
  // Match this exact action type based on the action creator
  actionCreator: pong,
  // Run this effect callback whenever that action is dispatched
  effect: async (action, listenerApi) => {
    // Listener effect functions get a `listenerApi` object
    // with many useful methods built in, including `delay`:
    await listenerApi.delay(1000)
    listenerApi.dispatch(pong())
  }
})
src/app/store.js
import { configureStore } from '@reduxjs/toolkit'

import { listenerMiddleware } from './listenerMiddleware'

// omit reducers

export const store = configureStore({
  reducer: rootReducer,
  // Add the listener middleware _before_ the thunk or dev checks
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().prepend(listenerMiddleware.middleware)
})
Migrating TypeScript for Redux Logic
Legacy Redux code that uses TypeScript typically follows very verbose patterns for defining types. In particular, many users in the community have decided to manually define TS types for each individual action, and then created ""action type unions"" that try to limit what specific actions can actually be passed to dispatch.
We specifically and strongly recommend against these patterns!
src/actions/todos.ts
import { ADD_TODO, TOGGLE_TODO } from '../constants/todos'

// ❌ Common pattern: manually defining types for each action object
interface AddTodoAction {
  type: typeof ADD_TODO
  text: string
  id: string
}

interface ToggleTodoAction {
  type: typeof TOGGLE_TODO
  id: string
}

// ❌ Common pattern: an ""action type union"" of all possible actions
export type TodoActions = AddTodoAction | ToggleTodoAction

export const addTodo = (id: string, text: string): AddTodoAction => ({
  type: ADD_TODO,
  text,
  id
})

export const toggleTodo = (id: string): ToggleTodoAction => ({
  type: TOGGLE_TODO,
  id
})
src/reducers/todos.ts
import { ADD_TODO, TOGGLE_TODO, TodoActions } from '../constants/todos'

interface Todo {
  id: string
  text: string
  completed: boolean
}

export type TodosState = Todo[]

const initialState: TodosState = []

export default function todosReducer(
  state = initialState,
  action: TodoActions
) {
  switch (action.type) {
    // omit reducer logic
    default:
      return state
  }
}
src/app/store.ts
import { createStore, Dispatch } from 'redux'

import { TodoActions } from '../actions/todos'
import { CounterActions } from '../actions/counter'
import { TodosState } from '../reducers/todos'
import { CounterState } from '../reducers/counter'

// omit reducer setup

export const store = createStore(rootReducer)

// ❌ Common pattern: an ""action type union"" of all possible actions
export type RootAction = TodoActions | CounterActions
// ❌ Common pattern: manually defining the root state type with each field
export interface RootState {
  todos: TodosState
  counter: CounterState
}

// ❌ Common pattern: limiting what can be dispatched at the types level
export type AppDispatch = Dispatch<RootAction>
Redux Toolkit is designed to drastically simplify TS usage, and our recommendations include inferring types as much as possible!
Per our standard TypeScript setup and usage guidelines, start with setting up the store file to infer AppDispatch and RootState types directly from the store itself. That will correctly include any modifications to dispatch that were added by middleware, such as the ability to dispatch thunks, and update the RootState type any time you modify a slice's state definition or add more slices.
app/store.ts
import { configureStore } from '@reduxjs/toolkit'
// omit any other imports

const store = configureStore({
  reducer: {
    todos: todosReducer,
    counter: counterReducer
  }
})

// Infer the `RootState` and `AppDispatch` types from the store itself

// Inferred state type: {todos: TodosState, counter: CounterState}
export type RootState = ReturnType<typeof store.getState>

// Inferred dispatch type: Dispatch & ThunkDispatch<RootState, undefined, UnknownAction>
export type AppDispatch = typeof store.dispatch
Each slice file should declare and export a type for its own slice state. Then, use the PayloadAction type to declare the type of any action argument inside of createSlice.reducers. The generated action creators will then also have the correct type for the argument they accept, and the type of action.payload that they return.
src/features/todos/todosSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

interface Todo {
  id: string
  text: string
  completed: boolean
}

// Declare and export a type for the slice's state
export type TodosState = Todo[]

const initialState: TodosState = []

const todosSlice = createSlice({
  name: 'todos',
  // The `state` argument type will be inferred for all case reducers
  // from the type of `initialState`
  initialState,
  reducers: {
    // Use `PayloadAction<YourPayloadTypeHere>` for each `action` argument
    todoAdded(state, action: PayloadAction<{ id: string; text: string }>) {
      // omit logic
    },
    todoToggled(state, action: PayloadAction<string>) {
      // omit logic
    }
  }
})
Modernizing React Components with React-Redux
The general approach to migrating React-Redux usage in components is:
Migrate an existing React class component to be a function component
Replace the connect wrapper with uses of the useSelector and useDispatch hooks inside the component
You can do this on an individual per-component basis. Components with connect and with hooks can coexist at the same time.
This page won't cover the process of migrating class components to function components, but will focus on the changes specific to React-Redux.
Migrating connect to Hooks
A typical legacy component using React-Redux's connect API might look like this:
src/features/todos/TodoListItem.js
import { connect } from 'react-redux'
import { bindActionCreators } from 'redux'
import {
  todoToggled,
  todoDeleted,
  selectTodoById,
  selectActiveTodoId
} from './todosSlice'

// A `mapState` function, possibly using values from `ownProps`,
// and returning an object with multiple separate fields inside
const mapStateToProps = (state, ownProps) => {
  return {
    todo: selectTodoById(state, ownProps.todoId),
    activeTodoId: selectActiveTodoId(state)
  }
}

// Several possible variations on how you might see `mapDispatch` written:

// 1) a separate function, manual wrapping of `dispatch`
const mapDispatchToProps = dispatch => {
  return {
    todoDeleted: id => dispatch(todoDeleted(id)),
    todoToggled: id => dispatch(todoToggled(id))
  }
}

// 2) A separate function, wrapping with `bindActionCreators`
const mapDispatchToProps2 = dispatch => {
  return bindActionCreators(
    {
      todoDeleted,
      todoToggled
    },
    dispatch
  )
}

// 3) An object full of action creators
const mapDispatchToProps3 = {
  todoDeleted,
  todoToggled
}

// The component, which gets all these fields as props
function TodoListItem({ todo, activeTodoId, todoDeleted, todoToggled }) {
  // rendering logic here
}

// Finished with the call to `connect`
export default connect(mapStateToProps, mapDispatchToProps)(TodoListItem)
With the React-Redux hooks API, the connect call and mapState/mapDispatch arguments are replaced by hooks!
Each individual field returned in mapState becomes a separate useSelector call
Each function passed in via mapDispatch becomes a separate callback function defined inside the component
src/features/todos/TodoListItem.js
import { useState } from 'react'
import { useSelector, useDispatch } from 'react-redux'
import {
  todoAdded,
  todoToggled,
  selectTodoById,
  selectActiveTodoId
} from './todosSlice'

export function TodoListItem({ todoId }) {
  // Get the actual `dispatch` function with `useDispatch`
  const dispatch = useDispatch()

  // Select values from the state with `useSelector`
  const activeTodoId = useSelector(selectActiveTodoId)
  // Use prop in scope to select a specific value
  const todo = useSelector(state => selectTodoById(state, todoId))

  // Create callback functions that dispatch as needed, with arguments
  const handleToggleClick = () => {
    dispatch(todoToggled(todoId))
  }

  const handleDeleteClick = () => {
    dispatch(todoDeleted(todoId))
  }

  // omit rendering logic
}
One thing that's different is that connect optimized rendering performance by preventing the wrapped component from rendering unless its incoming stateProps+dispatchProps+ownProps had changed. The hooks cannot do that, since they're inside the component. If you need to prevent React's normal recursive rendering behavior, wrap the component in React.memo(MyComponent) yourself.
Migrating TypeScript for Components
One of the major downsides with connect is that it is very hard to type correctly, and the type declarations end up being extremely verbose. This is due to it being a Higher-Order Component, and also the amount of flexibility in its API (four arguments, all optional, each with multiple possible overloads and variations).
The community came up with multiple variations on how to handle this, with varying levels of complexity. On the low end, some usages required typing state in mapState(), and then calculating the types of all the props for the component:
Simple connect TS example
import { connect } from 'react-redux'
import { RootState } from '../../app/store'
import {
  todoToggled,
  todoDeleted,
  selectTodoById,
  selectActiveTodoId
} from './todosSlice'

interface TodoListItemOwnProps {
  todoId: string
}

const mapStateToProps = (state: RootState, ownProps) => {
  return {
    todo: selectTodoById(state, ownProps.todoId),
    activeTodoId: selectActiveTodoId(state)
  }
}

const mapDispatchToProps = {
  todoDeleted,
  todoToggled
}

type TodoListItemProps = TodoListItemOwnProps &
  ReturnType<typeof mapStateToProps> &
  typeof mapDispatchToProps

function TodoListItem({
  todo,
  activeTodoId,
  todoDeleted,
  todoToggled
}: TodoListItemProps) {}

export default connect(mapStateToProps, mapDispatchToProps)(TodoListItem)
The use of typeof mapDispatch as an object in particular was dangerous, because it would fail if thunks were included.
Other community-created patterns required significantly more overhead, including declaring mapDispatch as a function and calling bindActionCreators in order to pass through a dispatch: Dispatch<RootActions> type, or manually calculating the types of all the props received by the wrapped component and passing those as generics to connect.
One slightly-better alternative was the ConnectedProps<T> type that was added to @types/react-redux in v7.x, which enabled inferring the type of all the props that would be passed to the component from connect. This did require splitting up the call to connect into two parts for the inference to work right:
ConnectedProps<T> TS example
import { connect, ConnectedProps } from 'react-redux'
import { RootState } from '../../app/store'
import {
  todoToggled,
  todoDeleted,
  selectTodoById,
  selectActiveTodoId
} from './todosSlice'

interface TodoListItemOwnProps {
  todoId: string
}

const mapStateToProps = (state: RootState, ownProps) => {
  return {
    todo: selectTodoById(state, ownProps.todoId),
    activeTodoId: selectActiveTodoId(state)
  }
}

const mapDispatchToProps = {
  todoDeleted,
  todoToggled
}

// Call the first part of `connect` to get the function that accepts the component.
// This knows the types of the props returned by `mapState/mapDispatch`
const connector = connect(mapStateToProps, mapDispatchToProps)
// The `ConnectedProps<T> util type can extract ""the type of all props from Redux""
type PropsFromRedux = ConnectedProps<typeof connector>

// The final component props are ""the props from Redux"" + ""props from the parent""
type TodoListItemProps = PropsFromRedux & TodoListItemOwnProps

// That type can then be used in the component
function TodoListItem({
  todo,
  activeTodoId,
  todoDeleted,
  todoToggled
}: TodoListItemProps) {}

// And the final wrapped component is generated and exported
export default connector(TodoListItem)
The React-Redux hooks API is much simpler to use with TypeScript! Instead of dealing with layers of component wrapping, type inference, and generics, the hooks are simple functions that take arguments and return a result. All that you need to pass around are the types for RootState and AppDispatch.
Per our standard TypeScript setup and usage guidelines, we specifically teach setting up ""pre-typed"" aliases for the hooks, so that those have the correct types baked in, and only use those pre-typed hooks in the app.
First, set up the hooks:
src/app/hooks.ts
import { useDispatch, useSelector } from 'react-redux'
import type { AppDispatch, RootState } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()
Then, use them in your components:
src/features/todos/TodoListItem.tsx
import { useAppSelector, useAppDispatch } from '../../app/hooks'
import {
  todoToggled,
  todoDeleted,
  selectTodoById,
  selectActiveTodoId
} from './todosSlice'

interface TodoListItemProps {
  todoId: string
}

function TodoListItem({ todoId }: TodoListItemProps) {
  // Use the pre-typed hooks in the component
  const dispatch = useAppDispatch()
  const activeTodoId = useAppSelector(selectActiveTodoId)
  const todo = useAppSelector(state => selectTodoById(state, todoId))

  // omit event handlers and rendering logic
}
Further Information
See these docs pages and blog posts for more details:
Tutorials
Redux Essentials: Redux Toolkit App Structure
Redux Fundamentals: Modern Redux with Redux Toolkit
Redux TypeScript Quick Start
Additional Documentation
Why Redux Toolkit is How to use Redux Today
Redux Style Guide: Best Practices and Recommendations
Redux core: Usage with TypeScript
Redux Toolkit: Usage with TypeScript
Articles
Presentation: Modern Redux with Redux Toolkit
Mark Erikson: Redux Toolkit 1.0 Announcement and development history
Lenz Weber: Do Not Create Action Type Unions
Edit this page
Last updated on Mar 20, 2024""""""",7672,35241,redux
https://redux.js.org/usage/migrations/migrating-rtk-2,"""""""Using ReduxMigrationsMigrating to RTK 2.0 and Redux 5.0
Migrating to RTK 2.0 and Redux 5.0
WHAT YOU'LL LEARN
What's changed in Redux Toolkit 2.0, Redux core 5.0, Reselect 5.0, and Redux Thunk 3.0, including breaking changes and new features
Introduction
Redux Toolkit has been available since 2019, and today it's the standard way to write Redux apps. We've gone 4+ years without any breaking changes. Now, RTK 2.0 gives us a chance to modernize the packaging, clean up deprecated options, and tighten up some edge cases.
Redux Toolkit 2.0 is accompanied by major versions of all the other Redux packages: Redux core 5.0, React-Redux 9.0, Reselect 5.0, and Redux Thunk 3.0.
This page lists known potentially breaking changes in each of those packages, as well as new features in Redux Toolkit 2.0. As a reminder, you should not need to actually install or use the core redux package directly - RTK wraps that, and re-exports all methods and types.
In practice, most of the ""breaking"" changes should not have an actual effect on end users, and we expect that many projects can just update the package versions with very few code changes needed.
The changes most likely to need app code updates are:
Object syntax removed for createReducer and createSlice.extraReducers
configureStore.middleware must be a callback
Middleware type changed - Middleware action and next are typed as unknown
Packaging Changes (all)
We've made updates to the build packaging for all of the Redux-related libraries. These are technically ""breaking"", but should be transparent to end users, and actually enable better support for scenarios such as using Redux via ESM files under Node.
Addition of exports field in package.json
We've migrated the package definitions to include the exports field for defining which artifacts to load, with a modern ESM build as the primary artifact (with CJS still included for compatibility purposes).
We've done local testing of the package, but we ask the community to try out this in your own projects and report any breakages you find!
Build Artifact Modernization
We've updated the build output in several ways:
Build output is no longer transpiled! Instead we target modern JS syntax (ES2020)
Moved all build artifacts to live under ./dist/, instead of separate top-level folders
The lowest Typescript version we test against is now TS 4.7.
Dropping UMD builds
Redux has always shipped with UMD build artifacts. These are primarily meant for direct import as script tags, such as in a CodePen or a no-bundler build environment.
For now, we're dropping those build artifacts from the published package, on the grounds that the use cases seem pretty rare today.
We do have a browser-ready ESM build artifact included at dist/$PACKAGE_NAME.browser.mjs, which can be loaded via a script tag that points to that file on Unpkg.
If you have strong use cases for us continuing to include UMD build artifacts, please let us know!
Breaking Changes
Core
Action types must be strings
We've always specifically told our users that actions and state must be serializable, and that action.type should be a string. This is both to ensure that actions are serializable, and to help provide a readable action history in the Redux DevTools.
store.dispatch(action) now specifically enforces that action.type must be a string and will throw an error if not, in the same way it throws an error if the action is not a plain object.
In practice, this was already true 99.99% of the time and shouldn't have any effect on users (especially those using Redux Toolkit and createSlice), but there may be some legacy Redux codebases that opted to use Symbols as action types.
createStore Deprecation
In Redux 4.2.0, we marked the original createStore method as @deprecated. Strictly speaking, this is not a breaking change, nor is it new in 5.0, but we're documenting it here for completeness.
This deprecation is solely a visual indicator that is meant to encourage users to migrate their apps from legacy Redux patterns to use the modern Redux Toolkit APIs.
The deprecation results in a visual strikethrough when imported and used, like createStore, but with no runtime errors or warnings.
createStore will continue to work indefinitely, and will not ever be removed. But, today we want all Redux users to be using Redux Toolkit for all of their Redux logic.
To fix this, there are three options:
Follow our strong suggestion to switch over to Redux Toolkit and configureStore
Do nothing. It's just a visual strikethrough, and it doesn't affect how your code behaves. Ignore it.
Switch to using the legacy_createStore API that is now exported, which is the exact same function but with no @deprecated tag. The simplest option is to do an aliased import rename, like import { legacy_createStore as createStore } from 'redux'
Typescript rewrite
In 2019, we began a community-powered conversion of the Redux codebase to TypeScript. The original effort was discussed in #3500: Port to TypeScript, and the work was integrated in PR #3536: Convert to TypeScript.
However, the TS-converted code sat around in the repo for several years, unused and unpublished, due to concerns about possible compatibility issues with the existing ecosystem (as well as general inertia on our part).
Redux core v5 is now built from that TS-converted source code. In theory, this should be almost identical in both runtime behavior and types to the 4.x build, but it's very likely that some of the changes may cause types issues.
Please report any unexpected compatibility issues on Github!
AnyAction deprecated in favour of UnknownAction
The Redux TS types have always exported an AnyAction type, which is defined to have {type: string} and treat any other field as any. This makes it easy to write uses like console.log(action.whatever), but unfortunately does not provide any meaningful type safety.
We now export an UnknownAction type, which treats all fields other than action.type as unknown. This encourages users to write type guards that check the action object and assert its specific TS type. Inside of those checks, you can access a field with better type safety.
UnknownAction is now the default any place in the Redux source that expects an action object.
AnyAction still exists for compatibility, but has been marked as deprecated.
Note that Redux Toolkit's action creators have a .match() method that acts as a useful type guard:
if (todoAdded.match(someUnknownAction)) {
  // action is now typed as a PayloadAction<Todo>
}
You can also use the new isAction util to check if an unknown value is some kind of action object.
Middleware type changed - Middleware action and next are typed as unknown
Previously, the next parameter is typed as the D type parameter passed, and action is typed as the Action extracted from the dispatch type. Neither of these are a safe assumption:
next would be typed to have all of the dispatch extensions, including the ones earlier in the chain that would no longer apply.
Technically it would be mostly safe to type next as the default Dispatch implemented by the base redux store, however this would cause next(action) to error (as we cannot promise action is actually an Action) - and it wouldn't account for any following middlewares that return anything other than the action they're given when they see a specific action.
action is not necessarily a known action, it can be literally anything - for example a thunk would be a function with no .type property (so AnyAction would be inaccurate)
We've changed next to be (action: unknown) => unknown (which is accurate, we have no idea what next expects or will return), and changed the action parameter to be unknown (which as above, is accurate).
In order to safely interact with values or access fields inside of the action argument, you must first do a type guard check to narrow the type, such as isAction(action) or someActionCreator.match(action).
This new type is incompatible with the v4 Middleware type, so if a package's middleware is saying it's incompatible, check which version of Redux it's getting its types from! (See overriding dependencies later in this page.)
PreloadedState type removed in favour of Reducer generic
We've made tweaks to the TS types to improve type safety and behavior.
First, the Reducer type now has a PreloadedState possible generic:
type Reducer<S, A extends Action, PreloadedState = S> = (
  state: S | PreloadedState | undefined,
  action: A
) => S
Per the explanation in #4491:
Why the need for this change? When the store is first created by createStore/configureStore, the initial state is set to whatever is passed as the preloadedState argument (or undefined if nothing is passed). That means that the first time that the reducer is called, it is called with the preloadedState. After the first call, the reducer is always passed the current state (which is S).
For most normal reducers, S | undefined accurately describes what can be passed in for the preloadedState. However the combineReducers function allows for a preloaded state of Partial<S> | undefined.
The solution is to have a separate generic that represents what the reducer accepts for its preloaded state. That way createStore can then use that generic for its preloadedState argument.
Previously, this was handled by a $CombinedState type, but that complicated things and led to some user-reported issues. This removes the need for $CombinedState altogether.
This change does include some breaking changes, but overall should not have a huge impact on users upgrading in user-land:
The Reducer, ReducersMapObject, and createStore/configureStore types/function take an additional PreloadedState generic which defaults to S.
The overloads for combineReducers are removed in favor of a single function definition that takes the ReducersMapObject as its generic parameter. Removing the overloads was necessary with these changes, since sometimes it was choosing the wrong overload.
Enhancers that explicitly list the generics for the reducer will need to add the third generic.
Toolkit only
Object syntax for createSlice.extraReducers and createReducer removed
RTK's createReducer API was originally designed to accept a lookup table of action type strings to case reducers, like { ""ADD_TODO"": (state, action) => {} }. We later added the ""builder callback"" form to allow more flexibility in adding ""matchers"" and a default handler, and did the same for createSlice.extraReducers.
We have removed the ""object"" form for both createReducer and createSlice.extraReducers in RTK 2.0, as the builder callback form is effectively the same number of lines of code, and works much better with TypeScript.
As an example, this:
const todoAdded = createAction('todos/todoAdded')

createReducer(initialState, {
  [todoAdded]: (state, action) => {}
})

createSlice({
  name,
  initialState,
  reducers: {
    /* case reducers here */
  },
  extraReducers: {
    [todoAdded]: (state, action) => {}
  }
})
should be migrated to:
createReducer(initialState, builder => {
  builder.addCase(todoAdded, (state, action) => {})
})

createSlice({
  name,
  initialState,
  reducers: {
    /* case reducers here */
  },
  extraReducers: builder => {
    builder.addCase(todoAdded, (state, action) => {})
  }
})
Codemods
To simplify upgrading codebases, we've published a set of codemods that will automatically transform the deprecated ""object"" syntax into the equivalent ""builder"" syntax.
The codemods package is available on NPM as @reduxjs/rtk-codemods. More details are available here.
To run the codemods against your codebase, run npx @reduxjs/rtk-codemods <TRANSFORM NAME> path/of/files/ or/some**/*glob.js.
Examples:
npx @reduxjs/rtk-codemods createReducerBuilder ./src

npx @reduxjs/rtk-codemods createSliceBuilder ./packages/my-app/**/*.ts
We also recommend re-running Prettier on the codebase before committing the changes.
These codemods should work, but we would greatly appreciate feedback from more real-world codebases!
configureStore.middleware must be a callback
Since the beginning, configureStore has accepted a direct array value as the middleware option. However, providing an array directly prevents configureStore from calling getDefaultMiddleware(). So, middleware: [myMiddleware] means there is no thunk middleware added (or any of the dev-mode checks).
This is a footgun, and we've had numerous users accidentally do this and cause their apps to fail because the default middleware never got configured.
As a result, we've now made the middleware only accept the callback form. If for some reason you still want to replace all of the built-in middleware, do so by returning an array from the callback:
const store = configureStore({
  reducer,
  middleware: getDefaultMiddleware => {
    // WARNING: this means that _none_ of the default middleware are added!
    return [myMiddleware]
    // or for TS users, use:
    // return new Tuple(myMiddleware)
  }
})
But note that we consistently recommend not replacing the default middleware entirely, and that you should use return getDefaultMiddleware().concat(myMiddleware).
configureStore.enhancers must be a callback
Similarly to configureStore.middleware, the enhancers field must also be a callback, for the same reasons.
The callback will receive a getDefaultEnhancers function that can be used to customise the batching enhancer that's now included by default.
For example:
const store = configureStore({
  reducer,
  enhancers: getDefaultEnhancers => {
    return getDefaultEnhancers({
      autoBatch: { type: 'tick' }
    }).concat(myEnhancer)
  }
})
It's important to note that the result of getDefaultEnhancers will also contain the middleware enhancer created with any configured/default middleware. To help prevent mistakes, configureStore will log an error to console if middleware was provided and the middleware enhancer wasn't included in the callback result.
const store = configureStore({
  reducer,
  enhancers: getDefaultEnhancers => {
    return [myEnhancer] // we've lost the  middleware here
    // instead:
    return getDefaultEnhancers().concat(myEnhancer)
  }
})
Standalone getDefaultMiddleware and getType removed
The standalone version of getDefaultMiddleware has been deprecated since v1.6.1, and has now been removed. Use the function passed to the middleware callback instead, which has the correct types.
We have also removed the getType export, which was used to extract a type string from action creators made with createAction. Instead, use the static property actionCreator.type.
RTK Query behaviour changes
We've had a number of reports where RTK Query had issues around usage of dispatch(endpoint.initiate(arg, {subscription: false})). There were also reports that multiple triggered lazy queries were resolving the promises at the wrong time. Both of these had the same underlying issue, which was that RTKQ wasn't tracking cache entries in these cases (intentionally). We've reworked the logic to always track cache entries (and remove them as needed), which should resolve those behavior issues.
We also have had issues raised about trying to run multiple mutations in a row and how tag invalidation behaves. RTKQ now has internal logic to delay tag invalidation briefly, to allow multiple invalidations to get handled together. This is controlled by a new invalidationBehavior: 'immediate' | 'delayed' flag on createApi. The new default behavior is 'delayed'. Set it to 'immediate' to revert to the behavior in RTK 1.9.
In RTK 1.9, we reworked RTK Query's internals to keep most of the subscription status inside the RTKQ middleware. The values are still synced to the Redux store state, but this is primarily for display by the Redux DevTools ""RTK Query"" panel. Related to the cache entry changes above, we've optimized how often those values get synced to the Redux state for perf.
reactHooksModule custom hook configuration
Previously, custom versions of React Redux's hooks (useSelector, useDispatch, and useStore) could be passed separately to reactHooksModule, usually to enable using a different context to the default ReactReduxContext.
In practicality, the react hooks module needs all three of these hooks to be provided, and it became an easy mistake to only pass useSelector and useDispatch, without useStore.
The module has now moved all three of these under the same configuration key, and will check that all three are provided if the key is present.
// previously
const customCreateApi = buildCreateApi(
  coreModule(),
  reactHooksModule({
    useDispatch: createDispatchHook(MyContext),
    useSelector: createSelectorHook(MyContext),
    useStore: createStoreHook(MyContext)
  })
)

// now
const customCreateApi = buildCreateApi(
  coreModule(),
  reactHooksModule({
    hooks: {
      useDispatch: createDispatchHook(MyContext),
      useSelector: createSelectorHook(MyContext),
      useStore: createStoreHook(MyContext)
    }
  })
)
Error message extraction
Redux 4.1.0 optimized its bundle size by extracting error message strings out of production builds, based on React's approach. We've applied the same technique to RTK. This saves about 1000 bytes from prod bundles (actual benefits will depend on which imports are being used).
configureStore field order for middleware matters
If you are passing both the middleware and enhancers fields to configureStore, the middleware field must come first in order for internal TS inference to work properly.
Non-default middleware/enhancers must use Tuple
We've seen many cases where users passing the middleware parameter to configureStore have tried spreading the array returned by getDefaultMiddleware(), or passed an alternate plain array. This unfortunately loses the exact TS types from the individual middleware, and often causes TS problems down the road (such as dispatch being typed as Dispatch<AnyAction> and not knowing about thunks).
getDefaultMiddleware() already used an internal MiddlewareArray class, an Array subclass that had strongly typed .concat/prepend() methods to correctly capture and retain the middleware types.
We've renamed that type to Tuple, and configureStore's TS types now require that you must use Tuple if you want to pass your own array of middleware:
import { configureStore, Tuple } from '@reduxjs/toolkit'

configureStore({
  reducer: rootReducer,
  middleware: getDefaultMiddleware => new Tuple(additionalMiddleware, logger)
})
(Note that this has no effect if you're using RTK with plain JS, and you could still pass a plain array here.)
This same restriction applies to the enhancers field.
Entity adapter type updates
createEntityAdapter now has an Id generic argument, which will be used to strongly type the item IDs anywhere those are exposed. Previously, the ID field type was always string | number. TS will now try to infer the exact type from either the .id field of your entity type, or the selectId return type. You could also fall back to passing that generic type directly. If you use the EntityState<Data, Id> type directly, you must supply both generic arguments!
The .entities lookup table is now defined to use a standard TS Record<Id, MyEntityType>, which assumes that each item lookup exists by default. Previously, it used a Dictionary<MyEntityType> type, which assumed the result was MyEntityType | undefined. The Dictionary type has been removed.
If you prefer to assume that the lookups might be undefined, use TypeScript's noUncheckedIndexedAccess configuration option to control that.
Reselect
createSelector Uses weakMapMemoize As Default Memoizer
createSelector now uses a new default memoization function called weakMapMemoize. This memoizer offers an effectively infinite cache size, which should simplify usage with varying arguments, but relies exclusively on reference comparisons.
If you need to customize equality comparisons, customize createSelector to use the original lruMemoize method instead:
createSelector(inputs, resultFn, {
  memoize: lruMemoize,
  memoizeOptions: { equalityCheck: yourEqualityFunction }
})
defaultMemoize Renamed to lruMemoize
Since the original defaultMemoize function is no longer actually the default, we've renamed it to lruMemoize for clarity. This only matters if you specifically imported it into your app to customize selectors.
createSelector Dev-Mode Checks
createSelector now does checks in development mode for common mistakes, like input selectors that always return new references, or result functions that immediately return their argument. These checks can be customized at selector creation or globally.
This is important, as an input selector returning a materially different result with the same parameters means that the output selector will never memoize correctly and be run unnecessarily, thus (potentially) creating a new result and causing rerenders.
const addNumbers = createSelector(
  // this input selector will always return a new reference when run
  // so cache will never be used
  (a, b) => ({ a, b }),
  ({ a, b }) => ({ total: a + b })
)
// instead, you should have an input selector for each stable piece of data
const addNumbersStable = createSelector(
  (a, b) => a,
  (a, b) => b,
  (a, b) => ({
    total: a + b
  })
)
This is done the first time the selector is called, unless configured otherwise. More details are available in the Reselect docs on dev-mode checks.
Note that while RTK re-exports createSelector, it intentionally does not re-export the function to configure this check globally - if you wish to do so, you should instead depend on reselect directly and import it yourself.
ParametricSelector Types Removed
The ParametricSelector and OutputParametricSelector types have been removed. Use Selector and OutputSelector instead.
React-Redux
Requires React 18
React-Redux v7 and v8 worked with all versions of React that supported hooks (16.8+, 17, and 18). v8 switched from internal subscription management to React's new useSyncExternalStore hook, but used the ""shim"" implementation to provide support for React 16.8 and 17, which did not have that hook built in.
React-Redux v9 switches to requiring React 18, and does not support React 16 or 17. This allows us to drop the shim and save a small bit of bundle size.
Redux Thunk
Thunk Uses Named Exports
The redux-thunk package previously used a single default export that was the middleware, with an attached field named withExtraArgument that allowed customization.
The default export has been removed. There are now two named exports: thunk (the basic middleware) and withExtraArgument.
If you are using Redux Toolkit, this should have no effect, as RTK already handles this inside of configureStore.
New Features
These features are new in Redux Toolkit 2.0, and help cover additional use cases that we've seen users ask for in the ecosystem.
combineSlices API with slice reducer injection for code-splitting
The Redux core has always included combineReducers, which takes an object full of ""slice reducer"" functions and generates a reducer that calls those slice reducers. RTK's createSlice generates slice reducers + associated action creators, and we've taught the pattern of exporting individual action creators as named exports and the slice reducer as a default export. Meanwhile, we've never had official support for lazy-loading reducers, although we've had sample code for some ""reducer injection"" patterns in our docs.
This release includes a new combineSlices API that is designed to enable lazy-loading of reducers at runtime. It accepts individual slices or an object full of slices as arguments, and automatically calls combineReducers using the sliceObject.name field as the key for each state field. The generated reducer function has an additional .inject() method attached that can be used to dynamically inject additional slices at runtime. It also includes a .withLazyLoadedSlices() method that can be used to generate TS types for reducers that will be added later. See #2776 for the original discussion around this idea.
For now, we are not building this into configureStore, so you'll need to call const rootReducer = combineSlices(.....) yourself and pass that to configureStore({reducer: rootReducer}).
Basic usage: a mixture of slices and standalone reducers passed to combineSlices
const stringSlice = createSlice({
  name: 'string',
  initialState: '',
  reducers: {}
})

const numberSlice = createSlice({
  name: 'number',
  initialState: 0,
  reducers: {}
})

const booleanReducer = createReducer(false, () => {})

const api = createApi(/*  */)

const combinedReducer = combineSlices(
  stringSlice,
  {
    num: numberSlice.reducer,
    boolean: booleanReducer
  },
  api
)
expect(combinedReducer(undefined, dummyAction())).toEqual({
  string: stringSlice.getInitialState(),
  num: numberSlice.getInitialState(),
  boolean: booleanReducer.getInitialState(),
  api: api.reducer.getInitialState()
})
Basic slice reducer injection
// Create a reducer with a TS type that knows `numberSlice` will be injected
const combinedReducer =
  combineSlices(stringSlice).withLazyLoadedSlices<
    WithSlice<typeof numberSlice>
  >()

// `state.number` doesn't exist initially
expect(combinedReducer(undefined, dummyAction()).number).toBe(undefined)

// Create a version of the reducer with `numberSlice` injected (mainly useful for types)
const injectedReducer = combinedReducer.inject(numberSlice)

// `state.number` now exists, and injectedReducer's type no longer marks it as optional
expect(injectedReducer(undefined, dummyAction()).number).toBe(
  numberSlice.getInitialState()
)

// original reducer has also been changed (type is still optional)
expect(combinedReducer(undefined, dummyAction()).number).toBe(
  numberSlice.getInitialState()
)
selectors field in createSlice
The existing createSlice API now has support for defining selectors directly as part of the slice. By default, these will be generated with the assumption that the slice is mounted in the root state using slice.name as the field, such as name: ""todos"" -> rootState.todos. Additionally, there's now a slice.selectSlice method that does that default root state lookup.
You can call sliceObject.getSelectors(selectSliceState) to generate the selectors with an alternate location, similar to how entityAdapter.getSelectors() works.
const slice = createSlice({
  name: 'counter',
  initialState: 42,
  reducers: {},
  selectors: {
    selectSlice: state => state,
    selectMultiple: (state, multiplier: number) => state * multiplier
  }
})

// Basic usage
const testState = {
  [slice.name]: slice.getInitialState()
}
const { selectSlice, selectMultiple } = slice.selectors
expect(selectSlice(testState)).toBe(slice.getInitialState())
expect(selectMultiple(testState, 2)).toBe(slice.getInitialState() * 2)

// Usage with the slice reducer mounted under a different key
const customState = {
  number: slice.getInitialState()
}
const { selectSlice, selectMultiple } = slice.getSelectors(
  (state: typeof customState) => state.number
)
expect(selectSlice(customState)).toBe(slice.getInitialState())
expect(selectMultiple(customState, 2)).toBe(slice.getInitialState() * 2)
createSlice.reducers callback syntax and thunk support
One of the oldest feature requests we've had is the ability to declare thunks directly inside of createSlice. Until now, you've always had to declare them separately, give the thunk a string action prefix, and handle the actions via createSlice.extraReducers:
// Declare the thunk separately
const fetchUserById = createAsyncThunk(
  'users/fetchByIdStatus',
  async (userId: number, thunkAPI) => {
    const response = await userAPI.fetchById(userId)
    return response.data
  }
)

const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    // standard reducer logic, with auto-generated action types per reducer
  },
  extraReducers: builder => {
    // Add reducers for additional action types here, and handle loading state as needed
    builder.addCase(fetchUserById.fulfilled, (state, action) => {
      state.entities.push(action.payload)
    })
  }
})
Many users have told us that this separation feels awkward.
We've wanted to include a way to define thunks directly inside of createSlice, and have played around with various prototypes. There were always two major blocking issues, and a secondary concern:
It wasn't clear what the syntax for declaring a thunk inside should look like.
Thunks have access to getState and dispatch, but the RootState and AppDispatch types are normally inferred from the store, which in turn infers it from the slice state types. Declaring thunks inside createSlice would cause circular type inference errors, as the store needs the slice types but the slice needs the store types. We weren't willing to ship an API that would work okay for our JS users but not for our TS users, especially since we want people to use TS with RTK.
You can't do synchronous conditional imports in ES modules, and there's no good way to make the createAsyncThunk import optional. Either createSlice always depends on it (and adds that to the bundle size), or it can't use createAsyncThunk at all.
We've settled on these compromises:
In order to create async thunks with createSlice, you specifically need to set up a custom version of createSlice that has access to createAsyncThunk.
You can declare thunks inside of createSlice.reducers, by using a ""creator callback"" syntax for the reducers field that is similar to the build callback syntax in RTK Query's createApi (using typed functions to create fields in an object). Doing this does look a bit different than the existing ""object"" syntax for the reducers field, but is still fairly similar.
You can customize some of the types for thunks inside of createSlice, but you cannot customize the state or dispatch types. If those are needed, you can manually do an as cast, like getState() as RootState.
In practice, we hope these are reasonable tradeoffs. Creating thunks inside of createSlice has been widely asked for, so we think it's an API that will see usage. If the TS customization options are a limitation, you can still declare thunks outside of createSlice as always, and most async thunks don't need dispatch or getState - they just fetch data and return. And finally, setting up a custom createSlice allows you to opt into createAsyncThunk being included in your bundle size (though it may already be included if used directly or as part of RTK Query - in either of these cases there's no additional bundle size).
Here's what the new callback syntax looks like:
const createSliceWithThunks = buildCreateSlice({
  creators: { asyncThunk: asyncThunkCreator }
})

const todosSlice = createSliceWithThunks({
  name: 'todos',
  initialState: {
    loading: false,
    todos: [],
    error: null
  } as TodoState,
  reducers: create => ({
    // A normal ""case reducer"", same as always
    deleteTodo: create.reducer((state, action: PayloadAction<number>) => {
      state.todos.splice(action.payload, 1)
    }),
    // A case reducer with a ""prepare callback"" to customize the action
    addTodo: create.preparedReducer(
      (text: string) => {
        const id = nanoid()
        return { payload: { id, text } }
      },
      // action type is inferred from prepare callback
      (state, action) => {
        state.todos.push(action.payload)
      }
    ),
    // An async thunk
    fetchTodo: create.asyncThunk(
      // Async payload function as the first argument
      async (id: string, thunkApi) => {
        const res = await fetch(`myApi/todos?id=${id}`)
        return (await res.json()) as Item
      },
      // An object containing `{pending?, rejected?, fulfilled?, settled?, options?}` second
      {
        pending: state => {
          state.loading = true
        },
        rejected: (state, action) => {
          state.error = action.payload ?? action.error
        },
        fulfilled: (state, action) => {
          state.todos.push(action.payload)
        },
        // settled is called for both rejected and fulfilled actions
        settled: (state, action) => {
          state.loading = false
        }
      }
    )
  })
})

// `addTodo` and `deleteTodo` are normal action creators.
// `fetchTodo` is the async thunk
export const { addTodo, deleteTodo, fetchTodo } = todosSlice.actions
Codemod
Using the new callback syntax is entirely optional (the object syntax is still standard), but an existing slice would need to be converted before it can take advantage of the new capabilities this syntax provides. To make this easier, a codemod is provided.
npx @reduxjs/rtk-codemods createSliceReducerBuilder ./src/features/todos/slice.ts
""Dynamic middleware"" middleware
A Redux store's middleware pipeline is fixed at store creation time and can't be changed later. We have seen ecosystem libraries that tried to allow dynamically adding and removing middleware, potentially useful for things like code splitting.
This is a relatively niche use case, but we've built our own version of a ""dynamic middleware"" middleware. Add it to the Redux store at setup time, and it lets you add middleware later at runtime. It also comes with a React hook integration that will automatically add a middleware to the store and return the updated dispatch method..
import { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'

const dynamicMiddleware = createDynamicMiddleware()

const store = configureStore({
  reducer: {
    todos: todosReducer
  },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().prepend(dynamicMiddleware.middleware)
})

// later
dynamicMiddleware.addMiddleware(someOtherMiddleware)
configureStore adds autoBatchEnhancer by default
In v1.9.0, we added a new autoBatchEnhancer that delays notifying subscribers briefly when multiple ""low-priority"" actions are dispatched in a row. This improves perf, as UI updates are typically the most expensive part of the update process. RTK Query marks most of its own internal actions as ""low-pri"" by default, but you have to have the autoBatchEnhancer added to the store to benefit from that.
We've updated configureStore to add the autoBatchEnhancer to the store setup by default, so that users can benefit from the improved perf without needing to manually tweak the store config themselves.
entityAdapter.getSelectors accepts a createSelector function
entityAdapter.getSelectors() now accepts an options object as its second argument. This allows you to pass in your own preferred createSelector method, which will be used to memoize the generated selectors. This could be useful if you want to use one of Reselect's new alternate memoizers, or some other memoization library with an equivalent signature.
Immer 10.0
Immer 10.0 is now final, and has several major improvements and updates:
Much faster update perf
Much smaller bundle size
Better ESM/CJS package formatting
No default export
No ES5 fallback
We've updated RTK to depend on the final Immer 10.0 release.
Next.js Setup Guide
We now have a docs page that covers how to set up Redux properly with Next.js. We've seen a lot of questions around using Redux, Next, and the App Router together, and this guide should help provide advice.
(At this time, the Next.js with-redux example is still showing outdated patterns - we're going to file a PR shortly to update that to match our docs guide.)
Overriding dependencies
It will take a while for packages to update their peer dependencies to allow for Redux core 5.0, and in the meantime changes like the Middleware type will result in perceived incompatibilities.
It's likely that most libraries will not actually have any practices that are incompatible with 5.0, but due to the peer dependency on 4.0 they end up pulling in old type declarations.
This can be solved by manually overriding the dependency resolution, which is supported by both npm and yarn.
npm - overrides
NPM supports this through an overrides field in your package.json. You can override the dependency for a specific package, or make sure that every package that pulls in Redux receives the same version.
Individual override - redux-persist
{
  ""overrides"": {
    ""redux-persist"": {
      ""redux"": ""^5.0.0""
    }
  }
}
Blanket override
{
  ""overrides"": {
    ""redux"": ""^5.0.0""
  }
}
yarn - resolutions
Yarn supports this through a resolutions field in your package.json. Just like with NPM, you can override the dependency for a specific package, or make sure that every package that pulls in Redux receives the same version.
Individual override - redux-persist
{
  ""resolutions"": {
    ""redux-persist/redux"": ""^5.0.0""
  }
}
Blanket override
{
  ""resolutions"": {
    ""redux"": ""^5.0.0""
  }
}
Recommendations
Based on changes in 2.0 and previous versions, there have been some shifts in thinking that are good to know about, if non-essential.
Alternatives to actionCreator.toString()
As part of RTK's original API, action creators made with createAction have a custom toString() override that returns the action type.
This was primarily useful for the (now removed) object syntax for createReducer:
const todoAdded = createAction<Todo>('todos/todoAdded')

createReducer(initialState, {
  [todoAdded]: (state, action) => {} // toString called here, 'todos/todoAdded'
})
While this was convenient (and other libraries in the Redux ecosystem such as redux-saga and redux-observable have supported this to various capacities), it didn't play well with Typescript and was generally a bit too ""magic"".
const test = todoAdded.toString()
//    ^? typed as string, rather than specific action type
Over time, the action creator also gained a static type property and match method which were more explicit and worked better with Typescript.
const test = todoAdded.type
//    ^? 'todos/todoAdded'

// acts as a type predicate
if (todoAdded.match(unknownAction)) {
  unknownAction.payload
  // ^? now typed as PayloadAction<Todo>
}
For compatibility, this override is still in place, but we encourage considering using either of the static properties for more understandable code.
For example, with redux-observable:
// before (works in runtime, will not filter types properly)
const epic = (action$: Observable<Action>) =>
  action$.pipe(
    ofType(todoAdded),
    map(action => action)
    //   ^? still Action<any>
  )

// consider (better type filtering)
const epic = (action$: Observable<Action>) =>
  action$.pipe(
    filter(todoAdded.match),
    map(action => action)
    //   ^? now PayloadAction<Todo>
  )
With redux-saga:
// before (still works)
yield takeEvery(todoAdded, saga)

// consider
yield takeEvery(todoAdded.match, saga)
// or
yield takeEvery(todoAdded.type, saga)
Future plans
Custom slice reducer creators
With the addition of the callback syntax for createSlice, the suggestion was made to enable custom slice reducer creators. These creators would be able to:
Modify reducer behaviour by adding case or matcher reducers
Attach actions (or any other useful functions) to slice.actions
Attach provided case reducers to slice.caseReducers
The creator would need to first return a ""definition"" shape when createSlice is first called, which it then handles by adding any necessary reducers and/or actions.
An API for this is not set in stone, but the existing create.asyncThunk creator implemented with a potential API could look like:
const asyncThunkCreator = {
  type: ReducerType.asyncThunk,
  define(payloadCreator, config) {
    return {
      type: ReducerType.asyncThunk, // needs to match reducer type, so correct handler can be called
      payloadCreator,
      ...config
    }
  },
  handle(
    {
      // the key the reducer was defined under
      reducerName,
      // the autogenerated action type, i.e. `${slice.name}/${reducerName}`
      type
    },
    // the definition from define()
    definition,
    // methods to modify slice
    context
  ) {
    const { payloadCreator, options, pending, fulfilled, rejected, settled } =
      definition
    const asyncThunk = createAsyncThunk(type, payloadCreator, options)

    if (pending) context.addCase(asyncThunk.pending, pending)
    if (fulfilled) context.addCase(asyncThunk.fulfilled, fulfilled)
    if (rejected) context.addCase(asyncThunk.rejected, rejected)
    if (settled) context.addMatcher(asyncThunk.settled, settled)

    context.exposeAction(reducerName, asyncThunk)
    context.exposeCaseReducer(reducerName, {
      pending: pending || noop,
      fulfilled: fulfilled || noop,
      rejected: rejected || noop,
      settled: settled || noop
    })
  }
}

const createSlice = buildCreateSlice({
  creators: {
    asyncThunk: asyncThunkCreator
  }
})
We're not sure how many people/libraries would actually make use of this though, so any feedback over on the Github issue is welcome!
createSlice.selector selector factories
There have been some concerns raised internally about whether createSlice.selectors supports memoized selectors sufficiently. You can provide a memoized selector to your createSlice.selectors configuration, but you're stuck with that one instance.
const todoSlice = createSlice({
  name: 'todos',
  initialState: {
    todos: [] as Todo[]
  },
  reducers: {},
  selectors: {
    selectTodosByAuthor = createSelector(
      (state: TodoState) => state.todos,
      (state: TodoState, author: string) => author,
      (todos, author) => todos.filter(todo => todo.author === author)
    )
  }
})

export const { selectTodosByAuthor } = todoSlice.selectors
With createSelector's default cache size of 1, this can cause caching issues if called in multiple components with different arguments. One typical solution for this (without createSlice) is a selector factory:
export const makeSelectTodosByAuthor = () =>
  createSelector(
    (state: RootState) => state.todos.todos,
    (state: RootState, author: string) => author,
    (todos, author) => todos.filter(todo => todo.author === author)
  )

function AuthorTodos({ author }: { author: string }) {
  const selectTodosByAuthor = useMemo(makeSelectTodosByAuthor, [])
  const todos = useSelector(state => selectTodosByAuthor(state, author))
}
Of course, with createSlice.selectors this is no longer possible, as you need the selector instance when creating your slice.
In 2.0.0 we have no set solution for this - a few APIs have been floated (PR 1, PR 2) but nothing was decided upon. If this is something you'd like to see supported, consider providing feedback in the Github discussion!
3.0 - RTK Query
RTK 2.0 was largely focused on core and toolkit changes. Now that 2.0 is released, we would like to shift our focus to RTK Query, as there are still some rough edges to iron out - some of which may require breaking changes, necessitating a 3.0 release.
If you have any feedback for what that could look like, please consider chiming in at the RTK Query API pain points and rough spots feedback thread!
Edit this page
Last updated on Dec 16, 2023""""""",9196,42890,redux
https://redux.js.org/usage/usage-with-typescript,"""""""Using ReduxCode QualityUsage With TypeScript
Usage with TypeScript
WHAT YOU'LL LEARN
Standard patterns for setting up a Redux app with TypeScript
Techniques for correctly typing portions of Redux logic
PREREQUISITES
Understanding of TypeScript syntax and terms
Familiarity with TypeScript concepts like generics and utility types
Knowledge of React Hooks
Overview
TypeScript is a typed superset of JavaScript that provides compile-time checking of source code. When used with Redux, TypeScript can help provide:
Type safety for reducers, state and action creators, and UI components
Easy refactoring of typed code
A superior developer experience in a team environment
We strongly recommend using TypeScript in Redux applications. However, like all tools, TypeScript has tradeoffs. It adds complexity in terms of writing additional code, understanding TS syntax, and building the application. At the same time, it provides value by catching errors earlier in development, enabling safer and more efficient refactoring, and acting as documentation for existing source code.
We believe that pragmatic use of TypeScript provides more than enough value and benefit to justify the added overhead, especially in larger codebases, but you should take time to evaluate the tradeoffs and decide whether it's worth using TS in your own application.
There are multiple possible approaches to type checking Redux code. This page shows our standard recommended patterns for using Redux and TypeScript together, and is not an exhaustive guide. Following these patterns should result in a good TS usage experience, with the best tradeoffs between type safety and amount of type declarations you have to add to your codebase.
Standard Redux Toolkit Project Setup with TypeScript
We assume that a typical Redux project is using Redux Toolkit and React Redux together.
Redux Toolkit (RTK) is the standard approach for writing modern Redux logic. RTK is already written in TypeScript, and its API is designed to provide a good experience for TypeScript usage.
React Redux has its type definitions in a separate @types/react-redux typedefs package on NPM. In addition to typing the library functions, the types also export some helpers to make it easier to write typesafe interfaces between your Redux store and your React components.
As of React Redux v7.2.3, the react-redux package has a dependency on @types/react-redux, so the type definitions will be automatically installed with the library. Otherwise, you'll need to manually install them yourself (typically npm install @types/react-redux ).
The Redux+TS template for Create-React-App comes with a working example of these patterns already configured.
Define Root State and Dispatch Types
Using configureStore should not need any additional typings. You will, however, want to extract the RootState type and the Dispatch type so that they can be referenced as needed. Inferring these types from the store itself means that they correctly update as you add more state slices or modify middleware settings.
Since those are types, it's safe to export them directly from your store setup file such as app/store.ts and import them directly into other files.
app/store.ts
import { configureStore } from '@reduxjs/toolkit'
// ...

export const store = configureStore({
  reducer: {
    posts: postsReducer,
    comments: commentsReducer,
    users: usersReducer
  }
})

// Get the type of our store variable
export type AppStore = typeof store
// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<AppStore['getState']>
// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}
export type AppDispatch = AppStore['dispatch']
Define Typed Hooks
While it's possible to import the RootState and AppDispatch types into each component, it's better to create pre-typed versions of the useDispatch and useSelector hooks for usage in your application. This is important for a couple reasons:
For useSelector, it saves you the need to type (state: RootState) every time
For useDispatch, the default Dispatch type does not know about thunks or other middleware. In order to correctly dispatch thunks, you need to use the specific customized AppDispatch type from the store that includes the thunk middleware types, and use that with useDispatch. Adding a pre-typed useDispatch hook keeps you from forgetting to import AppDispatch where it's needed.
Since these are actual variables, not types, it's important to define them in a separate file such as app/hooks.ts, not the store setup file. This allows you to import them into any component file that needs to use the hooks, and avoids potential circular import dependency issues.
.withTypes()
Previously, the approach for ""pre-typing"" hooks with your app setting was a little varied. The result would look something like the snippet below:
app/hooks.ts
import type { TypedUseSelectorHook } from 'react-redux'
import { useDispatch, useSelector, useStore } from 'react-redux'
import type { AppDispatch, AppStore, RootState } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector
export const useAppStore: () => AppStore = useStore
React Redux v9.1.0 adds a new .withTypes method to each of these hooks, analogous to the .withTypes method found on Redux Toolkit's createAsyncThunk.
The setup now becomes:
app/hooks.ts
import { useDispatch, useSelector, useStore } from 'react-redux'
import type { AppDispatch, AppStore, RootState } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()
export const useAppStore = useStore.withTypes<AppStore>()
Application Usage
Define Slice State and Action Types
Each slice file should define a type for its initial state value, so that createSlice can correctly infer the type of state in each case reducer.
All generated actions should be defined using the PayloadAction<T> type from Redux Toolkit, which takes the type of the action.payload field as its generic argument.
You can safely import the RootState type from the store file here. It's a circular import, but the TypeScript compiler can correctly handle that for types. This may be needed for use cases like writing selector functions.
features/counter/counterSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit'
import type { RootState } from '../../app/store'

// Define a type for the slice state
interface CounterState {
  value: number
}

// Define the initial state using that type
const initialState: CounterState = {
  value: 0
}

export const counterSlice = createSlice({
  name: 'counter',
  // `createSlice` will infer the state type from the `initialState` argument
  initialState,
  reducers: {
    increment: state => {
      state.value += 1
    },
    decrement: state => {
      state.value -= 1
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload
    }
  }
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions

// Other code such as selectors can use the imported `RootState` type
export const selectCount = (state: RootState) => state.counter.value

export default counterSlice.reducer
The generated action creators will be correctly typed to accept a payload argument based on the PayloadAction<T> type you provided for the reducer. For example, incrementByAmount requires a number as its argument.
In some cases, TypeScript may unnecessarily tighten the type of the initial state. If that happens, you can work around it by casting the initial state using as, instead of declaring the type of the variable:
// Workaround: cast state instead of declaring variable type
const initialState = {
  value: 0
} as CounterState
Use Typed Hooks in Components
In component files, import the pre-typed hooks instead of the standard hooks from React Redux.
features/counter/Counter.tsx
import React, { useState } from 'react'

import { useAppSelector, useAppDispatch } from 'app/hooks'

import { decrement, increment } from './counterSlice'

export function Counter() {
  // The `state` arg is correctly typed as `RootState` already
  const count = useAppSelector(state => state.counter.value)
  const dispatch = useAppDispatch()

  // omit rendering logic
}
WARN ABOUT WRONG IMPORTS
ESLint can help your team import the right hooks easily. The typescript-eslint/no-restricted-imports rule can show a warning when the wrong import is used accidentally.
You could add this to your ESLint config as an example:
""no-restricted-imports"": ""off"",
""@typescript-eslint/no-restricted-imports"": [
  ""warn"",
  {
    ""name"": ""react-redux"",
    ""importNames"": [""useSelector"", ""useDispatch""],
    ""message"": ""Use typed hooks `useAppDispatch` and `useAppSelector` instead.""
  }
],
Typing Additional Redux Logic
Type Checking Reducers
Reducers are pure functions that receive the current state and incoming action as arguments, and return a new state.
If you are using Redux Toolkit's createSlice, you should rarely need to specifically type a reducer separately. If you do actually write a standalone reducer, it's typically sufficient to declare the type of the initialState value, and type the action as UnknownAction:
import { UnknownAction } from 'redux'

interface CounterState {
  value: number
}

const initialState: CounterState = {
  value: 0
}

export default function counterReducer(
  state = initialState,
  action: UnknownAction
) {
  // logic here
}
However, the Redux core does export a Reducer<State, Action> type you can use as well.
Type Checking Middleware
Middleware are an extension mechanism for the Redux store. Middleware are composed into a pipeline that wrap the store's dispatch method, and have access to the store's dispatch and getState methods.
The Redux core exports a Middleware type that can be used to correctly type a middleware function:
export interface Middleware<
  DispatchExt = {}, // optional override return behavior of `dispatch`
  S = any, // type of the Redux store state
  D extends Dispatch = Dispatch // type of the dispatch method
>
A custom middleware should use the Middleware type, and pass the generic args for S (state) and D (dispatch) if needed:
import { Middleware } from 'redux'

import { RootState } from '../store'

export const exampleMiddleware: Middleware<
  {}, // Most middleware do not modify the dispatch return value
  RootState
> = storeApi => next => action => {
  const state = storeApi.getState() // correctly typed as RootState
}
CAUTION
If you are using typescript-eslint, the @typescript-eslint/ban-types rule might report an error if you use {} for the dispatch value. The recommended changes it makes are incorrect and will break your Redux store types, you should disable the rule for this line and keep using {}.
The dispatch generic should likely only be needed if you are dispatching additional thunks within the middleware.
In cases where type RootState = ReturnType<typeof store.getState> is used, a circular type reference between the middleware and store definitions can be avoided by switching the type definition of RootState to:
const rootReducer = combineReducers({ ... });
type RootState = ReturnType<typeof rootReducer>;
Switching the type definition of RootState with Redux Toolkit example:
//instead of defining the reducers in the reducer field of configureStore, combine them here:
const rootReducer = combineReducers({ counter: counterReducer })

//then set rootReducer as the reducer object of configureStore
const store = configureStore({
  reducer: rootReducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().concat(yourMiddleware)
})

type RootState = ReturnType<typeof rootReducer>
Type Checking Redux Thunks
Redux Thunk is the standard middleware for writing sync and async logic that interacts with the Redux store. A thunk function receives dispatch and getState as its parameters. Redux Thunk has a built in ThunkAction type which we can use to define types for those arguments:
export type ThunkAction<
  R, // Return type of the thunk function
  S, // state type used by getState
  E, // any ""extra argument"" injected into the thunk
  A extends Action // known types of actions that can be dispatched
> = (dispatch: ThunkDispatch<S, E, A>, getState: () => S, extraArgument: E) => R
You will typically want to provide the R (return type) and S (state) generic arguments. Unfortunately, TS does not allow only providing some generic arguments, so the usual values for the other arguments are unknown for E and UnknownAction for A:
import { UnknownAction } from 'redux'
import { sendMessage } from './store/chat/actions'
import { RootState } from './store'
import { ThunkAction } from 'redux-thunk'

export const thunkSendMessage =
  (message: string): ThunkAction<void, RootState, unknown, UnknownAction> =>
  async dispatch => {
    const asyncResp = await exampleAPI()
    dispatch(
      sendMessage({
        message,
        user: asyncResp,
        timestamp: new Date().getTime()
      })
    )
  }

function exampleAPI() {
  return Promise.resolve('Async Chat Bot')
}
To reduce repetition, you might want to define a reusable AppThunk type once, in your store file, and then use that type whenever you write a thunk:
export type AppThunk<ReturnType = void> = ThunkAction<
  ReturnType,
  RootState,
  unknown,
  UnknownAction
>
Note that this assumes that there is no meaningful return value from the thunk. If your thunk returns a promise and you want to use the returned promise after dispatching the thunk, you'd want to use this as AppThunk<Promise<SomeReturnType>>.
CAUTION
Don't forget that the default useDispatch hook does not know about thunks, and so dispatching a thunk will cause a type error. Be sure to use an updated form of Dispatch in your components that recognizes thunks as an acceptable type to dispatch.
Usage with React Redux
While React Redux is a separate library from Redux itself, it is commonly used with React.
For a complete guide on how to correctly use React Redux with TypeScript, see the ""Static Typing"" page in the React Redux docs. This section will highlight the standard patterns.
If you are using TypeScript, the React Redux types are maintained separately in DefinitelyTyped, but included as a dependency of the react-redux package, so they should be installed automatically. If you still need to install them manually, run:
npm install @types/react-redux
Typing the useSelector hook
Declare the type of the state parameter in the selector function, and the return type of useSelector will be inferred to match the return type of the selector:
interface RootState {
  isOn: boolean
}

// TS infers type: (state: RootState) => boolean
const selectIsOn = (state: RootState) => state.isOn

// TS infers `isOn` is boolean
const isOn = useSelector(selectIsOn)
This can also be done inline as well:
const isOn = useSelector((state: RootState) => state.isOn)
However, prefer creating a pre-typed useAppSelector hook with the correct type of state built-in instead.
Typing the useDispatch hook
By default, the return value of useDispatch is the standard Dispatch type defined by the Redux core types, so no declarations are needed:
const dispatch = useDispatch()
However, prefer creating a pre-typed useAppDispatch hook with the correct type of Dispatch built-in instead.
Typing the connect higher order component
If you are still using connect, you should use the ConnectedProps<T> type exported by @types/react-redux^7.1.2 to infer the types of the props from connect automatically. This requires splitting the connect(mapState, mapDispatch)(MyComponent) call into two parts:
import { connect, ConnectedProps } from 'react-redux'

interface RootState {
  isOn: boolean
}

const mapState = (state: RootState) => ({
  isOn: state.isOn
})

const mapDispatch = {
  toggleOn: () => ({ type: 'TOGGLE_IS_ON' })
}

const connector = connect(mapState, mapDispatch)

// The inferred type will look like:
// {isOn: boolean, toggleOn: () => void}
type PropsFromRedux = ConnectedProps<typeof connector>

type Props = PropsFromRedux & {
  backgroundColor: string
}

const MyComponent = (props: Props) => (
  <div style={{ backgroundColor: props.backgroundColor }}>
    <button onClick={props.toggleOn}>
      Toggle is {props.isOn ? 'ON' : 'OFF'}
    </button>
  </div>
)

export default connector(MyComponent)
Usage with Redux Toolkit
The Standard Redux Toolkit Project Setup with TypeScript section already covered the normal usage patterns for configureStore and createSlice, and the Redux Toolkit ""Usage with TypeScript"" page covers all of the RTK APIs in detail.
Here are some additional typing patterns you will commonly see when using RTK.
Typing configureStore
configureStore infers the type of the state value from the provided root reducer function, so no specific type declarations should be needed.
If you want to add additional middleware to the store, be sure to use the specialized .concat() and .prepend() methods included in the array returned by getDefaultMiddleware(), as those will correctly preserve the types of the middleware you're adding. (Using plain JS array spreads often loses those types.)
const store = configureStore({
  reducer: rootReducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware()
      .prepend(
        // correctly typed middlewares can just be used
        additionalMiddleware,
        // you can also type middlewares manually
        untypedMiddleware as Middleware<
          (action: Action<'specialAction'>) => number,
          RootState
        >
      )
      // prepend and concat calls can be chained
      .concat(logger)
})
Matching Actions
RTK-generated action creators have a match method that acts as a type predicate. Calling someActionCreator.match(action) will do a string comparison against the action.type string, and if used as a condition, narrow the type of action down to be the correct TS type:
const increment = createAction<number>('increment')
function test(action: Action) {
  if (increment.match(action)) {
    // action.payload inferred correctly here
    const num = 5 + action.payload
  }
}
This is particularly useful when checking for action types in Redux middleware, such as custom middleware, redux-observable, and RxJS's filter method.
Typing createSlice
Defining Separate Case Reducers
If you have too many case reducers and defining them inline would be messy, or you want to reuse case reducers across slices, you can also define them outside the createSlice call and type them as CaseReducer:
type State = number
const increment: CaseReducer<State, PayloadAction<number>> = (state, action) =>
  state + action.payload

createSlice({
  name: 'test',
  initialState: 0,
  reducers: {
    increment
  }
})
Typing extraReducers
If you are adding an extraReducers field in createSlice, be sure to use the ""builder callback"" form, as the ""plain object"" form cannot infer action types correctly. Passing an RTK-generated action creator to builder.addCase() will correctly infer the type of the action:
const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    // fill in primary logic here
  },
  extraReducers: builder => {
    builder.addCase(fetchUserById.pending, (state, action) => {
      // both `state` and `action` are now correctly typed
      // based on the slice state and the `pending` action creator
    })
  }
})
Typing prepare Callbacks
If you want to add a meta or error property to your action, or customize the payload of your action, you have to use the prepare notation for defining the case reducer. Using this notation with TypeScript looks like:
const blogSlice = createSlice({
  name: 'blogData',
  initialState,
  reducers: {
    receivedAll: {
      reducer(
        state,
        action: PayloadAction<Page[], string, { currentPage: number }>
      ) {
        state.all = action.payload
        state.meta = action.meta
      },
      prepare(payload: Page[], currentPage: number) {
        return { payload, meta: { currentPage } }
      }
    }
  }
})
Fixing Circular Types in Exported Slices
Finally, on rare occasions you might need to export the slice reducer with a specific type in order to break a circular type dependency problem. This might look like:
export default counterSlice.reducer as Reducer<Counter>
Typing createAsyncThunk
For basic usage, the only type you need to provide for createAsyncThunk is the type of the single argument for your payload creation callback. You should also ensure that the return value of the callback is typed correctly:
const fetchUserById = createAsyncThunk(
  'users/fetchById',
  // Declare the type your function argument here:
  async (userId: number) => {
    const response = await fetch(`https://reqres.in/api/users/${userId}`)
    // Inferred return type: Promise<MyData>
    return (await response.json()) as MyData
  }
)

// the parameter of `fetchUserById` is automatically inferred to `number` here
// and dispatching the resulting thunkAction will return a Promise of a correctly
// typed ""fulfilled"" or ""rejected"" action.
const lastReturnedAction = await store.dispatch(fetchUserById(3))
If you need to modify the types of the thunkApi parameter, such as supplying the type of the state returned by getState(), you must supply the first two generic arguments for return type and payload argument, plus whichever ""thunkApi argument fields"" are relevant in an object:
const fetchUserById = createAsyncThunk<
  // Return type of the payload creator
  MyData,
  // First argument to the payload creator
  number,
  {
    // Optional fields for defining thunkApi field types
    dispatch: AppDispatch
    state: State
    extra: {
      jwt: string
    }
  }
>('users/fetchById', async (userId, thunkApi) => {
  const response = await fetch(`https://reqres.in/api/users/${userId}`, {
    headers: {
      Authorization: `Bearer ${thunkApi.extra.jwt}`
    }
  })
  return (await response.json()) as MyData
})
Typing createEntityAdapter
Usage of createEntityAdapter with Typescript varies based on whether your entities are normalized by an id property, or whether a custom selectId is needed.
If your entities are normalized by an id property, createEntityAdapter only requires you to specify the entity type as the single generic argument. For example:
interface Book {
  id: number
  title: string
}

// no selectId needed here, as the entity has an `id` property we can default to
const booksAdapter = createEntityAdapter<Book>({
  sortComparer: (a, b) => a.title.localeCompare(b.title)
})

const booksSlice = createSlice({
  name: 'books',
  // The type of the state is inferred here
  initialState: booksAdapter.getInitialState(),
  reducers: {
    bookAdded: booksAdapter.addOne,
    booksReceived(state, action: PayloadAction<{ books: Book[] }>) {
      booksAdapter.setAll(state, action.payload.books)
    }
  }
})
On the other hand, if the entity needs to be normalized by a different property, we instead recommend passing a custom selectId function and annotating there. This allows proper inference of the ID's type, instead of having to provide it manually.
interface Book {
  bookId: number
  title: string
  // ...
}

const booksAdapter = createEntityAdapter({
  selectId: (book: Book) => book.bookId,
  sortComparer: (a, b) => a.title.localeCompare(b.title)
})

const booksSlice = createSlice({
  name: 'books',
  // The type of the state is inferred here
  initialState: booksAdapter.getInitialState(),
  reducers: {
    bookAdded: booksAdapter.addOne,
    booksReceived(state, action: PayloadAction<{ books: Book[] }>) {
      booksAdapter.setAll(state, action.payload.books)
    }
  }
})
Additional Recommendations
Use the React Redux Hooks API
We recommend using the React Redux hooks API as the default approach. The hooks API is much simpler to use with TypeScript, as useSelector is a simple hook that takes a selector function, and the return type is easily inferred from the type of the state argument.
While connect still works fine, and can be typed, it's much more difficult to type correctly.
Avoid Action Type Unions
We specifically recommend against trying to create unions of action types, as it provides no real benefit and actually misleads the compiler in some ways. See RTK maintainer Lenz Weber's post Do Not Create Union Types with Redux Action Types for an explanation of why this is a problem.
In addition, if you're using createSlice, you already know that all actions defined by that slice are being handled correctly.
Resources
For further information, see these additional resources:
Redux library documentation:
React Redux docs: Static Typing: Examples of how to use the React Redux APIs with TypeScript
Redux Toolkit docs: Usage with TypeScript: Examples of how to use the Redux Toolkit APIs with TypeScript
React + Redux + TypeScript guides:
React+TypeScript Cheatsheet: a comprehensive guide to using React with TypeScript
React + Redux in TypeScript Guide: extensive information on patterns for using React and Redux with TypeScript
Note: while this guide has some useful info, many of the patterns it shows go against our recommended practices shown in this page, such as using action type unions. We link this out of completeness
Other articles:
Do Not Create Union Types with Redux Action Types
Redux with Code-Splitting and Type Checking
Edit this page
Last updated on Jun 4, 2024""""""",5446,25764,redux
https://redux.js.org/usage/writing-tests,"""""""Using ReduxCode QualityWriting Tests
Writing Tests
WHAT YOU'LL LEARN
Recommended practices for testing apps using Redux
Examples of test configuration and setup
Guiding Principles
The guiding principles for testing Redux logic closely follow that of React Testing Library:
The more your tests resemble the way your software is used, the more confidence they can give you. - Kent C. Dodds
Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking. However, you should consider whether each piece of your Redux code needs its own dedicated tests. In the majority of scenarios, the end-user does not know, and does not care whether Redux is used within the application at all. As such, the Redux code can be treated as an implementation detail of the app, without requiring explicit tests for the Redux code in many circumstances.
Our general advice for testing an app using Redux is:
Prefer writing integration tests with everything working together. For a React app using Redux, render a <Provider> with a real store instance wrapping the components being tested. Interactions with the page being tested should use real Redux logic, with API calls mocked out so app code doesn't have to change, and assert that the UI is updated appropriately.
If needed, use basic unit tests for pure functions such as particularly complex reducers or selectors. However, in many cases, these are just implementation details that are covered by integration tests instead.
Do not try to mock selector functions or the React-Redux hooks! Mocking imports from libraries is fragile, and doesn't give you confidence that your actual app code is working.
INFO
For background on why we recommend integration-style tests, see:
Kent C Dodds: Testing Implementation Details: thoughts on why he recommends avoiding testing implementation details.
Mark Erikson: Blogged Answers: The Evolution of Redux Testing Approaches: thoughts on how Redux testing has evolved from 'isolation' to 'integration' over time.
Setting Up a Test Environment
Test Runners
Redux can be tested with any test runner, since it's just plain JavaScript. One common option is Jest, a widely used test runner that comes with Create-React-App, and is used by the Redux library repos. If you're using Vite to build your project, you may be using Vitest as your test runner.
Typically, your test runner needs to be configured to compile JavaScript/TypeScript syntax. If you're going to be testing UI components, you will likely need to configure the test runner to use JSDOM to provide a mock DOM environment.
The examples in this page will assume you're using Jest, but the same patterns apply no matter what test runner you're using.
See these resources for typical test runner configuration instructions:
Jest:
Jest: Getting Started
Jest: Configuration - Test Environment
Vitest
Vitest: Getting Started
Vitest: Configuration - Test Environment
UI and Network Testing Tools
The Redux team recommends using React Testing Library (RTL) to test React components that connect to Redux. React Testing Library is a simple and complete React DOM testing utility that encourages good testing practices. It uses ReactDOM's render function and act from react-dom/tests-utils. (The Testing Library family of tools also includes adapters for many other popular frameworks as well.)
We also recommend using Mock Service Worker (MSW) to mock network requests, as this means your application logic does not need to be changed or mocked when writing tests.
DOM/React Testing Library
DOM Testing Library: Setup
React Testing Library: Setup
Testing Library Jest-DOM Matchers
Mock Service Worker
MSW: Installation
MSW: Setting up mock requests
MSW: Mock server configuration for Node
Integration Testing Connected Components and Redux Logic
Our recommendation for testing Redux-connected React components is via integration tests that include everything working together, with assertions aimed at verifying that the app behaves the way you expect when the user interacts with it in a given manner.
Example App Code
Consider the following userSlice slice, store, and App component:
TypeScript
JavaScript
features/users/usersSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'
import { userAPI } from './userAPI'
import type { RootState } from '../../app/store'

export const fetchUser = createAsyncThunk('user/fetchUser', async () => {
  const response = await userAPI.fetchUser()
  return response.data
})

interface UserState {
  name: string
  status: 'idle' | 'loading' | 'complete'
}

const initialState: UserState = {
  name: 'No user',
  status: 'idle'
}

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder.addCase(fetchUser.pending, (state, action) => {
      state.status = 'loading'
    })
    builder.addCase(fetchUser.fulfilled, (state, action) => {
      state.status = 'complete'
      state.name = action.payload
    })
  }
})

export const selectUserName = (state: RootState) => state.user.name
export const selectUserFetchStatus = (state: RootState) => state.user.status

export default userSlice.reducer
































TypeScript
JavaScript
app/store.ts
import { combineReducers, configureStore } from '@reduxjs/toolkit'
import userReducer from '../features/users/userSlice'
// Create the root reducer independently to obtain the RootState type
const rootReducer = combineReducers({
  user: userReducer
})
export function setupStore(preloadedState?: Partial<RootState>) {
  return configureStore({
    reducer: rootReducer,
    preloadedState
  })
}
export type RootState = ReturnType<typeof rootReducer>
export type AppStore = ReturnType<typeof setupStore>
export type AppDispatch = AppStore['dispatch']












TypeScript
JavaScript
app/hooks.ts
import { useDispatch, useSelector } from 'react-redux'
import type { AppDispatch, RootState } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()





TypeScript
JavaScript
features/users/UserDisplay.tsx
import React from 'react'
import { useAppDispatch, useAppSelector } from '../../app/hooks'
import { fetchUser, selectUserName, selectUserFetchStatus } from './userSlice'

export default function UserDisplay() {
  const dispatch = useAppDispatch()
  const userName = useAppSelector(selectUserName)
  const userFetchStatus = useAppSelector(selectUserFetchStatus)

  return (
    <div>
      {/* Display the current user name */}
      <div>{userName}</div>
      {/* On button click, dispatch a thunk action to fetch a user */}
      <button onClick={() => dispatch(fetchUser())}>Fetch user</button>
      {/* At any point if we're fetching a user, display that on the UI */}
      {userFetchStatus === 'loading' && <div>Fetching user...</div>}
    </div>
  )
}




















This app involves thunks, reducers and selectors. All of these can be tested by writing an integration test with the following in mind:
Upon first loading the app, there should be no user yet - we should see 'No user' on the screen.
After clicking the button that says 'Fetch user', we expect it to start fetching the user. We should see 'Fetching user...' displayed on the screen.
After some time, the user should be received. We should no longer see 'Fetching user...', but instead should see the expected user's name based on the response from our API.
Writing our tests to focus on the above as a whole, we can avoid mocking as much of the app as possible. We will also have confidence that the critical behavior of our app does what we expect it to when interacted with in the way we expect the user to use the app.
To test the component, we render it into the DOM, and assert that the app responds to interactions in the way we expect the user to use the app.
Setting Up a Reusable Test Render Function
React Testing Library's render function accepts a tree of React elements and renders those components. Just like in a real app, any Redux-connected components will need a React-Redux <Provider> component wrapped around them, with a real Redux store set up and provided.
Additionally, the test code should create a separate Redux store instance for every test, rather than reusing the same store instance and resetting its state. That ensures no values accidentally leak between tests.
Instead of copy-pasting the same store creation and Provider setup in every test, we can use the wrapper option in the render function and export our own customized renderWithProviders function that creates a new Redux store and renders a <Provider>, as explained in React Testing Library's setup docs.
The custom render function should let us:
Create a new Redux store instance every time it's called, with an optional preloadedState value that can be used for an initial value
Alternately pass in an already-created Redux store instance
Pass through additional options to RTL's original render function
Automatically wrap the component being tested with a <Provider store={store}>
Return the store instance in case the test needs to dispatch more actions or check state
A typical custom render function setup could look like this:
TypeScript
JavaScript
utils/test-utils.tsx
import React, { PropsWithChildren } from 'react'
import { render } from '@testing-library/react'
import type { RenderOptions } from '@testing-library/react'
import { configureStore } from '@reduxjs/toolkit'
import { Provider } from 'react-redux'

import type { AppStore, RootState } from '../app/store'
import { setupStore } from '../app/store'
// As a basic setup, import your same slice reducers
import userReducer from '../features/users/userSlice'

// This type interface extends the default options for render from RTL, as well
// as allows the user to specify other things such as initialState, store.
interface ExtendedRenderOptions extends Omit<RenderOptions, 'queries'> {
  preloadedState?: Partial<RootState>
  store?: AppStore
}

export function renderWithProviders(
  ui: React.ReactElement,
  extendedRenderOptions: ExtendedRenderOptions = {}
) {
  const {
    preloadedState = {},
    // Automatically create a store instance if no store was passed in
    store = setupStore(preloadedState),
    ...renderOptions
  } = extendedRenderOptions

  const Wrapper = ({ children }: PropsWithChildren) => (
    <Provider store={store}>{children}</Provider>
  )

  // Return an object with the store and all of RTL's query functions
  return {
    store,
    ...render(ui, { wrapper: Wrapper, ...renderOptions })
  }
}























In this example, we're directly importing the same slice reducers that the real app uses to create the store. It may be helpful to create a reusable setupStore function that does the actual store creation with the right options and configuration, and use that in the custom render function instead.
TypeScript
JavaScript
app/store.ts
import { combineReducers, configureStore } from '@reduxjs/toolkit'

import userReducer from '../features/users/userSlice'

// Create the root reducer separately so we can extract the RootState type
const rootReducer = combineReducers({
  user: userReducer
})

export const setupStore = (preloadedState?: Partial<RootState>) => {
  return configureStore({
    reducer: rootReducer,
    preloadedState
  })
}

export type RootState = ReturnType<typeof rootReducer>
export type AppStore = ReturnType<typeof setupStore>
export type AppDispatch = AppStore['dispatch']















Then, use setupStore in the test utils file instead of calling configureStore again:
TypeScript
JavaScript
import React, { PropsWithChildren } from 'react'
import { render } from '@testing-library/react'
import type { RenderOptions } from '@testing-library/react'
import { Provider } from 'react-redux'

import { setupStore } from '../app/store'
import type { AppStore, RootState } from '../app/store'

// This type interface extends the default options for render from RTL, as well
// as allows the user to specify other things such as initialState, store.
interface ExtendedRenderOptions extends Omit<RenderOptions, 'queries'> {
  preloadedState?: Partial<RootState>
  store?: AppStore
}

export function renderWithProviders(
  ui: React.ReactElement,
  {
    preloadedState = {},
    // Automatically create a store instance if no store was passed in
    store = setupStore(preloadedState),
    ...renderOptions
  }: ExtendedRenderOptions = {}
) {
  function Wrapper({ children }: PropsWithChildren<{}>): JSX.Element {
    return <Provider store={store}>{children}</Provider>
  }
  return { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) }
}




















Writing Integration Tests With Components
The actual test files should use the custom render function to actually render our Redux-connected components. If the code that we're testing involves making network requests, we should also configure MSW to mock the expected requests with appropriate test data.
TypeScript
JavaScript
features/users/tests/UserDisplay.test.tsx
import React from 'react'
import { http, HttpResponse, delay } from 'msw'
import { setupServer } from 'msw/node'
import { fireEvent, screen } from '@testing-library/react'
// We're using our own custom render function and not RTL's render.
import { renderWithProviders } from '../../../utils/test-utils'
import UserDisplay from '../UserDisplay'

// We use msw to intercept the network request during the test,
// and return the response 'John Smith' after 150ms
// when receiving a get request to the `/api/user` endpoint
export const handlers = [
  http.get('/api/user', async () => {
    await delay(150)
    return HttpResponse.json('John Smith')
  })
]

const server = setupServer(...handlers)

// Enable API mocking before tests.
beforeAll(() => server.listen())

// Reset any runtime request handlers we may add during the tests.
afterEach(() => server.resetHandlers())

// Disable API mocking after the tests are done.
afterAll(() => server.close())

test('fetches & receives a user after clicking the fetch user button', async () => {
  renderWithProviders(<UserDisplay />)

  // should show no user initially, and not be fetching a user
  expect(screen.getByText(/no user/i)).toBeInTheDocument()
  expect(screen.queryByText(/Fetching user\.\.\./i)).not.toBeInTheDocument()

  // after clicking the 'Fetch user' button, it should now show that it is fetching the user
  fireEvent.click(screen.getByRole('button', { name: /Fetch user/i }))
  expect(screen.getByText(/no user/i)).toBeInTheDocument()

  // after some time, the user should be received
  expect(await screen.findByText(/John Smith/i)).toBeInTheDocument()
  expect(screen.queryByText(/no user/i)).not.toBeInTheDocument()
  expect(screen.queryByText(/Fetching user\.\.\./i)).not.toBeInTheDocument()
})













































In this test, we have completely avoided testing any Redux code directly, treating it as an implementation detail. As a result, we are free to re-factor the implementation, while our tests will continue to pass and avoid false negatives (tests that fail despite the app still behaving how we want it to). We might change our state structure, convert our slice to use RTK-Query, or remove Redux entirely, and our tests will still pass. We have a strong degree of confidence that if we change some code and our tests report a failure, then our app really is broken.
Preparing Initial Test State
Many tests require that certain pieces of state already exist in the Redux store before the component is rendered. With the custom render function, there are a couple different ways you can do that.
One option is to pass a preloadedState argument in to the custom render function:
TodoList.test.tsx
test('Uses preloaded state to render', () => {
  const initialTodos = [{ id: 5, text: 'Buy Milk', completed: false }]

  const { getByText } = renderWithProviders(<TodoList />, {
    preloadedState: {
      todos: initialTodos
    }
  })
})
Another option is to create a custom Redux store first and dispatch some actions to build up the desired state, then pass in that specific store instance:
TodoList.test.tsx
test('Sets up initial state state with actions', () => {
  const store = setupStore()
  store.dispatch(todoAdded('Buy milk'))

  const { getByText } = renderWithProviders(<TodoList />, { store })
})
You can also extract store from the object returned by the custom render function, and dispatch more actions later as part of the test.
Unit Testing Individual Functions
While we recommend using integration tests by default, since they exercise all the Redux logic working together, you may sometimes want to write unit tests for individual functions as well.
Reducers
Reducers are pure functions that return the new state after applying the action to the previous state. In the majority of cases, the reducer is an implementation detail that does not need explicit tests. However, if your reducer contains particularly complex logic that you would like the confidence of having unit tests for, reducers can be easily tested.
Because reducers are pure functions, so testing them should be straightforward. Call the reducer with a specific input state and action, and assert that the result state matches expectations.
Example
TypeScript
JavaScript
import { createSlice, PayloadAction } from '@reduxjs/toolkit'

export type Todo = {
  id: number
  text: string
  completed: boolean
}

const initialState: Todo[] = [{ text: 'Use Redux', completed: false, id: 0 }]

const todosSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    todoAdded(state, action: PayloadAction<string>) {
      state.push({
        id: state.reduce((maxId, todo) => Math.max(todo.id, maxId), -1) + 1,
        completed: false,
        text: action.payload
      })
    }
  }
})

export const { todoAdded } = todosSlice.actions

export default todosSlice.reducer





















can be tested like:
TypeScript
JavaScript
import reducer, { todoAdded, Todo } from './todosSlice'

test('should return the initial state', () => {
  expect(reducer(undefined, { type: 'unknown' })).toEqual([
    { text: 'Use Redux', completed: false, id: 0 }
  ])
})

test('should handle a todo being added to an empty list', () => {
  const previousState: Todo[] = []

  expect(reducer(previousState, todoAdded('Run the tests'))).toEqual([
    { text: 'Run the tests', completed: false, id: 0 }
  ])
})

test('should handle a todo being added to an existing list', () => {
  const previousState: Todo[] = [
    { text: 'Run the tests', completed: true, id: 0 }
  ]

  expect(reducer(previousState, todoAdded('Use Redux'))).toEqual([
    { text: 'Run the tests', completed: true, id: 0 },
    { text: 'Use Redux', completed: false, id: 1 }
  ])
})
























Selectors
Selectors are also generally pure functions, and thus can be tested using the same basic approach as reducers: set up an initial value, call the selector function with those inputs, and assert that the result matches the expected output.
However, since most selectors are memoized to remember their last inputs, you may need to watch for cases where a selector is returning a cached value when you expected it to generate a new one depending on where it's being used in the test.
Action Creators & Thunks
In Redux, action creators are functions which return plain objects. Our recommendation is not to write action creators manually, but instead have them generated automatically by createSlice, or created via createAction from @reduxjs/toolkit. As such, you should not feel the need to test action creators by themselves (the Redux Toolkit maintainers have already done that for you!).
The return value of action creators is considered an implementation detail within your application, and when following an integration testing style, do not need explicit tests.
Similarly for thunks using Redux Thunk, our recommendation is not to write them manually, but instead use createAsyncThunk from @reduxjs/toolkit. The thunk handles dispatching the appropriate pending, fulfilled and rejected action types for you based on the lifecycle of the thunk.
We consider thunk behavior to be an implementation detail of the application, and recommend that it be covered by testing the group of components (or whole app) using it, rather than testing the thunk in isolation.
Our recommendation is to mock async requests at the fetch/xhr level using tools like msw, miragejs, jest-fetch-mock, fetch-mock, or similar. By mocking requests at this level, none of the thunk logic has to change in a test - the thunk still tries to make a ""real"" async request, it just gets intercepted. See the ""Integration Test"" example for an example of testing a component which internally includes the behavior of a thunk.
INFO
If you prefer, or are otherwise required to write unit tests for your action creators or thunks, refer to the tests that Redux Toolkit uses for createAction and createAsyncThunk.
Middleware
Middleware functions wrap behavior of dispatch calls in Redux, so to test this modified behavior we need to mock the behavior of the dispatch call.
Example
First, we'll need a middleware function. This is similar to the real redux-thunk.
const thunkMiddleware =
  ({ dispatch, getState }) =>
  next =>
  action => {
    if (typeof action === 'function') {
      return action(dispatch, getState)
    }

    return next(action)
  }
We need to create fake getState, dispatch, and next functions. We use jest.fn() to create stubs, but with other test frameworks you would likely use Sinon.
The invoke function runs our middleware in the same way Redux does.
const create = () => {
  const store = {
    getState: jest.fn(() => ({})),
    dispatch: jest.fn()
  }
  const next = jest.fn()

  const invoke = action => thunkMiddleware(store)(next)(action)

  return { store, next, invoke }
}
We test that our middleware is calling the getState, dispatch, and next functions at the right time.
test('passes through non-function action', () => {
  const { next, invoke } = create()
  const action = { type: 'TEST' }
  invoke(action)
  expect(next).toHaveBeenCalledWith(action)
})

test('calls the function', () => {
  const { invoke } = create()
  const fn = jest.fn()
  invoke(fn)
  expect(fn).toHaveBeenCalled()
})

test('passes dispatch and getState', () => {
  const { store, invoke } = create()
  invoke((dispatch, getState) => {
    dispatch('TEST DISPATCH')
    getState()
  })
  expect(store.dispatch).toHaveBeenCalledWith('TEST DISPATCH')
  expect(store.getState).toHaveBeenCalled()
})
In some cases, you will need to modify the create function to use different mock implementations of getState and next.
Further Information
React Testing Library: React Testing Library is a very light-weight solution for testing React components. It provides light utility functions on top of react-dom and react-dom/test-utils, in a way that encourages better testing practices. Its primary guiding principle is: ""The more your tests resemble the way your software is used, the more confidence they can give you.""
Blogged Answers: The Evolution of Redux Testing Approaches: Mark Erikson's thoughts on how Redux testing has evolved from 'isolation' to 'integration'.
Testing Implementation Details: Blog post by Kent C. Dodds on why he recommends to avoid testing implementation details.
Edit this page
Last updated on Jan 12, 2024""""""",4977,23578,redux
https://redux.js.org/usage/troubleshooting,"""""""Using ReduxCode QualityTroubleshooting
Troubleshooting
This is a place to share common problems and solutions to them. The examples use React, but you should still find them useful if you use something else.
Nothing happens when I dispatch an action
Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.
Never mutate reducer arguments
It is tempting to modify the state or action passed to you by Redux. Don't do this!
Redux assumes that you never mutate the objects it gives to you in the reducer. Every single time, you must return the new state object. Even if you don't use a library like Immer, you need to completely avoid mutation.
Immutability is what lets react-redux efficiently subscribe to fine-grained updates of your state. It also enables great developer experience features such as time travel with redux-devtools.
For example, a reducer like this is wrong because it mutates the state:
function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      // Wrong! This mutates state
      state.push({
        text: action.text,
        completed: false
      })
      return state
    case 'COMPLETE_TODO':
      // Wrong! This mutates state[action.index].
      state[action.index].completed = true
      return state
    default:
      return state
  }
}
It needs to be rewritten like this:
function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      // Return a new array
      return [
        ...state,
        {
          text: action.text,
          completed: false
        }
      ]
    case 'COMPLETE_TODO':
      // Return a new array
      return state.map((todo, index) => {
        if (index === action.index) {
          // Copy the object before mutating
          return Object.assign({}, todo, {
            completed: true
          })
        }
        return todo
      })
    default:
      return state
  }
}
It's more code, but it's exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like React.addons.update to write immutable transformations with a terse syntax:
// Before:
return state.map((todo, index) => {
  if (index === action.index) {
    return Object.assign({}, todo, {
      completed: true
    })
  }
  return todo
})

// After
return update(state, {
  [action.index]: {
    completed: {
      $set: true
    }
  }
})
Finally, to update objects, you'll need something like _.extend from Underscore, or better, an Object.assign polyfill.
Make sure that you use Object.assign correctly. For example, instead of returning something like Object.assign(state, newData) from your reducers, return Object.assign({}, state, newData). This way you don't override the previous state.
You can also use the object spread operator proposal for a more succinct syntax:
// Before:
return state.map((todo, index) => {
  if (index === action.index) {
    return Object.assign({}, todo, {
      completed: true
    })
  }
  return todo
})

// After:
return state.map((todo, index) => {
  if (index === action.index) {
    return { ...todo, completed: true }
  }
  return todo
})
Note that experimental language features are subject to change.
Also keep an eye out for nested state objects that need to be deeply copied. Both _.extend and Object.assign make a shallow copy of the state. See Updating Nested Objects for suggestions on how to deal with nested state objects.
Don't forget to call dispatch(action)
If you define an action creator, calling it will not automatically dispatch the action. For example, this code will do nothing:
TodoActions.js
export function addTodo(text) {
  return { type: 'ADD_TODO', text }
}
AddTodo.js
import React, { Component } from 'react'
import { addTodo } from './TodoActions'

class AddTodo extends Component {
  handleClick() {
    // Won't work!
    addTodo('Fix the issue')
  }

  render() {
    return <button onClick={() => this.handleClick()}>Add</button>
  }
}
It doesn't work because your action creator is just a function that returns an action. It is up to you to actually dispatch it. We can't bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.
The fix is to call dispatch() method on the store instance:
handleClick() {
  // Works! (but you need to grab store somehow)
  store.dispatch(addTodo('Fix the issue'))
}
If you're somewhere deep in the component hierarchy, it is cumbersome to pass the store down manually. This is why react-redux lets you use a connect higher-order component that will, apart from subscribing you to a Redux store, inject dispatch into your component's props.
The fixed code looks like this:
AddTodo.js
import React, { Component } from 'react'
import { connect } from 'react-redux'
import { addTodo } from './TodoActions'

class AddTodo extends Component {
  handleClick() {
    // Works!
    this.props.dispatch(addTodo('Fix the issue'))
  }

  render() {
    return <button onClick={() => this.handleClick()}>Add</button>
  }
}

// In addition to the state, `connect` puts `dispatch` in our props.
export default connect()(AddTodo)
You can then pass dispatch down to other components manually, if you want to.
Make sure mapStateToProps is correct
It's possible you're correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.
Something else doesn't work
Ask around on the #redux Reactiflux Discord channel, or create an issue.
If you figure it out, edit this document as a courtesy to the next person having the same problem.
Edit this page
Last updated on Jun 26, 2022""""""",1270,5765,redux
https://redux.js.org/usage/reducing-boilerplate,"""""""Using ReduxRedux Logic and PatternsReducing Boilerplate
Reducing Boilerplate
Redux is in part inspired by Flux, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.
Actions
Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that actions being objects you have to dispatch is not boilerplate, but one of the fundamental design choices of Redux.
There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement hot reloading with time travel. If you'd rather modify data directly, you don't need Redux.
Actions look like this:
{ type: 'ADD_TODO', text: 'Use Redux' }
{ type: 'REMOVE_TODO', id: 42 }
{ type: 'LOAD_ARTICLE', response: { ... } }
It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not Symbols for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.
In Flux, it is traditionally thought that you would define every action type as a string constant:
const ADD_TODO = 'ADD_TODO'
const REMOVE_TODO = 'REMOVE_TODO'
const LOAD_ARTICLE = 'LOAD_ARTICLE'
Why is this beneficial? It is often claimed that constants are unnecessary, and for small projects, this might be correct. For larger projects, there are some benefits to defining action types as constants:
It helps keep the naming consistent because all action types are gathered in a single place.
Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.
The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.
If you make a typo when importing an action constant, you will get undefined. Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner.
It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.
Action Creators
It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.
For example, instead of calling dispatch with an object literal:
// somewhere in an event handler
dispatch({
  type: 'ADD_TODO',
  text: 'Use Redux'
})
You might write an action creator in a separate file, and import it into your component:
actionCreators.js
export function addTodo(text) {
  return {
    type: 'ADD_TODO',
    text
  }
}
AddTodo.js
import { addTodo } from './actionCreators'

// somewhere in an event handler
dispatch(addTodo('Use Redux'))
Action creators have often been criticized as boilerplate. Well, you don't have to write them! You can use object literals if you feel this better suits your project. There are, however, some benefits for writing action creators you should know about.
Let's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with redux-thunk middleware and adding an early exit:
function addTodoWithoutCheck(text) {
  return {
    type: 'ADD_TODO',
    text
  }
}

export function addTodo(text) {
  // This form is allowed by Redux Thunk middleware
  // described below in “Async Action Creators” section.
  return function (dispatch, getState) {
    if (getState().todos.length === 3) {
      // Exit early
      return
    }
    dispatch(addTodoWithoutCheck(text))
  }
}
We just modified how the addTodo action creator behaves, completely invisible to the calling code. We don't have to worry about looking at each place where todos are being added, to make sure they have this check. Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.
Generating Action Creators
Some frameworks like Flummox generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define ADD_TODO constant and addTodo() action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.
Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:
export function addTodo(text) {
  return {
    type: 'ADD_TODO',
    text
  }
}

export function editTodo(id, text) {
  return {
    type: 'EDIT_TODO',
    id,
    text
  }
}

export function removeTodo(id) {
  return {
    type: 'REMOVE_TODO',
    id
  }
}
You can always write a function that generates an action creator:
function makeActionCreator(type, ...argNames) {
  return function (...args) {
    const action = { type }
    argNames.forEach((arg, index) => {
      action[argNames[index]] = args[index]
    })
    return action
  }
}

const ADD_TODO = 'ADD_TODO'
const EDIT_TODO = 'EDIT_TODO'
const REMOVE_TODO = 'REMOVE_TODO'

export const addTodo = makeActionCreator(ADD_TODO, 'text')
export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'text')
export const removeTodo = makeActionCreator(REMOVE_TODO, 'id')
There are also utility libraries to aid in generating action creators, such as redux-act and redux-actions. These can help reduce boilerplate code and enforce adherence to standards such as Flux Standard Action (FSA).
Async Action Creators
Middleware lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.
Without any middleware, dispatch only accepts a plain object, so we have to perform AJAX calls inside our components:
actionCreators.js
export function loadPostsSuccess(userId, response) {
  return {
    type: 'LOAD_POSTS_SUCCESS',
    userId,
    response
  }
}

export function loadPostsFailure(userId, error) {
  return {
    type: 'LOAD_POSTS_FAILURE',
    userId,
    error
  }
}

export function loadPostsRequest(userId) {
  return {
    type: 'LOAD_POSTS_REQUEST',
    userId
  }
}
UserInfo.js
import { Component } from 'react'
import { connect } from 'react-redux'
import {
  loadPostsRequest,
  loadPostsSuccess,
  loadPostsFailure
} from './actionCreators'

class Posts extends Component {
  loadData(userId) {
    // Injected into props by React Redux `connect()` call:
    const { dispatch, posts } = this.props

    if (posts[userId]) {
      // There is cached data! Don't do anything.
      return
    }

    // Reducer can react to this action by setting
    // `isFetching` and thus letting us show a spinner.
    dispatch(loadPostsRequest(userId))

    // Reducer can react to these actions by filling the `users`.
    fetch(`http://myapi.com/users/${userId}/posts`).then(
      response => dispatch(loadPostsSuccess(userId, response)),
      error => dispatch(loadPostsFailure(userId, error))
    )
  }

  componentDidMount() {
    this.loadData(this.props.userId)
  }

  componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      this.loadData(this.props.userId)
    }
  }

  render() {
    if (this.props.isFetching) {
      return <p>Loading...</p>
    }

    const posts = this.props.posts.map(post => (
      <Post post={post} key={post.id} />
    ))

    return <div>{posts}</div>
  }
}

export default connect(state => ({
  posts: state.posts,
  isFetching: state.isFetching
}))(Posts)
However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.
Middleware lets us write more expressive, potentially async action creators. It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.
The simplest example of middleware is redux-thunk. “Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions. This inverts the control: you will get dispatch as an argument, so you can write an action creator that dispatches many times.
Note
Thunk middleware is just one example of middleware. Middleware is not about “letting you dispatch functions”. It's about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.
Consider the code above rewritten with redux-thunk:
actionCreators.js
export function loadPosts(userId) {
  // Interpreted by the thunk middleware:
  return function (dispatch, getState) {
    const { posts } = getState()
    if (posts[userId]) {
      // There is cached data! Don't do anything.
      return
    }

    dispatch({
      type: 'LOAD_POSTS_REQUEST',
      userId
    })

    // Dispatch vanilla actions asynchronously
    fetch(`http://myapi.com/users/${userId}/posts`).then(
      response =>
        dispatch({
          type: 'LOAD_POSTS_SUCCESS',
          userId,
          response
        }),
      error =>
        dispatch({
          type: 'LOAD_POSTS_FAILURE',
          userId,
          error
        })
    )
  }
}
UserInfo.js
import { Component } from 'react'
import { connect } from 'react-redux'
import { loadPosts } from './actionCreators'

class Posts extends Component {
  componentDidMount() {
    this.props.dispatch(loadPosts(this.props.userId))
  }

  componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      this.props.dispatch(loadPosts(this.props.userId))
    }
  }

  render() {
    if (this.props.isFetching) {
      return <p>Loading...</p>
    }

    const posts = this.props.posts.map(post => (
      <Post post={post} key={post.id} />
    ))

    return <div>{posts}</div>
  }
}

export default connect(state => ({
  posts: state.posts,
  isFetching: state.isFetching
}))(Posts)
This is much less typing! If you'd like, you can still have “vanilla” action creators like loadPostsSuccess which you'd use from a container loadPosts action creator.
Finally, you can write your own middleware. Let's say you want to generalize the pattern above and describe your async action creators like this instead:
export function loadPosts(userId) {
  return {
    // Types of actions to emit before and after
    types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],
    // Check the cache (optional):
    shouldCallAPI: state => !state.posts[userId],
    // Perform the fetching:
    callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),
    // Arguments to inject in begin/end actions
    payload: { userId }
  }
}
The middleware that interprets such actions could look like this:
function callAPIMiddleware({ dispatch, getState }) {
  return next => action => {
    const { types, callAPI, shouldCallAPI = () => true, payload = {} } = action

    if (!types) {
      // Normal action: pass it on
      return next(action)
    }

    if (
      !Array.isArray(types) ||
      types.length !== 3 ||
      !types.every(type => typeof type === 'string')
    ) {
      throw new Error('Expected an array of three string types.')
    }

    if (typeof callAPI !== 'function') {
      throw new Error('Expected callAPI to be a function.')
    }

    if (!shouldCallAPI(getState())) {
      return
    }

    const [requestType, successType, failureType] = types

    dispatch(
      Object.assign({}, payload, {
        type: requestType
      })
    )

    return callAPI().then(
      response =>
        dispatch(
          Object.assign({}, payload, {
            response,
            type: successType
          })
        ),
      error =>
        dispatch(
          Object.assign({}, payload, {
            error,
            type: failureType
          })
        )
    )
  }
}
After passing it once to applyMiddleware(...middlewares), you can write all your API-calling action creators the same way:
export function loadPosts(userId) {
  return {
    types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],
    shouldCallAPI: state => !state.posts[userId],
    callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),
    payload: { userId }
  }
}

export function loadComments(postId) {
  return {
    types: [
      'LOAD_COMMENTS_REQUEST',
      'LOAD_COMMENTS_SUCCESS',
      'LOAD_COMMENTS_FAILURE'
    ],
    shouldCallAPI: state => !state.comments[postId],
    callAPI: () => fetch(`http://myapi.com/posts/${postId}/comments`),
    payload: { postId }
  }
}

export function addComment(postId, message) {
  return {
    types: [
      'ADD_COMMENT_REQUEST',
      'ADD_COMMENT_SUCCESS',
      'ADD_COMMENT_FAILURE'
    ],
    callAPI: () =>
      fetch(`http://myapi.com/posts/${postId}/comments`, {
        method: 'post',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message })
      }),
    payload: { postId, message }
  }
}
Reducers
Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.
Consider this Flux store:
const _todos = []

const TodoStore = Object.assign({}, EventEmitter.prototype, {
  getAll() {
    return _todos
  }
})

AppDispatcher.register(function (action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO:
      const text = action.text.trim()
      _todos.push(text)
      TodoStore.emitChange()
  }
})

export default TodoStore
With Redux, the same update logic can be described as a reducer function:
export function todos(state = [], action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO:
      const text = action.text.trim()
      return [...state, text]
    default:
      return state
  }
}
The switch statement is not the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).
It's unfortunate that many still choose Flux framework based on whether it uses switch statements in the documentation. If you don't like switch, you can solve this with a single function, as we show below.
Generating Reducers
Let's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our todos reducers to be defined like this:
export const todos = createReducer([], {
  [ActionTypes.ADD_TODO]: (state, action) => {
    const text = action.text.trim()
    return [...state, text]
  }
})
We can write the following helper to accomplish this:
function createReducer(initialState, handlers) {
  return function reducer(state = initialState, action) {
    if (handlers.hasOwnProperty(action.type)) {
      return handlers[action.type](state, action)
    } else {
      return state
    }
  }
}
This wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.
The Redux reducer API is (state, action) => newState, but how you create those reducers is up to you.
Edit this page
Last updated on Nov 25, 2023""""""",3632,16624,redux
https://redux.js.org/usage/deriving-data-selectors,"""""""Using ReduxRedux Logic and PatternsDeriving Data with Selectors
Deriving Data with Selectors
WHAT YOU'LL LEARN
Why good Redux architecture keeps state minimal and derives additional data
Principles of using selector functions to derive data and encapsulate lookups
How to use the Reselect library to write memoized selectors for optimization
Advanced techniques for using Reselect
Additional tools and libraries for creating selectors
Best practices for writing selectors
Deriving Data
We specifically recommend that Redux apps should keep the Redux state minimal, and derive additional values from that state whenever possible.
This includes things like calculating filtered lists or summing up values. As an example, a todo app would keep an original list of todo objects in state, but derive a filtered list of todos outside the state whenever the state is updated. Similarly, a check for whether all todos have been completed, or number of todos remaining, can be calculated outside the store as well.
This has several benefits:
The actual state is easier to read
Less logic is needed to calculate those additional values and keep them in sync with the rest of the data
The original state is still there as a reference and isn't being replaced
TIP
This is also a good principle for React state as well! Many times users tried to define a useEffect hook that waits for a state value to change, and then sets state with some derived value like setAllCompleted(allCompleted). Instead, that value can be derived during the rendering process and used directly, without having to save the value into state at all:
function TodoList() {
  const [todos, setTodos] = useState([])

  // Derive the data while rendering
  const allTodosCompleted = todos.every(todo => todo.completed)

  // render with this value
}
Calculating Derived Data with Selectors
In a typical Redux application, the logic for deriving data is usually written as functions we call selectors.
Selectors are primarily used to encapsulate logic for looking up specific values from state, logic for actually deriving values, and improving performance by avoiding unnecessary recalculations.
You are not required to use selectors for all state lookups, but they are a standard pattern and widely used.
Basic Selector Concepts
A ""selector function"" is any function that accepts the Redux store state (or part of the state) as an argument, and returns data that is based on that state.
Selectors don't have to be written using a special library, and it doesn't matter whether you write them as arrow functions or the function keyword. For example, all of these are valid selector functions:
// Arrow function, direct lookup
const selectEntities = state => state.entities

// Function declaration, mapping over an array to derive values
function selectItemIds(state) {
  return state.items.map(item => item.id)
}

// Function declaration, encapsulating a deep lookup
function selectSomeSpecificField(state) {
  return state.some.deeply.nested.field
}

// Arrow function, deriving values from an array
const selectItemsWhoseNamesStartWith = (items, namePrefix) =>
  items.filter(item => item.name.startsWith(namePrefix))
A selector function can have any name you want. However, we recommend prefixing selector function names with the word select combined with a description of the value being selected. Typical examples of this would look like selectTodoById, selectFilteredTodos, and selectVisibleTodos.
If you've used the useSelector hook from React-Redux, you're probably already familiar with the basic idea of a selector function - the functions that we pass to useSelector must be selectors:
function TodoList() {
  // This anonymous arrow function is a selector!
  const todos = useSelector(state => state.todos)
}
Selector functions are typically defined in two different parts of a Redux application:
In slice files, alongside the reducer logic
In component files, either outside the component, or inline in useSelector calls
A selector function can be used anywhere you have access to the entire Redux root state value. This includes the useSelector hook, the mapState function for connect, middleware, thunks, and sagas. For example, thunks and middleware have access to the getState argument, so you can call a selector there:
function addTodosIfAllowed(todoText) {
  return (dispatch, getState) => {
    const state = getState()
    const canAddTodos = selectCanAddTodos(state)

    if (canAddTodos) {
      dispatch(todoAdded(todoText))
    }
  }
}
It's not typically possible to use selectors inside of reducers, because a slice reducer only has access to its own slice of the Redux state, and most selectors expect to be given the entire Redux root state as an argument.
Encapsulating State Shape with Selectors
The first reason to use selector functions is for encapsulation and reusability when dealing with your Redux state shape.
Let's say that one of your useSelector hooks makes a very specific lookup into part of your Redux state:
const data = useSelector(state => state.some.deeply.nested.field)
That is legal code, and will run fine. But, it might not be the best idea architecturally. Imagine that you've got several components that need to access that field. What happens if you need to make a change to where that piece of state lives? You would now have to go change every useSelector hook that references that value. So, in the same way that we recommend using action creators to encapsulate details of creating actions, we recommend defining reusable selectors to encapsulate the knowledge of where a given piece of state lives. Then, you can use a given selector function many times in the codebase, anywhere that your app needs to retrieve that particular data.
Ideally, only your reducer functions and selectors should know the exact state structure, so if you change where some state lives, you would only need to update those two pieces of logic.
Because of this, it's often a good idea to define reusable selectors directly inside slice files, rather than always defining them inside of a component.
One common description of selectors is that they're like ""queries into your state"". You don't care about exactly how the query came up with the data you needed, just that you asked for the data and got back a result.
Optimizing Selectors with Memoization
Selector functions often need to perform relatively ""expensive"" calculations, or create derived values that are new object and array references. This can be a concern for application performance, for several reasons:
Selectors used with useSelector or mapState will be re-run after every dispatched action, regardless of what section of the Redux root state was actually updated. Re-running expensive calculations when the input state sections didn't change is a waste of CPU time, and it's very likely that the inputs won't have changed most of the time anyway.
useSelector and mapState rely on === reference equality checks of the return values to determine if the component needs to re-render. If a selector always returns new references, it will force the component to re-render even if the derived data is effectively the same as last time. This is especially common with array operations like map() and filter(), which return new array references.
As an example, this component is written badly, because its useSelector call always returns a new array reference. That means the component will re-render after every dispatched action, even if the input state.todos slice hasn't changed:
function TodoList() {
  // ❌ WARNING: this _always_ returns a new reference, so it will _always_ re-render!
  const completedTodos = useSelector(state =>
    state.todos.map(todo => todo.completed)
  )
}
Another example is a component that needs to do some ""expensive"" work to transform data:
function ExampleComplexComponent() {
  const data = useSelector(state => {
    const initialData = state.data
    const filteredData = expensiveFiltering(initialData)
    const sortedData = expensiveSorting(filteredData)
    const transformedData = expensiveTransformation(sortedData)

    return transformedData
  })
}
Similarly, this ""expensive"" logic will re-run after every dispatched action. Not only will it probably create new references, but it's work that doesn't need to be done unless state.data actually changes.
Because of this, we need a way to write optimized selectors that can avoid recalculating results if the same inputs are passed in. This is where the idea of memoization comes in.
Memoization is a form of caching. It involves tracking inputs to a function, and storing the inputs and the results for later reference. If a function is called with the same inputs as before, the function can skip doing the actual work, and return the same result it generated the last time it received those input values. This optimizes performance by only doing work if inputs have changed, and consistently returning the same result references if the inputs are the same.
Next, we'll look at some options for writing memoized selectors.
Writing Memoized Selectors with Reselect
The Redux ecosystem has traditionally used a library called Reselect to create memoized selector functions. There also are other similar libraries, as well as multiple variations and wrappers around Reselect - we'll look at those later.
createSelector Overview
Reselect provides a function called createSelector to generate memoized selectors. createSelector accepts one or more ""input selector"" functions, plus an ""output selector"" function, and returns a new selector function for you to use.
createSelector is included as part of our official Redux Toolkit package, and is re-exported for ease of use.
createSelector can accept multiple input selectors, which can be provided as separate arguments or as an array. The results from all the input selectors are provided as separate arguments to the output selector:
const selectA = state => state.a
const selectB = state => state.b
const selectC = state => state.c

const selectABC = createSelector([selectA, selectB, selectC], (a, b, c) => {
  // do something with a, b, and c, and return a result
  return a + b + c
})

// Call the selector function and get a result
const abc = selectABC(state)

// could also be written as separate arguments, and works exactly the same
const selectABC2 = createSelector(selectA, selectB, selectC, (a, b, c) => {
  // do something with a, b, and c, and return a result
  return a + b + c
})
When you call the selector, Reselect will run your input selectors with all of the arguments you gave, and looks at the returned values. If any of the results are === different than before, it will re-run the output selector, and pass in those results as the arguments. If all of the results are the same as the last time, it will skip re-running the output selector, and just return the cached final result from before.
This means that ""input selectors"" should usually just extract and return values, and the ""output selector"" should do the transformation work.
CAUTION
A somewhat common mistake is to write an ""input selector"" that extracts a value or does some derivation, and an ""output selector"" that just returns its result:
// ❌ BROKEN: this will not memoize correctly, and does nothing useful!
const brokenSelector = createSelector(
  state => state.todos,
  todos => todos
)
Any ""output selector"" that just returns its inputs is incorrect! The output selector should always have the transformation logic.
Similarly, a memoized selector should never use state => state as an input! That will force the selector to always recalculate.
In typical Reselect usage, you write your top-level ""input selectors"" as plain functions, and use createSelector to create memoized selectors that look up nested values:
const state = {
  a: {
    first: 5
  },
  b: 10
}

const selectA = state => state.a
const selectB = state => state.b

const selectA1 = createSelector([selectA], a => a.first)

const selectResult = createSelector([selectA1, selectB], (a1, b) => {
  console.log('Output selector running')
  return a1 + b
})

const result = selectResult(state)
// Log: ""Output selector running""
console.log(result)
// 15

const secondResult = selectResult(state)
// No log output
console.log(secondResult)
// 15
Note that the second time we called selectResult, the ""output selector"" didn't execute. Because the results of selectA1 and selectB were the same as the first call, selectResult was able to return the memoized result from the first call.
createSelector Behavior
It's important to note that by default, createSelector only memoizes the most recent set of parameters. That means that if you call a selector repeatedly with different inputs, it will still return a result, but it will have to keep re-running the output selector to produce the result:
const a = someSelector(state, 1) // first call, not memoized
const b = someSelector(state, 1) // same inputs, memoized
const c = someSelector(state, 2) // different inputs, not memoized
const d = someSelector(state, 1) // different inputs from last time, not memoized
Also, you can pass multiple arguments into a selector. Reselect will call all of the input selectors with those exact inputs:
const selectItems = state => state.items
const selectItemId = (state, itemId) => itemId

const selectItemById = createSelector(
  [selectItems, selectItemId],
  (items, itemId) => items[itemId]
)

const item = selectItemById(state, 42)

/*
Internally, Reselect does something like this:

const firstArg = selectItems(state, 42);  
const secondArg = selectItemId(state, 42);  
  
const result = outputSelector(firstArg, secondArg);  
return result;  
*/
Because of this, it's important that all of the ""input selectors"" you provide should accept the same types of parameters. Otherwise, the selectors will break.
const selectItems = state => state.items

// expects a number as the second argument
const selectItemId = (state, itemId) => itemId

// expects an object as the second argument
const selectOtherField = (state, someObject) => someObject.someField

const selectItemById = createSelector(
  [selectItems, selectItemId, selectOtherField],
  (items, itemId, someField) => items[itemId]
)
In this example, selectItemId expects that its second argument will be some simple value, while selectOtherField expects that the second argument is an object. If you call selectItemById(state, 42), selectOtherField will break because it's trying to access 42.someField.
Reselect Usage Patterns and Limitations
Nesting Selectors
It's possible to take selectors generated with createSelector, and use them as inputs for other selectors as well. In this example, the selectCompletedTodos selector is used as an input to selectCompletedTodoDescriptions:
const selectTodos = state => state.todos

const selectCompletedTodos = createSelector([selectTodos], todos =>
  todos.filter(todo => todo.completed)
)

const selectCompletedTodoDescriptions = createSelector(
  [selectCompletedTodos],
  completedTodos => completedTodos.map(todo => todo.text)
)
Passing Input Parameters
A Reselect-generated selector function can be called with as many arguments as you want: selectThings(a, b, c, d, e). However, what matters for re-running the output is not the number of arguments, or whether the arguments themselves have changed to be new references. Instead, it's about the ""input selectors"" that were defined, and whether their results have changed. Similarly, the arguments for the ""output selector"" are solely based on what the input selectors return.
This means that if you want to pass additional parameters through to the output selector, you must define input selectors that extract those values from the original selector arguments:
const selectItemsByCategory = createSelector(
  [
    // Usual first input - extract value from `state`
    state => state.items,
    // Take the second arg, `category`, and forward to the output selector
    (state, category) => category
  ],
  // Output selector gets (`items, category)` as args
  (items, category) => items.filter(item => item.category === category)
)
You can then use the selector like this:
const electronicItems = selectItemsByCategory(state, ""electronics"");
For consistency, you may want to consider passing additional parameters to a selector as a single object, such as selectThings(state, otherArgs), and then extracting values from the otherArgs object.
Selector Factories
createSelector only has a default cache size of 1, and this is per each unique instance of a selector. This creates problems when a single selector function needs to get reused in multiple places with differing inputs.
One option is to create a ""selector factory"" - a function that runs createSelector() and generates a new unique selector instance every time it's called:
const makeSelectItemsByCategory = () => {
  const selectItemsByCategory = createSelector(
    [state => state.items, (state, category) => category],
    (items, category) => items.filter(item => item.category === category)
  )
  return selectItemsByCategory
}
This is particularly useful when multiple similar UI components need to derive different subsets of the data based on props.
Alternative Selector Libraries
While Reselect is the most widely used selector library with Redux, there are many other libraries that solve similar problems, or expand on Reselect's capabilities.
proxy-memoize
proxy-memoize is a relatively new memoized selector library that uses a unique implementation approach. It relies on ES2015 Proxy objects to track attempted reads of nested values, then compares only the nested values on later calls to see if they've changed. This can provide better results than Reselect in some cases.
A good example of this is a selector that derives an array of todo descriptions:
import { createSelector } from 'reselect'

const selectTodoDescriptionsReselect = createSelector(
  [state => state.todos],
  todos => todos.map(todo => todo.text)
)
Unfortunately, this will recalculate the derived array if any other value inside of state.todos changes, such as toggling a todo.completed flag. The contents of the derived array are identical, but because the input todos array changed, it has to calculate a new output array, and that has a new reference.
The same selector with proxy-memoize might look like:
import { memoize } from 'proxy-memoize'

const selectTodoDescriptionsProxy = memoize(state =>
  state.todos.map(todo => todo.text)
)
Unlike Reselect, proxy-memoize can detect that only the todo.text fields are being accessed, and will only recalculate the rest if one of the todo.text fields changed.
It also has a built-in size option, which lets you set the desired cache size for a single selector instance.
It has some tradeoffs and differences from Reselect:
All values are passed in as a single object argument
It requires that the environment supports ES2015 Proxy objects (no IE11)
It's more magical, whereas Reselect is more explicit
There are some edge cases regarding the Proxy-based tracking behavior
It's newer and less widely used
All that said, we officially encourage considering using proxy-memoize as a viable alternative to Reselect.
re-reselect
https://github.com/toomuchdesign/re-reselect improves Reselect's caching behavior, by allowing you to define a ""key selector"". This is used to manage multiple instances of Reselect selectors internally, which can help simplify usage across multiple components.
import { createCachedSelector } from 're-reselect'

const getUsersByLibrary = createCachedSelector(
  // inputSelectors
  getUsers,
  getLibraryId,

  // resultFunc
  (users, libraryId) => expensiveComputation(users, libraryId)
)(
  // re-reselect keySelector (receives selectors' arguments)
  // Use ""libraryName"" as cacheKey
  (_state_, libraryName) => libraryName
)
reselect-tools
Sometimes it can be hard to trace how multiple Reselect selectors relate to each other, and what caused a selector to recalculate. https://github.com/skortchmark9/reselect-tools provides a way to trace selector dependencies, and its own DevTools to help visualize those relationships and check selector values.
redux-views
https://github.com/josepot/redux-views is similar to re-reselect, in that it provides a way to select unique keys for each item for consistent caching. It was designed as a near-drop-in replacement for Reselect, and actually proposed as an option for a potential Reselect version 5.
Reselect v5 Proposal
We've opened up a roadmap discussion in the Reselect repo to figure out potential enhancements to a future version of Reselect, such as improving the API to better support larger cache sizes, rewriting the codebase in TypeScript, and other possible improvements. We'd welcome additional community feedback in that discussion:
Reselect v5 Roadmap Discussion: Goals and API Design
Using Selectors with React-Redux
Calling Selectors with Parameters
It's common to want to pass additional arguments to a selector function. However, useSelector always calls the provided selector function with one argument - the Redux root state.
The simplest solution is to pass an anonymous selector to useSelector, and then immediately call the real selector with both state and any additional arguments:
import { selectTodoById } from './todosSlice'

function TodoListitem({ todoId }) {
  // Captures `todoId` from scope, gets `state` as an arg, and forwards both
  // to the actual selector function to extract the result
  const todo = useSelector(state => selectTodoById(state, todoId))
}
Creating Unique Selector Instances
There are many cases where a selector function needs to be reused across multiple components. If the components will all be calling the selector with different arguments, it will break memoization - the selector never sees the same arguments multiple times in a row, and thus can never return a cached value.
The standard approach here is to create a unique instance of a memoized selector in the component, and then use that with useSelector. That allows each component to consistently pass the same arguments to its own selector instance, and that selector can correctly memoize the results.
For function components, this is normally done with useMemo or useCallback:
import { makeSelectItemsByCategory } from './categoriesSlice'

function CategoryList({ category }) {
  // Create a new memoized selector, for each component instance, on mount
  const selectItemsByCategory = useMemo(makeSelectItemsByCategory, [])

  const itemsByCategory = useSelector(state =>
    selectItemsByCategory(state, category)
  )
}
For class components with connect, this can be done with an advanced ""factory function"" syntax for mapState. If the mapState function returns a new function on its first call, that will be used as the real mapState function. This provides a closure where you can create a new selector instance:
import { makeSelectItemsByCategory } from './categoriesSlice'

const makeMapState = (state, ownProps) => {
  // Closure - create a new unique selector instance here,
  // and this will run once for every component instance
  const selectItemsByCategory = makeSelectItemsByCategory()

  const realMapState = (state, ownProps) => {
    return {
      itemsByCategory: selectItemsByCategory(state, ownProps.category)
    }
  }

  // Returning a function here will tell `connect` to use it as
  // `mapState` instead of the original one given to `connect`
  return realMapState
}

export default connect(makeMapState)(CategoryList)
Using Selectors Effectively
While selectors are a common pattern in Redux applications, they are often misused or misunderstood. Here are some guidelines for using selector functions correctly.
Define Selectors Alongside Reducers
Selector functions are often defined in the UI layer, directly inside of useSelector calls. However, this means that there can be repetition between selectors defined in different files, and the functions are anonymous.
Like any other function, you can extract an anonymous function outside the component to give it a name:
const selectTodos = state => state.todos

function TodoList() {
  const todos = useSelector(selectTodos)
}
However, multiple parts of the application may want to use the same lookups. Also, conceptually, we may want to keep the knowledge of how the todos state is organized as an implementation detail inside the todosSlice file, so that it's all in one place.
Because of this, it's a good idea to define reusable selectors alongside their corresponding reducers. In this case, we could export selectTodos from the todosSlice file:
src/features/todos/todosSlice.js
import { createSlice } from '@reduxjs/toolkit'

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    todoAdded(state, action) {
      state.push(action.payload)
    }
  }
})

export const { todoAdded } = todosSlice.actions
export default todosSlice.reducer

// Export a reusable selector here
export const selectTodos = state => state.todos
That way, if we happen to make an update to the structure of the todos slice state, the relevant selectors are right here and can be updated at the same time, with minimal changes to any other parts of the app.
Balance Selector Usage
It's possible to add too many selectors to an application. Adding a separate selector function for every single field is not a good idea! That ends up turning Redux into something resembling a Java class with getter/setter functions for every field. It's not going to improve the code, and it's probably going to make the code worse - maintaining all those extra selectors is a lot of additional effort, and it will be harder to trace what values are being used where.
Similarly, don't make every single selector memoized!. Memoization is only needed if you are truly deriving results, and if the derived results would likely create new references every time. A selector function that does a direct lookup and return of a value should be a plain function, not memoized.
Some examples of when and when not to memoize:
// ❌ DO NOT memoize: will always return a consistent reference
const selectTodos = state => state.todos
const selectNestedValue = state => state.some.deeply.nested.field
const selectTodoById = (state, todoId) => state.todos[todoId]

// ❌ DO NOT memoize: deriving data, but will return a consistent result
const selectItemsTotal = state => {
  return state.items.reduce((result, item) => {
    return result + item.total
  }, 0)
}
const selectAllCompleted = state => state.todos.every(todo => todo.completed)

// ✅ SHOULD memoize: returns new references when called
const selectTodoDescriptions = state => state.todos.map(todo => todo.text)
Reshape State as Needed for Components
Selectors do not have to limit themselves to direct lookups - they can perform any needed transformation logic inside. This is especially valuable to help prepare data that is needed by specific components.
A Redux state often has data in a ""raw"" form, because the state should be kept minimal, and many components may need to present the same data differently. You can use selectors to not only extract state, but to reshape it as needed for this specific component's needs. That could include pulling data from multiple slices of the root state, extracting specific values, merging different pieces of the data together, or any other transformations that are helpful.
It's fine if a component has some of this logic too, but it can be beneficial to pull all of this transformation logic out into separate selectors for better reuse and testability.
Globalize Selectors if Needed
There's an inherent imbalance between writing slice reducers and selectors. Slice reducers only know about their one portion of the state - to the reducer, its state is all that exists, such as the array of todos in a todoSlice. Selectors, on the other hand, usually are written to take the entire Redux root state as their argument. This means that they have to know where in the root state this slice's data is kept, such as state.todos, even though that's not really defined until the root reducer is created (typically in the app-wide store setup logic).
A typical slice file often has both of these patterns side-by-side. That's fine, especially in small or midsize apps. But, depending on your app's architecture, you may want to further abstract the selectors so that they don't know where the slice state is kept - it has to be handed to them.
We refer to this pattern as ""globalizing"" selectors. A ""globalized"" selector is one that accepts the Redux root state as an argument, and knows how to find the relevant slice of state to perform the real logic. A ""localized"" selector is one that expects just a piece of the state as an argument, without knowing or caring where that is in the root state:
// ""Globalized"" - accepts root state, knows to find data at `state.todos`
const selectAllTodosCompletedGlobalized = state =>
  state.todos.every(todo => todo.completed)

// ""Localized"" - only accepts `todos` as argument, doesn't know where that came from
const selectAllTodosCompletedLocalized = todos =>
  todos.every(todo => todo.completed)
""Localized"" selectors can be turned into ""globalized"" selectors by wrapping them in a function that knows how to retrieve the right slice of state and pass it onwards.
Redux Toolkit's createEntityAdapter API is an example of this pattern. If you call todosAdapter.getSelectors(), with no argument, it returns a set of ""localized"" selectors that expect the entity slice state as their argument. If you call todosAdapter.getSelectors(state => state.todos), it returns a set of ""globalized"" selectors that expect to be called with the Redux root state as their argument.
There may also be other benefits to having ""localized"" versions of selectors as well. For example, say we have an advanced scenario of keeping multiple copies of createEntityAdapter data nested in the store, such as a chatRoomsAdapter that tracks rooms, and each room definition then has a chatMessagesAdapter state to store the messages. We can't directly look up the messages for each room - we first have to retrieve the room object, then select the messages out of that. This is easier if we have a set of ""localized"" selectors for the messages.
Further Information
Selector libraries:
Reselect: https://github.com/reduxjs/reselect
proxy-memoize: https://github.com/dai-shi/proxy-memoize
re-reselect: https://github.com/toomuchdesign/re-reselect
reselect-tools: https://github.com/skortchmark9/reselect-tools
redux-views: https://github.com/josepot/redux-views
Reselect v5 Roadmap Discussion: Goals and API Design
Randy Coulman has an excellent series of blog posts on selector architecture and different approaches for globalizing Redux selectors, with tradeoffs:
Encapsulating the Redux State Tree
Redux Reducer/Selector Asymmetry
Modular Reducers and Selectors
Globalizing Redux Selectors
Globalizing Curried Selectors
Solving Circular Dependencies in Modular Redux
Edit this page
Last updated on Mar 21, 2024""""""",6497,31098,redux
https://redux.js.org/usage/writing-logic-thunks,"""""""Using ReduxRedux Logic and PatternsWriting Logic with Thunks
Writing Logic with Thunks
WHAT YOU'LL LEARN
What ""thunks"" are, and why they're used for writing Redux logic
How the thunk middleware works
Techniques for writing sync and async logic in thunks
Common thunk usage patterns
Thunk Overview
What is a ""thunk""?
The word ""thunk"" is a programming term that means ""a piece of code that does some delayed work"". Rather than execute some logic now, we can write a function body or code that can be used to perform the work later.
For Redux specifically, ""thunks"" are a pattern of writing functions with logic inside that can interact with a Redux store's dispatch and getState methods.
Using thunks requires the redux-thunk middleware to be added to the Redux store as part of its configuration.
Thunks are a standard approach for writing async logic in Redux apps, and are commonly used for data fetching. However, they can be used for a variety of tasks, and can contain both synchronous and asynchronous logic.
Writing Thunks
A thunk function is a function that accepts two arguments: the Redux store dispatch method, and the Redux store getState method. Thunk functions are not directly called by application code. Instead, they are passed to store.dispatch():
Dispatching thunk functions
const thunkFunction = (dispatch, getState) => {
  // logic here that can dispatch actions or read state
}

store.dispatch(thunkFunction)
A thunk function may contain any arbitrary logic, sync or async, and can call dispatch or getState at any time.
In the same way that Redux code normally uses action creators to generate action objects for dispatching instead of writing action objects by hand, we normally use thunk action creators to generate the thunk functions that are dispatched. A thunk action creator is a function that may have some arguments, and returns a new thunk function. The thunk typically closes over any arguments passed to the action creator, so they can be used in the logic:
Thunk action creators and thunk functions
// fetchTodoById is the ""thunk action creator""
export function fetchTodoById(todoId) {
  // fetchTodoByIdThunk is the ""thunk function""
  return async function fetchTodoByIdThunk(dispatch, getState) {
    const response = await client.get(`/fakeApi/todo/${todoId}`)
    dispatch(todosLoaded(response.todos))
  }
}
Thunk functions and action creators can be written using either the function keyword or arrow functions - there's no meaningful difference here. The same fetchTodoById thunk could also be written using arrow functions, like this:
Writing thunks using arrow functions
export const fetchTodoById = todoId => async dispatch => {
  const response = await client.get(`/fakeApi/todo/${todoId}`)
  dispatch(todosLoaded(response.todos))
}
In either case, the thunk is dispatched by calling the action creator, in the same way as you'd dispatch any other Redux action:
function TodoComponent({ todoId }) {
  const dispatch = useDispatch()

  const onFetchClicked = () => {
    // Calls the thunk action creator, and passes the thunk function to dispatch
    dispatch(fetchTodoById(todoId))
  }
}
Why Use Thunks?
Thunks allow us to write additional Redux-related logic separate from a UI layer. This logic can include side effects, such as async requests or generating random values, as well as logic that requires dispatching multiple actions or access to the Redux store state.
Redux reducers must not contain side effects, but real applications require logic that has side effects. Some of that may live inside components, but some may need to live outside the UI layer. Thunks (and other Redux middleware) give us a place to put those side effects.
It's common to have logic directly in components, such as making an async request in a click handler or a useEffect hook and then processing the results. However, it's often necessary to move as much of that logic as possible outside the UI layer. This may be done to improve testability of the logic, to keep the UI layer as thin and ""presentational"" as possible, or to improve code reuse and sharing.
In a sense, a thunk is a loophole where you can write any code that needs to interact with the Redux store, ahead of time, without needing to know which Redux store will be used. This keeps the logic from being bound to any specific Redux store instance and keeps it reusable.
Detailed Explanation: Thunks, Connect, and ""Container Components""
Thunk Use Cases
Because thunks are a general-purpose tool that can contain arbitrary logic, they can be used for a wide variety of purposes. The most common use cases are:
Moving complex logic out of components
Making async requests or other async logic
Writing logic that needs to dispatch multiple actions in a row or over time
Writing logic that needs access to getState to make decisions or include other state values in an action
Thunks are ""one-shot"" functions, with no sense of a lifecycle. They also cannot see other dispatched actions. So, they should not generally be used for initializing persistent connections like websockets, and you can't use them to respond to other actions.
Thunks are best used for complex synchronous logic, and simple to moderate async logic such as making a standard AJAX request and dispatching actions based on the request results.
Redux Thunk Middleware
Dispatching thunk functions requires that the redux-thunk middleware has been added to the Redux store as part of its configuration.
Adding the Middleware
The Redux Toolkit configureStore API automatically adds the thunk middleware during store creation, so it should typically be available with no extra configuration needed.
If you need to add the thunk middleware to a store manually, that can be done by passing the thunk middleware to applyMiddleware() as part of the setup process.
How Does the Middleware Work?
To start, let's review how Redux middleware work in general.
Redux middleware are all written as a series of 3 nested functions:
The outer function receives a ""store API"" object with {dispatch, getState}
The middle function receives the next middleware in the chain (or the actual store.dispatch method)
The inner function will be called with each action as it's passed through the middleware chain
It's important to note that middleware can be used to allow passing values that are not action objects into store.dispatch(), as long as the middleware intercepts those values and does not let them reach the reducers.
With that in mind, we can look at the specifics of the thunk middleware.
The actual implementation of the thunk middleware is very short - only about 10 lines. Here's the source, with additional added comments:
Redux thunk middleware implementation, annotated
// standard middleware definition, with 3 nested functions:
// 1) Accepts `{dispatch, getState}`
// 2) Accepts `next`
// 3) Accepts `action`
const thunkMiddleware =
  ({ dispatch, getState }) =>
  next =>
  action => {
    // If the ""action"" is actually a function instead...
    if (typeof action === 'function') {
      // then call the function and pass `dispatch` and `getState` as arguments
      return action(dispatch, getState)
    }

    // Otherwise, it's a normal action - send it onwards
    return next(action)
  }
In other words:
If you pass a function into dispatch, the thunk middleware sees that it's a function instead of an action object, intercepts it, and calls that function with (dispatch, getState) as its arguments
If it's a normal action object (or anything else), it's forwarded to the next middleware in the chain
Injecting Config Values Into Thunks
The thunk middleware does have one customization option. You can create a custom instance of the thunk middleware at setup time, and inject an ""extra argument"" into the middleware. The middleware will then inject that extra value as the third argument of every thunk function. This is most commonly used for injecting an API service layer into thunk functions, so that they don't have hardcoded dependencies on the API methods:
Thunk setup with an extra argument
import thunkMiddleware from 'redux-thunk'

const serviceApi = createServiceApi('/some/url')

const thunkMiddlewareWithArg = thunkMiddleware.withExtraArgument({ serviceApi })
Redux Toolkit's configureStore supports this as part of its middleware customization in getDefaultMiddleware:
Thunk extra argument with configureStore
const store = configureStore({
  reducer: rootReducer,
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      thunk: {
        extraArgument: { serviceApi }
      }
    })
})
There can only be one extra argument value. If you need to pass in multiple values, pass in an object containing those.
The thunk function will then receive that extra value as its third argument:
Thunk function with extra argument
export const fetchTodoById =
  todoId => async (dispatch, getState, extraArgument) => {
    // In this example, the extra arg is an object with an API service inside
    const { serviceApi } = extraArgument
    const response = await serviceApi.getTodo(todoId)
    dispatch(todosLoaded(response.todos))
  }
Thunk Usage Patterns
Dispatching Actions
Thunks have access to the dispatch method. This can be used to dispatch actions, or even other thunks. This can be useful for dispatching multiple actions in a row (although this is a pattern that should be minimized), or orchestrating complex logic that needs to dispatch at multiple points in the process.
Example: thunks dispatching actions and thunks
// An example of a thunk dispatching other action creators,
// which may or may not be thunks themselves. No async code, just
// orchestration of higher-level synchronous logic.
function complexSynchronousThunk(someValue) {
  return (dispatch, getState) => {
    dispatch(someBasicActionCreator(someValue))
    dispatch(someThunkActionCreator())
  }
}
Accessing State
Unlike components, thunks also have access to getState. This can be called at any time to retrieve the current root Redux state value. This can be useful for running conditional logic based on the current state. It's common to use selector functions when reading state inside of thunks rather than accessing nested state fields directly, but either approach is fine.
Example: Conditional dispatching based on state
const MAX_TODOS = 5

function addTodosIfAllowed(todoText) {
  return (dispatch, getState) => {
    const state = getState()

    // Could also check `state.todos.length < MAX_TODOS`
    if (selectCanAddNewTodo(state, MAX_TODOS)) {
      dispatch(todoAdded(todoText))
    }
  }
}
It's preferable to put as much logic as possible in reducers, but it's fine for thunks to also have additional logic inside as well.
Since the state is synchronously updated as soon as the reducers process an action, you can call getState after a dispatch to get the updated state.
Example: checking state after dispatch
function checkStateAfterDispatch() {
  return (dispatch, getState) => {
    const firstState = getState()
    dispatch(firstAction())

    const secondState = getState()

    if (secondState.someField != firstState.someField) {
      dispatch(secondAction())
    }
  }
}
One other reason to consider accessing state in a thunk is to fill out an action with additional info. Sometimes a slice reducer really needs to read a value that isn't in its own slice of state. A possible workaround to that is to dispatch a thunk, extract the needed values from state, and then dispatch a plain action containing the additional info.
Example: actions containing cross-slice data
// One solution to the ""cross-slice state in reducers"" problem:
// read the current state in a thunk, and include all the necessary
// data in the action
function crossSliceActionThunk() {
  return (dispatch, getState) => {
    const state = getState()
    // Read both slices out of state
    const { a, b } = state

    // Include data from both slices in the action
    dispatch(actionThatNeedsMoreData(a, b))
  }
}
Async Logic and Side Effects
Thunks may contain async logic, as well as side effects such as updating localStorage. That logic may use Promise chaining such as someResponsePromise.then(), although the async/await syntax is usually preferable for readability.
When making async requests, it's standard to dispatch actions before and after a request to help track loading state. Typically, a ""pending"" action before the request and a loading state enum is marked as ""in progress"". If the request succeeds, a ""fulfilled"" action is dispatched with the result data, or a ""rejected"" action is dispatched containing the error info.
Error handling here can be trickier than most people think. If you chain resPromise.then(dispatchFulfilled).catch(dispatchRejected) together, you may end up dispatching a ""rejected"" action if some non-network error occurs during the process of handling the ""fulfilled"" action. It's better to use the second argument of .then() to ensure you only handle errors related to the request itself:
Example: async request with promise chaining
function fetchData(someValue) {
  return (dispatch, getState) => {
    dispatch(requestStarted())

    myAjaxLib.post('/someEndpoint', { data: someValue }).then(
      response => dispatch(requestSucceeded(response.data)),
      error => dispatch(requestFailed(error.message))
    )
  }
}
With async/await, this can be even trickier, because of how try/catch logic is usually organized. In order to ensure that the catch block only handles errors from the network level, it may be necessary to reorganize the logic so that the thunk returns early if there's an error, and ""fulfilled"" action only happens at the end:
Example: error handling with async/await
function fetchData(someValue) {
  return async (dispatch, getState) => {
    dispatch(requestStarted())

    // Have to declare the response variable outside the try block
    let response

    try {
      response = await myAjaxLib.post('/someEndpoint', { data: someValue })
    } catch (error) {
      // Ensure we only catch network errors
      dispatch(requestFailed(error.message))
      // Bail out early on failure
      return
    }

    // We now have the result and there's no error. Dispatch ""fulfilled"".
    dispatch(requestSucceeded(response.data))
  }
}
Note that this issue isn't exclusive to Redux or thunks - it can apply even if you're only working with React component state as well, or any other logic that requires additional processing of a successful result.
This pattern is admittedly awkward to write and read. In most cases you can probably get away with a more typical try/catch pattern where the request and the dispatch(requestSucceeded()) are back-to-back. It's still worth knowing that this can be an issue.
Returning Values from Thunks
By default, store.dispatch(action) returns the actual action object. Middleware can override the return value being passed back from dispatch, and substitute whatever other value they want to return. For example, a middleware could choose to always return 42 instead:
Middleware return values
const return42Middleware = storeAPI => next => action => {
  const originalReturnValue = next(action)
  return 42
}

// later
const result = dispatch(anyAction())
console.log(result) // 42
The thunk middleware does this, by returning whatever the called thunk function returns.
The most common use case for this is returning a promise from a thunk. This allows the code that dispatched the thunk to wait on the promise to know that the thunk's async work is complete. This is often used by components to coordinate additional work:
Example: Awaiting a thunk result promise
const onAddTodoClicked = async () => {
  await dispatch(saveTodo(todoText))
  setTodoText('')
}
There's also a neat trick you can do with this: you can repurpose a thunk as a way to make a one-time selection from the Redux state when you only have access to dispatch. Since dispatching a thunk returns the thunk return value, you could write a thunk that accepts a selector, and immediately calls the selector with the state and returns the result. This can be useful in a React component, where you have access to dispatch but not getState.
Example: reusing thunks for selecting data
// In your Redux slices:
const getSelectedData = selector => (dispatch, getState) => {
  return selector(getState())
}

// in a component
const onClick = () => {
  const todos = dispatch(getSelectedData(selectTodos))
  // do more logic with this data
}
This is not a recommended practice per se, but it's semantically legal and will work fine.
Using createAsyncThunk
Writing async logic with thunks can be somewhat tedious. Each thunk typically requires defining three different action types + matching action creators for ""pending/fulfilled/rejected"", plus the actual thunk action creator + thunk function. There's also the edge cases with error handling to deal with.
Redux Toolkit has a createAsyncThunk API that abstracts the process of generating those actions, dispatching them based on a Promise lifecycle, and handling the errors correctly. It accepts a partial action type string (used to generate the action types for pending, fulfilled, and rejected), and a ""payload creation callback"" that does the actual async request and returns a Promise. It then automatically dispatches the actions before and after the request, with the right arguments.
Since this is an abstraction for the specific use case of async requests, createAsyncThunk does not address all possible use cases for thunks. If you need to write synchronous logic or other custom behavior, you should still write a ""normal"" thunk by hand yourself instead.
The thunk action creator has the action creators for pending, fulfilled, and rejected attached. You can use the extraReducers option in createSlice to listen for those action types and update the slice's state accordingly.
Example: createAsyncThunk
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

// omit imports and state

export const fetchTodos = createAsyncThunk('todos/fetchTodos', async () => {
  const response = await client.get('/fakeApi/todos')
  return response.todos
})

const todosSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    // omit reducer cases
  },
  extraReducers: builder => {
    builder
      .addCase(fetchTodos.pending, (state, action) => {
        state.status = 'loading'
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        const newEntities = {}
        action.payload.forEach(todo => {
          newEntities[todo.id] = todo
        })
        state.entities = newEntities
        state.status = 'idle'
      })
  }
})
Fetching Data with RTK Query
Redux Toolkit has a new RTK Query data fetching API. RTK Query is a purpose built data fetching and caching solution for Redux apps, and can eliminate the need to write any thunks or reducers to manage data fetching.
RTK Query actually uses createAsyncThunk internally for all requests, along with a custom middleware to manage cache data lifetimes.
First, create an ""API slice"" with definitions for the server endpoints your app will talk to. Each endpoint will auto-generate a React hook with a name based on the endpoint and request type, like useGetPokemonByNameQuery:
RTK Query: API slice (pokemonSlice.js)
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const pokemonApi = createApi({
  reducerPath: 'pokemonApi',
  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),
  endpoints: builder => ({
    getPokemonByName: builder.query({
      query: (name: string) => `pokemon/${name}`
    })
  })
})

export const { useGetPokemonByNameQuery } = pokemonApi
Then, add the generated API slice reducer and custom middleware to the store:
RTK Query: store setup
import { configureStore } from '@reduxjs/toolkit'
// Or from '@reduxjs/toolkit/query/react'
import { setupListeners } from '@reduxjs/toolkit/query'
import { pokemonApi } from './services/pokemon'

export const store = configureStore({
  reducer: {
    // Add the generated reducer as a specific top-level slice
    [pokemonApi.reducerPath]: pokemonApi.reducer
  },
  // Adding the api middleware enables caching, invalidation, polling,
  // and other useful features of `rtk-query`.
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware().concat(pokemonApi.middleware)
})
Finally, import the auto-generated React hook into your component and call it. The hook will automatically fetch data when the component mounts, and if multiple components use the same hook with the same arguments, they will share the cached results:
RTK Query: using fetching hooks
import { useGetPokemonByNameQuery } from './services/pokemon'

export default function Pokemon() {
  // Using a query hook automatically fetches data and returns query values
  const { data, error, isLoading } = useGetPokemonByNameQuery('bulbasaur')

  // rendering logic
}
We encourage you to try out RTK Query and see if it can help simplify the data fetching code in your own apps.
Further Information
Reason for middleware and side effects:
""How to dispatch a Redux action with a timeout?""
""Why do we need middleware for async flow?""
Thunk tutorials:
What the heck is a thunk?
Thunks in Redux: the basics
Edit this page
Last updated on Dec 27, 2022""""""",4458,21327,redux
https://redux.js.org/usage/side-effects-approaches,"""""""Using ReduxRedux Logic and PatternsSide Effects Approaches
Side Effects Approaches
WHAT YOU'LL LEARN
What ""side effects"" are and how they fit into Redux
Common tools for managing side effects with Redux
Our recommendations for which tools to use for different use cases
Redux and Side Effects
Side Effects Overview
By itself, a Redux store doesn't know anything about async logic. It only knows how to synchronously dispatch actions, update the state by calling the root reducer function, and notify the UI that something has changed. Any asynchronicity has to happen outside the store.
Redux reducers must never contain ""side effects"". A ""side effect"" is any change to state or behavior that can be seen outside of returning a value from a function. Some common kinds of side effects are things like:
Logging a value to the console
Saving a file
Setting an async timer
Making an AJAX HTTP request
Modifying some state that exists outside of a function, or mutating arguments to a function
Generating random numbers or unique random IDs (such as Math.random() or Date.now())
However, any real app will need to do these kinds of things somewhere. So, if we can't put side effects in reducers, where can we put them?
Middleware and Side Effects
Redux middleware were designed to enable writing logic that has side effects.
A Redux middleware can do anything when it sees a dispatched action: log something, modify the action, delay the action, make an async call, and more. Also, since middleware form a pipeline around the real store.dispatch function, this also means that we could actually pass something that isn't a plain action object to dispatch, as long as a middleware intercepts that value and doesn't let it reach the reducers.
Middleware also have access to dispatch and getState. That means you could write some async logic in a middleware, and still have the ability to interact with the Redux store by dispatching actions.
Because of this, Redux side effects and async logic are normally implemented through middleware.
Side Effects Use Cases
In practice, the single most common use case for side effects in a typical Redux app is fetching and caching data from the server.
Another use case more specific to Redux is writing logic that responds to a dispatched action or state change by executing additional logic, such as dispatching more actions.
Recommendations
We recommend using the tools that best fit each use case (see below for the reasons for our recommendations, as well as further details on each tool):
TIP
Data Fetching
Use RTK Query as the default approach for data fetching and caching
If RTKQ doesn't fully fit for some reason, use createAsyncThunk
Only fall back to handwritten thunks if nothing else works
Don't use sagas or observables for data fetching!
Reacting to Actions / State Changes, Async Workflows
Use RTK listeners as the default for responding to store updates and writing long-running async workflows
Only use sagas / observables if listeners don't solve your use case well enough
Logic with State Access
Use thunks for complex sync and moderate async logic, including access to getState and dispatching multiple actions
Why RTK Query for Data Fetching
Per the React docs section on ""alternatives for data fetching in Effects"", you should use either data fetching approaches that are built into a server-side framework, or a client-side cache. You should not write data fetching and cache management code yourself.
RTK Query was specifically designed to be a complete data fetching and caching layer for Redux-based applications. It manages all the fetching, caching, and loading status logic for you, and covers many edge cases that are typically forgotten or hard to handle if you write data fetching code yourself, as well as having cache lifecycle management built-in. It also makes it simple to fetch and use data via the auto-generated React hooks.
We specifically recommend against sagas for data fetching because the complexity of sagas is not helpful, and you would still have to write all of the caching + loading status management logic yourself.
Why Listeners for Reactive Logic
We've intentionally designed the RTK listener middleware to be straightforward to use. It uses standard async/await syntax, covers most common reactive use cases (responding to actions or state changes, debouncing, delays), and even several advanced cases (launching child tasks). It has a small bundle size (~3K), is included with Redux Toolkit, and works great with TypeScript.
We specifically recommend against sagas or observables for most reactive logic for multiple reasons:
Sagas: require understanding generator function syntax as well as the saga effects behaviors; add multiple levels of indirection due to needing extra actions dispatched; have poor TypeScript support; and the power and complexity is simply not needed for most Redux use cases.
Observables: require understanding the RxJS API and mental model; can be difficult to debug; can add significant bundle size
Common Side Effects Approaches
The lowest-level technique for managing side effects with Redux is to write your own custom middleware that listens for specific actions and runs logic. However, that's rarely used. Instead, most apps have historically used one of the common pre-built Redux side effects middleware available in the ecosystem: thunks, sagas, or observables. Each of these has its own different use cases and tradeoffs.
More recently, our official Redux Toolkit package has added two new APIs for managing side effects: the ""listener"" middleware for writing reactive logic, and RTK Query for fetching and caching server state.
Thunks
The Redux ""thunk"" middleware has traditionally been the most widely used middleware for writing async logic.
Thunks work by passing a function into dispatch. The thunk middleware intercepts the function, calls it, and passes in theThunkFunction(dispatch, getState). The thunk function can now do any sync/async logic and interact with the store.
Thunk Use Cases
Thunks are best used for complex sync logic that needs access to dispatch and getState, or moderate async logic such as one-shot ""fetch some async data and dispatch an action with the result"" requests.
We have traditionally recommended thunks as the default approach, and Redux Toolkit specifically includes the createAsyncThunk API for the ""request and dispatch"" use case. For other use cases, you can write your own thunk functions.
Thunk Tradeoffs
👍: Just write functions; may contain any logic
👎: Can't respond to dispatched actions; imperative; can't be cancelled
Thunk Examples
const thunkMiddleware =
  ({ dispatch, getState }) =>
  next =>
  action => {
    if (typeof action === 'function') {
      return action(dispatch, getState)
    }

    return next(action)
  }

// Original ""hand-written"" thunk fetch request pattern
const fetchUserById = userId => {
  return async (dispatch, getState) => {
    // Dispatch ""pending"" action to help track loading state
    dispatch(fetchUserStarted())
    // Need to pull this out to have correct error handling
    let lastAction
    try {
      const user = await userApi.getUserById(userId)
      // Dispatch ""fulfilled"" action on success
      lastAction = fetchUserSucceeded(user)
    } catch (err) {
      // Dispatch ""rejected"" action on failure
      lastAction = fetchUserFailed(err.message)
    }
    dispatch(lastAction)
  }
}

// Similar request with `createAsyncThunk`
const fetchUserById2 = createAsyncThunk('fetchUserById', async userId => {
  const user = await userApi.getUserById(userId)
  return user
})
Sagas
The Redux-Saga middleware has traditionally been the second most common tool for side effects, after thunks. It's inspired by the backend ""saga"" pattern, where long-running workflows can respond to events triggered throughout the system.
Conceptually, you can think of sagas as ""background threads"" inside the Redux app, which have the ability to listen to dispatched actions and run additional logic.
Sagas are written using generator functions. Saga functions return descriptions of side effects and pause themselves, and the saga middleware is responsible for executing the side effect and resuming the saga function with the result. The redux-saga library includes a variety of effects definitions such as:
call: executes an async function and returns the result when the promise resolves:
put: dispatches a Redux action
fork: spawns a ""child saga"", like an additional thread that can do more work
takeLatest: listens for a given Redux action, triggers a saga function to execute, and cancels previous running copies of the saga if it's dispatched again
Saga Use Cases
Sagas are extremely powerful, and are best used for highly complex async workflows that require ""background thread""-type behavior or debouncing/cancelling.
Saga users have often pointed to the fact that saga functions only return descriptions of the desired effects as a major positive that makes them more testable.
Saga Tradeoffs
👍: Sagas are testable because they only return descriptions of effects; powerful effects model; pause/cancel capabilities
👎: generator functions are complex; unique saga effects API; saga tests often only test implementation results and need to be rewritten every time the saga is touched, making them a lot less valuable; do not work well with TypeScript;
Saga Examples
import { call, put, takeEvery } from 'redux-saga/effects'

// ""Worker"" saga: will be fired on USER_FETCH_REQUESTED actions
function* fetchUser(action) {
  yield put(fetchUserStarted())
  try {
    const user = yield call(userApi.getUserById, action.payload.userId)
    yield put(fetchUserSucceeded(user))
  } catch (err) {
    yield put(fetchUserFailed(err.message))
  }
}

// ""Watcher"" saga: starts fetchUser on each `USER_FETCH_REQUESTED` action
function* fetchUserWatcher() {
  yield takeEvery('USER_FETCH_REQUESTED', fetchUser)
}

// Can use also use sagas for complex async workflows with ""child tasks"":
function* fetchAll() {
  const task1 = yield fork(fetchResource, 'users')
  const task2 = yield fork(fetchResource, 'comments')
  yield delay(1000)
}

function* fetchResource(resource) {
  const { data } = yield call(api.fetch, resource)
  yield put(receiveData(data))
}
Observables
The Redux-Observable middleware lets you use RxJS observables to create processing pipelines called ""epics"".
Since RxJS is a framework-agnostic library, observable users point to the fact that you can reuse knowledge of how to use it across different platforms as a major selling point. In addition, RxJS lets you construct declarative pipelines that handle timing cases like cancellation or debouncing.
Observable Use Cases
Similar to sagas, observables are powerful and best used for highly complex async workflows that require ""background thread""-type behavior or debouncing/cancelling.
Observable Tradeoffs
👍: Observables are a highly powerful data flow model; RxJS knowledge can be used separate from Redux; declarative syntax
👎: RxJS API is complex; mental model; can be hard to debug; bundle size
Observable Examples
// Typical AJAX example:
const fetchUserEpic = action$ =>
  action$.pipe(
    filter(fetchUser.match),
    mergeMap(action =>
      ajax
        .getJSON(`https://api.github.com/users/${action.payload}`)
        .pipe(map(response => fetchUserFulfilled(response)))
    )
  )

// Can write highly complex async pipelines, including delays,
// cancellation, debouncing, and error handling:
const fetchReposEpic = action$ =>
  action$.pipe(
    filter(fetchReposInput.match),
    debounceTime(300),
    switchMap(action =>
      of(fetchReposStart()).pipe(
        concat(
          searchRepos(action.payload).pipe(
            map(payload => fetchReposSuccess(payload.items)),
            catchError(error => of(fetchReposError(error)))
          )
        )
      )
    )
  )
Listeners
Redux Toolkit includes the createListenerMiddleware API to handle ""reactive"" logic. It's specifically intended to be a lighter-weight alternative to sagas and observables that handles 90% of the same use cases, with a smaller bundle size, simpler API, and better TypeScript support.
Conceptually, this is similar to React's useEffect hook, but for Redux store updates.
The listener middleware lets you add entries that match against actions to determine when to run the effect callback. Similar to thunks, an effect callback can be sync or async, and have access to dispatch and getState. They also receive a listenerApi object with several primitives for building async workflows, such as:
condition(): pauses until a certain action is dispatched or state change occurs
cancelActiveListeners(): cancel existing in-progress instances of the effect
fork(): creates a ""child task"" that can do additional work
These primitives allow listeners to replicate almost all of the effects behaviors from Redux-Saga.
Listener Use Cases
Listeners can be used for a wide variety of tasks, such as lightweight store persistence, triggering additional logic when an action is dispatched, watching for state changes, and complex long-running ""background thread""-style async workflows.
In addition, listener entries can be added and removed dynamically at runtime by dispatching special add/removeListener actions. This integrates nicely with React's useEffect hook, and can be used for adding additional behavior that corresponds to a component's lifetime.
Listener Tradeoffs
👍: Built into Redux Toolkit; async/await is more familiar syntax; similar to thunks; lightweight concepts and size; works great with TypeScript
👎: Relatively new and not as ""battle-tested"" yet; not quite as flexible as sagas/observables
Listener Examples
// Create the middleware instance and methods
const listenerMiddleware = createListenerMiddleware()

// Add one or more listener entries that look for specific actions.
// They may contain any sync or async logic, similar to thunks.
listenerMiddleware.startListening({
  actionCreator: todoAdded,
  effect: async (action, listenerApi) => {
    // Run whatever additional side-effect-y logic you want here
    console.log('Todo added: ', action.payload.text)

    // Can cancel other running instances
    listenerApi.cancelActiveListeners()

    // Run async logic
    const data = await fetchData()

    // Use the listener API methods to dispatch, get state,
    // unsubscribe the listener, start child tasks, and more
    listenerApi.dispatch(todoAdded('Buy pet food'))
  }
})

listenerMiddleware.startListening({
  // Can match against actions _or_ state changes/contents
  predicate: (action, currentState, previousState) => {
    return currentState.counter.value !== previousState.counter.value
  },
  // Listeners can have long-running async workflows
  effect: async (action, listenerApi) => {
    // Pause until action dispatched or state changed
    if (await listenerApi.condition(matchSomeAction)) {
      // Spawn ""child tasks"" that can do more work and return results
      const task = listenerApi.fork(async forkApi => {
        // Can pause execution
        await forkApi.delay(5)
        // Complete the child by returning a value
        return 42
      })

      // Unwrap the child result in the listener
      const result = await task.result
      if (result.status === 'ok') {
        console.log('Child succeeded: ', result.value)
      }
    }
  }
})
RTK Query
Redux Toolkit includes RTK Query, a purpose-built data fetching and caching solution for Redux apps. It's designed to simplify common cases for loading data in a web application, eliminating the need to hand-write data fetching & caching logic yourself.
RTK Query relies on creating an API definition consisting of many ""endpoints"". An endpoint can be a ""query"" for fetching data, or a ""mutation"" for sending an update to the server. RTKQ manages fetching and caching data internally, including tracking usage of each cache entry and removing cached data that's no longer needed. It features a unique ""tag"" system for triggering automatic refetches of data as mutations update state on the server.
Like the rest of Redux, RTKQ is UI-agnostic at its core, and can be used with any UI framework. However, it also comes with React integration built in, and can automatically generate React hooks for each endpoint. This provides a familiar and simple API for fetching and updating data from React components.
RTKQ provides a fetch-based implementation out of the box, and works great with REST APIs. It's also flexible enough to be used with GraphQL APIs, and can even be configured to work with arbitrary async functions, allowing integration with external SDKs such as Firebase, Supabase, or your own async logic.
RTKQ also has powerful capabilities such as endpoint ""lifecycle methods"", allowing you to run logic as cache entries are added and removed. This can be used for scenarios like fetching initial data for a chat room, then subscribing to a socket for additional messages that are used to update the cache.
RTK Query Use Cases
RTK Query is specifically built to solve the use case of data fetching and caching of server state.
RTK Query Tradeoffs
👍: Built into RTK; eliminates the need to write any code (thunks, selectors, effects, reducers) for managing data fetching and loading state; works great with TS; integrates into the rest of the Redux store; built-in React hooks
👎: Intentionally a ""document""-style cache, rather than ""normalized""; Adds a one-time additional bundle size cost
RTK Query Examples
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
import type { Pokemon } from './types'

// Create an API definition using a base URL and expected endpoints
export const api = createApi({
  reducerPath: 'pokemonApi',
  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),
  endpoints: builder => ({
    getPokemonByName: builder.query<Pokemon, string>({
      query: name => `pokemon/${name}`
    }),
    getPosts: builder.query<Post[], void>({
      query: () => '/posts'
    }),
    addNewPost: builder.mutation<void, Post>({
      query: initialPost => ({
        url: '/posts',
        method: 'POST',
        // Include the entire post object as the body of the request
        body: initialPost
      })
    })
  })
})

// Export hooks for usage in functional components, which are
// auto-generated based on the defined endpoints
export const { useGetPokemonByNameQuery } = api

export default function App() {
  // Using a query hook automatically fetches data and returns query values
  const { data, error, isLoading } = useGetPokemonByNameQuery('bulbasaur')

  // render UI based on data and loading state
}
Other Approaches
Custom Middleware
Given that thunks, sagas, observables, and listeners are all forms of Redux middleware (and RTK Query includes its own custom middleware), it's always possible to write your own custom middleware if none of these tools sufficiently handles your use cases.
Note that we specifically recommend against trying to use custom middleware as a technique for managing the bulk of your app's logic! Some users have tried creating dozens of custom middleware, one per specific app feature. This adds significant overhead, as each middleware has to run as part of each call to dispatch. It's better to use a general-purpose middleware such as thunks or listeners instead, where there's a single middleware instance added that can handle many different chunks of logic.
Custom Middleware Example
const delayedActionMiddleware = storeAPI => next => action => {
  if (action.type === 'todos/todoAdded') {
    setTimeout(() => {
      // Delay this action by one second
      next(action)
    }, 1000)
    return
  }

  return next(action)
}
Websockets
Many apps use websockets or some other form of persistent connection, primarily to receive streaming updates from the server.
We generally recommend that most websocket usage in a Redux app should live inside a custom middleware, for several reasons:
Middleware exist for the lifetime of the application
Like with the store itself, you probably only need a single instance of a given connection that the whole app can use
Middleware can see all dispatched actions and dispatch actions themselves. This means a middleware can take dispatched actions and turn those into messages sent over the websocket, and dispatch new actions when a message is received over the websocket.
A websocket connection instance isn't serializable, so it doesn't belong in the store state itself
Depending on the needs of the application, you could create the socket as part of the middleware init process, create the socket on demand in the middleware by dispatching an initialization action, or create it in a separate module file so it can be accessed elsewhere.
Websockets can also be used in an RTK Query lifecycle callback, where they could respond to messages by applying updates to the RTKQ cache.
XState
State machines can be very useful for defining possible known states for a system and the possible transitions between each state, as well as triggering side effects when a transition occurs.
Redux reducers can be written as true Finite State Machines, but RTK doesn't include anything to help with this. In practice, they tend to be partial state machines that really only care about the dispatched action to determine how to update the state. Listeners, sagas, and observables can be used for the ""run side effects after dispatch"" aspect, but can sometimes require more work to ensure a side effect only runs at a specific time.
XState is a powerful library for defining true state machines and executing them, including managing state transitions based on events and triggering related side effects. It also has related tools for creating state machine definitions via a graphical editor, which can then be loaded into the XState logic for execution.
While there currently is no official integration between XState and Redux, it is possible to use an XState machine as a Redux reducer, and the XState developers have created a useful POC demonstrating using XState as a Redux side effects middleware:
https://github.com/mattpocock/redux-xstate-poc
Further Information
Presentation: The Evolution of Redux Async Logic
Reason for middleware and side effects:
""How to dispatch a Redux action with a timeout?""
""Why do we need middleware for async flow?""
Docs and Tutorials:
Redux Fundamentals, Part 4: Store > Middleware
Redux Fundamentals, Part 6: Async Logic and Data Fetching
Redux Essentials, Part 5: Async Logic and Data Fetching
Redux Essentials, Part 7: RTK Query Basics
Using Redux: Writing Logic with Thunks
Redux Toolkit: RTK Query Overview
Articles and comparisons
Designing the RTK Listener Middleware
Thoughts on Async Redux: comparing thunks, sagas, and observables
Redux Toolkit’s new listener middleware vs. Redux-Saga
Experimenting with the Redux Listener Middleware
Edit this page
Last updated on Nov 25, 2023""""""",4740,22957,redux
https://redux.js.org/usage/writing-custom-middleware,"""""""Using ReduxRedux Logic and PatternsWriting Custom Middleware
Writing Custom Middleware
WHAT YOU'LL LEARN
When to use custom middleware
Standard patterns for middleware
How to make sure that your middleware is compatible with other Redux projects
Middleware in Redux can be mainly used to either
create side effects for actions,
modify or cancel actions, or to
modify the input accepted by dispatch.
Most use cases fall into the first category: For example Redux-Saga, redux-observable, and RTK listener middleware all create side effects that react to actions. These examples also show that this is a very common need: To be able to react to an action other than with a state change.
Modifying actions can be used to e.g. enhance an action with information from the state or from an external input, or to throttle, debounce or gate them.
The most obvious example for modifying the input of dispatch is Redux Thunk, which transforms a function returning an action into an action by calling it.
When to use custom middleware
Most of the time, you won't actually need custom middleware. The most likely use case for middleware is side effects, and there is plenty of packages who nicely package side effects for Redux and have been in use long enough to get rid of the subtle problems you would run into when building this yourself. A good starting point is RTK Query for managing server-side state and RTK listener middleware for other side effects.
You might still want to use custom middleware in one of two cases:
If you only have a single, very simple side effect, it might not be worth it to add a full additional framework. Just make sure that you switch to an existing framework once your application grows instead of growing your own custom solution.
If you need to modify or cancel actions.
Standard patterns for middleware
Create side effects for actions
This is the most common middleware. Here's what it looks like for rtk listener middleware:
const middleware: ListenerMiddleware<S, D, ExtraArgument> =
  api => next => action => {
    if (addListener.match(action)) {
      return startListening(action.payload)
    }

    if (clearAllListeners.match(action)) {
      clearListenerMiddleware()
      return
    }

    if (removeListener.match(action)) {
      return stopListening(action.payload)
    }

    // Need to get this state _before_ the reducer processes the action
    let originalState: S | typeof INTERNAL_NIL_TOKEN = api.getState()

    // `getOriginalState` can only be called synchronously.
    // @see https://github.com/reduxjs/redux-toolkit/discussions/1648#discussioncomment-1932820
    const getOriginalState = (): S => {
      if (originalState === INTERNAL_NIL_TOKEN) {
        throw new Error(
          `${alm}: getOriginalState can only be called synchronously`
        )
      }

      return originalState as S
    }

    let result: unknown

    try {
      // Actually forward the action to the reducer before we handle listeners
      result = next(action)

      if (listenerMap.size > 0) {
        let currentState = api.getState()
        // Work around ESBuild+TS transpilation issue
        const listenerEntries = Array.from(listenerMap.values())
        for (let entry of listenerEntries) {
          let runListener = false

          try {
            runListener = entry.predicate(action, currentState, originalState)
          } catch (predicateError) {
            runListener = false

            safelyNotifyError(onError, predicateError, {
              raisedBy: 'predicate'
            })
          }

          if (!runListener) {
            continue
          }

          notifyListener(entry, action, api, getOriginalState)
        }
      }
    } finally {
      // Remove `originalState` store from this scope.
      originalState = INTERNAL_NIL_TOKEN
    }

    return result
  }
In the first part, it listens to addListener, clearAllListeners and removeListener actions to change which listeners should be invoked later on.
In the second part, the code mainly calculates the state after passing the action through the other middlewares and the reducer, and then passes both the original state as well as the new state coming from the reducer to the listeners.
It is common to have side effects after dispatching the action, because this allows taking into account both the original and the new state, and because the interaction coming from the side effects shouldn't influence the current action execution anyways (otherwise, it wouldn't be a side effect).
Modify or cancel actions, or modify the input accepted by dispatch
While these patterns are less common, most of them (except for cancelling actions) are used by redux thunk middleware:
const middleware: ThunkMiddleware<State, BasicAction, ExtraThunkArg> =
  ({ dispatch, getState }) =>
  next =>
  action => {
    // The thunk middleware looks for any functions that were passed to `store.dispatch`.
    // If this ""action"" is really a function, call it and return the result.
    if (typeof action === 'function') {
      // Inject the store's `dispatch` and `getState` methods, as well as any ""extra arg""
      return action(dispatch, getState, extraArgument)
    }

    // Otherwise, pass the action down the middleware chain as usual
    return next(action)
  }
Usually, dispatch can only handle JSON actions. This middleware adds the ability to also handle actions in the form of functions. It also changes the return type of the dispatch function itself by passing the return value of the function-action to be the return value of the dispatch function.
Rules to make compatible middleware
In principle, middleware is a very powerful pattern and can do whatever it wants with an action. Existing middleware might have assumptions about what happens in the middleware around it, though, and being aware of these assumptions will make it easier to ensure that your middleware works well with existing commonly used middleware.
There are two contact points between our middleware and the other middlewares:
Calling the next middleware
When you call next, the middleware will expect some form of action. Unless you want to explicitly modify it, just pass through the action that you received.
More subtly, some middlewares expect that the middleware is called on the same tick as dispatch is called, so next should be called synchronously by your middleware.
Returning the dispatch return value
Unless the middleware needs to explicitly modify the return value of dispatch, just return what you get from next. If you do need to modify the return value, then your middleware will need to sit in a very specific spot in the middleware chain to be able to do what it is supposed to - you will need to check compatibility with all other middlewares manually and decide how they could work together.
This has a tricky consequence:
const middleware: Middleware = api => next => async action => {
  const response = next(action)

  // Do something after the action hits the reducer
  const afterState = api.getState()
  if (action.type === 'some/action') {
    const data = await fetchData()
    api.dispatch(dataFetchedAction(data))
  }

  return response
}
Even though it looks like we didn't modify the response, we actually did: Due to async-await, it is now a promise. This will break some middlewares like the one from RTK Query.
So, how can we write this middleware instead?
const middleware: Middleware = api => next => action => {
  const response = next(action)

  // Do something after the action hits the reducer
  const afterState = api.getState()
  if (action.type === 'some/action') {
    void loadData(api)
  }

  return response
}

async function loadData(api) {
  const data = await fetchData()
  api.dispatch(dataFetchedAction(data))
}
Just move out the async logic into a separate function so that you can still use async-await, but don't actually wait for the promise to resolve in the middleware. void indicates to others reading the code that you decided to not await the promise explicitly without having an effect on the code.
Next Steps
If you haven't yet, take a look at the Middleware section in Understanding Redux to understand how middleware works under the hood.
Edit this page
Last updated on Jan 1, 2024""""""",1687,8260,redux
https://redux.js.org/usage/implementing-undo-history,"""""""Using ReduxRedux Logic and PatternsImplementing Undo History
Implementing Undo History
PREREQUISITES
Completion of the ""Redux Fundamentals"" tutorial
Understanding of ""reducer composition""
Building an Undo and Redo functionality into an app has traditionally required conscious effort from the developer. It is not an easy problem with classical MVC frameworks because you need to keep track of every past state by cloning all relevant models. In addition, you need to be mindful of the undo stack because the user-initiated changes should be undoable.
This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like Command.
With Redux, however, implementing undo history is a breeze. There are three reasons for this:
There are no multiple models—just a state subtree that you want to keep track of.
The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.
The reducer (state, action) => state signature makes it natural to implement generic “reducer enhancers” or “higher order reducers”. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.
In the first part of this recipe, we will explain the underlying concepts that make Undo and Redo possible to implement in a generic way.
In the second part of this recipe, we will show how to use Redux Undo package that provides this functionality out of the box.
Understanding Undo History
Designing the State Shape
Undo history is also part of your app's state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the history of this state at different points in time.
For example, the state shape of a counter app might look like this:
{
  counter: 10
}
If we wanted to implement Undo and Redo in such an app, we'd need to store more state so we can answer the following questions:
Is there anything left to undo or redo?
What is the current state?
What are the past (and future) states in the undo stack?
It is reasonable to suggest that our state shape should change to answer these questions:
{
  counter: {
    past: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    present: 10,
    future: []
  }
}
Now, if user presses “Undo”, we want it to change to move into the past:
{
  counter: {
    past: [0, 1, 2, 3, 4, 5, 6, 7, 8],
    present: 9,
    future: [10]
  }
}
And further yet:
{
  counter: {
    past: [0, 1, 2, 3, 4, 5, 6, 7],
    present: 8,
    future: [9, 10]
  }
}
When the user presses “Redo”, we want to move one step back into the future:
{
  counter: {
    past: [0, 1, 2, 3, 4, 5, 6, 7, 8],
    present: 9,
    future: [10]
  }
}
Finally, if the user performs an action (e.g. decrement the counter) while we're in the middle of the undo stack, we're going to discard the existing future:
{
  counter: {
    past: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    present: 8,
    future: []
  }
}
The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:
{
  counter: {
    past: [0, 1, 2],
    present: 3,
    future: [4]
  }
}
{
  todos: {
    past: [
      [],
      [{ text: 'Use Redux' }],
      [{ text: 'Use Redux', complete: true }]
    ],
    present: [
      { text: 'Use Redux', complete: true },
      { text: 'Implement Undo' }
    ],
    future: [
      [
        { text: 'Use Redux', complete: true },
        { text: 'Implement Undo', complete: true }
      ]
    ]
  }
}
In general, it looks like this:
{
  past: Array<T>,
  present: T,
  future: Array<T>
}
It is also up to us whether to keep a single top-level history:
{
  past: [
    { counterA: 1, counterB: 1 },
    { counterA: 1, counterB: 0 },
    { counterA: 0, counterB: 0 }
  ],
  present: { counterA: 2, counterB: 1 },
  future: []
}
Or many granular histories so user can undo and redo actions in them independently:
{
  counterA: {
    past: [1, 0],
    present: 2,
    future: []
  },
  counterB: {
    past: [0],
    present: 1,
    future: []
  }
}
We will see later how the approach we take lets us choose how granular Undo and Redo need to be.
Designing the Algorithm
Regardless of the specific data type, the shape of the undo history state is the same:
{
  past: Array<T>,
  present: T,
  future: Array<T>
}
Let's talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: UNDO and REDO. In our reducer, we will do the following steps to handle these actions:
Handling Undo
Remove the last element from the past.
Set the present to the element we removed in the previous step.
Insert the old present state at the beginning of the future.
Handling Redo
Remove the first element from the future.
Set the present to the element we removed in the previous step.
Insert the old present state at the end of the past.
Handling Other Actions
Insert the present at the end of the past.
Set the present to the new state after handling the action.
Clear the future.
First Attempt: Writing a Reducer
const initialState = {
  past: [],
  present: null, // (?) How do we initialize the present?
  future: []
}

function undoable(state = initialState, action) {
  const { past, present, future } = state

  switch (action.type) {
    case 'UNDO':
      const previous = past[past.length - 1]
      const newPast = past.slice(0, past.length - 1)
      return {
        past: newPast,
        present: previous,
        future: [present, ...future]
      }
    case 'REDO':
      const next = future[0]
      const newFuture = future.slice(1)
      return {
        past: [...past, present],
        present: next,
        future: newFuture
      }
    default:
      // (?) How do we handle other actions?
      return state
  }
}
This implementation isn't usable because it leaves out three important questions:
Where do we get the initial present state from? We don't seem to know it beforehand.
Where do we react to the external actions to save the present to the past?
How do we actually delegate the control over the present state to a custom reducer?
It seems that reducer isn't the right abstraction, but we're very close.
Meet Reducer Enhancers
You might be familiar with higher order functions. If you use React, you might be familiar with higher order components. Here is a variation on the same pattern, applied to reducers.
A reducer enhancer (or a higher order reducer) is a function that takes a reducer, and returns a new reducer that is able to handle new actions, or to hold more state, delegating control to the inner reducer for the actions it doesn't understand. This isn't a new pattern—technically, combineReducers() is also a reducer enhancer because it takes reducers and returns a new reducer.
A reducer enhancer that doesn't do anything looks like this:
function doNothingWith(reducer) {
  return function (state, action) {
    // Just call the passed reducer
    return reducer(state, action)
  }
}
A reducer enhancer that combines other reducers might look like this:
function combineReducers(reducers) {
  return function (state = {}, action) {
    return Object.keys(reducers).reduce((nextState, key) => {
      // Call every reducer with the part of the state it manages
      nextState[key] = reducers[key](state[key], action)
      return nextState
    }, {})
  }
}
Second Attempt: Writing a Reducer Enhancer
Now that we have a better understanding of reducer enhancers, we can see that this is exactly what undoable should have been:
function undoable(reducer) {
  // Call the reducer with empty action to populate the initial state
  const initialState = {
    past: [],
    present: reducer(undefined, {}),
    future: []
  }

  // Return a reducer that handles undo and redo
  return function (state = initialState, action) {
    const { past, present, future } = state

    switch (action.type) {
      case 'UNDO':
        const previous = past[past.length - 1]
        const newPast = past.slice(0, past.length - 1)
        return {
          past: newPast,
          present: previous,
          future: [present, ...future]
        }
      case 'REDO':
        const next = future[0]
        const newFuture = future.slice(1)
        return {
          past: [...past, present],
          present: next,
          future: newFuture
        }
      default:
        // Delegate handling the action to the passed reducer
        const newPresent = reducer(present, action)
        if (present === newPresent) {
          return state
        }
        return {
          past: [...past, present],
          present: newPresent,
          future: []
        }
    }
  }
}
We can now wrap any reducer into undoable reducer enhancer to teach it to react to UNDO and REDO actions.
// This is a reducer
function todos(state = [], action) {
  /* ... */
}

// This is also a reducer!
const undoableTodos = undoable(todos)

import { createStore } from 'redux'
const store = createStore(undoableTodos)

store.dispatch({
  type: 'ADD_TODO',
  text: 'Use Redux'
})

store.dispatch({
  type: 'ADD_TODO',
  text: 'Implement Undo'
})

store.dispatch({
  type: 'UNDO'
})
There is an important gotcha: you need to remember to append .present to the current state when you retrieve it. You may also check .past.length and .future.length to determine whether to enable or to disable the Undo and Redo buttons, respectively.
You might have heard that Redux was influenced by Elm Architecture. It shouldn't come as a surprise that this example is very similar to elm-undo-redo package.
Using Redux Undo
This was all very informative, but can't we just drop a library and use it instead of implementing undoable ourselves? Sure, we can! Meet Redux Undo, a library that provides simple Undo and Redo functionality for any part of your Redux tree.
In this part of the recipe, you will learn how to make a small ""todo list"" app logic undoable. You can find the full source of this recipe in the todos-with-undo example that comes with Redux.
Installation
First of all, you need to run
npm install redux-undo
This installs the package that provides the undoable reducer enhancer.
Wrapping the Reducer
You will need to wrap the reducer you wish to enhance with undoable function. For example, if you exported a todos reducer from a dedicated file, you will want to change it to export the result of calling undoable() with the reducer you wrote:
reducers/todos.js
import undoable from 'redux-undo'

/* ... */

const todos = (state = [], action) => {
  /* ... */
}

const undoableTodos = undoable(todos)

export default undoableTodos
There are many other options to configure your undoable reducer, like setting the action type for Undo and Redo actions.
Note that your combineReducers() call will stay exactly as it was, but the todos reducer will now refer to the reducer enhanced with Redux Undo:
reducers/index.js
import { combineReducers } from 'redux'
import todos from './todos'
import visibilityFilter from './visibilityFilter'

const todoApp = combineReducers({
  todos,
  visibilityFilter
})

export default todoApp
You may wrap one or more reducers in undoable at any level of the reducer composition hierarchy. We choose to wrap todos instead of the top-level combined reducer so that changes to visibilityFilter are not reflected in the undo history.
Updating the Selectors
Now the todos part of the state looks like this:
{
  visibilityFilter: 'SHOW_ALL',
  todos: {
    past: [
      [],
      [{ text: 'Use Redux' }],
      [{ text: 'Use Redux', complete: true }]
    ],
    present: [
      { text: 'Use Redux', complete: true },
      { text: 'Implement Undo' }
    ],
    future: [
      [
        { text: 'Use Redux', complete: true },
        { text: 'Implement Undo', complete: true }
      ]
    ]
  }
}
This means you need to access your state with state.todos.present instead of just state.todos:
containers/VisibleTodoList.js
const mapStateToProps = state => {
  return {
    todos: getVisibleTodos(state.todos.present, state.visibilityFilter)
  }
}
Adding the Buttons
Now all you need to do is add the buttons for the Undo and Redo actions.
First, create a new container component called UndoRedo for these buttons. We won't bother to split the presentational part into a separate file because it is very small:
containers/UndoRedo.js
import React from 'react'

/* ... */

let UndoRedo = ({ canUndo, canRedo, onUndo, onRedo }) => (
  <p>
    <button onClick={onUndo} disabled={!canUndo}>
      Undo
    </button>
    <button onClick={onRedo} disabled={!canRedo}>
      Redo
    </button>
  </p>
)
You will use connect() from React Redux to generate a container component. To determine whether to enable Undo and Redo buttons, you can check state.todos.past.length and state.todos.future.length. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:
containers/UndoRedo.js
/* ... */

import { ActionCreators as UndoActionCreators } from 'redux-undo'
import { connect } from 'react-redux'

/* ... */

const mapStateToProps = state => {
  return {
    canUndo: state.todos.past.length > 0,
    canRedo: state.todos.future.length > 0
  }
}

const mapDispatchToProps = dispatch => {
  return {
    onUndo: () => dispatch(UndoActionCreators.undo()),
    onRedo: () => dispatch(UndoActionCreators.redo())
  }
}

UndoRedo = connect(mapStateToProps, mapDispatchToProps)(UndoRedo)

export default UndoRedo
Now you can add UndoRedo component to the App component:
components/App.js
import React from 'react'
import Footer from './Footer'
import AddTodo from '../containers/AddTodo'
import VisibleTodoList from '../containers/VisibleTodoList'
import UndoRedo from '../containers/UndoRedo'

const App = () => (
  <div>
    <AddTodo />
    <VisibleTodoList />
    <Footer />
    <UndoRedo />
  </div>
)

export default App
This is it! Run npm install and npm start in the example folder and try it out!
Edit this page
Last updated on Jun 26, 2021""""""",3416,14236,redux
https://redux.js.org/faq,"""""""FAQFAQ Index
Redux FAQ
Table of Contents
General
When should I learn Redux?
When should I use Redux?
Can Redux only be used with React?
Do I need to have a particular build tool to use Redux?
Reducers
How do I share state between two reducers? Do I have to use combineReducers?
Do I have to use the switch statement to handle actions?
Organizing State
Do I have to put all my state into Redux? Should I ever use React's useState or useReducer?
Can I put functions, promises, or other non-serializable items in my store state?
How do I organize nested or duplicate data in my state?
Should I put form state or other UI state in my store?
Store Setup
Can or should I create multiple stores? Can I import my store directly, and use it in components myself?
Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?
How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?
Actions
Why should type be a string, or at least serializable? Why should my action types be constants?
Is there always a one-to-one mapping between reducers and actions?
How can I represent “side effects” such as AJAX calls? Why do we need things like “action creators”, “thunks”, and “middleware” to do async behavior?
What async middleware should I use? How do you decide between thunks, sagas, observables, or something else?
Should I dispatch multiple actions in a row from one action creator?
Immutable Data
What are the benefits of immutability?
Why is immutability required by Redux?
What approaches are there for handling data immutability? Do I have to use Immer?
What are the issues with using JavaScript for immutable operations?
Code Structure
What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?
How should I split my logic between reducers and action creators? Where should my “business logic” go?
Why should I use action creators?
Where should websockets and other persistent connections live?
How can I use the Redux store in non-component files?
Performance
How well does Redux “scale” in terms of performance and architecture?
Won't calling “all my reducers” for each action be slow?
Do I have to deep-clone my state in a reducer? Isn't copying my state going to be slow?
How can I reduce the number of store update events?
Will having “one state tree” cause memory problems? Will dispatching many actions take up memory?
Will caching remote data cause memory problems?
Design Decisions
Why doesn't Redux pass the state and action to subscribers?
Why doesn't Redux support using classes for actions and reducers?
Why does the middleware signature use currying?
Why does applyMiddleware use a closure for dispatch?
Why doesn't combineReducers include a third argument with the entire state when it calls each reducer?
Why doesn't mapDispatchToProps allow use of return values from getState() or mapStateToProps()?
React Redux
Why should I use React-Redux?
Why isn't my component re-rendering, or my mapStateToProps running?
Why is my component re-rendering too often?
How can I speed up my mapStateToProps?
Why don't I have this.props.dispatch available in my connected component?
Should I only connect my top component, or can I connect multiple components in my tree?
Miscellaneous
Are there any larger, “real” Redux projects?
How can I implement authentication in Redux?
Edit this page
Last updated on Nov 21, 2022""""""",748,3530,redux
https://redux.js.org/faq/general,"""""""FAQGeneral
Redux FAQ: General
When should I learn Redux?
What to learn can be an overwhelming question for a JavaScript developer. It helps to narrow the range of options by learning one thing at a time and focusing on problems you find in your work. Redux is a pattern for managing application state. If you do not have problems with state management, you might find the benefits of Redux harder to understand. Some UI libraries (like React) have their own state management system. If you are using one of these libraries, especially if you are just learning to use them, we encourage you to learn the capabilities of that built-in system first. It might be all you need to build your application. If your application becomes so complex that you are confused about where state is stored or how state changes, then it is a good time to learn Redux.
TIP
We recommend that most new learners should focus on learning React first, and wait to learn Redux until after you're already comfortable with React. That way, there's fewer new concepts to learn at once, and it's more clear what concepts are part of React and what concepts are part of Redux. You'll also have a better understanding of how using Redux fits into a React app, and why Redux can be useful.
Further information
Articles
Deciding What Not To Learn
How to learn web frameworks
Redux vs MobX vs Flux vs... Do you even need that?
Discussions
Ask HN: Overwhelmed with learning front-end, how do I proceed?
Twitter: If you want to teach someone to use an abstraction...
Twitter: it was never intended to be learned before...
Twitter: Learning Redux before React?
Twitter: This was my experience with Redux...
Dev.to: When is it time to use Redux?
When should I use Redux?
Not all apps need Redux. It's important to understand the kind of application you're building, the kinds of problems that you need to solve, and what tools can best solve the problems you're facing.
Redux helps you deal with shared state management, but like any tool, it has tradeoffs. It's not designed to be the shortest or fastest way to write code. It's intended to help answer the question ""When did a certain slice of state change, and where did the data come from?"", with predictable behavior. There are more concepts to learn, and more code to write. It also adds some indirection to your code, and asks you to follow certain restrictions. It's a trade-off between short term and long term productivity.
As Pete Hunt, one of the early contributors to React, says:
You'll know when you need Flux. If you aren't sure if you need it, you don't need it.
Similarly, Dan Abramov, one of the creators of Redux, says:
I would like to amend this: don't use Redux until you have problems with vanilla React.
Redux is most useful in cases when:
You have large amounts of application state that are needed in many places in the app
The app state is updated frequently
The logic to update that state may be complex
The app has a medium or large-sized codebase, and might be worked on by many people
You need to see how that state is being updated over time
There are also many other tools available that can help solve some of the same problems Redux does: state management, caching fetched server data, and passing data through the UI.
INFO
If you're not sure whether Redux is a good choice for your app, these resources give some more guidance:
When (and when not) to reach for Redux
The Tao of Redux, Part 1 - Implementation and Intent
You Might Not Need Redux
In the end, Redux is just a tool. It's a great tool, and there are some great reasons to use it, but there are also reasons you might not want to use it. Make informed decisions about your tools, and understand the tradeoffs involved in each decision.
Further information
Documentation
Thinking in Redux: Motivation
Articles
When (and when not) to reach for Redux
The Tao of Redux, Part 1 - Implementation and Intent
You Might Not Need Redux
The Case for Flux
Discussions
Twitter: Don't use Redux until...
Twitter: Redux is designed to be predictable, not concise
Twitter: Redux is useful to eliminate deep prop passing
Twitter: Don't use Redux unless you're unhappy with local component state
Twitter: You don't need Redux if your data never changes
Twitter: If your reducer looks boring, don't use redux
Reddit: You don't need Redux if your app just fetches something on a single page
Stack Overflow: Why use Redux over Facebook Flux?
Stack Overflow: Why should I use Redux in this example?
Stack Overflow: What could be the downsides of using Redux instead of Flux?
Stack Overflow: When should I add Redux to a React app?
Stack Overflow: Redux vs plain React?
Twitter: Redux is a platform for developers to build customized state management with reusable things
Can Redux only be used with React?
Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code. That said, it is most useful when combined with a declarative view implementation that can infer the UI updates from the state changes, such as React or one of the similar libraries available.
Do I need to have a particular build tool to use Redux?
Redux is written using modern JS syntax (ES2020), but the code is fairly simple.
If you need to target older browsers, please transpile it yourself.
The counter-vanilla example demonstrates basic ES5 usage with Redux included as a <script> tag. As the relevant pull request says:
The new Counter Vanilla example is aimed to dispel the myth that Redux requires Webpack, React, hot reloading, sagas, action creators, constants, Babel, npm, CSS modules, decorators, fluent Latin, an Egghead subscription, a PhD, or an Exceeds Expectations O.W.L. level.
Nope, it's just HTML, some artisanal <script> tags, and plain old DOM manipulation. Enjoy!
Edit this page
Last updated on Nov 25, 2023""""""",1306,5996,redux
https://redux.js.org/faq/reducers,"""""""FAQReducers
Redux FAQ: Reducers
Table of Contents
Redux FAQ: Reducers
Table of Contents
Reducers
How do I share state between two reducers? Do I have to use combineReducers?
Further information
Do I have to use the switch statement to handle actions?
Further information
Reducers
How do I share state between two reducers? Do I have to use combineReducers?
The suggested structure for a Redux store is to split the state object into multiple “slices” or “domains” by key, and provide a separate reducer function to manage each individual data slice. This is similar to how the standard Flux pattern has multiple independent stores, and Redux provides the combineReducers utility function to make this pattern easier. However, it's important to note that combineReducers is not required—it is simply a utility function for the common use case of having a single reducer function per state slice, with plain JavaScript objects for the data.
Many users later want to try to share data between two reducers, but find that combineReducers does not allow them to do so. There are several approaches that can be used:
If a reducer needs to know data from another slice of state, the state tree shape may need to be reorganized so that a single reducer is handling more of the data.
You may need to write some custom functions for handling some of these actions. This may require replacing combineReducers with your own top-level reducer function. You can also use a utility such as reduce-reducers to run combineReducers to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.
Middleware with async logic such as redux-thunk have access to the entire state through getState(). An action creator can retrieve additional data from the state and put it in an action, so that each reducer has enough information to update its own state slice.
In general, remember that reducers are just functions—you can organize them and subdivide them any way you want, and you are encouraged to break them down into smaller, reusable functions (“reducer composition”). While you do so, you may pass a custom third argument from a parent reducer if a child reducer needs additional data to calculate its next state. You just need to make sure that together they follow the basic rules of reducers: (state, action) => newState, and update state immutably rather than mutating it directly.
Further information
Documentation
API: combineReducers
Using Redux: Structuring Reducers
Discussions
#601: A concern on combineReducers, when an action is related to multiple reducers
#1400: Is passing top-level state object to branch reducer an anti-pattern?
Stack Overflow: Accessing other parts of the state when using combined reducers?
Stack Overflow: Reducing an entire subtree with redux combineReducers
Sharing State Between Redux Reducers
Do I have to use the switch statement to handle actions?
No. You are welcome to use any approach you'd like to respond to an action in a reducer. The switch statement is the most common approach, but it's fine to use if statements, a lookup table of functions, or to create a function that abstracts this away. In fact, while Redux does require that action objects contain a type field, your reducer logic doesn't even have to rely on that to handle the action. That said, the standard approach is definitely using a switch statement or a lookup table based on type.
Further information
Documentation
Using Redux: Reducing Boilerplate
Using Redux: Structuring Reducers - Splitting Reducer Logic
Discussions
#883: take away the huge switch block
#1167: Reducer without switch
Edit this page
Last updated on Jun 26, 2021""""""",744,3683,redux
https://redux.js.org/faq/organizing-state,"""""""FAQOrganizing State
Redux FAQ: Organizing State
Table of Contents
Redux FAQ: Organizing State
Table of Contents
Organizing State
Do I have to put all my state into Redux? Should I ever use React's useState or useReducer?
Further information
Can I put functions, promises, or other non-serializable items in my store state?
Further information
How do I organize nested or duplicate data in my state?
Further information
Should I put form state or other UI state in my store?
Further Information
Organizing State
Do I have to put all my state into Redux? Should I ever use React's useState or useReducer?
There is no “right” answer for this. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as “is this dropdown currently open”, inside a component's internal state.
Using local component state is fine. As a developer, it is your job to determine what kinds of state make up your application, and where each piece of state should live. Find a balance that works for you, and go with it.
Some common rules of thumb for determining what kind of data should be put into Redux:
Do other parts of the application care about this data?
Do you need to be able to create further derived data based on this original data?
Is the same data being used to drive multiple components?
Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?
Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?
Do you want to keep this data consistent while hot-reloading UI components (which may lose their internal state when swapped)?
Further information
Articles
When (and when not) to reach for Redux
Discussions
Reddit: ""When should I put something into my Redux store?""
Stack Overflow: Should all component state be kept in Redux store?
Can I put functions, promises, or other non-serializable items in my store state?
It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It's technically possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store, as well as interfere with time-travel debugging.
If you are okay with things like persistence and time-travel debugging potentially not working as intended, then you are totally welcome to put non-serializable items into your Redux store. Ultimately, it's your application, and how you implement it is up to you. As with many other things about Redux, just be sure you understand what tradeoffs are involved.
Further information
Discussions
#1248: Is it ok and possible to store a react component in a reducer?
#1279: Have any suggestions for where to put a Map Component in Flux?
#1390: Component Loading
#1407: Just sharing a great base class
#1793: React Elements in Redux State
How do I organize nested or duplicate data in my state?
Data with IDs, nesting, or relationships should generally be stored in a “normalized” fashion: each object should be stored once, keyed by ID, and other objects that reference it should only store the ID rather than a copy of the entire object. It may help to think of parts of your store as a database, with individual “tables” per item type. Libraries such as normalizr and redux-orm can provide help and abstractions in managing normalized data.
Further information
Documentation
Redux Essentials: Normalizing Data
Redux Fundamentals: Async Logic and Data Flow
Redux Fundamentals: Standard Redux Patterns
Examples: Real World example
Using Redux: Structuring Reducers - Prerequisite Concepts
Using Redux: Structuring Reducers - Normalizing State Shape
Articles
Querying a Redux Store
Discussions
#316: How to create nested reducers?
#815: Working with Data Structures
#946: Best way to update related state fields with split reducers?
#994: How to cut the boilerplate when updating nested entities?
#1255: Normalizr usage with nested objects in React/Redux
#1824: Normalising state and garbage collection
Twitter: state shape should be normalized
Stack Overflow: How to handle tree-shaped entities in Redux reducers?
Should I put form state or other UI state in my store?
The same rules of thumb for deciding what should go in the Redux store apply for this question as well.
Based on those rules of thumb, most form state doesn't need to go into Redux, as it's probably not being shared between components. However, that decision is always going to be specific to you and your application. You might choose to keep some form state in Redux because you are editing data that came from the store originally, or because you do need to see the work-in-progress values reflected in other components elsewhere in the application. On the other hand, it may be a lot simpler to keep the form state local to the component, and only dispatch an action to put the data in the store once the user is done with the form.
Based on this, in most cases you probably don't need a Redux-based form management library either. We suggest trying these approaches, in this order:
Even if the data is coming from the Redux store, start by writing your form logic by hand. It's likely this is all you'll need. (See Gosha Arinich's posts on working with forms in React for some excellent guidance on this.)
If you decide that writing forms ""manually"" is too difficult, try a React-based form library like Formik or React-Final-Form.
If you are absolutely sure you must use a Redux-based form library because the other approaches aren't sufficient, then you may finally want to look at Redux-Form and React-Redux-Form.
If you are keeping form state in Redux, you should take some time to consider performance characteristics. Dispatching an action on every keystroke of a text input probably isn't worthwhile, and you may want to look into ways to buffer keystrokes to keep changes local before dispatching. As always, take some time to analyze the overall performance needs of your own application.
Other kinds of UI state follow these rules of thumb as well. The classic example is tracking an isDropdownOpen flag. In most situations, the rest of the app doesn't care about this, so in most cases it should stay in component state. However, depending on your application, it may make sense to use Redux to manage dialogs and other popups, tabs, expanding panels, and so on.
Further Information
Articles
Gosha Arinich: Writings on Forms in React
Practical Redux, Part 6: Connected Lists and Forms
Practical Redux, Part 7: Form Change Handling
Practical Redux, Part 10: Managing Modals and Context Menus
React/Redux Links: Redux UI Management
Edit this page
Last updated on Nov 21, 2022""""""",1473,6834,redux
https://redux.js.org/faq/store-setup,"""""""FAQStore Setup
Redux FAQ: Store Setup
Table of Contents
Redux FAQ: Store Setup
Table of Contents
Store Setup
Can or should I create multiple stores? Can I import my store directly, and use it in components myself?
Further information
Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?
Further information
How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?
Further information
Store Setup
Can or should I create multiple stores? Can I import my store directly, and use it in components myself?
The original Flux pattern describes having multiple “stores” in an app, each one holding a different area of domain data. This can introduce issues such as needing to have one store “waitFor” another store to update. This is not necessary in Redux because the separation between data domains is already achieved by splitting a single reducer into smaller reducers.
As with several other questions, it is possible to create multiple distinct Redux stores in a page, but the intended pattern is to have only a single store. Having a single store enables using the Redux DevTools, makes persisting and rehydrating data simpler, and simplifies the subscription logic.
Some valid reasons for using multiple stores in Redux might include:
Solving a performance issue caused by too frequent updates of some part of the state, when confirmed by profiling the app.
Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.
However, creating new stores shouldn't be your first instinct, especially if you come from a Flux background. Try reducer composition first, and only use multiple stores if it doesn't solve your problem.
Similarly, while you can reference your store instance by importing it directly, this is not a recommended pattern in Redux. If you create a store instance and export it from a module, it will become a singleton. This means it will be harder to isolate a Redux app as a component of a larger app, if this is ever necessary, or to enable server rendering, because on the server you want to create separate store instances for every request.
With React Redux, the wrapper classes generated by the connect() function do actually look for props.store if it exists, but it's best if you wrap your root component in <Provider store={store}> and let React Redux worry about passing the store down. This way components don't need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.
Further information
Documentation
API: Store
Discussions
#1346: Is it bad practice to just have a 'stores' directory?
Stack Overflow: Redux multiple stores, why not?
Stack Overflow: Accessing Redux state in an action creator
Gist: Breaking out of Redux paradigm to isolate apps
Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?
Redux middleware act like a linked list. Each middleware function can either call next(action) to pass an action along to the next middleware in line, call dispatch(action) to restart the processing at the beginning of the list, or do nothing at all to stop the action from being processed further.
This chain of middleware is defined by the arguments passed to the applyMiddleware function used when creating a store. Defining multiple chains will not work correctly, as they would have distinctly different dispatch references and the different chains would effectively be disconnected.
Further information
Documentation
Redux Fundamentals: Store - Middleware
API: applyMiddleware
Discussions
#1051: Shortcomings of the current applyMiddleware and composing createStore
Understanding Redux Middleware
Exploring Redux Middleware
How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?
Redux provides a single store.subscribe method for notifying listeners that the store has updated. Listener callbacks do not receive the current state as an argument—it is simply an indication that something has changed. The subscriber logic can then call getState() to get the current state value.
This API is intended as a low-level primitive with no dependencies or complications, and can be used to build higher-level subscription logic. UI bindings such as React Redux can create a subscription for each connected component. It is also possible to write functions that can intelligently compare the old state vs the new state, and execute additional logic if certain pieces have changed. Examples include redux-watch, redux-subscribe and redux-subscriber which offer different approaches to specifying subscriptions and handling changes.
The new state is not passed to the listeners in order to simplify implementing store enhancers such as the Redux DevTools. In addition, subscribers are intended to react to the state value itself, not the action. Middleware can be used if the action is important and needs to be handled specifically.
Further information
Documentation
Fundamentals: Store
API: Store
Discussions
#303: subscribe API with state as an argument
#580: Is it possible to get action and state in store.subscribe?
#922: Proposal: add subscribe to middleware API
#1057: subscribe listener can get action param?
#1300: Redux is great but major feature is missing
Libraries
Redux Addons Catalog: Store Change Subscriptions
Edit this page
Last updated on Jun 25, 2021""""""",1108,5638,redux
https://redux.js.org/faq/actions,"""""""FAQActions
Redux FAQ: Actions
Table of Contents
Redux FAQ: Actions
Table of Contents
Actions
Why should type be a string, or at least serializable? Why should my action types be constants?
Further information
Is there always a one-to-one mapping between reducers and actions?
Further information
How can I represent “side effects” such as AJAX calls? Why do we need things like “action creators”, “thunks”, and “middleware” to do async behavior?
Further information
What async middleware should I use? How do you decide between thunks, sagas, observables, or something else?
Should I dispatch multiple actions in a row from one action creator?
Further information
Actions
Why should type be a string? Why should my action types be constants?
As with state, serializable actions enable several of Redux's defining features, such as time travel debugging, and recording and replaying actions. Using something like a Symbol for the type value or using instanceof checks for actions themselves would break that. Strings are serializable and easily self-descriptive, and so are a better choice. Note that it is okay to use Symbols, Promises, or other non-serializable values in an action if the action is intended for use by middleware. Actions only need to be serializable by the time they actually reach the store and are passed to the reducers.
We can't reliably enforce serializable actions for performance reasons, so Redux only checks that every action is a plain object, and that the type is a string. The rest is up to you, but you might find that keeping everything serializable helps debug and reproduce issues.
Encapsulating and centralizing commonly used pieces of code is a key concept in programming. While it is certainly possible to manually create action objects everywhere, and write each type value by hand, defining reusable constants makes maintaining code easier. If you put constants in a separate file, you can check your import statements against typos so you can't accidentally use the wrong string.
Further information
Documentation
Using Redux: Reducing Boilerplate
Discussion
#384: Recommend that Action constants be named in the past tense
#628: Solution for simple action creation with less boilerplate
#1024: Proposal: Declarative reducers
#1167: Reducer without switch
Stack Overflow: Why do you need 'Actions' as data in Redux?
Stack Overflow: What is the point of the constants in Redux?
Is there always a one-to-one mapping between reducers and actions?
No. We suggest you write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this pattern “reducer composition”. A given action could be handled by all, some, or none of them. This keeps components decoupled from the actual data changes, as one action may affect different parts of the state tree, and there is no need for the component to be aware of this. Some users do choose to bind them more tightly together, such as the “ducks” file structure, but there is definitely no one-to-one mapping by default, and you should break out of such a paradigm any time you feel you want to handle an action in many reducers.
Further information
Documentation
Fundamentals: State, Actions, Reducers
Using Redux: Structuring Reducers
Discussions
Twitter: most common Redux misconception
#1167: Reducer without switch
Reduxible #8: Reducers and action creators aren't a one-to-one mapping
Stack Overflow: Can I dispatch multiple actions without Redux Thunk middleware?
How can I represent “side effects” such as AJAX calls? Why do we need things like “action creators”, “thunks”, and “middleware” to do async behavior?
This is a long and complex topic, with a wide variety of opinions on how code should be organized and what approaches should be used.
Any meaningful web app needs to execute complex logic, usually including asynchronous work such as making AJAX requests. That code is no longer purely a function of its inputs, and the interactions with the outside world are known as “side effects”
Redux is inspired by functional programming, and out of the box, has no place for side effects to be executed. In particular, reducer functions must always be pure functions of (state, action) => newState. However, Redux's middleware makes it possible to intercept dispatched actions and add additional complex behavior around them, including side effects.
In general, Redux suggests that code with side effects should be part of the action creation process. While that logic can be performed inside of a UI component, it generally makes sense to extract that logic into a reusable function so that the same logic can be called from multiple places—in other words, an action creator function.
The simplest and most common way to do this is to add the Redux Thunk middleware that lets you write action creators with more complex and asynchronous logic. Another widely-used method is Redux Saga which lets you write more synchronous-looking code using generators, and can act like “background threads” or “daemons” in a Redux app. Yet another approach is Redux Loop, which inverts the process by allowing your reducers to declare side effects in response to state changes and have them executed separately. Beyond that, there are many other community-developed libraries and ideas, each with their own take on how side effects should be managed.
Further information
Documentation
Redux Fundamentals: Async Logic and Data Flow
Redux Fundamentals: Store - Middleware
Articles
Redux Side-Effects and You
Pure functionality and side effects in Redux
From Flux to Redux: Async Actions the easy way
React/Redux Links: ""Redux Side Effects"" category
Gist: Redux-Thunk examples
Discussions
#291: Trying to put API calls in the right place
#455: Modeling side effects
#533: Simpler introduction to async action creators
#569: Proposal: API for explicit side effects
#1139: An alternative side effect model based on generators and sagas
Stack Overflow: Why do we need middleware for async flow in Redux?
Stack Overflow: How to dispatch a Redux action with a timeout?
Stack Overflow: Where should I put synchronous side effects linked to actions in redux?
Stack Overflow: How to handle complex side-effects in Redux?
Stack Overflow: How to unit test async Redux actions to mock ajax response
Stack Overflow: How to fire AJAX calls in response to the state changes with Redux?
Reddit: Help performing Async API calls with Redux-Promise Middleware.
Twitter: possible comparison between sagas, loops, and other approaches
What async middleware should I use? How do you decide between thunks, sagas, observables, or something else?
There are many async/side effect middlewares available, but the most commonly used ones are redux-thunk, redux-saga, and redux-observable. These are different tools, with different strengths, weaknesses, and use cases.
As a general rule of thumb:
Thunks are best for complex synchronous logic (especially code that needs access to the entire Redux store state), and simple async logic (like basic AJAX calls). With the use of async/await, it can be reasonable to use thunks for some more complex promise-based logic as well.
Sagas are best for complex async logic and decoupled ""background thread""-type behavior, especially if you need to listen to dispatched actions (which is something that can't be done with thunks). They require familiarity with generator functions and redux-saga's ""effects"" operators.
Observables solve the same problems as sagas, but rely on RxJS to implement async behavior. They require familiarity with the RxJS API.
We recommend that most Redux users should start with thunks, and then add an additional side effect library like sagas or observables later if their app really requires handling for more complex async logic.
Since sagas and observables have the same use case, an application would normally use one or the other, but not both. However, note that it's absolutely fine to use both thunks and either sagas or observables together, because they solve different problems.
Articles
Decembersoft: What is the right way to do asynchronous operations in Redux?
Redux-Thunk vs Redux-Saga: an overview
Redux-Saga V.S. Redux-Observable
Discussions
Reddit: discussion of using thunks and sagas together, and pros and cons of sagas
Stack Overflow: Pros/cons of using redux-saga with ES2015 generators vs redux-thunk with ES2017 async/await
Stack Overflow: Why use Redux-Observable over Redux-Saga?
Should I dispatch multiple actions in a row from one action creator?
There's no specific rule for how you should structure your actions. Using an async middleware like Redux Thunk certainly enables scenarios such as dispatching multiple distinct but related actions in a row, dispatching actions to represent progression of an AJAX request, dispatching actions conditionally based on state, or even dispatching an action and checking the updated state immediately afterwards.
In general, ask if these actions are related but independent, or should actually be represented as one action. Do what makes sense for your own situation but try to balance the readability of reducers with readability of the action log. For example, an action that includes the whole new state tree would make your reducer a one-liner, but the downside is now you have no history of why the changes are happening, so debugging gets really difficult. On the other hand, if you emit actions in a loop to keep them granular, it's a sign that you might want to introduce a new action type that is handled in a different way.
Try to avoid dispatching several times synchronously in a row in the places where you're concerned about performance. There are a number of addons and approaches that can batch up dispatches as well.
Further information
Documentation
FAQ: Performance - Reducing Update Events
Articles
Idiomatic Redux: Thoughts on Thunks, Sagas, Abstraction, and Reusability
Discussions
#597: Valid to dispatch multiple actions from an event handler?
#959: Multiple actions one dispatch?
Stack Overflow: Should I use one or several action types to represent this async action?
Stack Overflow: Do events and actions have a 1:1 relationship in Redux?
Stack Overflow: Should actions be handled by reducers to related actions or generated by action creators themselves?
Twitter: ""Good thread on the problems with Redux Thunk...""
Edit this page
Last updated on Dec 12, 2023""""""",2145,10427,redux
https://redux.js.org/faq/immutable-data,"""""""FAQImmutable Data
Redux FAQ: Immutable Data
Table of Contents
What are the benefits of immutability?
Why is immutability required by Redux?
Why does Redux’s use of shallow equality checking require immutability?
How do Shallow and Deep Equality Checking differ?
How does Redux use shallow equality checking?
How does combineReducers use shallow equality checking?
How does React-Redux use shallow equality checking?
How does React-Redux use shallow equality checking to determine whether a component needs re-rendering?
Why will shallow equality checking not work with mutable objects?
Does shallow equality checking with a mutable object cause problems with Redux?
Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?
Why does a selector mutating and returning a persistent object to mapStateToProps prevent React-Redux from re-rendering a wrapped component?
How does immutability enable a shallow check to detect object mutations?
How can immutability in your reducers cause components to render unnecessarily?
How can immutability in mapStateToProps cause components to render unnecessarily?
What approaches are there for handling data immutability? Do I have to use Immer?
What are the issues with using JavaScript for immutable operations?
What are the benefits of immutability?
Immutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.
In particular, immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to (a cornerstone of React’s performance improvements over other libraries).
Further information
Articles
Introduction to Immer
JavaScript Immutability presentation (PDF - see slide 12 for benefits)
React: Optimizing Performance
JavaScript Application Architecture On The Road To 2015
Why is immutability required by Redux?
Both Redux and React-Redux employ shallow equality checking. In particular:
Redux's combineReducers utility shallowly checks for reference changes caused by the reducers that it calls.
React-Redux's connect method generates components that shallowly check reference changes to the root state, and the return values from the mapStateToProps function to see if the wrapped components actually need to re-render. Such shallow checking requires immutability to function correctly.
Immutable data management ultimately makes data handling safer.
Time-travel debugging requires that reducers be pure functions with no side effects, so that you can correctly jump between different states.
Further Information
Documentation
Using Redux: Prerequisite Reducer Concepts
Discussions
Reddit: Why Redux Needs Reducers To Be Pure Functions
Why does Redux’s use of shallow equality checking require immutability?
Redux's use of shallow equality checking requires immutability if any connected components are to be updated correctly. To see why, we need to understand the difference between shallow and deep equality checking in JavaScript.
How do shallow and deep equality checking differ?
Shallow equality checking (or reference equality) simply checks that two different variables reference the same object; in contrast, deep equality checking (or value equality) must check every value of two objects' properties.
A shallow equality check is therefore as simple (and as fast) as a === b, whereas a deep equality check involves a recursive traversal through the properties of two objects, comparing the value of each property at each step.
It's for this improvement in performance that Redux uses shallow equality checking.
Further Information
Articles
Pros and Cons of using immutability with React.js
How does Redux use shallow equality checking?
Redux uses shallow equality checking in its combineReducers function to return either a new mutated copy of the root state object, or, if no mutations have been made, the current root state object.
Further Information
Documentation
API: combineReducers
How does combineReducers use shallow equality checking?
The suggested structure for a Redux store is to split the state object into multiple ""slices"" or ""domains"" by key, and provide a separate reducer function to manage each individual data slice.
combineReducers makes working with this style of structure easier by taking a reducers argument that’s defined as a hash table comprising a set of key/value pairs, where each key is the name of a state slice, and the corresponding value is the reducer function that will act on it.
So, for example, if your state shape is { todos, counter }, the call to combineReducers would be:
combineReducers({ todos: myTodosReducer, counter: myCounterReducer })
where:
the keys todos and counter each refer to a separate state slice;
the values myTodosReducer and myCounterReducer are reducer functions, with each acting on the state slice identified by the respective key.
combineReducers iterates through each of these key/value pairs. For each iteration, it:
creates a reference to the current state slice referred to by each key;
calls the appropriate reducer and passes it the slice;
creates a reference to the possibly-mutated state slice that's returned by the reducer.
As it continues through the iterations, combineReducers will construct a new state object with the state slices returned from each reducer. This new state object may or may not be different from the current state object. It is here that combineReducers uses shallow equality checking to determine whether the state has changed.
Specifically, at each stage of the iteration, combineReducers performs a shallow equality check on the current state slice and the state slice returned from the reducer. If the reducer returns a new object, the shallow equality check will fail, and combineReducers will set a hasChanged flag to true.
After the iterations have completed, combineReducers will check the state of the hasChanged flag. If it’s true, the newly-constructed state object will be returned. If it’s false, the current state object is returned.
This is worth emphasizing: If the reducers all return the same state object passed to them, then combineReducers will return the current root state object, not the newly updated one.
Further Information
Documentation
API: combineReducers
Redux FAQ - How do I share state between two reducers? do I have to use combineReducers?
Video
Egghead.io: Redux: Implementing combineReducers() from Scratch
How does React-Redux use shallow equality checking?
React-Redux uses shallow equality checking to determine whether the component it’s wrapping needs to be re-rendered.
To do this, it assumes that the wrapped component is pure; that is, that the component will produce the same results given the same props and state.
By assuming the wrapped component is pure, it need only check whether the root state object or the values returned from mapStateToProps have changed. If they haven’t, the wrapped component does not need re-rendering.
It detects a change by keeping a reference to the root state object, and a reference to each value in the props object that's returned from the mapStateToProps function.
It then runs a shallow equality check on its reference to the root state object and the state object passed to it, and a separate series of shallow checks on each reference to the props object’s values and those that are returned from running the mapStateToProps function again.
Further Information
Documentation
React-Redux Bindings
Articles
API: React-Redux’s connect function and mapStateToProps
Redux FAQ: Why isn't my component re-rendering, or my mapStateToProps running?
Why does React-Redux shallowly check each value within the props object returned from mapStateToProp?
React-Redux performs a shallow equality check on each value within the props object, not on the props object itself.
It does so because the props object is actually a hash of prop names and their values (or selector functions that are used to retrieve or generate the values), such as in this example:
function mapStateToProps(state) {
  return {
    todos: state.todos, // prop value
    visibleTodos: getVisibleTodos(state) // selector
  }
}

export default connect(mapStateToProps)(TodoApp)
As such, a shallow equality check of the props object returned from repeated calls to mapStateToProps would always fail, as a new object would be returned each time.
React-Redux therefore maintains separate references to each value in the returned props object.
Further Information
Articles
React.js pure render performance anti-pattern
How does React-Redux use shallow equality checking to determine whether a component needs re-rendering?
Each time React-Redux’s connect function is called, it will perform a shallow equality check on its stored reference to the root state object, and the current root state object passed to it from the store. If the check passes, the root state object has not been updated, and so there is no need to re-render the component, or even call mapStateToProps.
If the check fails, however, the root state object has been updated, and so connect will call mapStateToPropsto see if the props for the wrapped component have been updated.
It does this by performing a shallow equality check on each value within the object individually, and will only trigger a re-render if one of those checks fails.
In the example below, if state.todos and the value returned from getVisibleTodos() do not change on successive calls to connect, then the component will not re-render .
function mapStateToProps(state) {
  return {
    todos: state.todos, // prop value
    visibleTodos: getVisibleTodos(state) // selector
  }
}

export default connect(mapStateToProps)(TodoApp)
Conversely, in this next example (below), the component will always re-render, as the value of todos is always a new object, regardless of whether or not its values change:
// AVOID - will always cause a re-render
function mapStateToProps(state) {
  return {
    // todos always references a newly-created object
    todos: {
      all: state.todos,
      visibleTodos: getVisibleTodos(state)
    }
  }
}

export default connect(mapStateToProps)(TodoApp)
If the shallow equality check fails between the new values returned from mapStateToProps and the previous values that React-Redux kept a reference to, then a re-rendering of the component will be triggered.
Further Information
Articles
Practical Redux, Part 6: Connected Lists, Forms, and Performance
React.js Pure Render Performance Anti-Pattern
High Performance Redux Apps
Discussions
#1816: Component connected to state with mapStateToProps
#300: Potential connect() optimization
Why will shallow equality checking not work with mutable objects?
Shallow equality checking cannot be used to detect if a function mutates an object passed into it if that object is mutable.
This is because two variables that reference the same object will always be equal, regardless of whether the object’s values changes or not, as they're both referencing the same object. Thus, the following will always return true:
function mutateObj(obj) {
  obj.key = 'newValue'
  return obj
}

const param = { key: 'originalValue' }
const returnVal = mutateObj(param)

param === returnVal
//> true
The shallow check of param and returnValue simply checks whether both variables reference the same object, which they do.mutateObj() may return a mutated version of obj, but it's still the same object as that passed in. The fact that its values have been changed within mutateObj matters not at all to a shallow check.
Further Information
Articles
Pros and Cons of using immutability with React.js
Does shallow equality checking with a mutable object cause problems with Redux?
Shallow equality checking with a mutable object will not cause problems with Redux, but it will cause problems with libraries that depend on the store, such as React-Redux.
Specifically, if the state slice passed to a reducer by combineReducers is a mutable object, the reducer can modify it directly and return it.
If it does, the shallow equality check that combineReducers performs will always pass, as the values of the state slice returned by the reducer may have been mutated, but the object itself has not - it’s still the same object that was passed to the reducer.
Accordingly, combineReducers will not set its hasChanged flag, even though the state has changed. If none of the other reducers return a new, updated state slice, the hasChanged flag will remain set to false, causing combineReducers to return the existing root state object.
The store will still be updated with the new values for the root state, but because the root state object itself is still the same object, libraries that bind to Redux, such as React-Redux, will not be aware of the state’s mutation, and so will not trigger a wrapped component’s re-rendering.
Further Information
Documentation
Using Redux: Immutable Update Patterns
Troubleshooting: Never mutate reducer arguments
Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?
If a Redux reducer directly mutates, and returns, the state object passed into it, the values of the root state object will change, but the object itself will not.
Because React-Redux performs a shallow check on the root state object to determine if its wrapped components need re-rendering or not, it will not be able to detect the state mutation, and so will not trigger a re-rendering.
Further Information
Documentation
Troubleshooting: My views aren’t updating when something changes outside of Redux
Why does a selector mutating and returning a persistent object to mapStateToProps prevent React-Redux from re-rendering a wrapped component?
If one of the values of the props object returned from mapStateToProps is an object that persists across calls to connect (such as, potentially, the root state object), yet is directly mutated and returned by a selector function, React-Redux will not be able to detect the mutation, and so will not trigger a re-render of the wrapped component.
As we’ve seen, the values in the mutable object returned by the selector function may have changed, but the object itself has not, and shallow equality checking only compares the objects themselves, not their values.
For example, the following mapStateToProps function will never trigger a re-render:
// State object held in the Redux store
const state = {
  user: {
    accessCount: 0,
    name: 'keith'
  }
}

// Selector function
const getUser = state => {
  ++state.user.accessCount // mutate the state object
  return state
}

// mapStateToProps
const mapStateToProps = state => ({
  // The object returned from getUser() is always
  // the same object, so this wrapped
  // component will never re-render, even though it's been
  // mutated
  userRecord: getUser(state)
})

const a = mapStateToProps(state)
const b = mapStateToProps(state)

a.userRecord === b.userRecord
//> true
Note that, conversely, if an immutable object is used, the component may re-render when it should not.
Further Information
Articles
Practical Redux, Part 6: Connected Lists, Forms, and Performance
Discussions
#1948: Is getMappedItems an anti-pattern in mapStateToProps?
How does immutability enable a shallow check to detect object mutations?
If an object is immutable, any changes that need to be made to it within a function must be made to a copy of the object.
This mutated copy is a separate object from that passed into the function, and so when it is returned, a shallow check will identify it as being a different object from that passed in, and so will fail.
Further Information
Articles
Pros and Cons of using immutability with React.js
How can immutability in your reducers cause components to render unnecessarily?
You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.
That’s perfectly OK when you mutate the copy, but in the context of a reducer, if you return a copy that hasn’t been mutated, Redux’s combineReducers function will still think that the state needs to be updated, as you're returning an entirely different object from the state slice object that was passed in.
combineReducers will then return this new root state object to the store. The new object will have the same values as the current root state object, but because it's a different object, it will cause the store to be updated, which will ultimately cause all connected components to be re-rendered unnecessarily.
To prevent this from happening, you must always return the state slice object that’s passed into a reducer if the reducer does not mutate the state.
Further Information
Articles
React.js pure render performance anti-pattern
Building Efficient UI with React and Redux
How can immutability in mapStateToProps cause components to render unnecessarily?
Certain immutable operations, such as an Array filter, will always return a new object, even if the values themselves have not changed.
If such an operation is used as a selector function in mapStateToProps, the shallow equality check that React-Redux performs on each value in the props object that’s returned will always fail, as the selector is returning a new object each time.
As such, even though the values of that new object have not changed, the wrapped component will always be re-rendered,
For example, the following will always trigger a re-render:
// A JavaScript array's 'filter' method treats the array as immutable,
// and returns a filtered copy of the array.
const getVisibleTodos = todos => todos.filter(t => !t.completed)

const state = {
  todos: [
    {
      text: 'do todo 1',
      completed: false
    },
    {
      text: 'do todo 2',
      completed: true
    }
  ]
}

const mapStateToProps = state => ({
  // getVisibleTodos() always returns a new array, and so the
  // 'visibleToDos' prop will always reference a different array,
  // causing the wrapped component to re-render, even if the array's
  // values haven't changed
  visibleToDos: getVisibleTodos(state.todos)
})

const a = mapStateToProps(state)
//  Call mapStateToProps(state) again with exactly the same arguments
const b = mapStateToProps(state)

a.visibleToDos
//> { ""completed"": false, ""text"": ""do todo 1"" }

b.visibleToDos
//> { ""completed"": false, ""text"": ""do todo 1"" }

a.visibleToDos === b.visibleToDos
//> false
Note that, conversely, if the values in your props object refer to mutable objects, your component may not render when it should.
Further Information
Articles
React.js pure render performance anti-pattern
Building Efficient UI with React and Redux
ImmutableJS: worth the price?
What approaches are there for handling data immutability? Do I have to use Immer?
You do not need to use Immer with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.
However, guaranteeing immutability with JavaScript is difficult, and it can be easy to mutate an object accidentally, causing bugs in your app that are extremely difficult to locate. For this reason, using an immutable update utility library such as Immer can significantly improve the reliability of your app, and make your app’s development much easier.
Further Information
Discussions
#1185: Question: Should I use immutable data structures?
Introduction to Immer
What are the issues with using plain JavaScript for immutable operations?
JavaScript was never designed to provide guaranteed immutable operations. Accordingly, there are several issues you need to be aware of if you choose to use it for your immutable operations in your Redux app.
Accidental Object Mutation
With JavaScript, you can accidentally mutate an object (such as the Redux state tree) quite easily without realizing it. For example, updating deeply nested properties, creating a new reference to an object instead of a new object, or performing a shallow copy rather than a deep copy, can all lead to inadvertent object mutations, and can trip up even the most experienced JavaScript coder.
To avoid these issues, ensure you follow the recommended immutable update patterns.
Verbose Code
Updating complex nested state trees can lead to verbose code that is tedious to write and difficult to debug.
Poor Performance
Operating on JavaScript objects and arrays in an immutable way can be slow, particularly as your state tree grows larger.
Remember, to change an immutable object, you must mutate a copy of it, and copying large objects can be slow as every property must be copied.
In contrast, immutable libraries such as Immer can employ structural sharing, which effectively returns a new object that reuses much of the existing object being copied from.
Further Information
Documentation
Immutable Update Patterns
Articles
A deep dive into Clojure’s data structures
Immutable Javascript using ES6 and beyond
Pros and Cons of using immutability with React.js - React Kung Fu
Edit this page
Last updated on Nov 25, 2023""""""",4218,21243,redux
https://redux.js.org/faq/code-structure,"""""""FAQCode Structure
Redux FAQ: Code Structure
Table of Contents
What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?
How should I split my logic between reducers and action creators? Where should my “business logic” go?
Why should I use action creators?
Where should websockets and other persistent connections live?
How can I use the Redux store in non-component files?
What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?
Since Redux is just a data store library, it has no direct opinion on how your project should be structured. However, there are a few common patterns that most Redux developers tend to use:
Rails-style: separate folders for “actions”, “constants”, “reducers”, “containers”, and “components”
""Feature folders"" / ""Domain""-style : separate folders per feature or domain, possibly with sub-folders per file type
“Ducks/Slices”: similar to domain style, but explicitly tying together actions and reducers, often by defining them in the same file
It's generally suggested that selectors are defined alongside reducers and exported, and then reused elsewhere (such as in mapStateToProps functions, in async action creators, or sagas) to colocate all the code that knows about the actual shape of the state tree in the reducer files.
TIP
We specifically recommend organizing your logic into ""feature folders"", with all the Redux logic for a given feature in a single ""slice/ducks"" file"".
See this section for an example:
Detailed Explanation: Example Folder Structure
An example folder structure might look something like:
While it ultimately doesn't matter how you lay out your code on disk, it's important to remember that actions and reducers should not be considered in isolation. It's entirely possible (and encouraged) for a reducer defined in one folder to respond to an action defined in another folder.
Further information
Documentation
Style Guide: Structure Files as Feature Folders with Single-File Logic
Redux Essentials tutorial: App Structure
FAQ: Actions - ""1:1 mapping between reducers and actions?""
Articles
How to Scale React Applications (accompanying talk: Scaling React Applications)
Redux Best Practices
Rules For Structuring (Redux) Applications
A Better File Structure for React/Redux Applications
Four Strategies for Organizing Code
Encapsulating the Redux State Tree
Redux Reducer/Selector Asymmetry
Modular Reducers and Selectors
My journey towards a maintainable project structure for React/Redux
React/Redux Links: Architecture - Project File Structure
Discussions
#839: Emphasize defining selectors alongside reducers
#943: Reducer querying
React Boilerplate #27: Application Structure
Stack Overflow: How to structure Redux components/containers
Twitter: There is no ultimate file structure for Redux
How should I split my logic between reducers and action creators? Where should my “business logic” go?
There's no single clear answer to exactly what pieces of logic should go in a reducer or an action creator. Some developers prefer to have “fat” action creators, with “thin” reducers that simply take the data in an action and blindly merge it into the corresponding state. Others try to emphasize keeping actions as small as possible, and minimize the usage of getState() in an action creator. (For purposes of this question, other async approaches such as sagas and observables fall in the ""action creator"" category.)
There are several potential benefits from putting more logic into your reducers. It's likely that the action types would be more semantic and more meaningful (such as ""USER_UPDATED"" instead of ""SET_STATE""). In addition, having more logic in reducers means that more functionality will be affected by time travel debugging.
This comment sums up the dichotomy nicely:
Now, the problem is what to put in the action creator and what in the reducer, the choice between fat and thin action objects. If you put all the logic in the action creator, you end up with fat action objects that basically declare the updates to the state. Reducers become pure, dumb, add-this, remove that, update these functions. They will be easy to compose. But not much of your business logic will be there. If you put more logic in the reducer, you end up with nice, thin action objects, most of your data logic in one place, but your reducers are harder to compose since you might need info from other branches. You end up with large reducers or reducers that take additional arguments from higher up in the state.
TIP
We recommend putting as much logic as possible into reducers. There are times when you may need some logic to help prepare what goes into the action, but reducers should do most of the work.
Further information
Documentation
Style Guide: Put as Much Logic as Possible in Reducers
Style Guide: Model Actions as ""Events"", not ""Setters""
Articles
Where do I put my business logic in a React/Redux application?
How to Scale React Applications
The Tao of Redux, Part 2 - Practice and Philosophy. Thick and thin reducers.
Discussions
How putting too much logic in action creators could affect debugging
#384: The more that's in a reducer, the more you can replay via time travel
#1165: Where to put business logic / validation?
#1171: Recommendations for best practices regarding action-creators, reducers, and selectors
Stack Overflow: Accessing Redux state in an action creator?
#2796: Gaining clarity on ""business logic""
Twitter: Moving away from unclear terminology...
Why should I use action creators?
Redux does not require action creators. You are free to create actions in any way that is best for you, including simply passing an object literal to dispatch. Action creators emerged from the Flux architecture and have been adopted by the Redux community because they offer several benefits.
Action creators are more maintainable. Updates to an action can be made in one place and applied everywhere. All instances of an action are guaranteed to have the same shape and the same default values.
Action creators are testable. The correctness of an inline action must be verified manually. Like any function, tests for an action creator can be written once and run automatically.
Action creators are easier to document. The action creator's parameters enumerate the action's dependencies. And centralization of the action definition provides a convenient place for documentation comments. When actions are written inline, this information is harder to capture and communicate.
Action creators are a more powerful abstraction. Creating an action often involves transforming data or making AJAX requests. Action creators provide a uniform interface to this varied logic. This abstraction frees a component to dispatch an action without being complicated by the details of that action's creation.
Further information
Articles
Idiomatic Redux: Why use action creators?
Discussions
Reddit: Redbox - Redux action creation made simple
Where should websockets and other persistent connections live?
Middleware are the right place for persistent connections like websockets in a Redux app, for several reasons:
Middleware exist for the lifetime of the application
Like with the store itself, you probably only need a single instance of a given connection that the whole app can use
Middleware can see all dispatched actions and dispatch actions themselves. This means a middleware can take dispatched actions and turn those into messages sent over the websocket, and dispatch new actions when a message is received over the websocket.
A websocket connection instance isn't serializable, so it doesn't belong in the store state itself
See this example that shows how a socket middleware might dispatch and respond to Redux actions.
There's many existing middleware for websockets and other similar connections - see the link below.
Libraries
Middleware: Socket and Adapters
How can I use the Redux store in non-component files?
There should only be a single Redux store per application. This makes it effectively a singleton in terms of the app architecture. When used with React, the store is injected into the components at runtime by rendering a <Provider store={store}> around the root <App> component, so only the application setup logic needs to import the store directly.
However, there may be times when other parts of the codebase need to interact with the store as well.
You should avoid importing the store directly into other codebase files. While it may work in some cases, that often ends up causing circular import dependency errors.
Some possible solutions are:
Write your store-dependent logic as a thunk, and then dispatch that thunk from a component
Pass along references to dispatch from components as arguments to the relevant functions
Write the logic as middleware and add them to the store at setup time
Inject the store instance into the relevant files as the app is being created.
One common use case is reading API authorization information such as a token from the Redux state, inside of an Axios interceptor. The interceptor file needs to reference store.getState(), but also needs to be imported into API layer files, and this leads to circular imports.
You can expose an injectStore function from the interceptor file instead:
common/api.js
let store

export const injectStore = _store => {
  store = _store
}

axiosInstance.interceptors.request.use(config => {
  config.headers.authorization = store.getState().auth.token
  return config
})
Then, in your entry point file, inject the store into the API setup file:
index.js
import store from './app/store'
import { injectStore } from './common/api'
injectStore(store)
This way, the application setup is the only code that has to import the store, and the file dependency graph avoids circular dependencies.
Edit this page
Last updated on Apr 3, 2023""""""",1972,9951,redux
https://redux.js.org/faq/performance,"""""""FAQPerformance
Redux FAQ: Performance
Table of Contents
Redux FAQ: Performance
Table of Contents
Performance
How well does Redux “scale” in terms of performance and architecture?
Further information
Won't calling “all my reducers” for each action be slow?
Further information
Do I have to deep-clone my state in a reducer? Isn't copying my state going to be slow?
Further information
How can I reduce the number of store update events?
Further information
Will having “one state tree” cause memory problems? Will dispatching many actions take up memory?
Further information
Will caching remote data cause memory problems?
Further information
Performance
How well does Redux “scale” in terms of performance and architecture?
While there's no single definitive answer to this, most of the time this should not be a concern in either case.
The work done by Redux generally falls into a few areas: processing actions in middleware and reducers (including object duplication for immutable updates), notifying subscribers after actions are dispatched, and updating UI components based on the state changes. While it's certainly possible for each of these to become a performance concern in sufficiently complex situations, there's nothing inherently slow or inefficient about how Redux is implemented. In fact, React Redux in particular is heavily optimized to cut down on unnecessary re-renders, and React-Redux v5 shows noticeable improvements over earlier versions.
Redux may not be as efficient out of the box when compared to other libraries. For maximum rendering performance in a React application, state should be stored in a normalized shape, many individual components should be connected to the store instead of just a few, and connected list components should pass item IDs to their connected child list items (allowing the list items to look up their own data by ID). This minimizes the overall amount of rendering to be done. Use of memoized selector functions is also an important performance consideration.
As for architecture, anecdotal evidence is that Redux works well for varying project and team sizes. Redux is currently used by hundreds of companies and thousands of developers, with several hundred thousand monthly installations from NPM. One developer reported:
for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests
Further information
Documentation
Using Redux: Structuring Reducers - Normalizing State Shape
Articles
How to Scale React Applications (accompanying talk: Scaling React Applications)
High-Performance Redux
Improving React and Redux Perf with Reselect
Encapsulating the Redux State Tree
React/Redux Links: Performance - Redux
Discussions
#310: Who uses Redux?
#1751: Performance issues with large collections
React Redux #269: Connect could be used with a custom subscribe method
React Redux #407: Rewrite connect to offer an advanced API
React Redux #416: Rewrite connect for better performance and extensibility
Redux vs MobX TodoMVC Benchmark: #1
Reddit: What's the best place to keep the initial state?
Reddit: Help designing Redux state for a single page app
Reddit: Redux performance issues with a large state object?
Reddit: React/Redux for Ultra Large Scale apps
Twitter: Redux scaling
Twitter: Redux vs MobX benchmark graph - Redux state shape matters
Stack Overflow: How to optimize small updates to props of nested components?
Chat log: React/Redux perf - updating a 10K-item Todo list
Chat log: React/Redux perf - single connection vs many connections
Won't calling “all my reducers” for each action be slow?
It's important to note that a Redux store really only has a single reducer function. The store passes the current state and dispatched action to that one reducer function, and lets the reducer handle things appropriately.
Obviously, trying to handle every possible action in a single function does not scale well, simply in terms of function size and readability, so it makes sense to split the actual work into separate functions that can be called by the top-level reducer. In particular, the common suggested pattern is to have a separate sub-reducer function that is responsible for managing updates to a particular slice of state at a specific key. The combineReducers() that comes with Redux is one of the many possible ways to achieve this. It's also highly suggested to keep your store state as flat and as normalized as possible. Ultimately, though, you are in charge of organizing your reducer logic any way you want.
However, even if you happen to have many different reducer functions composed together, and even with deeply nested state, reducer speed is unlikely to be a problem. JavaScript engines are capable of running a very large number of function calls per second, and most of your reducers are probably just using a switch statement and returning the existing state by default in response to most actions.
If you actually are concerned about reducer performance, you can use a utility such as redux-ignore or reduxr-scoped-reducer to ensure that only certain reducers listen to specific actions. You can also use redux-log-slow-reducers to do some performance benchmarking.
Further information
Discussions
#912: Proposal: action filter utility
#1303: Redux Performance with Large Store and frequent updates
Stack Overflow: State in Redux app has the name of the reducer
Stack Overflow: How does Redux deal with deeply nested models?
Do I have to deep-clone my state in a reducer? Isn't copying my state going to be slow?
Immutably updating state generally means making shallow copies, not deep copies. Shallow copies are much faster than deep copies, because fewer objects and fields have to be copied, and it effectively comes down to moving some pointers around.
In addition, deep cloning state creates new references for every field. Since the React-Redux connect function relies on reference comparisons to determine if data has changed, this means that UI components will be forced to re-render unnecessarily even though the other data hasn't meaningfully changed.
However, you do need to create a copied and updated object for each level of nesting that is affected. Although that shouldn't be particularly expensive, it's another good reason why you should keep your state normalized and shallow if possible.
Common Redux misconception: you need to deeply clone the state. Reality: if something inside doesn't change, keep its reference the same!
Further information
Documentation
Using Redux: Structuring Reducers - Prerequisite Concepts
Using Redux: Structuring Reducers - Immutable Update Patterns
Discussions
#454: Handling big states in reducer
#758: Why can't state be mutated?
#994: How to cut the boilerplate when updating nested entities?
Twitter: common misconception - deep cloning
How can I reduce the number of store update events?
Redux notifies subscribers after each successfully dispatched action (i.e. an action reached the store and was handled by reducers). In some cases, it may be useful to cut down on the number of times subscribers are called, particularly if an action creator dispatches multiple distinct actions in a row.
There are several addons that add batching capabilities in various ways, like: redux-batched-actions (a higher-order reducer that lets you dispatch several actions as if it was one and “unpack” them in the reducer), redux-batched-subscribe (a store enhancer that lets you debounce subscriber calls for multiple dispatches), or redux-batch (a store enhancer that handles dispatching an array of actions with a single subscriber notification).
For React-Redux specifically, starting in React-Redux v7 a new batch public API is available to help minimize the number of React re-renders when dispatching actions outside of React event handlers. It wraps React's unstable_batchedUpdate() API, allows any React updates in an event loop tick to be batched together into a single render pass. React already uses this internally for its own event handler callbacks. This API is actually part of the renderer packages like ReactDOM and React Native, not the React core itself.
Since React-Redux needs to work in both ReactDOM and React Native environments, we've taken care of importing this API from the correct renderer at build time for our own use. We also now re-export this function publicly ourselves, renamed to batch(). You can use it to ensure that multiple actions dispatched outside of React only result in a single render update, like this:
import { batch } from 'react-redux'

function myThunk() {
  return (dispatch, getState) => {
    // should only result in one combined re-render, not two
    batch(() => {
      dispatch(increment())
      dispatch(increment())
    })
  }
}
Further information
Discussions
#125: Strategy for avoiding cascading renders
#542: Idea: batching actions
#911: Batching actions
#1813: Use a loop to support dispatching arrays
React Redux #263: Huge performance issue when dispatching hundreds of actions
React-Redux #1177: Roadmap: v6, Context, Subscriptions, and Hooks
Libraries
Redux Addons Catalog: Store - Change Subscriptions
Will having “one state tree” cause memory problems? Will dispatching many actions take up memory?
First, in terms of raw memory usage, Redux is no different than any other JavaScript library. The only difference is that all the various object references are nested together into one tree, instead of maybe saved in various independent model instances such as in Backbone. Second, a typical Redux app would probably have somewhat less memory usage than an equivalent Backbone app because Redux encourages use of plain JavaScript objects and arrays rather than creating instances of Models and Collections. Finally, Redux only holds onto a single state tree reference at a time. Objects that are no longer referenced in that tree will be garbage collected, as usual.
Redux does not store a history of actions itself. However, the Redux DevTools do store actions so they can be replayed, but those are generally only enabled during development, and not used in production.
Further information
Documentation
Redux Fundamentals: Async Logic and Data Flow
Discussions
Stack Overflow: Is there any way to ""commit"" the state in Redux to free memory?
Stack Overflow: Can a Redux store lead to a memory leak?
Stack Overflow: Redux and ALL the application state
Stack Overflow: Memory Usage Concern with Controlled Components
Reddit: What's the best place to keep initial state?
Will caching remote data cause memory problems?
The amount of memory available to JavaScript applications running in a browser is finite. Caching data will cause performance problems when the size of the cache approaches the amount of available memory. This tends to be a problem when the cached data is exceptionally large or the session is exceptionally long-running. And while it is good to be aware of the potential for these problems, this awareness should not discourage you from efficiently caching reasonable amounts of data.
Here are a few approaches to caching remote data efficiently:
First, only cache as much data as the user needs. If your application displays a paginated list of records, you don't necessarily need to cache the entire collection. Instead, cache what is visible to the user and add to that cache when the user has (or will soon have) an immediate need for more data.
Second, cache an abbreviated form of a record when possible. Sometimes a record includes data that is not relevant to the user. If the application does not depend on this data, it can be omitted from the cache.
Third, only cache a single copy of a record. This is especially important when records contain copies of other records. Cache a unique copy for each record and replace each nested copy with a reference. This is called normalization. Normalization is the preferred approach to storing relational data for several reasons, including efficient memory consumption.
Further information
Discussions
Stack Overflow: How to choose the Redux state shape for an app with list/detail views and pagination?
Twitter: ...concerns over having ""too much data in the state tree""...
Advanced Redux entity normalization
Edit this page
Last updated on May 24, 2022""""""",2438,12287,redux
https://redux.js.org/faq/design-decisions,"""""""FAQDesign Decisions
Redux FAQ: Design Decisions
Table of Contents
Why doesn't Redux pass the state and action to subscribers?
Why doesn't Redux support using classes for actions and reducers?
Why does the middleware signature use currying?
Why does applyMiddleware use a closure for dispatch?
Why doesn't combineReducers include a third argument with the entire state when it calls each reducer?
Why doesn't mapDispatchToProps allow use of return values from getState() or mapStateToProps()?
Design Decisions
Why doesn't Redux pass the state and action to subscribers?
Subscribers are intended to respond to the state value itself, not the action. Updates to the state are processed synchronously, but notifications to subscribers can be batched or debounced, meaning that subscribers are not always notified with every action. This is a common performance optimization to avoid repeated re-rendering.
Batching or debouncing is possible by using enhancers to override store.dispatch to change the way that subscribers are notified. Also, there are libraries that change Redux to process actions in batches to optimize performance and avoid repeated re-rendering:
redux-batch allows passing an array of actions to store.dispatch() with only one notification,
redux-batched-subscribe allows batching of subscribe notifications that occur as a result of dispatches.
The intended guarantee is that Redux eventually calls all subscribers with the most recent state available, but not that it always calls each subscriber for each action. The store state is available in the subscriber simply by calling store.getState(). The action cannot be made available in the subscribers without breaking the way that actions might be batched.
A potential use-case for using the action inside a subscriber -- which is an unsupported feature -- is to ensure that a component only re-renders after certain kinds of actions. Instead, re-rendering should be controlled through:
the shouldComponentUpdate lifecycle method
the virtual DOM equality check (vDOMEq)
React.PureComponent
Using React-Redux: use mapStateToProps to subscribe components to only the parts of the store that they need.
Further Information
Articles
How can I reduce the number of store update events?
Discussions
#580: Why doesn't Redux pass the state to subscribers?
#2214: Alternate Proof of Concept: Enhancer Overhaul -- more on debouncing
Why doesn't Redux support using classes for actions and reducers?
The pattern of using functions, called action creators, to return action objects may seem counterintuitive to programmers with a lot of Object Oriented Programming experience, who would see this is a strong use-case for Classes and instances. Class instances for action objects and reducers are not supported because class instances make serialization and deserialization tricky. Deserialization methods like JSON.parse(string) will return a plain old Javascript object rather than class instances.
As described in the Store FAQ, if you are okay with things like persistence and time-travel debugging not working as intended, you are welcome to put non-serializable items into your Redux store.
Serialization enables the browser to store all actions that have been dispatched, as well as the previous store states, with much less memory. Rewinding and 'hot reloading' the store is central to the Redux developer experience and the function of Redux DevTools. This also enables deserialized actions to be stored on the server and re-serialized in the browser in the case of server-side rendering with Redux.
Further Information
Articles
Can I put functions, promises, or other non-serializable items in my store state?
Discussions
#1171: Why doesn't Redux use classes for actions and reducers?
Why does the middleware signature use currying?
Redux middleware are written using a triply-nested function structure that looks like const middleware = storeAPI => next => action => {}, rather than a single function that looks like const middleware = (storeAPI, next, action) => {}. There's a few reasons for this.
One is that ""currying"" functions is a standard functional programming technique, and Redux was explicitly intended to use functional programming principles in its design. Another is that currying functions creates closures where you can declare variables that exist for the lifetime of the middleware (which could be considered a functional equivalent to instance variables that exist for the lifetime of a class instance). Finally, it's simply the approach that was chosen when Redux was initially designed.
The curried function signature of declaring middleware is deemed unnecessary by some, because both store and next are available when the applyMiddleware function is executed. This issue has been determined to not be worth introducing breaking changes, as there are now hundreds of middleware in the Redux ecosystem that rely on the existing middleware definition.
Further Information
Discussions
Why does the middleware signature use currying?
Prior discussions: #55, #534, #784, #922, #1744
React Boston 2017: You Might Need Redux (And Its Ecosystem)
Why does applyMiddleware use a closure for dispatch?
applyMiddleware takes the existing dispatch from the store and closes over it to create the initial chain of middlewares that have been invoked with an object that exposes the getState and dispatch functions, which enables middlewares that rely on dispatch during initialization to run.
Further Information
Discussions
Why does applyMiddleware use a closure for dispatch?
See - #1592 and #2097
Why doesn't combineReducers include a third argument with the entire state when it calls each reducer?
combineReducers is opinionated to encourage splitting reducer logic by domain. As stated in Beyond combineReducers,combineReducers is deliberately limited to handle a single common use case: updating a state tree that is a plain Javascript object by delegating the work of updating each slice of state to a specific slice reducer.
It's not immediately obvious what a potential third argument to each reducer should be: the entire state tree, some callback function, some other part of the state tree, etc. If combineReducers doesn't fit your use case, consider using libraries like combineSectionReducers or reduceReducers for other options with deeply nested reducers and reducers that require access to the global state.
If none of the published utilities solve your use case, you can always write a function yourself that does just exactly what you need.
Further information
Articles
Beyond combineReducers
Discussions
#1768 Allow reducers to consult global state
Why doesn't mapDispatchToProps allow use of return values from getState() or mapStateToProps()?
There have been requests to use either the entire state or the return value of mapState inside of mapDispatch, so that when functions are declared inside of mapDispatch, they can close over the latest returned values from the store.
This approach is not supported in mapDispatch because it would mean also calling mapDispatch every time the store is updated. This would cause the re-creation of functions with every state update, thus adding a lot of performance overhead.
The preferred way to handle this use-case--needing to alter props based on the current state and mapDispatchToProps functions--is to work from mergeProps, the third argument to the connect function. If specified, it is passed the result of mapStateToProps(), mapDispatchToProps(), and the container component's props. The plain object returned from mergeProps will be passed as props to the wrapped component.
Further information
Discussions
#237 Why doesn't mapDispatchToProps allow use of return values from getState() or mapStateToProps()?
Edit this page
Last updated on Jun 26, 2021""""""",1472,7801,redux
https://redux.js.org/faq/react-redux,"""""""FAQReact Redux
Redux FAQ: React Redux
Table of Contents
Redux FAQ: React Redux
Table of Contents
React Redux
Why should I use React-Redux?
Further Information
Why isn't my component re-rendering, or my mapStateToProps running?
Further information
Why is my component re-rendering too often?
Further information
How can I speed up my mapStateToProps?
Further information
Why don't I have this.props.dispatch available in my connected component?
Further information
Should I only connect my top component, or can I connect multiple components in my tree?
Further information
How does Redux compare to the React Context API?
Further information
React Redux
Why should I use React-Redux?
Redux itself is a standalone library that can be used with any UI layer or framework, including React, Angular, Vue, Ember, and vanilla JS. Although Redux and React are commonly used together, they are independent of each other.
If you are using Redux with any kind of UI framework, you will normally use a ""UI binding"" library to tie Redux together with your UI framework, rather than directly interacting with the store from your UI code.
React-Redux is the official Redux UI binding library for React. If you are using Redux and React together, you should also use React-Redux to bind these two libraries.
While it is possible to write Redux store subscription logic by hand, doing so would become very repetitive. In addition, optimizing UI performance would require complicated logic.
The process of subscribing to the store, checking for updated data, and triggering a re-render can be made more generic and reusable. A UI binding library like React-Redux handles the store interaction logic, so you don't have to write that code yourself.
Overall, React-Redux encourages good React architecture, and implements complex performance optimizations for you. It is also kept up-to-date with the latest API changes from Redux and React.
Further Information
Documentation
React-Redux docs: Why Use React-Redux?
Why isn't my component re-rendering, or my mapStateToProps running?
Accidentally mutating or modifying your state directly is by far the most common reason why components do not re-render after an action has been dispatched. Redux expects that your reducers will update their state “immutably”, which effectively means always making copies of your data, and applying your changes to the copies. If you return the same object from a reducer, Redux assumes that nothing has been changed, even if you made changes to its contents. Similarly, React Redux tries to improve performance by doing shallow equality reference checks on incoming props in shouldComponentUpdate, and if all references are the same, shouldComponentUpdate returns false to skip actually updating your original component.
It's important to remember that whenever you update a nested value, you must also return new copies of anything above it in your state tree. If you have state.a.b.c.d, and you want to make an update to d, you would also need to return new copies of c, b, a, and state. This state tree mutation diagram demonstrates how a change deep in a tree requires changes all the way up.
Note that “updating data immutably” does not mean that you must use Immer, although that is certainly an option. You can do immutable updates to plain JS objects and arrays using several different approaches:
Copying objects using functions like Object.assign() or _.extend(), and array functions such as slice() and concat()
The array spread operator in ES2015, and the similar object spread operator from ES2018
Utility libraries that wrap immutable update logic into simpler functions
Further information
Documentation
Troubleshooting
React Redux: Troubleshooting
Using Redux: Structuring Reducers - Prerequisite Concepts
Using Redux: Structuring Reducers - Immutable Update Patterns
Articles
Pros and Cons of Using Immutability with React
React/Redux Links: Immutable Data
Discussions
#1262: Immutable data + bad performance
React Redux #235: Predicate function for updating component
React Redux #291: Should mapStateToProps be called every time an action is dispatched?
Stack Overflow: Cleaner/shorter way to update nested state in Redux?
Gist: state mutations
Why is my component re-rendering too often?
React Redux implements several optimizations to ensure your actual component only re-renders when actually necessary. One of those is a shallow equality check on the combined props object generated by the mapStateToProps and mapDispatchToProps arguments passed to connect. Unfortunately, shallow equality does not help in cases where new array or object instances are created each time mapStateToProps is called. A typical example might be mapping over an array of IDs and returning the matching object references, such as:
const mapStateToProps = state => {
  return {
    objects: state.objectIds.map(id => state.objects[id])
  }
}
Even though the array might contain the exact same object references each time, the array itself is a different reference, so the shallow equality check fails and React Redux would re-render the wrapped component.
The extra re-renders could be resolved by saving the array of objects into the state using a reducer, caching the mapped array using Reselect, or implementing shouldComponentUpdate in the component by hand and doing a more in-depth props comparison using a function such as _.isEqual. Be careful to not make your custom shouldComponentUpdate() more expensive than the rendering itself! Always use a profiler to check your assumptions about performance.
For non-connected components, you may want to check what props are being passed in. A common issue is having a parent component re-bind a callback inside its render function, like <Child onClick={this.handleClick.bind(this)} />. That creates a new function reference every time the parent re-renders. It's generally good practice to only bind callbacks once in the parent component's constructor.
Further information
Documentation
FAQ: Performance - Scaling
Articles
A Deep Dive into React Perf Debugging
React.js pure render performance anti-pattern
Improving React and Redux Performance with Reselect
Encapsulating the Redux State Tree
React/Redux Links: React/Redux Performance
Discussions
Stack Overflow: Can a React Redux app scale as well as Backbone?
Libraries
Redux Addons Catalog: DevTools - Component Update Monitoring
How can I speed up my mapStateToProps?
While React Redux does work to minimize the number of times that your mapStateToProps function is called, it's still a good idea to ensure that your mapStateToProps runs quickly and also minimizes the amount of work it does. The common recommended approach is to create memoized “selector” functions using Reselect. These selectors can be combined and composed together, and selectors later in a pipeline will only run if their inputs have changed. This means you can create selectors that do things like filtering or sorting, and ensure that the real work only happens if needed.
Further information
Documentation
Using Redux: Deriving Data with Selectors
Articles
Improving React and Redux Performance with Reselect
Discussions
#815: Working with Data Structures
Reselect #47: Memoizing Hierarchical Selectors
Why don't I have this.props.dispatch available in my connected component?
The connect() function takes two primary arguments, both optional. The first, mapStateToProps, is a function you provide to pull data from the store when it changes, and pass those values as props to your component. The second, mapDispatchToProps, is a function you provide to make use of the store's dispatch function, usually by creating pre-bound versions of action creators that will automatically dispatch their actions as soon as they are called.
If you do not provide your own mapDispatchToProps function when calling connect(), React Redux will provide a default version, which simply returns the dispatch function as a prop. That means that if you do provide your own function, dispatch is not automatically provided. If you still want it available as a prop, you need to explicitly return it yourself in your mapDispatchToProps implementation.
Further information
Documentation
React Redux API: connect()
Discussions
React Redux #89: can i wrap multi actionCreators into one props with name?
React Redux #145: consider always passing down dispatch regardless of what mapDispatchToProps does
React Redux #255: this.props.dispatch is undefined if using mapDispatchToProps
Stack Overflow: How to get simple dispatch from this.props using connect w/ Redux?
Should I only connect my top component, or can I connect multiple components in my tree?
Early Redux documentation advised that you should only have a few connected components near the top of your component tree. However, time and experience has shown that such a component architecture generally requires a few components to know too much about the data requirements of all their descendants, and forces them to pass down a confusing number of props.
The current suggested best practice is to categorize your components as “presentational” or “container” components, and extract a connected container component wherever it makes sense:
Emphasizing “one container component at the top” in Redux examples was a mistake. Don't take this as a maxim. Try to keep your presentation components separate. Create container components by connecting them when it's convenient. Whenever you feel like you're duplicating code in parent components to provide data for same kinds of children, time to extract a container. Generally as soon as you feel a parent knows too much about “personal” data or actions of its children, time to extract a container.
In fact, benchmarks have shown that more connected components generally leads to better performance than fewer connected components.
In general, try to find a balance between understandable data flow and areas of responsibility with your components.
Further information
Documentation
Fundamentals: UI and React
FAQ: Performance - Scaling
Articles
Presentational and Container Components
High-Performance Redux
React/Redux Links: Architecture - Redux Architecture
React/Redux Links: Performance - Redux Performance
Discussions
Twitter: emphasizing “one container” was a mistake
#419: Recommended usage of connect
#756: container vs component?
#1176: Redux+React with only stateless components
Stack Overflow: can a dumb component use a Redux container?
How does Redux compare to the React Context API?
Similarities
Both Redux and React's Context API deal with ""prop drilling"". That said, they both allow you to pass data without having to pass the props through multiple layers of components. Internally, Redux uses the React context API that allows it to pass the store along your component tree.
Differences
With Redux, you get the power of Redux Dev Tools Extension. It automatically logs every action your app performs, and it allows time traveling – you can click on any past action and jump to that point in time. Redux also supports the concept of middleware, where you may bind customized function calls on every action dispatch. Such examples include an automatic event logger, interception of certain actions, etc.
With React's Context API, you deal with a pair of components speaking only to each other. This gives you nice isolation between irrelevant data. You also have the flexibility of how you may use the data with your components, i.e., you can provide the state of a parent component, and you may pass context data as props to wrapped components.
There is a key difference in how Redux and React's Context treat data. Redux maintains the data of your whole app in a giant, stateful object. It deduces the changes of your data by running the reducer function you provide, and returns the next state that corresponds to every action dispatched. React Redux then optimizes component rendering and makes sure that each component re-renders only when the data it needs change. Context, on the other hand, does not hold any state. It is only a conduit for the data. To express changes in data you need to rely on the state of a parent component.
Further information
When (and when not) to reach for Redux
Redux vs. The React Context API
You Might Not Need Redux (But You Can’t Replace It With Hooks)
Edit this page
Last updated on Apr 19, 2024""""""",2423,12387,redux
https://redux.js.org/faq/miscellaneous,"""""""FAQMiscellaneous
Redux FAQ: Miscellaneous
Table of Contents
Are there any larger, “real” Redux projects?
How can I implement authentication in Redux?
Miscellaneous
Are there any larger, “real” Redux projects?
Yes, lots of them! To name just a few:
Twitter's mobile site
Wordpress's new admin page
Firefox's new debugger
The HyperTerm terminal application
And many, many more! The Redux Addons Catalog has a list of Redux-based applications and examples that points to a variety of actual applications, large and small.
Further information
Documentation
Introduction: Examples
Discussions
Reddit: Large open source react/redux projects?
HN: Is there any huge web application built using Redux?
How can I implement authentication in Redux?
Authentication is essential to any real application. When going about authentication you must keep in mind that nothing changes with how you should organize your application and you should implement authentication in the same way you would any other feature. It is relatively straightforward:
Create action constants for LOGIN_SUCCESS, LOGIN_FAILURE, etc.
Create action creators that take in credentials, a flag that signifies whether authentication succeeded, a token, or an error message as the payload.
Create an async action creator with Redux Thunk middleware or any middleware you see fit to fire a network request to an API that returns a token if the credentials are valid. Then save the token in the local storage or show a response to the user if it failed. You can perform these side effects from the action creators you wrote in the previous step.
Create a reducer that returns the next state for each possible authentication case (LOGIN_SUCCESS, LOGIN_FAILURE, etc).
Further information
Articles
Authentication with JWT by Auth0
Tips to Handle Authentication in Redux
Examples
react-redux-jwt-auth-example
Libraries
Redux Addons Catalog: Use Cases - Authentication
Edit this page
Last updated on Jun 25, 2021""""""",389,1959,redux
https://redux.js.org/style-guide/,"""""""Style GuideStyle Guide: Best Practices
Redux Style Guide
Introduction
This is the official style guide for writing Redux code. It lists our recommended patterns, best practices, and suggested approaches for writing Redux applications.
Both the Redux core library and most of the Redux documentation are unopinionated. There are many ways to use Redux, and much of the time there is no single ""right"" way to do things.
However, time and experience have shown that for some topics, certain approaches work better than others. In addition, many developers have asked us to provide official guidance to reduce decision fatigue.
With that in mind, we've put together this list of recommendations to help you avoid errors, bikeshedding, and anti-patterns. We also understand that team preferences vary and different projects have different requirements, so no style guide will fit all sizes. You are encouraged to follow these recommendations, but take the time to evaluate your own situation and decide if they fit your needs.
Finally, we'd like to thank the Vue documentation authors for writing the Vue Style Guide page, which was the inspiration for this page.
Rule Categories
We've divided these rules into three categories:
Priority A: Essential
These rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Redux.
Priority B: Strongly Recommended
These rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified. Follow these rules whenever it is reasonably possible.
Priority C: Recommended
Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you're consistent and have a good reason. Please do have a good reason though!
Priority A Rules: Essential
Do Not Mutate State
Mutating state is the most common cause of bugs in Redux applications, including components failing to re-render properly, and will also break time-travel debugging in the Redux DevTools. Actual mutation of state values should always be avoided, both inside reducers and in all other application code.
Use tools such as redux-immutable-state-invariant to catch mutations during development, and Immer to avoid accidental mutations in state updates.
Note: it is okay to modify copies of existing values - that is a normal part of writing immutable update logic. Also, if you are using the Immer library for immutable updates, writing ""mutating"" logic is acceptable because the real data isn't being mutated - Immer safely tracks changes and generates immutably-updated values internally.
Reducers Must Not Have Side Effects
Reducer functions should only depend on their state and action arguments, and should only calculate and return a new state value based on those arguments. They must not execute any kind of asynchronous logic (AJAX calls, timeouts, promises), generate random values (Date.now(), Math.random()), modify variables outside the reducer, or run other code that affects things outside the scope of the reducer function.
Note: It is acceptable to have a reducer call other functions that are defined outside of itself, such as imports from libraries or utility functions, as long as they follow the same rules.
Detailed Explanation
Do Not Put Non-Serializable Values in State or Actions
Avoid putting non-serializable values such as Promises, Symbols, Maps/Sets, functions, or class instances into the Redux store state or dispatched actions. This ensures that capabilities such as debugging via the Redux DevTools will work as expected. It also ensures that the UI will update as expected.
Exception: you may put non-serializable values in actions if the action will be intercepted and stopped by a middleware before it reaches the reducers. Middleware such as redux-thunk and redux-promise are examples of this.
Only One Redux Store Per App
A standard Redux application should only have a single Redux store instance, which will be used by the whole application. It should typically be defined in a separate file such as store.js.
Ideally, no app logic will import the store directly. It should be passed to a React component tree via <Provider>, or referenced indirectly via middleware such as thunks. In rare cases, you may need to import it into other logic files, but this should be a last resort.
Priority B Rules: Strongly Recommended
Use Redux Toolkit for Writing Redux Logic
Redux Toolkit is our recommended toolset for using Redux. It has functions that build in our suggested best practices, including setting up the store to catch mutations and enable the Redux DevTools Extension, simplifying immutable update logic with Immer, and more.
You are not required to use RTK with Redux, and you are free to use other approaches if desired, but using RTK will simplify your logic and ensure that your application is set up with good defaults.
Use Immer for Writing Immutable Updates
Writing immutable update logic by hand is frequently difficult and prone to errors. Immer allows you to write simpler immutable updates using ""mutative"" logic, and even freezes your state in development to catch mutations elsewhere in the app. We recommend using Immer for writing immutable update logic, preferably as part of Redux Toolkit.
Structure Files as Feature Folders with Single-File Logic
Redux itself does not care about how your application's folders and files are structured. However, co-locating logic for a given feature in one place typically makes it easier to maintain that code.
Because of this, we recommend that most applications should structure files using a ""feature folder"" approach (all files for a feature in the same folder). Within a given feature folder, the Redux logic for that feature should be written as a single ""slice"" file, preferably using the Redux Toolkit createSlice API. (This is also known as the ""ducks"" pattern). While older Redux codebases often used a ""folder-by-type"" approach with separate folders for ""actions"" and ""reducers"", keeping related logic together makes it easier to find and update that code.
Detailed Explanation: Example Folder Structure
An example folder structure might look something like:
Put as Much Logic as Possible in Reducers
Wherever possible, try to put as much of the logic for calculating a new state into the appropriate reducer, rather than in the code that prepares and dispatches the action (like a click handler). This helps ensure that more of the actual app logic is easily testable, enables more effective use of time-travel debugging, and helps avoid common mistakes that can lead to mutations and bugs.
There are valid cases where some or all of the new state should be calculated first (such as generating a unique ID), but that should be kept to a minimum.
Detailed Explanation



























Reducers Should Own the State Shape
The Redux root state is owned and calculated by the single root reducer function. For maintainability, that reducer is intended to be split up by key/value ""slices"", with each ""slice reducer"" being responsible for providing an initial value and calculating the updates to that slice of the state.
In addition, slice reducers should exercise control over what other values are returned as part of the calculated state. Minimize the use of ""blind spreads/returns"" like return action.payload or return {...state, ...action.payload}, because those rely on the code that dispatched the action to correctly format the contents, and the reducer effectively gives up its ownership of what that state looks like. That can lead to bugs if the action contents are not correct.
Note: A ""spread return"" reducer may be a reasonable choice for scenarios like editing data in a form, where writing a separate action type for each individual field would be time-consuming and of little benefit.
Detailed Explanation
Picture a ""current user"" reducer that looks like:





















Name State Slices Based On the Stored Data
As mentioned in Reducers Should Own the State Shape, the standard approach for splitting reducer logic is based on ""slices"" of state. Correspondingly, combineReducers is the standard function for joining those slice reducers into a larger reducer function.
The key names in the object passed to combineReducers will define the names of the keys in the resulting state object. Be sure to name these keys after the data that is kept inside, and avoid use of the word ""reducer"" in the key names. Your object should look like {users: {}, posts: {}}, rather than {usersReducer: {}, postsReducer: {}}.
Detailed Explanation
Object literal shorthand makes it easy to define a key name and a value in an object at the same time:















Organize State Structure Based on Data Types, Not Components
Root state slices should be defined and named based on the major data types or areas of functionality in your application, not based on which specific components you have in your UI. This is because there is not a strict 1:1 correlation between data in the Redux store and components in the UI, and many components may need to access the same data. Think of the state tree as a sort of global database that any part of the app can access to read just the pieces of state needed in that component.
For example, a blogging app might need to track who is logged in, information on authors and posts, and perhaps some info on what screen is active. A good state structure might look like {auth, posts, users, ui}. A bad structure would be something like {loginScreen, usersList, postsList}.
Treat Reducers as State Machines
Many Redux reducers are written ""unconditionally"". They only look at the dispatched action and calculate a new state value, without basing any of the logic on what the current state might be. This can cause bugs, as some actions may not be ""valid"" conceptually at certain times depending on the rest of the app logic. For example, a ""request succeeded"" action should only have a new value calculated if the state says that it's already ""loading"", or an ""update this item"" action should only be dispatched if there is an item marked as ""being edited"".
To fix this, treat reducers as ""state machines"", where the combination of both the current state and the dispatched action determines whether a new state value is actually calculated, not just the action itself unconditionally.
Detailed Explanation














































Normalize Complex Nested/Relational State
Many applications need to cache complex data in the store. That data is often received in a nested form from an API, or has relations between different entities in the data (such as a blog that contains Users, Posts, and Comments).
Prefer storing that data in a ""normalized"" form in the store. This makes it easier to look up items based on their ID and update a single item in the store, and ultimately leads to better performance patterns.
Keep State Minimal and Derive Additional Values
Whenever possible, keep the actual data in the Redux store as minimal as possible, and derive additional values from that state as needed. This includes things like calculating filtered lists or summing up values. As an example, a todo app would keep an original list of todo objects in state, but derive a filtered list of todos outside the state whenever the state is updated. Similarly, a check for whether all todos have been completed, or number of todos remaining, can be calculated outside the store as well.
This has several benefits:
The actual state is easier to read
Less logic is needed to calculate those additional values and keep them in sync with the rest of the data
The original state is still there as a reference and isn't being replaced
Deriving data is often done in ""selector"" functions, which can encapsulate the logic for doing the derived data calculations. In order to improve performance, these selectors can be memoized to cache previous results, using libraries like reselect and proxy-memoize.
Model Actions as Events, Not Setters
Redux does not care what the contents of the action.type field are - it just has to be defined. It is legal to write action types in present tense (""users/update""), past tense (""users/updated""), described as an event (""upload/progress""), or treated as a ""setter"" (""users/setUserName""). It is up to you to determine what a given action means in your application, and how you model those actions.
However, we recommend trying to treat actions more as ""describing events that occurred"", rather than ""setters"". Treating actions as ""events"" generally leads to more meaningful action names, fewer total actions being dispatched, and a more meaningful action log history. Writing ""setters"" often results in too many individual action types, too many dispatches, and an action log that is less meaningful.
Detailed Explanation
Imagine you've got a restaurant app, and someone orders a pizza and a bottle of Coke. You could dispatch an action like:














Write Meaningful Action Names
The action.type field serves two main purposes:
Reducer logic checks the action type to see if this action should be handled to calculate a new state
Action types are shown in the Redux DevTools history log for you to read
Per Model Actions as ""Events"", the actual contents of the type field do not matter to Redux itself. However, the type value does matter to you, the developer. Actions should be written with meaningful, informative, descriptive type fields. Ideally, you should be able to read through a list of dispatched action types, and have a good understanding of what happened in the application without even looking at the contents of each action. Avoid using very generic action names like ""SET_DATA"" or ""UPDATE_STORE"", as they don't provide meaningful information on what happened.
Allow Many Reducers to Respond to the Same Action
Redux reducer logic is intended to be split into many smaller reducers, each independently updating their own portion of the state tree, and all composed back together to form the root reducer function. When a given action is dispatched, it might be handled by all, some, or none of the reducers.
As part of this, you are encouraged to have many reducer functions all handle the same action separately if possible. In practice, experience has shown that most actions are typically only handled by a single reducer function, which is fine. But, modeling actions as ""events"" and allowing many reducers to respond to those actions will typically allow your application's codebase to scale better, and minimize the number of times you need to dispatch multiple actions to accomplish one meaningful update.
Avoid Dispatching Many Actions Sequentially
Avoid dispatching many actions in a row to accomplish a larger conceptual ""transaction"". This is legal, but will usually result in multiple relatively expensive UI updates, and some of the intermediate states could be potentially invalid by other parts of the application logic. Prefer dispatching a single ""event""-type action that results in all of the appropriate state updates at once, or consider use of action batching addons to dispatch multiple actions with only a single UI update at the end.
Detailed Explanation
There is no limit on how many actions you can dispatch in a row. However, each dispatched action does result in execution of all store subscription callbacks (typically one or more per Redux-connected UI component), and will usually result in UI updates.
Evaluate Where Each Piece of State Should Live
The ""Three Principles of Redux"" says that ""the state of your whole application is stored in a single tree"". This phrasing has been over-interpreted. It does not mean that literally every value in the entire app must be kept in the Redux store. Instead, there should be a single place to find all values that you consider to be global and app-wide. Values that are ""local"" should generally be kept in the nearest UI component instead.
Because of this, it is up to you as a developer to decide what state should actually live in the Redux store, and what should stay in component state. Use these rules of thumb to help evaluate each piece of state and decide where it should live.
Use the React-Redux Hooks API
Prefer using the React-Redux hooks API (useSelector and useDispatch) as the default way to interact with a Redux store from your React components. While the classic connect API still works fine and will continue to be supported, the hooks API is generally easier to use in several ways. The hooks have less indirection, less code to write, and are simpler to use with TypeScript than connect is.
The hooks API does introduce some different tradeoffs than connect does in terms of performance and data flow, but we now recommend them as the default.
Detailed Explanation
Connect More Components to Read Data from the Store
Prefer having more UI components subscribed to the Redux store and reading data at a more granular level. This typically leads to better UI performance, as fewer components will need to render when a given piece of state changes.
For example, rather than just connecting a <UserList> component and reading the entire array of users, have <UserList> retrieve a list of all user IDs, render list items as <UserListItem userId={userId}>, and have <UserListItem> be connected and extract its own user entry from the store.
This applies for both the React-Redux connect() API and the useSelector() hook.
Use the Object Shorthand Form of mapDispatch with connect
The mapDispatch argument to connect can be defined as either a function that receives dispatch as an argument, or an object containing action creators. We recommend always using the ""object shorthand"" form of mapDispatch, as it simplifies the code considerably. There is almost never a real need to write mapDispatch as a function.
Call useSelector Multiple Times in Function Components
When retrieving data using the useSelector hook, prefer calling useSelector many times and retrieving smaller amounts of data, instead of having a single larger useSelector call that returns multiple results in an object. Unlike mapState, useSelector is not required to return an object, and having selectors read smaller values means it is less likely that a given state change will cause this component to render.
However, try to find an appropriate balance of granularity. If a single component does need all fields in a slice of the state , just write one useSelector that returns that whole slice instead of separate selectors for each individual field.
Use Static Typing
Use a static type system like TypeScript or Flow rather than plain JavaScript. The type systems will catch many common mistakes, improve the documentation of your code, and ultimately lead to better long-term maintainability. While Redux and React-Redux were originally designed with plain JS in mind, both work well with TS and Flow. Redux Toolkit is specifically written in TS and is designed to provide good type safety with a minimal amount of additional type declarations.
Use the Redux DevTools Extension for Debugging
Configure your Redux store to enable debugging with the Redux DevTools Extension. It allows you to view:
The history log of dispatched actions
The contents of each action
The final state after an action was dispatched
The diff in the state after an action
The function stack trace showing the code where the action was actually dispatched
In addition, the DevTools allows you to do ""time-travel debugging"", stepping back and forth in the action history to see the entire app state and UI at different points in time.
Redux was specifically designed to enable this kind of debugging, and the DevTools are one of the most powerful reasons to use Redux.
Use Plain JavaScript Objects for State
Prefer using plain JavaScript objects and arrays for your state tree, rather than specialized libraries like Immutable.js. While there are some potential benefits to using Immutable.js, most of the commonly stated goals such as easy reference comparisons are a property of immutable updates in general, and do not require a specific library. This also keeps bundle sizes smaller and reduces complexity from data type conversions.
As mentioned above, we specifically recommend using Immer if you want to simplify immutable update logic, specifically as part of Redux Toolkit.
Detailed Explanation
Immutable.js has been semi-frequently used in Redux apps since the beginning. There are several common reasons stated for using Immutable.js:
Priority C Rules: Recommended
Write Action Types as domain/eventName
The original Redux docs and examples generally used a ""SCREAMING_SNAKE_CASE"" convention for defining action types, such as ""ADD_TODO"" and ""INCREMENT"". This matches typical conventions in most programming languages for declaring constant values. The downside is that the uppercase strings can be hard to read.
Other communities have adopted other conventions, usually with some indication of the ""feature"" or ""domain"" the action is related to, and the specific action type. The NgRx community typically uses a pattern like ""[Domain] Action Type"", such as ""[Login Page] Login"". Other patterns like ""domain:action"" have been used as well.
Redux Toolkit's createSlice function currently generates action types that look like ""domain/action"", such as ""todos/addTodo"". Going forward, we suggest using the ""domain/action"" convention for readability.
Write Actions Using the Flux Standard Action Convention
The original ""Flux Architecture"" documentation only specified that action objects should have a type field, and did not give any further guidance on what kinds of fields or naming conventions should be used for fields in actions. To provide consistency, Andrew Clark created a convention called ""Flux Standard Actions"" early in Redux's development. Summarized, the FSA convention says that actions:
Should always put their data into a payload field
May have a meta field for additional info
May have an error field to indicate the action represents a failure of some kind
Many libraries in the Redux ecosystem have adopted the FSA convention, and Redux Toolkit generates action creators that match the FSA format.
Prefer using FSA-formatted actions for consistency.
Note: The FSA spec says that ""error"" actions should set error: true, and use the same action type as the ""valid"" form of the action. In practice, most developers write separate action types for the ""success"" and ""error"" cases. Either is acceptable.
Use Action Creators
""Action creator"" functions started with the original ""Flux Architecture"" approach. With Redux, action creators are not strictly required. Components and other logic can always call dispatch({type: ""some/action""}) with the action object written inline.
However, using action creators provides consistency, especially in cases where some kind of preparation or additional logic is needed to fill in the contents of the action (such as generating a unique ID).
Prefer using action creators for dispatching any actions. However, rather than writing action creators by hand, we recommend using the createSlice function from Redux Toolkit, which will generate action creators and action types automatically.
Use RTK Query for Data Fetching
In practice, the single most common use case for side effects in a typical Redux app is fetching and caching data from the server.
Because of this, we recommend using RTK Query as the default approach for data fetching and caching in a Redux app. RTK Query has been designed to correctly manage the logic for fetching data from the server as needed, caching it, deduplicating requests, updating components, and much more. We recommend against writing data fetching logic by hand in almost all cases.
Use Thunks and Listeners for Other Async Logic
Redux was designed to be extensible, and the middleware API was specifically created to allow different forms of async logic to be plugged into the Redux store. That way, users wouldn't be forced to learn a specific library like RxJS if it wasn't appropriate for their needs.
This led to a wide variety of Redux async middleware addons being created, and that in turn has caused confusion and questions over which async middleware should be used.
We recommend using the Redux thunk middleware for imperative logic, such as complex sync logic that needs access to dispatch or getState, and moderately complex async logic. This includes use cases like moving logic out of components.
We recommend using the RTK ""listener"" middleware"" for ""reactive"" logic that needs to respond to dispatched actions or state changes, such as longer-running async workflows and ""background thread""-type behavior.
We recommend against using the more complex Redux-Saga and Redux-Observable libraries in most cases, especially for async data fetching. Only use these libraries if no other tool is powerful enough to handle your use case.
Move Complex Logic Outside Components
We have traditionally suggested keeping as much logic as possible outside components. That was partly due to encouraging the ""container/presentational"" pattern, where many components simply accept data as props and display UI accordingly, but also because dealing with async logic in class component lifecycle methods can become difficult to maintain.
We still encourage moving complex synchronous or async logic outside components, usually into thunks. This is especially true if the logic needs to read from the store state.
However, the use of React hooks does make it somewhat easier to manage logic like data fetching directly inside a component, and this may replace the need for thunks in some cases.
Use Selector Functions to Read from Store State
""Selector functions"" are a powerful tool for encapsulating reading values from the Redux store state and deriving further data from those values. In addition, libraries like Reselect enable creating memoized selector functions that only recalculate results when the inputs have changed, which is an important aspect of optimizing performance.
We strongly recommend using memoized selector functions for reading store state whenever possible, and recommend creating those selectors with Reselect.
However, don't feel that you must write selector functions for every field in your state. Find a reasonable balance for granularity, based on how often fields are accessed and updated, and how much actual benefit the selectors are providing in your application.
Name Selector Functions as selectThing
We recommend prefixing selector function names with the word select, combined with a description of the value being selected. Examples of this would be selectTodos, selectVisibleTodos, and selectTodoById.
Avoid Putting Form State In Redux
Most form state shouldn't go in Redux. In most use cases, the data is not truly global, is not being cached, and is not being used by multiple components at once. In addition, connecting forms to Redux often involves dispatching actions on every single change event, which causes performance overhead and provides no real benefit. (You probably don't need to time-travel backwards one character from name: ""Mark"" to name: ""Mar"".)
Even if the data ultimately ends up in Redux, prefer keeping the form edits themselves in local component state, and only dispatching an action to update the Redux store once the user has completed the form.
There are use cases when keeping form state in Redux does actually make sense, such as WYSIWYG live previews of edited item attributes. But, in most cases, this isn't necessary.
Edit this page
Last updated on Nov 25, 2023""""""",5453,27947,redux
https://redux.js.org/api/api-reference,"""""""API ReferenceAPI Reference
API Reference
This section documents the original Redux core API. The Redux core is small - it defines a set of contracts for you to implement (such as reducers) and provides a few helper functions to tie these contracts together.
In practice, you won't use the Redux core directly. Redux Toolkit is our official recommended approach for writing Redux logic. It wraps around the Redux core, and contains packages and functions that we think are essential for building a Redux app. Redux Toolkit builds in our suggested best practices, simplifies most Redux tasks, prevents common mistakes, and makes it easier to write Redux applications. Additionally, React-Redux lets your React components talk to the Redux store.
See their API docs here:
https://redux-toolkit.js.org/
https://react-redux.js.org/
DANGER
The original Redux core createStore method is deprecated!
createStore will continue to work indefinitely, but we discourage direct use of createStore or the original redux package.
Instead, you should use the configureStore method from our official Redux Toolkit package, which wraps createStore to provide a better default setup and configuration approach. You should also use Redux Toolkit's createSlice method for writing reducer logic.
Redux Toolkit also re-exports all of the other APIs included in the redux package as well.
See the Migrating to Modern Redux page for details on how to update your existing legacy Redux codebase to use Redux Toolkit.
Top-Level Exports
createStore(reducer, preloadedState?, enhancer?)
combineReducers(reducers)
applyMiddleware(...middlewares)
bindActionCreators(actionCreators, dispatch)
compose(...functions)
Store API
Store
getState()
dispatch(action)
subscribe(listener)
replaceReducer(nextReducer)
Edit this page
Last updated on Nov 24, 2023""""""",353,1818,redux
https://redux.js.org/api/createstore,"""""""API ReferencecreateStore
createStore(reducer, preloadedState?, enhancer?)
Creates a Redux store that holds the complete state tree of your app. There should only be a single store in your app.
DANGER
The original Redux core createStore method is deprecated!
createStore will continue to work indefinitely, but we discourage direct use of createStore or the original redux package.
Instead, you should use the configureStore method from our official Redux Toolkit package, which wraps createStore to provide a better default setup and configuration approach. You should also use Redux Toolkit's createSlice method for writing reducer logic.
Redux Toolkit also re-exports all of the other APIs included in the redux package as well.
See the Migrating to Modern Redux page for details on how to update your existing legacy Redux codebase to use Redux Toolkit.
Arguments
reducer (Function): A root reducer function that returns the next state tree, given the current state tree and an action to handle.
[preloadedState] (any): The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced reducer with combineReducers, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your reducer can understand.
[enhancer] (Function): The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is applyMiddleware().
Returns
(Store): An object that holds the complete state of your app. The only way to change its state is by dispatching actions. You may also subscribe to the changes to its state to update the UI.
Example
import { createStore } from 'redux'

function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return state.concat([action.text])
    default:
      return state
  }
}

const store = createStore(todos, ['Use Redux'])

store.dispatch({
  type: 'ADD_TODO',
  text: 'Read the docs'
})

console.log(store.getState())
// [ 'Use Redux', 'Read the docs' ]
Deprecation and Alternate legacy_createStore Export
In Redux 4.2.0, we marked the original createStore method as @deprecated. Strictly speaking, this is not a breaking change, nor is it new in 5.0, but we're documenting it here for completeness.
This deprecation is solely a visual indicator that is meant to encourage users to migrate their apps from legacy Redux patterns to use the modern Redux Toolkit APIs. The deprecation results in a visual strikethrough when imported and used, like createStore, but with no runtime errors or warnings.
createStore will continue to work indefinitely, and will not ever be removed. But, today we want all Redux users to be using Redux Toolkit for all of their Redux logic.
To fix this, there are three options:
Follow our strong suggestion to switch over to Redux Toolkit and configureStore
Do nothing. It's just a visual strikethrough, and it doesn't affect how your code behaves. Ignore it.
Switch to using the legacy_createStore API that is now exported, which is the exact same function but with no @deprecated tag. The simplest option is to do an aliased import rename, like import { legacy_createStore as createStore } from 'redux'
Tips
Don't create more than one store in an application! Instead, use combineReducers to create a single root reducer out of many.
Redux state is normally plain JS objects and arrays.
If your state is a plain object, make sure you never mutate it! Immutable updates require making copies of each level of data, typically using the object spread operator ( return { ...state, ...newData } ).
For universal apps that run on the server, create a store instance with every request so that they are isolated. Dispatch a few data fetching actions to a store instance and wait for them to complete before rendering the app on the server.
When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is undefined, and you're all set.
To apply multiple store enhancers, you may use compose().
Edit this page
Last updated on Nov 25, 2023""""""",926,4443,redux
https://redux.js.org/api/store,"""""""API ReferenceStore
Store
A store holds the whole state tree of your application. The only way to change the state inside it is to dispatch an action on it, which triggers the root reducer function to calculate the new state.
A store is not a class. It's just an object with a few methods on it.
To create a store, pass your root reducer function to Redux Toolkit's configureStore method, which will set up a Redux store with a good default configuration. (Alternately, if you're not yet using Redux Toolkit, you can use the original createStore method, but we encourage you to migrate your code to use Redux Toolkit as soon as possible)
Store Methods
getState()
Returns the current state tree of your application. It is equal to the last value returned by the store's reducer.
Returns
(any): The current state tree of your application.
dispatch(action)
Dispatches an action. This is the only way to trigger a state change.
The store's reducer function will be called with the current getState() result and the given action synchronously. Its return value will be considered the next state. It will be returned from getState() from now on, and the change listeners will immediately be notified.
CAUTION
If you attempt to call dispatch from inside the reducer, it will throw with an error saying ""Reducers may not dispatch actions."" Reducers are pure functions - they can only return a new state value and must not have side effects (and dispatching is a side effect).
In Redux, subscriptions are called after the root reducer has returned the new state, so you may dispatch in the subscription listeners. You are only disallowed to dispatch inside the reducers because they must have no side effects. If you want to cause a side effect in response to an action, the right place to do this is in the potentially async action creator.
Arguments
action (Object†): A plain object describing the change that makes sense for your application. Actions are the only way to get data into the store, so any data, whether from the UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions. Actions must have a type field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for type than Symbols because strings are serializable. Other than type, the structure of an action object is really up to you. If you're interested, check out Flux Standard Action for recommendations on how actions could be constructed.
Returns
(Object†): The dispatched action (see notes).
Notes
† The “vanilla” store implementation you get by calling [`createStore`](/api/createstore) only supports plain object actions and hands them immediately to the reducer.
However, if you wrap createStore with applyMiddleware, the middleware can interpret actions differently, and provide support for dispatching async actions. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.
Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like redux-thunk or redux-promise to use it. You may also create your own middleware.
To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for applyMiddleware.
Example
import { createStore } from 'redux'
const store = createStore(todos, ['Use Redux'])

function addTodo(text) {
  return {
    type: 'ADD_TODO',
    text
  }
}

store.dispatch(addTodo('Read the docs'))
store.dispatch(addTodo('Read about the middleware'))
subscribe(listener)
Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed. You may then call getState() to read the current state tree inside the callback.
You may call dispatch() from a change listener, with the following caveats:
The listener should only call dispatch() either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling dispatch() without any conditions is technically possible, however it leads to an infinite loop as every dispatch() call usually triggers the listener again.
The subscriptions are snapshotted just before every dispatch() call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the dispatch() that is currently in progress. However, the next dispatch() call, whether nested or not, will use a more recent snapshot of the subscription list.
The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested dispatch() before the listener is called. It is, however, guaranteed that all subscribers registered before the dispatch() started will be called with the latest state by the time it exits.
It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to write a custom observeStore utility. The Store is also an Observable, so you can subscribe to changes with libraries like RxJS.
To unsubscribe the change listener, invoke the function returned by subscribe.
Arguments
listener (Function): The callback to be invoked any time an action has been dispatched, and the state tree might have changed. You may call getState() inside this callback to read the current state tree. It is reasonable to expect that the store's reducer is a pure function, so you may compare references to some deep path in the state tree to learn whether its value has changed.
Returns
(Function): A function that unsubscribes the change listener.
Example
function select(state) {
  return state.some.deep.property
}

let currentValue
function handleChange() {
  let previousValue = currentValue
  currentValue = select(store.getState())

  if (previousValue !== currentValue) {
    console.log(
      'Some deep nested property changed from',
      previousValue,
      'to',
      currentValue
    )
  }
}

const unsubscribe = store.subscribe(handleChange)
unsubscribe()
replaceReducer(nextReducer)
Replaces the reducer currently used by the store to calculate the state.
It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.
Arguments
nextReducer (Function) The next reducer for the store to use.
Edit this page
Last updated on Nov 25, 2023""""""",1342,6703,redux
https://redux.js.org/api/combinereducers,"""""""API ReferencecombineReducers
combineReducers(reducers)
Overview
The combineReducers helper function turns an object whose values are different ""slice reducer"" functions into a single combined reducer function you can pass to Redux Toolkit's configureStore (or the legacy createStore method)
The resulting combined reducer calls every slice reducer any time an action is dispatched, and gathers their results into a single state object. This enables splitting up reducer logic into separate functions, each managing their own slice of the state independently.
TIP
This should be rarely needed - Redux Toolkit's configureStore method will automatically call combineReducers for you if you pass in an object of slice reducers:
const store = configureStore({
  reducer: {
    posts: postsReducer,
    comments: commentsReducer
  }
})
You can still call combineReducers() yourself if you need to construct the root reducer manually first.
State Slices
The state produced by combineReducers() namespaces the states of each reducer under their keys as passed to combineReducers()
Example:
rootReducer = combineReducers({potato: potatoReducer, tomato: tomatoReducer})
// This would produce the following state object
{
  potato: {
    // ... potatoes, and other state managed by the potatoReducer ...
  },
  tomato: {
    // ... tomatoes, and other state managed by the tomatoReducer, maybe some nice sauce? ...
  }
}
You can control state key names by using different keys for the reducers in the passed object. For example, you may call combineReducers({ todos: myTodosReducer, counter: myCounterReducer }) for the state shape to be { todos, counter }.
Arguments
reducers (Object): An object whose values correspond to different reducer functions that need to be combined into one.
combineReducers({
  posts: postsReducer,
  comments: commentsReducer
})
See the notes below for some rules every passed reducer must follow.
Returns
(Function): A reducer that invokes every reducer inside the reducers object, and constructs a state object with the same shape.
Notes
This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don't have to follow if you write the root reducer manually.
Any reducer passed to combineReducers must satisfy these rules:
For any action that is not recognized, it must return the state given to it as the first argument.
It must never return undefined. It is too easy to do this by mistake via an early return statement, so combineReducers throws if you do that instead of letting the error manifest itself somewhere else.
If the state given to it is undefined, it must return the initial state for this specific reducer. According to the previous rule, the initial state must not be undefined either. It is handy to specify it with optional arguments syntax, but you can also explicitly check the first argument for being undefined.
While combineReducers attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. combineReducers will check your reducers by passing undefined to them; this is done even if you specify initial state to Redux.createStore(combineReducers(...), initialState). Therefore, you must ensure your reducers work properly when receiving undefined as state, even if you never intend for them to actually receive undefined in your own code.
Example
reducers/todos.js
export default function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return state.concat([action.text])
    default:
      return state
  }
}
reducers/counter.js
export default function counter(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1
    case 'DECREMENT':
      return state - 1
    default:
      return state
  }
}
reducers/index.js
import { combineReducers } from '@reduxjs/toolkit'
import todos from './todos'
import counter from './counter'

export default combineReducers({
  todos,
  counter
})
App.js
import { configureStore } from '@reduxjs/toolkit'
import reducer from './reducers/index'

const store = configureStore({
  reducer
})
console.log(store.getState())
// {
//   counter: 0,
//   todos: []
// }

store.dispatch({
  type: 'ADD_TODO',
  text: 'Use Redux'
})
console.log(store.getState())
// {
//   counter: 0,
//   todos: [ 'Use Redux' ]
// }
Tips
This helper is just a convenience! You can write your own combineReducers that works differently, or even assemble the state object from the child reducers manually and write a root reducer function explicitly, like you would write any other function.
You may call combineReducers at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.
Edit this page
Last updated on Mar 20, 2024""""""",1003,4952,redux
https://redux.js.org/api/applymiddleware,"""""""API ReferenceapplyMiddleware
applyMiddleware(...middleware)
Overview
Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.
WARNING
You shouldn't have to call applyMiddleware directly. Redux Toolkit's configureStore method automatically adds a default set of middleware to the store, or can accept a list of middleware to add.
The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like Rx. It does so by letting you dispatch async actions in addition to normal actions.
For example, redux-thunk lets the action creators invert control by dispatching functions. They would receive dispatch as an argument and may call it asynchronously. Such functions are called thunks. Another example of middleware is redux-promise. It lets you dispatch a Promise async action, and dispatches a normal action when the Promise resolves.
The original Redux createStore method does not understand what middleware are out of the box - it has to be configured with applyMiddleware to add that behavior. However, Redux Toolkit's configureStore method automatically adds middleware support by default.
Arguments
...middleware (arguments): Functions that conform to the Redux middleware API. Each middleware receives Store's dispatch and getState functions as named arguments, and returns a function. That function will be given the next middleware's dispatch method, and is expected to return a function of action calling next(action) with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store's dispatch method as the next parameter, thus ending the chain. So, the middleware signature is ({ getState, dispatch }) => next => action.
Returns
(Function) A store enhancer that applies the given middleware. The store enhancer signature is createStore => createStore but the easiest way to apply it is to pass it to createStore() as the last enhancer argument.
Examples
Example: Custom Logger Middleware
import { createStore, applyMiddleware } from 'redux'
import todos from './reducers'

function logger({ getState }) {
  return next => action => {
    console.log('will dispatch', action)

    // Call the next dispatch method in the middleware chain.
    const returnValue = next(action)

    console.log('state after dispatch', getState())

    // This will likely be the action itself, unless
    // a middleware further in chain changed it.
    return returnValue
  }
}

const store = createStore(todos, ['Use Redux'], applyMiddleware(logger))

store.dispatch({
  type: 'ADD_TODO',
  text: 'Understand the middleware'
})
// (These lines will be logged by the middleware:)
// will dispatch: { type: 'ADD_TODO', text: 'Understand the middleware' }
// state after dispatch: [ 'Use Redux', 'Understand the middleware' ]
Example: Using Thunk Middleware for Async Actions
import { createStore, combineReducers, applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import * as reducers from './reducers'

const reducer = combineReducers(reducers)
// applyMiddleware supercharges createStore with middleware:
const store = createStore(reducer, applyMiddleware(thunk))

function fetchSecretSauce() {
  return fetch('https://www.google.com/search?q=secret+sauce')
}

// These are the normal action creators you have seen so far.
// The actions they return can be dispatched without any middleware.
// However, they only express “facts” and not the “async flow”.
function makeASandwich(forPerson, secretSauce) {
  return {
    type: 'MAKE_SANDWICH',
    forPerson,
    secretSauce
  }
}

function apologize(fromPerson, toPerson, error) {
  return {
    type: 'APOLOGIZE',
    fromPerson,
    toPerson,
    error
  }
}

function withdrawMoney(amount) {
  return {
    type: 'WITHDRAW',
    amount
  }
}

// Even without middleware, you can dispatch an action:
store.dispatch(withdrawMoney(100))

// But what do you do when you need to start an asynchronous action,
// such as an API call, or a router transition?

// Meet thunks.
// A thunk is a function that returns a function.
// This is a thunk.
function makeASandwichWithSecretSauce(forPerson) {
  // Invert control!
  // Return a function that accepts `dispatch` so we can dispatch later.
  // Thunk middleware knows how to turn thunk async actions into actions.
  return function (dispatch) {
    return fetchSecretSauce().then(
      sauce => dispatch(makeASandwich(forPerson, sauce)),
      error => dispatch(apologize('The Sandwich Shop', forPerson, error))
    )
  }
}

// Thunk middleware lets me dispatch thunk async actions
// as if they were actions!
store.dispatch(makeASandwichWithSecretSauce('Me'))

// It even takes care to return the thunk's return value
// from the dispatch, so I can chain Promises as long as I return them.
store.dispatch(makeASandwichWithSecretSauce('My wife')).then(() => {
  console.log('Done!')
})

// In fact I can write action creators that dispatch
// actions and async actions from other action creators,
// and I can build my control flow with Promises.
function makeSandwichesForEverybody() {
  return function (dispatch, getState) {
    if (!getState().sandwiches.isShopOpen) {
      // You don't have to return Promises, but it's a handy convention
      // so the caller can always call .then() on async dispatch result.
      return Promise.resolve()
    }

    // We can dispatch both plain object actions and other thunks,
    // which lets us compose the asynchronous actions in a single flow.
    return dispatch(makeASandwichWithSecretSauce('My Grandma'))
      .then(() =>
        Promise.all([
          dispatch(makeASandwichWithSecretSauce('Me')),
          dispatch(makeASandwichWithSecretSauce('My wife'))
        ])
      )
      .then(() => dispatch(makeASandwichWithSecretSauce('Our kids')))
      .then(() =>
        dispatch(
          getState().myMoney > 42
            ? withdrawMoney(42)
            : apologize('Me', 'The Sandwich Shop')
        )
      )
  }
}

// This is very useful for server side rendering, because I can wait
// until data is available, then synchronously render the app.

import { renderToString } from 'react-dom/server'

store
  .dispatch(makeSandwichesForEverybody())
  .then(() => response.send(renderToString(<MyApp store={store} />)))

// I can also dispatch a thunk async action from a component
// any time its props change to load the missing data.

import React from 'react'
import { connect } from 'react-redux'

function SandwichShop(props) {
  const { dispatch, forPerson } = props

  useEffect(() => {
    dispatch(makeASandwichWithSecretSauce(forPerson))
  }, [forPerson])

  return <p>{this.props.sandwiches.join('mustard')}</p>
}

export default connect(state => ({
  sandwiches: state.sandwiches
}))(SandwichShop)
Tips
Middleware only wraps the store's dispatch function. Technically, anything a middleware can do, you can do manually by wrapping every dispatch call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.
If you use other store enhancers in addition to applyMiddleware, make sure to put applyMiddleware before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before redux-devtools because otherwise the DevTools won't see the raw actions emitted by the Promise middleware and such.
If you want to conditionally apply a middleware, make sure to only import it when it's needed:
let middleware = [a, b]
if (process.env.NODE_ENV !== 'production') {
  const c = require('some-debug-middleware')
  const d = require('another-debug-middleware')
  middleware = [...middleware, c, d]
}

const store = createStore(
  reducer,
  preloadedState,
  applyMiddleware(...middleware)
)
This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.
Ever wondered what applyMiddleware itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, applyMiddleware is an example of the most powerful Redux extension mechanism called store enhancers. It is highly unlikely you'll ever want to write a store enhancer yourself. Another example of a store enhancer is redux-devtools. Middleware is less powerful than a store enhancer, but it is easier to write.
Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you'll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.
To apply multiple store enhancers, you may use compose().
Edit this page
Last updated on Nov 24, 2023""""""",1939,9130,redux
https://redux.js.org/api/bindactioncreators,"""""""API ReferencebindActionCreators
bindActionCreators(actionCreators, dispatch)
Overview
Turns an object whose values are action creators, into an object with the same keys, but with every action creator wrapped into a dispatch call so they may be invoked directly.
Normally you should just call dispatch directly on your Store instance. If you use Redux with React, react-redux will provide you with the dispatch function so you can call it directly, too.
The only use case for bindActionCreators is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass dispatch or the Redux store to it.
For convenience, you can also pass an action creator as the first argument, and get a dispatch wrapped function in return.
WARNING
This was originally intended for use with the legacy React-Redux connect method. It still works, but is rarely needed.
Parameters
actionCreators (Function or Object): An action creator, or an object whose values are action creators.
dispatch (Function): A dispatch function available on the Store instance.
Returns
(Function or Object): An object mimicking the original object, but with each function immediately dispatching the action returned by the corresponding action creator. If you passed a function as actionCreators, the return value will also be a single function.
Example
TodoActionCreators.js
export function addTodo(text) {
  return {
    type: 'ADD_TODO',
    text
  }
}

export function removeTodo(id) {
  return {
    type: 'REMOVE_TODO',
    id
  }
}
SomeComponent.js
import React from 'react'
import { bindActionCreators } from 'redux'
import { connect } from 'react-redux'

import * as TodoActionCreators from './TodoActionCreators'
console.log(TodoActionCreators)
// {
//   addTodo: Function,
//   removeTodo: Function
// }

function TodoListContainer(props) {
  // Injected by react-redux:
  const { dispatch, todos } = props

  // Here's a good use case for bindActionCreators:
  // You want a child component to be completely unaware of Redux.
  // We create bound versions of these functions now so we can
  // pass them down to our child later.

  const boundActionCreators = useMemo(
    () => bindActionCreators(TodoActionCreators, dispatch),
    [dispatch]
  )
  console.log(boundActionCreators)
  // {
  //   addTodo: Function,
  //   removeTodo: Function
  // }

  useEffect(() => {
    // Note: this won't work:
    // TodoActionCreators.addTodo('Use Redux')

    // You're just calling a function that creates an action.
    // You must dispatch the action, too!

    // This will work:
    let action = TodoActionCreators.addTodo('Use Redux')
    dispatch(action)
  }, [])

  return <TodoList todos={todos} {...this.boundActionCreators} />

  // An alternative to bindActionCreators is to pass
  // just the dispatch function down, but then your child component
  // needs to import action creators and know about them.

  // return <TodoList todos={todos} dispatch={dispatch} />
}

export default connect(state => ({ todos: state.todos }))(TodoListContainer)
Edit this page
Last updated on Nov 24, 2023""""""",670,3117,redux
https://redux.js.org/api/compose,"""""""API Referencecompose
compose(...functions)
Overview
Composes functions from right to left.
This is a functional programming utility, and is included in Redux as a convenience. You might want to use it to apply several store enhancers in a row. compose is also usable as a general-purpose standalone method.
WARNING
You shouldn't have to call compose directly. Redux Toolkit's configureStore method automatically configures a Redux store with the standard applyMiddleware and Redux DevTools store enhancers, and offers an enhancers argument to pass in additional enhancers.
Arguments
(arguments): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.
Returns
(Function): The final function obtained by composing the given functions from right to left.
Example
This example demonstrates how to use compose to enhance a store with applyMiddleware and a few developer tools from the redux-devtools package.
import { createStore, applyMiddleware, compose } from 'redux'
import thunk from 'redux-thunk'
import DevTools from './containers/DevTools'
import reducer from '../reducers'

const store = createStore(
  reducer,
  compose(applyMiddleware(thunk), DevTools.instrument())
)
Tips
All compose does is let you write deeply nested function transformations without the rightward drift of the code. Don't give it too much credit!
Edit this page
Last updated on Nov 24, 2023""""""",320,1642,redux
https://redux.js.org/api/utils,"""""""API ReferenceAdditional Utilities
Utility Functions
The Redux core exports additional utility functions for reuse.
isAction
Returns true if the parameter is a valid Redux action object (a plain object with a string type field).
This also serves as a TypeScript type predicate, which will narrow the TS type to Action<string>.
isPlainObject
Returns true if the value appears to be a plain JS object.
Edit this page
Last updated on Nov 25, 2023""""""",92,442,redux
https://redux.js.org/errors,"""""""""""""",0,0,redux
https://redux.js.org/redux-toolkit/overview,"""""""Redux ToolkitRedux Toolkit: Overview
What is Redux Toolkit?
Redux Toolkit is our official, opinionated, batteries-included toolset for efficient Redux development. It is intended to be the standard way to write Redux logic, and we strongly recommend that you use it.
It includes several utility functions that simplify the most common Redux use cases, including store setup, defining reducers, immutable update logic, and even creating entire ""slices"" of state at once without writing any action creators or action types by hand. It also includes the most widely used Redux addons, like Redux Thunk for async logic and Reselect for writing selector functions, so that you can use them right away.
Installation
Redux Toolkit is available as a package on NPM for use with a module bundler or in a Node application:
# NPM
npm install @reduxjs/toolkit

# Yarn
yarn add @reduxjs/toolkit
Purpose
The Redux core library is deliberately unopinionated. It lets you decide how you want to handle everything, like store setup, what your state contains, and how you want to build your reducers.
This is good in some cases, because it gives you flexibility, but that flexibility isn't always needed. Sometimes we just want the simplest possible way to get started, with some good default behavior out of the box. Or, maybe you're writing a larger application and finding yourself writing some similar code, and you'd like to cut down on how much of that code you have to write by hand.
Redux Toolkit was originally created to help address three common concerns about Redux:
""Configuring a Redux store is too complicated""
""I have to add a lot of packages to get Redux to do anything useful""
""Redux requires too much boilerplate code""
We can't solve every use case, but in the spirit of create-react-app and apollo-boost, we can provide an official recommended set of tools that handle the most common use cases and reduce the need to make extra decisions.
Why You Should Use Redux Toolkit
Redux Toolkit makes it easier to write good Redux applications and speeds up development, by baking in our recommended best practices, providing good default behaviors, catching mistakes, and allowing you to write simpler code. Redux Toolkit is beneficial to all Redux users regardless of skill level or experience. It can be added at the start of a new project, or used as part of an incremental migration in an existing project.
Note that you are not required to use Redux Toolkit to use Redux. There are many existing applications that use other Redux wrapper libraries, or write all Redux logic ""by hand"", and if you still prefer to use a different approach, go ahead!
However, we strongly recommend using Redux Toolkit for all Redux apps.
Overall, whether you're a brand new Redux user setting up your first project, or an experienced user who wants to simplify an existing application, using Redux Toolkit will make your code better and more maintainable.
What's Included
Redux Toolkit includes:
configureStore(): wraps createStore to provide simplified configuration options and good defaults. It can automatically combine your slice reducers, adds whatever Redux middleware you supply, includes redux-thunk by default, and enables use of the Redux DevTools Extension.
createReducer(): that lets you supply a lookup table of action types to case reducer functions, rather than writing switch statements. In addition, it automatically uses the immer library to let you write simpler immutable updates with normal mutative code, like state.todos[3].completed = true.
createAction(): generates an action creator function for the given action type string. The function itself has toString() defined, so that it can be used in place of the type constant.
createSlice(): accepts an object of reducer functions, a slice name, and an initial state value, and automatically generates a slice reducer with corresponding action creators and action types.
createAsyncThunk: accepts an action type string and a function that returns a promise, and generates a thunk that dispatches pending/fulfilled/rejected action types based on that promise
createEntityAdapter: generates a set of reusable reducers and selectors to manage normalized data in the store
The createSelector utility from the Reselect library, re-exported for ease of use.
Redux Toolkit also has the RTK Query data fetching API. RTK Query is a powerful data fetching and caching tool built specifically for Redux. It is designed to simplify common cases for loading data in a web application, eliminating the need to hand-write data fetching & caching logic yourself.
Documentation
The complete Redux Toolkit documentation is available at https://redux-toolkit.js.org.
Edit this page
Last updated on Mar 6, 2023""""""",934,4745,redux
