golem:
- id_parent: 1
  title: Home
  url: https://learn.golem.cloud/
  content: |
    Home
    Golem Developer Documentation
    Welcome to the Golem developer documentation portal! Here you will find comprehensive documentation on how to build, deploy, and manage applications on Golem.
    Golem is available in both an open source version that you can deploy yourself and a hosted version that we manage for you. This documentation covers both versions, and we will discuss any differences between the two.
    Getting Started
    Why Golem?
    Fundamentals
    Quickstart
    Quick Links
    Develop
    Deploy
    Invoke
    Operate
    CLI
    REST API
    Last updated on March 28, 2025
    Why Golem?
    
  section: Home
  char_count: 559
  approx_token_count: 140
- id_parent: 2
  title: Why golem
  url: https://learn.golem.cloud/why-golem
  content: |
    Why Golem?
    Why Golem?
    Golem is a durable computing platform that makes it simple to build and deploy highly reliable distributed systems.
    Through durable computing, workers executing on Golem are automatically fault-tolerant, update-tolerant, and flaky-tolerant.
    Golem workers continue execution uninterrupted, even when hardware fails, servers go down, clusters are resized, or new updates are deployed.
    Golem simplifies the development of highly-reliable, distributed applications.
    Benefits
    Golem shares many of the benefits of serverless computing, including faster development, lower maintenance overhead, and reduced need for operations.
    Due to the fact that Golem is built on durable computing, Golem offers benefits not seen in most serverless solutions, including:
    Fault-Tolerance. Golem performs real-time, incremental backups of the state of workers and supervises all workers. In the event of a fault, Golem restores failed workers to new nodes, where they continue execution where they left off.
    Update-Tolerance. Golem lets you deploy new versions of your software at any time, and these new versions only affect new workers (by default). Because versions are isolated, you can update freely without breaking critical live code.
    Flaky-Tolerance. While Golem is reliable, sometimes your system needs to talk to external systems. Golem performs sophisticated, user-configurable retry policies on recoverable failures, freeing you from the drudgery of retries.
    These benefits allow you to easily build highly-reliable distributed systems, without complex architecture or infrastructure.
    Example Use Cases
    In the following examples, you will learn how Golem simplifies the architecture and development of several different types of distributed applications.
    Order Processing
    In an online storefront, we may have to take many steps during end-to-end processing of an order:
    Check and reserve sufficient inventory.
    Validate details of the order, such as shipping address.
    Validate payment method details.
    Charge the user's credit card or debit their bank account.
    Retry or abort on an failed charge (as appropriate), or continue on success.
    Record the successful charge in a database.
    Dispatch the order to fulfillment.
    Send the customer an email with their order details.
    Send the user updates as the state of the order is updated by fulfillment.
    Handle unexpected errors during fulfillment, or the user's cancellation of the order before dispatch.
    The major part of this process can take several seconds to several minutes, while the entire process could take days or even weeks.
    In a perfect world, we could write a simple function that performs all of these step in order, in a handful of helper functions that call out to other web services.
    However, if we were to push this naive solution into production, we would run into serious problems. Due to faults, updates, and upgrades, there would exist some customers whose order processing was interrupted midway.
    When running code is interrupted midway, it often leaves the overall system in an inconsistent state. The user might be surprised to see they were charged for the items that will never be delivered, because the function that was processing the order was interrupted midway.
    In order to compensate for these failure scenarios, we might adopt an event-driven architecture. Because events are stored persistently in a durable message queue like Apache Kafka or Apache Pulsar, we would then have a reliable means to detect which steps have been performed, and which have not. We could write processes that recover partially completed orders, and resume at the point where they left off.
    While industry-proven and reliable, this approach ends up significantly increasing our development and maintenance costs, and turns what could be a simple and short program into many disparate services, all introducing additional overhead and points of failure.
    With Golem, the entire order processing process can be written and deployed as a serverless function. When an API triggers an invocation of the function, the worker will run transactionally, regardless of faults, updates, or flakiness. This automatic reliability lets us focus on business logic, rather than the complexities of designing and maintaining an event-driven architecture.
    Session Management
    In a multiplayer online betting game, each gaming session could last several minutes to an hour, and depending on the nature of the game, players may be able to place bets days or weeks in advance of the live session.
    The responsibilities of session management include:
    Financial Transaction Processing. Taking bets and settlement, which involve traditional commerce processes such as the preceding storefront example.
    State Management. Managing the state of the game session during play, as game play unfolds.
    Due to the financial nature of betting games, it is important that bets be tracked precisely and placed only be allowed when the state of the game and the rules of the game permit the bets to be placed. Moreover, faults can occur at any point and should never halt the progress of a game nor interfere with bets that have been placed so far.
    One way of solving this problem would be to use a relational database in order to obtain ACID guarantees on bets. However, the state of the game evolves in real-time, so to make concurrent bets in the presence of a changing game state, it would also be necessary to store the game state in the database. Storing both all bets and the game state itself in the relational database could negatively impact performance, necessitating alternate approaches, such as event-sourcing with CQRS.
    In the end, a traditional solution to the problem of session management is likely to be highly tailored to the specific nature of the game and the audience size, and likely to involve some kind of event-sourcing, potentially with CQRS, in order to ensure consistency and recoverability in the event of unanticipated failures.
    With Golem, the entire game session can be deployed as a single serverless worker, which responds to updates in game state and takes new bets. Since the data is stored in memory and latency of workers in Golem is very low, performance can be very high, without sacrificing the durability guarantees of other approaches based on ACID databases or event-sourcing.
    AI Agent
    When implementing an AI agent, each step of the AI agent may translate into multiple different models, some of which may have to be repeated if they do not yield a satisfactory answer.
    In addition, many AI agents are stateful, and must accumulate the total information they have produced from the beginning of time until the current moment in time, as this information assists subsequent step formation and execution.
    Each execution of a model takes time and resources, which equates to higher latency or higher costs. Due to these realities, it is often a technical requirement for AI agents to execute durably, such that they are fault-tolerant.
    Implementing fault-tolerant AI agents can be done using state machines and event-sourcing, together with durable queues and key/value stores.
    Golem provides an alternative: each executing AI agent can be a single worker, which can naturally accumulate state in memory, without the need for queues or databases.
    Because Golem workers are fault-tolerant, they will continue execution uninterrupted regardless of failures in hardware, restarts, updates, or upgrades.
    Because Golem workers are update-tolerant, they can be updated without affecting running workers.
    Finally, because Golem workers are flaky-tolerant, the model executions will eventually succeed, even if the cause of the transient failure is a rate limit or other issue.
    Summary
    All of the examples presented here can be implemented reliably and scalably with existing and industry-proven architectures.
    However, when using Golem, each becomes at least an order of magnitude simpler, without compromising reliability or scalability.
    Golem gives you the ability to build highly-reliable distributed systems with simple code and simple architecture.
    Last updated on March 28, 2025
    Home
    Fundamentals
    
  section: Why golem
  char_count: 8164
  approx_token_count: 2041
- id_parent: 3
  title: Fundamentals
  url: https://learn.golem.cloud/fundamentals
  content: |
    Fundamentals
    Fundamentals
    Golem is a serverless computing platform that helps you build and deploy reliable distributed systems with simple code.
    In this section, you will learn some key terms and architecture that will help you better understand Golem.
    Key Terms
    WASM. WebAssembly
    (opens in a new tab)
    , or WASM, for short, is a specification for a portable and secure virtual machine. Software compiled to WASM can execute on any platform and architecture using a WASM Runtime.
    Components. In WebAssembly, components are the basic building block of applications, backends, and web services. Components requires certain capabilities from the host platform (like input/output), and expose a typed public API.
    Workers. In Golem, workers are running instances created from components, with their own resources, such as RAM, file system, and environment variables. Workers are created from external events like requests or by other workers.
    Invocations. In Golem, the fundamental unit of work is an invocation of a function that is part of a worker's typed public API. Functions may require typed parameters as input and may return typed values as output.
    High-Reliability. Highly reliable systems must execute critical logic uninterrupted, even through faults, updates, and cloud flakiness. Golem provides transparent high-reliability, regardless of language or technology stack.
    WIT. WIT is a standard of WASM, similar to Protobuf, which allows developers to export a typed public API from components. Through the Worker Gateway, Golem lets you build HTTP or gRPC APIs atop these typed public APIs.
    Golem Architecture
    Golem is architected as a series of independent and modular components, ranging from command-line tools to core systems responsible for deployment and execution.
    CLI. Golem CLI is a command-line interface to Golem, which has the ability to create and manage components and workers, perform invocations, and even connect to live workers for diagnostics and troubleshooting.
    Worker Gateway. Worker Gateway executes requests by delegating their processing to specific functions on specified workers. Worker Gateway can extract worker input from JSON, and produce JSON from worker output.
    Worker Executor. Worker Executor creates and executes the logic of many individual workers, potentially created from different components, exposing their public typed API via the Worker Gateway.
    Golem Services. Golem Services runs a variety of different HTTP endpoints that allow programmatic management of all the features of Golem. CLI and Console are both implemented atop Golem Services.
    Shard Manager. Shard Manager handles both supervision of individual executor nodes in the Golem cluster and the task of partitioning all workers across the available executor nodes in a Golem cluster.
    Golem Cloud. Golem Cloud is the fully managed version of Golem, suitable for companies looking for a true zero-ops approach to building highly-reliable distributed systems with simple code.
    Console. Console is a graphical user-interface designed to help manage accounts, components, and workers on Golem Cloud. It provides high-level ways of performing many of the same tasks that are supported by CLI.
    Last updated on March 28, 2025
    Why Golem?
    Quickstart
    
  section: Fundamentals
  char_count: 3250
  approx_token_count: 813
- id_parent: 4
  title: Quickstart
  url: https://learn.golem.cloud/quickstart
  content: |
    Quickstart
    Quickstart
    This guide will get you up and running in Golem in minutes.
    Install Golem CLI
    Golem CLI is a command-line application that allows you to deploy components, create and invoke workers, and otherwise manage your Golem applications.
    There are precompiled binaries of golem (and its other variants) for various platforms. Alternatively, you can build Golem CLI for yourself.
    Precompiled binaries
    You can download the full version of golem from the following page:
    Golem CLI Releases
    There are precompiled binaries of two variants of the CLI here:
    golem is the full version of the command line interface, including a locally runnable version of Golem itself.
    golem-cli is a lightweight version of the command line interface, requiring a running Golem cluster
    In this documentation we will use the golem command in the snippets. The available commands of (except the one for starting up the local Golem cluster) are the same in both variants.
    Running Golem
    It is possible to test Golem locally without installing anything else than the above described golem executable. To use it, start the local Golem cluster by running the following command:
    golem server run
    To use the open source version of Golem in production you will need to deploy it in your own infrastructure. See the deployment page for available deployment options.
    It is also possible to use our hosted version of Golem, available at [https://console.golem.cloud
    (opens in a new tab)
    ].
    Creating a Profile
    To specify the Golem service location, run the following command:
    golem init
    This command starts an interactive configuration process. For non-interactive options - see Golem CLI page.
    On the first step you'll see 3 options:
    Golem Default. Use this options if you have started Golem locally using golem server run.
    Golem. Use this option in case of a customised Golem installation in your own infrastructure.
    Golem Cloud. Use this option for a hosted version of Golem.
    Building an Example
    Golem runs components that are WebAssembly programs. Components are like applications, except they may expose functions that can be called externally.
    To deploy to Golem, you must first build a component using any programming language and toolchain that can build WebAssembly components.
    The golem command line interface provides integrates a set of commands to create, build, and deploy components.
    To get started, you create an application and a single component using your chosen programming language with the golem app new and golem component new commands.
    Rust
    TypeScript
    Go
    Python
    C
    JavaScript
    Zig
    MoonBit
    Scala.js
    golem app new example rust
    cd example
    golem component new rust example:component
    This will generate a new component in the current, ready to be compiled and deployed to Golem.
    ⚠️
    Each supported programming language may require additional setup before you can build your component. Refer to the language specific guides for more information.
    To build the newly created component, use the following command:
    golem app build
    This compiles the newly created application, which consists of a single Golem component at the moment. An application can have multiple components and they can depend on each other. New components can be added to the application by using the golem component new command.
    Uploading Your Component
    To upload your component to Golem, you can use the component deploy command.
    golem component deploy
    When you add a component you will see some basic information about the component such as its name, unique identifier, version, and size. In addition, you will see a list of exports. These are the public API of your worker and can be used to call it with the CLI or REST API, as we will see below.
    Uploading a component to Golem does not actually execute the component. Instead, it only makes it available for execution to Golem.
    Every separate execution of your component is referred to as a worker based on that component.
    Create Workers
    In Golem, every worker has a unique id, which is arbitrary text that you define. If you don't need a meaningful id for workers, you can generate a UUID.
    Once you have chosen a worker id, you can launch the worker either explicitly, or by invoking any function on the worker (for example, a “main” function).
    Here, we creating a new worker test-1 :
    golem worker new test-1
    We don't have to specify which component to use, because golem detects that the current directory belongs to a Golem application consisting of a single component.
    Invoking Workers
    Thanks to the WebAssembly component model, your Golem applications are not just an executable. Rather, they may export functions that can be called from the outside. Exported functions allow your workers to be given instructions or queried for their state.
    The default template used by the above commands for each language creates a component that exports a simple counter interface. To use it, we can invoke the add and get functions, using their fully quialified names:
    golem worker invoke test-1 'example:component/api.{add}' 2
    golem worker invoke test-1 'example:component/api.{add}' 3
    golem worker invoke test-1 'example:component/api.{get}'
    If a worker of the specified name has not been created, then when you attempt to invoke a function on the worker, it will first be created.
    The parameters are either listed one by one and are using the WAVE format
    (opens in a new tab)
    Check the Invoke section to learn about more about where the fully qualified function names are coming from and what other ways you have to interact with workers.
    Next Steps
    In this guide, you have learned how to build and deploy invincible serverless workers on Golem, and seen how you can interact with them as they execute.
    Take your next steps with Golem by exploring the following resources:
    Read about the fundamentals of Golem
    Learn about the main concepts
    Read one of the language-specific guides to learn how to develop Golem components
    Check out how to deploy Golem to your infrastructure
    Read the details of how to invoke workers
    Learn more about the Golem CLI
    Explore operational aspects such as how worker state is persisted, what metrics and logs are available
    Check the References section for detailed information on APIs and syntaxes
    Last updated on March 28, 2025
    Fundamentals
    Concepts
    
  section: Quickstart
  char_count: 6288
  approx_token_count: 1572
- id_parent: 5
  title: Concepts
  url: https://learn.golem.cloud/concepts
  content: |
    Concepts
    Concepts
    This section is a collection of Golem's primary concepts.
    Reliability
    Components
    Workers
    Invocations
    Worker Gateway
    Worker to Worker Communication
    API Definitions
    Plugins
    Last updated on March 28, 2025
    Quickstart
    Reliability
    
  section: Concepts
  char_count: 242
  approx_token_count: 61
- id_parent: 6
  title: Reliability
  url: https://learn.golem.cloud/concepts/reliability
  content: |
    Concepts
    Reliability
    Introduction
    Golem is a durable computing platform that makes it simple to build and deploy highly reliabile distributed systems.
    When developing for Golem, you normally don't need to worry about most of the complexity of ensuring reliable execution. Golem takes care of the heavy lifting for you, ensuring that your applications are resilient, robust, fault-tolerant, and highly available.
    However, when evaluating Golem for your use case, it is essential to understand exactly what guarantees Golem provides, what you need to handle on your own, and how you can tune Golem to meet your specific requirements.
    In this section, we'll explore all of these aspects in detail, starting with the essential concepts of reliability in distributed systems.
    Essential Concepts
    In the field of distributed systems, several technical concepts are crucial to the development of reliable solutions:
    Resiliency: The system's ability to correctly identify and respond to failures in external dependencies.
    Robustness: The system's capacity to prevent, identify, and correctly respond to internal failures.
    Fault-Tolerance: The system's ability to continue functioning correctly even when experiencing one or more faults.
    High-Availability: The system's capability to remain available and responsive under various conditions, including partial failures or high stress.
    Let's explore each of these concepts in detail to understand how they contribute to overall system reliability.
    Resiliency
    Resiliency is the ability of a system to continue functioning correctly even in the presence of failures in the systems it interacts with.
    Modern systems interact with numerous remote components through network protocols. These external systems can fail in various ways, presenting challenges for maintaining overall system reliability.
    Common types of external failures include:
    Network Failures: Disruptions in connectivity, degraded performance, or unstable connections preventing reliable communication.
    Internal Failures in Remote Systems: Bugs, crashes, or other malfunctions within external systems causing incorrect behavior or non-responsiveness.
    Load-Related Failures: Overwhelmed systems leading to degraded performance or total unavailability.
    Maintenance-Related Downtime: Planned or unplanned system updates, migrations, or other maintenance activities causing temporary unavailability.
    API Versioning Incompatibilities: Mismatches between different versions of interacting systems or APIs leading to errors or unpredictable outcomes.
    Authorization and Authentication Issues: Invalid credentials, insufficient permissions, or other access-related problems.
    Highly resilient systems employ various strategies to handle these external failures:
    Intelligent Retry Mechanisms: Implementing advanced retry policies, often combining exponential backoff with random jitter to handle transient failures gracefully.
    Circuit Breaker Pattern: Temporarily disabling calls to failing services to prevent cascading failures.
    Bulkhead Pattern: Isolating components to ensure that failures in one part of the system don't bring down the entire application.
    Robustness
    Robustness is the ability of a system to both prevent, as well as identify and correctly respond to, failures of the system itself.
    Internal failure scenarios can be categorized into a hierarchy, ranging from business logic issues to infrastructure problems:
    Defect Failures: Errors due to software defects, such as null pointer exceptions, buffer overflows, or division by zero.
    Domain Failures: Failures to handle scenarios anticipated and specified by the business logic.
    Unrecoverable Failures: Situations where the software cannot recover, such as database access failures due to incorrect configuration.
    OS Faults: Operating system interference with process execution.
    Hardware Faults: Failures in critical hardware components like RAM, CPU, or network interfaces.
    Strategies for improving robustness include:
    Comprehensive Error Handling: Implementing thorough error handling covering various failure scenarios.
    Graceful Degradation: Allowing systems to continue operating with reduced functionality rather than complete shutdown when encountering non-critical failures.
    Rapid Failure Detection: Quickly identifying and reporting internal failures to enable fast resolution.
    Fault-Tolerance
    Fault-tolerant systems are designed to continue functioning correctly even in the presence of one or more faults. Fault-tolerance can be considered a specific type of robustness, focusing on a system's ability to handle systemic issues.
    Strategies for fault-tolerant systems include:
    Replication: Duplicating critical components across multiple nodes to ensure continued operation if some nodes fail.
    State Management: Implementing robust state management tools to allow systems to recover gracefully from failures without data loss.
    Failover Mechanisms: Automatically redirecting traffic to healthy nodes in case of node failures.
    High-Availability
    High-availability systems are designed to be accessible and responsive to their intended workloads, even under conditions of partial failure or stress.
    Strategies for achieving high availability include:
    Load Balancing: Distributing traffic across multiple instances to prevent any single point of failure.
    Auto-Scaling: Automatically adjusting resources based on demand to ensure optimal performance during peak times.
    Geographic Distribution: Deploying across multiple geographic regions to reduce latency and improve resilience against regional outages.
    Reliability: Bringing It All Together
    Reliability is a comprehensive term that encompasses all of the preceding concepts. A highly reliable system is one that is:
    Resilient to external failures
    Robust in handling internal failures
    Fault-tolerant to systemic issues
    Highly available under various conditions
    By addressing each of these aspects, developers can create distributed systems that ensure data integrity, maintain consistent performance, and provide a seamless experience for end-users, even in the face of various challenges and failure scenarios.
    High-Reliability with Golem
    With any programming language, tech stack, or SDK, Golem automatically provides you with a high degree of built-in reliability.
    These guarantees are summarized as follows:
    Transactional execution. Golem ensures that your workers execute transactionally. Once they begin execution, they will complete execution, even if there are software or hardware faults, restarts, or updates.
    Durable state. Golem ensures that the state of your workers is durable. If a worker is recovered after a failure, it will resume with the same state as before the failure.
    Reliable internal communication. Golem ensures that communication between workers is delivered reliably. If a message is sent, it will eventually be delivered, with exactly-once semantics; even if there are network partitions, faults, or other failures.
    Resilient external communication. Golem automatically applies retry strategies and other techniques to ensure that transient failures of external systems do not affect reliability.
    In the following sections, we will explore these guarantees in more detail, looking at how each of them improves different faucets of reliability.
    Resiliency
    As discussed in Components, all components deployed on Golem ultimately derive their capability to interact with external systems from WASI, which is the Posix-like interface provided by the WASM component model.
    WASI provides facilities to interact with file systems, sockets, time, and other system resources in a portable and secure manner.
    Because Golem provides a custom implementation of WASI, it has direct insight into the interactions between components and the underlying system. This allows Golem to detect a variety of transient failure scenarios and automatically apply resiliency strategies, such as retries, to ensure that the system remains resilient to these failures.
    Golem automatically applies retry strategies to the following types of failures:
    HTTP Request Failures
    In the case of errors which are not resolved on their own, Golem will eventually give up and mark the worker as failed. This is to prevent the system from getting stuck in an infinite loop of retries.
    These workers can be detected using worker enumeration.
    Limitations
    Golem does not have awareness into transient errors that are expressed in protocol- agnostic ways. For example, if an HTTP response contains a 200 status code, but the body contains a transient error, then Golem will not be able to detect this error and attempt recovery.
    You should be aware of this limitation when designing your applications, and consider implementing your own retry strategies for such cases.
    Customization
    Currently, you can customize a worker's retry policy, including number of retries, delays, and so on, but it is a global setting that applies to all failed operations. See Golem host functions for more details, or langauge-specific SDKs.
    Fault-Tolerance
    Golem's fault-tolerance guarantees are focused on ensuring that your workers are executed transactionally and that their state is durable, regardless of software or hardware faults, restarts, or updates.
    In order to more precisely define the scope of these guarantees, we need to introduce some terminology:
    Failure Event. A failure event is any event that causes a worker to interrupt execution, but excluding all internal errors in the worker itself. This includes operating system faults, hardware faults, disruptions (termination through the container orchestrator), restarts, and updates.
    Supervision. Supervision is the process by which Golem detects failure events and takes action to recover interrupted workers.
    Recovery. Recovery is the process by which Golem restores the state of a worker to its state before the failure event, and resumes execution.
    Limitations
    Golem's fault-tolerant guarantees are extensive, and they enable you to build highly reliable distributed systems without having to think about most failure scenarios. However, you should be aware of the following limitation:
    Execution Semantics. For external systems (those not executed by Golem), Golem generally guarantees only at-least once semantics with respect to the last external request made before the failure event.
    The following section discusses this limitation in more depth and what you can do to mitigate it.
    Execution Semantics
    All local code, as well as all communication between workers, is executed with exactly-once semantics. All local code executed strictly inside Golem, including worker-to-worker communication, is guaranteed to have exactly-once semantics. This means that during recovery, the state of the worker is restored to the exact state it was in before the failure event, and no operations performed by the worker are repeated.
    However, for remote operations, such as invoking an HTTP API, Golem cannot generally guarantee exactly-once semantics. This is because a failure event may occur after a request has been sent, but before the response has been received. In this scenario, during the recovery, the request must be retried, which may lead to the remote system processing the same request multiple times.
    To mitigate this issue, you should consider using HTTP APIs that support the The Idempotency-Key HTTP Header Field
    (opens in a new tab)
    . This header allows you to provide a unique key for each request, which the remote system can use to ensure that the request is idempotent.
    In a future release, Golem will automatically generate idempotency keys for each request. For now, however, you can use the language-specific Golem SDK to generate an idempotency key, which you can then pass to the remote system.
    ⚠️
    It is recommended to use the Golem SDK to generate idempotency keys, rather than generating them yourself, to ensure that Golem transactionally commits the key to durable persistence right away. If you generate a random idempotency key yourself, without also using the Golem SDK to manually perform a commit, then there is a small but nonzero chance that a failure event could happen after the HTTP API is invoked, but before the idempotency key is committed to durable persistence.
    Idempotency keys guarantee exactly-once semantics for requests that support them, ensuring that the remote system can safely process the request multiple times without causing any side effects.
    High-Availability
    Golem is designed to be highly-available with respect to the creation and execution of new workers in the Golem cluster.
    This is accomplished by supporting large cluster sizes that can evenly distribute workloads any number of nodes, and by automatically rebalancing workloads across the cluster when nodes are added or removed.
    However, because Golem allows and encourages communication with specific, stateful workers, there are limitations around the availability of specific workers in the cluster.
    The following sections overview these limitations.
    Limitations
    The availability of specific workers in a Golem cluster is affected by several different factors, including all of the following:
    Cluster Size. The number of worker executor nodes in the cluster. If the cluster is too small, then it may not be able to handle the workload, leading to degraded performance or unavailability.
    Cluster Resizing. Cluster resizing requires rebalancing the workload across the new set of nodes. This process may take some time, during which availability of specific workers being relocated may be degraded.
    Worker Executor Node Health. If the node running a shard of workers goes down, then those workers will be unavailable until the node is recovered. This process may take anywhere from a few seconds to a few minutes, depending on how quickly the failure is detected and the number of workers in the shard.
    Shard Manager Health. If the shard manager goes down, there are scenarios where this can negatively impact availability.
    Tuning
    Though not supported currently, it is very likely Golem will increase the availability of specific high-priority workers by supporting instant-failover.
    Conclusion
    Throughout this document, we've explored the crucial aspects of reliability in distributed systems and how Golem addresses these challenges. We began by examining the four pillars of reliability: resiliency, robustness, fault- tolerance, and high availability. These concepts form the foundation for creating dependable systems that can withstand various failure scenarios and maintain consistent performance.
    Golem provides a robust set of built-in reliability guarantees that significantly simplify the development of highly reliable distributed systems. These include transactional execution, durable state management, reliable internal communication, and resilient external communication.
    By automatically handling many complex reliability concerns, Golem allows developers to focus on their core business logic rather than intricate failure handling mechanisms. While Golem offers substantial reliability features, it's essential to understand its current limitations. These include the potential for at-least-once semantics in certain external system interactions and limitations in the availability of specific workers during cluster changes. However, Golem's team is actively working on addressing these areas, with plans for customizable retry strategies and improved worker availability on the horizon.
    For developers leveraging Golem, a deep understanding of these reliability concepts and Golem's capabilities is crucial. This knowledge allows you to make informed decisions about system design, identify areas where additional reliability measures may be necessary, and fully utilize Golem's built-in features to create robust distributed applications.
    As distributed systems continue to grow in complexity and importance, platforms like Golem evolve to meet these challenges. Future releases promise to bring even more advanced reliability features, such as automatic idempotency key generation and instant failover for high-priority workers, further enhancing Golem's ability to support mission-critical applications.
    In conclusion, Golem provides a powerful foundation for building highly reliable distributed systems. By abstracting away many of the complexities associated with fault-tolerance and high availability, it enables developers to create resilient applications that can withstand the unpredictable nature of distributed environments.
    As you embark on your journey with Golem, remember that reliability is not just a feature, but a fundamental aspect of system design that Golem helps you achieve with greater ease and confidence.
    Last updated on March 28, 2025
    Concepts
    Components
    
  section: Concepts
  char_count: 16771
  approx_token_count: 4193
- id_parent: 7
  title: Components
  url: https://learn.golem.cloud/concepts/components
  content: |
    Concepts
    Components
    Introduction
    Golem is a durable computing platform that makes it simple to build and deploy highly reliable distributed systems.
    Golem provides transparent durability to applications by taking over execution of code. However, for performance and portability reasons, Golem does not execute machine code. Rather Golem executes code that has been compiled to WebAssembly.
    WebAssembly (WASM) is a binary instruction set for a stack-based virtual machine that can be run on any platform and device. WASM is designed to be a portable, cross-language target for compilers and interpreters.
    Golem has a custom executor that executes WASM code durably, by performing real-time state replication across multiple nodes. Combined with supervision and automatic recovery, this allows Golem to execute code transactionally, impervious to faults, restarts, and updates.
    The WASM standard by itself does not provide any built-in I/O capabilities or system interfaces, making it insufficient for real-world applications. To address this fundamental gap, Golem adopts and fully supports the WebAssembly component model.
    The component model serves as the foundation for WASI (WebAssembly System Interface), which provides crucial OS-like functionality to WASM modules. WASI defines a standardized set of system interfaces, allowing WebAssembly programs to perform essential operations such as file I/O, network access, and time management.
    For Golem, this means that components can interact with the underlying system in a consistent and portable manner, regardless of the host environment.
    Languages that support WASM use WASI (through the component model) to provide the functionality built into their standard libraries, which are in turn used to build libraries and frameworks that developers use to build applications.
    By embracing the component model and WASI, Golem enables your WASM-based applications to benefit from the full capabilities of the underlying system, while also ensuring security and portability.
    As an added benefit, the component model also facilitates cross-language interoperability, further extending Golem's flexibility as a development platform, and enabling polyglot development without having to go through bulky and slow protocols like HTTP or gRPC.
    In this document, we will focus on the Golem-specific aspects of the component model, and provide high-level overview of working with components.
    A full introduction to WASM, WASI, and the component model is beyond the scope of this document. For detailed information, you can refer to the official WebAssembly Component Model
    (opens in a new tab)
    and WASI
    (opens in a new tab)
    resources.
    Structure
    WASM components have a well-defined structure, which facilitates their execution in a host environment, as well as their interaction with other components.
    The high-level structure of a WASM component is as follows:
    Code. The code section of a WASM component contains the WebAssembly bytecode that implements the component's functionality.
    Data. The data section of a WASM component contains all static data that the component requires at runtime, such as constant strings.
    Imports. The import section of a WASM component contains a list of imports that the component requires from other components or the host environment.
    Exports. The export section of a WASM component contains a list of exports that the component provides to other components or to the host environment.
    In order to be executed, a WASM component must be provided with all of its dependencies, which are defined in the import section. The host environment then provides the actual implementations for these imports.
    Typically, these dependencies are WASI imports, which define the low-level, OS-like functionality that the component requires to function. For example, a component that needs to read from a file might import a WASI import for file I/O.
    Developers of WASM components do not typically have to know about or interact with WASI directly, because the standard library for their language of choice will be implemented in terms of WASI. In turn, frameworks and libraries that developers use are implemented in terms of the standard library, hiding details of WASI from developers.
    WASM components bear some similarities to machine-code executables, but they are much richer:
    A machine-code executable interacts directly with the operating system, and has only a single entry point, the main function. WASM components, on the other hand, must be passed capabilities explicitly from the host environment, and they can export many different functions, which can be called by the host environment or by other components.
    Thus, conceptually, WASM components are much closer to libraries, such as shared libraries that can be used by multiple executables, rather than executables themselves.
    Development
    Development of WASM components requires language-specific support, including:
    A compiler that can compile the language to WASM; or, for interpreted languages, an interpreter that can be compiled to WASM.
    A standard library that is implemented in terms of WASI, and that provides the functionality that the language requires to operate, such as I/O.
    Support for importing and exporting functions, so that components developed in the language can interact with the host environment, and with other components.
    You can find detailed information on building WASM components in the following language-specific guides:
    Rust
    C/C++
    Python
    Go
    Javascript
    Typescript
    Zig
    There are some aspects of developing WASM components that are language- independent, and relevant to all developers working with components on Golem.
    Lifecycle
    The lifecycle for developing a WASM component typically involves the following steps:
    Dependencies. Identify the dependencies that the component requires, including dependencies such as WASI that are required by the language's standard library.
    Interface. Define the public interface of the component, which includes both types and functions. In serverless environments like Golem, the interface dictates how external systems may interact with the component.
    Implementation. Implement the component's functionality, including satisfying the public interface of the component, using the language's standard library and any other dependencies that are required.
    Building. Using language-specific tools, compile the implementation of the component to a WASM component; or, for interpreted languages, package the code into a WASM component, typically by bundling the interpreter.
    Both steps (1) and (2) are heavily dependent on WebAssembly Interface Type (WIT), a language-independent interface description language (IDL) that is used to describe both dependencies and interface of components.
    The following section provides a brief introduction to WIT.
    WIT
    Wasm Interface Type (WIT) is a language-independent interface description language (IDL) that is used both to describe the dependencies of a component, and to describe the interface of a component.
    WIT can be compared to protocol buffers (protobuf), but there are a number of distinctions:
    Unlike protobuf, WIT is used to describe the dependencies of components;
    WIT is designed specifically for WASM components;
    WIT operates at a lower-level than protobuf, enabling cross-language interoperability—for example, a Javascript component calling into a C/C++ component.
    It is beyond the scope of this document to provide a full introduction to WIT, but the following list introduces some key concepts:
    Worlds. A world contains both imports and exports, describing both required dependencies, and provided functionality.
    Types. WIT supports a number of primitive types, including integers, floats, and strings, as well as compound types such as records and lists.
    Functions. WIT supports the definition of functions, including their arguments and return types. Functions can be defined as part of an interface, and may be organized into packages.
    Resources. A resource is a special type used for representing values that exist in one component (or the host environment) and accessed elsewhere.
    The following example shows a simple WIT interface that defines a function add that takes two integers and returns an integer:
    package adder;
    interface math {
      add: func(a: s32, b: s32) -> s32;
    }
    An analogous protobuf definition for this interface would be:
    syntax = "proto3";
    package adder;
    service Math {
      rpc Add(AddRequest) returns (AddResponse);
    }
    message AddRequest {
      int32 a = 1;
      int32 b = 2;
    }
    message AddResponse {
      int32 result = 1;
    }
    Further information on WIT can be found in official documentation
    (opens in a new tab)
    , as well as the WIT specification
    (opens in a new tab)
    .
    Language-Agnostic Tooling
    Although the exact toolchain used to build a WASM component will depend on the language being used, there are a number of language-agnostic tools that are useful for working with WASM components.
    In this section, you will learn about these tools.
    wasm-tools
    The Bytecode Alliance provides a set of tools for working with WASM components, called wasm-tools. This command-line interface (CLI) provides a number of related commands for working with WASM components, including:
    validate. Validate a WebAssembly file.
    parse. Translate the WebAssembly text format to binary.
    print. Translate the WebAssembly binary format to text.
    smith. Generate a valid WebAssembly module from an input seed.
    mutate. Mutate an input WASM file into a new valid WASM file.
    shrink. Shrink a WASM file while preserving a predicate.
    dump. Print debugging information about the binary format.
    objdump. Print debugging information about section headers.
    strip. Remove custom sections from a WebAssembly file.
    demangle. Demangle Rust and C++ symbol names in the name section.
    compose. Compose WASM components together (deprecated).
    component new. Create a component from a core WASM binary.
    component wit. Extract a *.wit interface from a component.
    component embed. Embed a component-type custom section in a core WASM binary.
    metadata show. Show name and producer metadata in a component or module.
    metadata add. Add name or producer metadata to a component or module.
    addr2line. Translate WASM offsets to filename/line numbers with DWARF.
    completion. Generate shell completion scripts for wasm-tools.
    json-from-wast. Convert a *.wast file into JSON commands.
    One of the most useful commands is component new, which provides the ability to create a WASM component from a core WASM binary. This is useful for language ecosystems that do not yet have a native way to produce WASM components, but which can produce WASM modules.
    You can download precompiled artifacts for wasm-tools on Github
    (opens in a new tab)
    . To build from source code, first install Rust
    (opens in a new tab)
    , then use Cargo to build wasm-tools:
    $ cargo install --force --locked  wasm-tools@1.223.0
    wit-bindgen
    The wit-bindgen tool, also from the Bytecode Alliance, is a tool for generating language bindings from WIT interfaces, which makes it easier to both consume dependencies, as well as export functionality, from components in a variety of programming languages with immature support for the component model.
    wit-bindgen generates bindings for a number of languages, including:
    C/C++
    Rust
    Java (TeaVM)
    Go (TinyGo)
    C#
    Deployment on Golem
    Once you have developed a WASM component, you can deploy it on Golem. Since Golem is open source, there are an unlimited
    Last updated on March 28, 2025
    Reliability
    Workers
    
  section: Concepts
  char_count: 11508
  approx_token_count: 2877
- id_parent: 8
  title: Workers
  url: https://learn.golem.cloud/concepts/workers
  content: |
    Concepts
    Workers
    Introduction
    Golem is a durable computing platform that makes it simple to build and deploy highly reliable distributed systems.
    In server-based programming, the fundamental unit of work is the server, which accepts incoming connections, and handles requests by generating responses.
    In Golem, which is a serverless computing platform, the fundamental unit of work is the worker. A worker is a running instance of a component, with a unique identity, which allows addressing specific workers.
    Workers are similar to lambdas or functions in other serverless computing platforms, but they are far more powerful and expressive.
    The relationship between a component and a worker is the same as the relationship between an executable and a process: processes are running instances of executables. While the executable contains mostly code, which awaits execution, a process contains both code, as well as dynamic state, which captures work-in-progress.
    Worker Essentials
    The fundamental elements of every worker include:
    Identity. Every worker has a unique identity, which allows addressing specific workers.
    State. Every worker has state, including memory, environment variables, and file system.
    API. Every worker has a public API, defined by its component.
    These core elements are discussed in the sections that follow.
    Ephemeral vs Durable Workers
    Golem supports two types of workers, ephemeral and durable. Ephemeral workers are created on the fly for each invocation, and are not suitable for stateful applications. This makes them cheaper and more performant. Durable workers, on the other hand, preserve their state across invocations and provide much stronger guarantees.
    Whether a worker is ephemeral or durable depends on the configuration of the deployed component. The component type can be changed from ephemeral to durable or the other way around, but this change results in a new component version, and will not affect the already running workers.
    Identity
    Every worker has a globally unique identity, which is formed from the following elements:
    Component ID. Every component deployed on Golem has a globally unique identity (UUID), which is assigned by Golem when a new component is uploaded to Golem.
    Worker Name. The worker name can be chosen by you for each worker. If you do not need to address specific workers, you can also use a UUID for the worker name. The only constraint is that worker names must be unique within the scope of their component. Ephemeral workers have no user-defined names, their name is always a generated UUID provided by the execution environment.
    The unique identity of workers allows them to be addressed individually, which unlocks many powerful patterns for building distributed systems.
    Durable Worker State
    Workers are inherently stateful, in the same way that any running process is stateful. Workers have the following stateful elements:
    Memory. A worker has in-memory state, such as global variables, stack, and so on, which constantly changes over the life of the worker.
    Environment Variables. A worker has environment variables, which it inherits from component settings and any initial settings when the worker is created, and which may change over time.
    File System. A worker has a file system, which currently starts out empty, but which may evolve over the life of the worker.
    Status. The status of the worker, managed by Golem, is one of the following: running, idle, suspended, interrupted, retrying, failed, or exited.
    State also includes something called the instruction pointer, which is not accessible in most programming languages, but which tracks which location in the code the CPU is currently executing.
    API
    Workers are running instances of components. Because components have a public API, which is defined by WIT, workers inherit this API.
    To perform work, such as handling a request, you invoke a worker's public API. This process is referred to as invocation, and you can learn more in the section on invocation.
    Durable Worker Guarantees
    Golem executes workers with strong guarantees. To understand these guarantees, you should read the section on reliability.
    However, in brief, Golem provides the following guarantees:
    Transactional Execution. Workers are executed transactionally. Once a worker is started, it will be executed to completion, even in the presence of faults, restarts, or updates. It's perfectly acceptable to use workers for high-value use cases, such as financial transaction processing; or for implementing APIs that coordinate updates across multiple systems.
    Durable State. All worker state, including in-memory state, is durable, and can be treated as automatically persistent. This means that state survives failures, restarts, and updates without the loss of any information. Workers may treat their memory as a database, and use it to persist state indefinitely and across any number of invocations.
    Reliable Internal Communication. Workers can communicate with each other using their public APIs, in a type-safe way. Worker-to-worker communication is reliable, with exactly-once semantics, and can be used to build sophisticated and stateful distributed systems.
    Resilient External Communication. Workers can freely communicate with external systems, such as databases, message queues, and APIs. External communication is automatically resilient, with exactly-once semantics for systems that support idempotency keys, and at-least-once semantics for systems that do not.
    Indefinite Life. Unless forcibly deleted or failed in a way that is unrecoverable (e.g. corruption of memory in a C program), workers live forever, without loss of state or progress. This allows workers to be used for long-running tasks, such as background processing, or for implementing APIs that require long-lived state.
    Secure Sandboxing. Workers are executed in completely sandboxed environments, with no possibility of workers interacting with each other (except via their public APIs), and no possibility that one worker's failure impacts another worker's health.
    Some of these guarantees are common across all serverless platforms, but others are unique to the durable computing environment that Golem provides.
    Classic Serverless
    Although Golem brings the power of durable computing to serverless, it is still possible to use Golem as a classic serverless platform.
    This enables increased reliability and use of serverless for long-running tasks, financial transactions, and other use cases that are not well-suited to traditional serverless platforms.
    Comparing Functions to Workers
    Worker Function Explanation
    Low-Latency ✅ ✅ Functions in serverless environments are designed to execute quickly, making them suitable for low-latency use cases.
    Scalable ✅ ✅ Functions in serverless environments scale automatically, making them suitable for high-throughput use cases.
    Stateful ✅ ❌ Workers are inherently stateful, which means they maintain state for their lifetime, and across repeated invocations.
    Long-Running ✅ ❌ Workers run indefinitely, without loss of state or progress, making them uniquely suitable for long-running tasks.
    Transactional ✅ ❌ Workers are executed with strong transactional guarantees, transparently surviving faults, restarts, and updates.
    Persistent ✅ ❌ All worker state, including in-memory state, is persistent and survives failures, restarts, and updates without loss.
    Emulating Classic Serverless
    Golem's ephemeral workers are emulating the classic serverless behavior, with the difference that they can have multiple entry points (exported functions). To fully emulate the classic serverless approach, you only need to do two things:
    One-Export Component. While WASM components can have any number of exports, when emulating classic serverless, you should only have one export per component. This export represents the event or request handler that you would typically have in a classic serverless function.
    Define the component as ephemeral. Choosing the ephemeral component type will make all its workers ephemeral, which means invocations does not have to specify a worker name, and for each invocation a new instance of the ephemeral worker will be created.
    Golem still persists some information about each ephemeral worker that was created, which can be used for debugging purposes, but this state gets persisted in the background, not affecting the worker's performance.
    Operations
    Workers support the following operations:
    Creation. Workers benefit from automatic creation, which occurs when a worker is invoked for the first time. Therefore, it is not necessary to create workers explicitly.
    Interruption. Workers can be interrupted at any time, which causes the worker to stop executing. Interrupted workers can be resumed later.
    Deletion. Workers can be deleted, which causes all state of the worker to be permanently deleted. Deleted workers cannot be undeleted or resumed, and if invoked again, they will be recreated from scratch.
    Updating. Workers can be updated to a newer version of a component, which is useful for long-lived workers that can benefit from bug fixes or new features.
    Observation. The persistent operation log of a worker can be queried and searched, which can be useful in debugging and auditing scenarios.
    Details about how to perform these operations can be found in the CLI guide, the REST API reference, and language-specific SDK documentation.
    Worker Update
    When a new version of a component is created (by deploying a new version of the component, changing its type or installing plugins to it), the existing workers continue to run using the version they have been created with. Existing workers have to be explicitly updated to a new version if needed.
    Newly created workers are created using the latest version of the component. This also means that for ephemeral workers each invocation always runs using the latest version of the component.
    There are two ways to update an existing worker to a new version of a component, and the update operation (triggered through the REST API, CLI, Console or host interface) can choose from either of them. These are the following:
    Automatic update. Golem tries to automatically update the worker to the new version, and may fail to do so.
    Manual update. For manual update the component author must provide a pair of save/load functions that are used to migrate the state of the worker from the old version to the new version.
    Automatic update details
    Automatic update can be initiated any time, even while the worker is processing an invocation. The executor interrupts the worker, reloads it using the new component version and then replays the worker's oplog from the beginning of time. If the replay succeeds with the new codebase, the worker continues running from where it was interrupted, but now on the new component version. If the replay fails, the worker gets reverted to the original component version and continues running with that.
    How can the replay fail? Golem performs divergence detection during replaying the oplog. The following situations are considered divergences:
    Invocation result divergence. If the new component produces a different result value for a past invocation than the old one
    Side effect divergence. If the new component would perform different side effects (such as HTTP requests, generating random numbers, accessing the current time, etc) than the ones that have been recorded.
    Because of these strict requirements, automatic update is only useful when the changed code is minor or it affects code paths that haven't run yet or did not exist at all before.
    Manual update details
    For manual update the old component version must implement the golem:api/save-snaphot interface, and the new component version must implement the golem:api/load-snapshot interface. The update operation is enqueued the same way as invocations are enqueued, as it can only be performed when the worker is idle. As soon as all the previously enqueued and running invocations are finished, the executor calls the save snapshot function that returns an array of bytes representing the state of the worker. Then the worker gets restarted using the new component version, and the new component's load snapshot functions is called with the saved state. The load snapshot function may return with a failure in which case the worker's component version gets reverted to the original version and it continues running with that. Otherwise if the snapshot was successfully loaded the worker continues running with the new component version.
    Last updated on March 28, 2025
    Components
    Invocations
    
  section: Concepts
  char_count: 12612
  approx_token_count: 3153
- id_parent: 9
  title: Invocations
  url: https://learn.golem.cloud/concepts/invocations
  content: |
    Concepts
    Invocations
    Introduction
    Golem is a durable computing platform that makes it simple to build and deploy highly reliable distributed systems.
    The fundamental building block of every Golem application is the component, which is instantiated to form workers. The only way to create or interact with workers is through invocations.
    An invocation is the act of invoking an exported function on a specific worker, by supplying the function with its required input parameters. If the invoked function has a return value, the invocation will return the value.
    Perhaps surprisingly for those new to Golem, every invocation occurs on a specific worker, rather than more generally on a component. If an attempt is made to invoke a function on a worker that does not exist yet, it will be created through the act of invocation.
    Invocation is such a fundamental aspect of building useful applications on Golem that in this section, we will discuss the origin of invocations, and provide high-level instructions on how to perform invocations during development, testing, and production scenarios.
    Structure of Invocations
    The structure of invocations on workers derives from the WASM component model, which defines the constructs that make up the public APIs of components.
    The public API of a component is defined using WASM Interface Types (WIT), a text format analogous to protocol buffers (protobuf).
    Through WIT, components may export functions, which can be called from other components (as per the component model), but which Golem also makes available for remote invocation through multiple protocols.
    Understanding the structure of invocations, then, comes down to understanding the structure of component model types, as defined by WIT.
    In the next section, you will learn the basics of this structure. For a more detailed reference, you can see the page on Function names.
    Basic Invocations
    Assume we have created a component designed to provide durable counters, whose public API is defined by the following WIT:
    package demo:counter;
     
    interface counters {
      get-total-counters: func() -> u32;
     
      increment-counter: func(index: s32) -> s32;
     
      get-counter: func(index: s32) -> s32;
    }
    This API defines three standalone functions, named get-total-counters, increment-counter, and get-counter.
    In order to perform an invocation on a worker created from this component, we will need to specify two things:
    The fully qualified name of the function that we are invoking on the worker.
    The parameters to invoke the function with, which must have the correct structure.
    The structure of the name of the function is fully standardized across all supported invocation protocols, and is as follows:
    <package-name>/<interface-name>.{<function-name>}
    So, in the preceding example, if we wish to invoke the get-total-counters function on some worker, we must utilize the following fully qualified name:
    demo:counter/counters.{get-total-counters}
    This name identifies the get-total-counters function, unique from any other function that is exported by the component.
    You will learn how to specify parameters later, when the different supported protocols are introduced. For more information on the structure of function names, see the page on Function names.
    Resource Invocations
    In the WASM component model, resources are similar to classes in object-oriented programming languages. Like classes, they have constructors and methods.
    Because Golem is a durable computing platform, it is natural to use workers to store persistent information. For example, a user profile worker might store information related to a user; while an auction worker might store all information related to an online auction, including bids and bidders.
    Accomplishing this in some programming languages is straightforward. For example, a counter component written in C/C++ could have a global variable to keep track of a count, and then it could export two functions: one to retrieve the current total, and one to adjust the counter, up or down.
    However, some languages, including strongly object-oriented languages like Java, as well as languages like Haskell and Rust, strongly discourage or prevent global state.
    Because resources must be constructed before their methods can be invoked, the state associated with a resource need not be global, which provides a much more natural fit for many programming languages.
    Golem has special support for invoking methods on resources that is designed to greatly simplify these use cases. In particular, Golem supports an easy way to invoke methods on resources that are uniquely identified by their constructor parameters, and automatically constructs resources as necessary.
    ⚠️
    In order to use Golem's special support for invoking methods on resources, each resource in your component must be uniquely identified by constructor parameters alone. If the constructor parameters of your resource are not sufficient to uniquely identify a desired instance of that resource, then you will have to manage the resource on your own, without Golem's special support for invoking methods on the resources.
    Let's take the following example counter component, which defines a resource named counter:
    package demo:counter;
     
    interface counters {
      get-total-counters: func() -> u32;
     
      resource counter {
        constructor(id: string);
     
        increment: func(s32) -> s32;
     
        get: func() -> s32;
      }
    }
    In an object-oriented programming language such as Java, the counter resource would be bound to a class, with a single constructor and two methods.
    Golem allows us to invoke methods on counters that are uniquely identified by their constructor parameters. In this example, the constructor of a new counter takes an id as input, which is intended to be a user-defined string that uniquely identifies the counter.
    In order to invoke methods on a specific counter, we must include the values for the constructor parameter in the fully qualified name of the function being invoked.
    The generic structure of the fully qualified name for such a resource invocation is as follows:
    <package-name>/<interface-name>.{<resource-name>(<resource-params>).<function-name>}
    In the case of the preceding counter, we could specify the fully qualified name of the increment method on a counter with id "total-profile-views" with the following syntax:
    demo:counter/counters.{counter("total-profile-views").increment}
    In English, this fully qualified name indicates we are invoking the method increment on a specific counter, namely, the counter that is constructed with the constructor parameter "total-profile-views".
    If we invoke this method on such a counter, but it does not exist yet, then Golem will automatically create the counter, and associate it with its constructor parameters. The next time a method is invoked on this counter, then Golem will lookup and find the existing counter, and invoke the method on it.
    Using Golem's special support for invoking methods on resources enables you to cleanly and automatically create local state on workers, which provides a pleasant experience for languages that discourage global state.
    We have overlooked one detail of resource invocation: the syntax used for specifying constructor parameters. The syntax that Golem requires is WAVE
    (opens in a new tab)
    , which stands for WebAssembly Value Encoding.
    Golem supports WAVE syntax because it has a 1-to-1 mapping with the data types supported by the WASM component model, ensuring that all resource constructor parameters have a single unambiguous value representation.
    Performing Invocations
    There are four different ways you can perform invocations on workers, each suited to different use cases:
    CLI. The Golem command-line interface (CLI) allows you to invoke any function on any worker, providing a user-friendly way to input required parameters and display return values. The CLI is useful for development, or for interacting with your systems through scripts. For more information, see Invoke Using Golem CLI.
    Generic REST API. The Golem REST API allows you to invoke any function on any worker. The REST API is a low-level interface designed mostly for building tooling, such as the CLI. For more information, see Invoking Through the REST API.
    Custom API. In order to facilitate interacting with Golem applications, Golem makes it easy to build a custom API atop workers. This custom API can be high-level and support arbitrary business requirements. For more information, see API Definitions.
    Workers. Workers themselves are able to invoke functions on other workers, a feature referred to as worker-to-worker communication. For more information, see Worker-to-Worker Communication.
    Last updated on March 28, 2025
    Workers
    Worker Gateway
    
  section: Concepts
  char_count: 8737
  approx_token_count: 2185
- id_parent: 10
  title: Worker gateway
  url: https://learn.golem.cloud/concepts/worker-gateway
  content: |
    Concepts
    Worker Gateway
    Introduction
    Golem is a durable computing platform that makes it simple to build and deploy highly reliable distributed systems.
    Golem is highly scalable, and partitions workers across many worker executor nodes, which are each in charge of running a different subset of workers.
    Although partitioning workers across many nodes provides the benefit of horizontal scalability, it makes it more difficult to know which node is executing a particular worker.
    Even if you know which node is executing a worker, it would not be convenient to interact with the node directly, because it could fail, and you would have to implement logic that detects failure and waits until the worker is recovered on a new node before retrying the invocation.
    Moreover, the native protocol for invoking workers is low-level and inflexible, and most developers will not want to expose the invocation API to the outside world or to front-end applications.
    In order to address these issues, Golem has a Worker Gateway service, which is effectively stateless and scaled independently of worker executor nodes.
    The primary functions of the Worker Gateway are as follows:
    Identify the node that is responsible for executing the worker being invoked, and route the invocation request to the node.
    Transparently handle executor node failures by detecting failure, awaiting recovery, and retrying the invocation.
    Support the execution of custom APIs, which satisfy arbitrary business and technical requirements.
    To learn more about how the Worker Gateway supports custom APIs, you can read the high-level introduction to API Definitions, which links to further references.
    Last updated on March 28, 2025
    Invocations
    Worker to Worker Communication
    
  section: Concepts
  char_count: 1739
  approx_token_count: 435
- id_parent: 11
  title: Worker to worker communication
  url: https://learn.golem.cloud/concepts/worker-to-worker-communication
  content: |
    Concepts
    Worker to Worker Communication
    Introduction
    Golem is a durable computing platform that makes it simple to build and deploy highly reliable distributed systems.
    The WASM component model eliminates the need for microservice architectures, since components written in different languages can interact with each other in-process (through component composition), without having to go through remote protocols like HTTP, gRPC, or JSON RPC.
    Despite this, however, there are times when remote procedure calls (RPC) are useful or necessary when developing applications on Golem:
    You want to parallelize computation that cannot be done on a single worker, either due to lack of memory or lack of compute.
    You want to partition state that is too large to store in a single worker; or, perhaps, you want to partition state that can fit in a single worker, but cannot be read and written fast enough due to contention.
    Both of these are examples require the development of a distributed system, where some combination of state and computation is distributed to improve performance, reduce latency, or improve scalability.
    To build a system that distributes state or compute, it is necessary to coordinate work, which requires RPC of some kind.
    Recognizing the critical nature of internal communication for many distributed systems, Golem provides a feature called worker-to-worker communication. This feature allows you to simply, and in a type-safe way, communicate between workers, with strong guarantees, such as reliable, exactly-once invocation semantics.
    Technical details
    For worker-to-worker communication, Golem generates a type-safe client interface for each remotely callable component. These client interfaces are matching the component's interface, but packaged into a resource that can be only constructed by giving enough information to know which worker to communicate with.
    In case of durable components, this can be either a worker name (using the known name of the component) or a custom worker ID for special use cases. For ephemeral components, there is no need to specify a worker name, as each call will spawn a new ephemeral worker.
    Caller components are importing this generated client interface, so they no longer only use the host interfaces provided by Golem but also this dynamically created one.
    There are two ways to resolve this extra import:
    Using the wasm-rpc binding type in the application manifest. In this case the import will be dynamically linked in the Golem server whenever a worker of the caller component is created. This is the recommended way as it has no additional build-time dependencies.
    Using the static-wasm-rpc binding type in the application manifest. In this case the build tool (golem app build) will generate a Rust implementation of the client interface, compile it to WASM and compose it with the caller component's WASM module. This is useful for studying how the client implementation works, but as it requires the Rust toolchain to be installed, it is not recommended in general.
    Learn More
    Worker to Worker Communication
    The WASM-RPC host interface
    Last updated on March 28, 2025
    Worker Gateway
    API Definitions
    
  section: Concepts
  char_count: 3169
  approx_token_count: 793
- id_parent: 12
  title: Api definitions
  url: https://learn.golem.cloud/concepts/api-definitions
  content: |
    Concepts
    API Definitions
    Introduction
    Golem is a durable computing platform that makes it simple to build and deploy highly reliable distributed systems.
    As a serverless platform, Golem allows you to deploy components of your application, without having to write servers or implement protocols like HTTP, gRPC, or GraphQL.
    Without having to write any additional code, Golem provides you with the ability to trigger the creation of workers from your components based on HTTP API calls.
    Although useful for building tooling or quick prototypes, the generic APIs that Golem gives you to create and interact with your workers are usually not the polished, engineered APIs that you want to expose to other organizations, developers of mobile or web applications, or other backend teams.
    To allow you to stand up a custom API for your components, Golem supports a feature called API Definitions. API definitions give you the flexibility of having a precisely engineered API, but without any of the typical boilerplate.
    This page contains a high-level introduction to API definitions, with links to technical reference material.
    API Definitions
    In Golem, an API Definition is similar to an OpenAPI specification for an API. Like OpenAPI specifications, API Definitions contain the following elements:
    Version. The version defines the version of the API.
    Status. The status defines whether the API is a draft, or whether it is published. Currently, published APIs may not be modified.
    Routes. The routes are a list of individual HTTP endpoints.
    In an API definition, the routes define not just the structure of the overall HTTP, but also how invocation of these APIs triggers the creation and activation of workers.
    The next section introduces routes in more detail.
    Routes
    The elements of a route are as follows:
    Path. The path of the route, such as /users/{user-id}. Paths may contain variables, which may be accessed inside the route binding.
    Method. The method of the route, such as GET, PUT, POST, or DELETE.
    Binding. The binding defines what worker will be created and invoked when the endpoint itself is invoked.
    In the following section, you will learn more about the binding.
    Bindings
    Bindings are the glue that connects your endpoint to an actual worker. Examples of what binding can do include invoking a worker, retrieving files from the worker filesystem and forwarding http requests to the wasi:http/proxy world.
    There are many different binding types that address various usecases, learn more about them here.
    Management
    There are a variety of ways to create and manage API Definition:
    Golem CLI. The command-line interface lets you manage API definition.
    REST API. The Golem REST API lets you manage API definition
    Both the CLI and REST API let you import an existing OpenAPI definition, with a custom per-endpoint extension that contains the binding.
    See more examples of implementing custom APIs here.
    Last updated on March 28, 2025
    Worker to Worker Communication
    Plugins
    
  section: Concepts
  char_count: 2981
  approx_token_count: 746
- id_parent: 13
  title: Plugins
  url: https://learn.golem.cloud/concepts/plugins
  content: |
    Concepts
    Plugins
    Introduction
    Golem Plugins provide ways to extend the functionality of Golem without having to modify the core codebase. Plugins can be installed to both the open-source and the hosted versions of Golem.
    This page introduces the types of plugins Golem supports and explains their lifecycle.
    ⚠️
    Plugin support is experimental and not fully available in Golem 1.1 yet. The next release will include stronger guarantees, UI support and better documentation and examples.
    Types of plugins
    Golem supports the following types of plugins:
    Component transformer plugins can alter an uploaded component when it gets uploaded to Golem
    Oplog processor plugins can observe running workers
    Library plugins and application plugins are special, easier to use versions of component transformer plugins
    Component transformer plugins
    Component transformer plugins are external web services providing a HTTP endpoint that receives a WASM component and returns a transformed WASM component. The most common use case for this type of plugin is to use component composition to achieve one of the following goals:
    Replace one or more of the host interfaces provided by Golem. For example a component transformer plugin may implement the WASI KeyValue store interface for a component by connecting to a third party database, instead of using the one provided by Golem.
    Wrap the host interfaces provided by Golem. In this case the adapter the plugin composes the uploaded component with both imports and exports the same interfaces, and by that wraps Golem's implementation for example to publish metrics or perform logging.
    Extend the provided interface of the component by exporting additional invokeable functions.
    Library plugins
    Library plugins are special component transformer plugins that does not require any external HTTP services running. A library plugin is a WASM component that is going to be composed with the user's uploaded components in a way that every exported interface of the plugin's WASM is plugged into the user component's matching imports.
    Application plugins
    Application plugins are similar to library plugins with the difference that the user's component's exported interface is getting plugged into the plugin's matching imports.
    Oplog processor plugins
    Oplog processor plugins are special golem workers implementing the golem:api@1.1.0/oplog-processor interface. These plugins are instantiated and by Golem, and got periodically invoked with oplog entries - a journal of operations performed by workers where the plugin is installed.
    ⚠️
    Oplog processor plugin support is experimental. The final version will guarantee exactly-once semantics for processing the oplog of the workers, which means that if the plugin is installed and activated for a worker, we guarantee that the plugin will receive all of the oplog entries of that worker (even from before the plugin was acitve), and each entry will be only sent exactly once. This guarantee is not implemented yet.
    Plugin configuration
    Plugins can have configuration in the form of key-value pairs, which are customizable for each plugin installation. Golem sends these configuration values to the plugins when they are invoked.
    Plugin lifecycle
    Plugins are first defined using Golem's Plugin API (using the REST API, CLI or the Console). Each defined plugin is identified by a name and a version. In Golem Cloud plugins are defined per account.
    Defining a plugin does not immediately make that plugin used by Golem. To make use of a plugin, it must be installed to a component. This can be done either when a component is created, or later using the Component API. In Golem Cloud plugins can also be installed to projects, in which case each new component created in the given project will have those plugins installed.
    Installing a plugin to a component creates a new component version, similarly how updating a component's WASM file does. This guarantees that already running workers are not affected by the plugin installation process. To make an existing worker use of an installed plugin, the worker must be updated to the new component version.
    Oplog processor plugins can also be activated and deactivated on a running worker dynamically using the Worker API. This is an advanced feature which allows the user to temporarily pause an effect of a plugin for a given worker.
    Last updated on March 28, 2025
    API Definitions
    Language Guides
    
  section: Concepts
  char_count: 4415
  approx_token_count: 1104
- id_parent: 14
  title: Develop overview
  url: https://learn.golem.cloud/develop-overview
  content: |
    Language Guides
    Develop an application Golem
    Developing an application on golem consists of two major steps:
    Writing one or more Golem components in one of the supported programming languages.
    Defining external HTTP endpoints
    This page summarizes the workflow of developing an application on Golem, with links to more specific guides for each step.
    Creating an application
    The primary tool for developing an application on Golem is the Golem CLI.
    To create a new application, use the golem app new command, passing the name of the application and it's default programming language (note: it is possible to add components using different languages later).
    golem app new my-app rust
    Writing the code
    The application is just a project directory that can contain multiple components. To learn how to add a new component and implement it, check the language specific guides linked below.
    Guidelines per language
    Rust
    C/C++
    Python
    Go
    JavaScript
    Typescript
    Experimentally supported languages
    Zig
    Scala.js
    MoonBit
    Iterations
    During development the whole application can be built using
    golem app build
    and every component can be deployed using
    golem app deploy
    This is going to create a new version of each component. If there are workers created already, those are not going to be updated automatically to these new versions. Check the workers page for more information about updating workers.
    Defining APIs
    Most applications require a public HTTP API (but this is not mandatory - you can always use Golem's invocation API to directly communicate with your Golem application).
    Guidelines
    Check the defining custom APIs page as a starting point for learning how to define custom APIs.
    The recommended way to manage these custom APIs is to create a single API definition YAML in the application's root directory. Future Golem versions will integrate API definitions into the application manifest itself.
    Iterations
    Use the golem api commands to iterate on your APIs.
    Incrementing the version
    Every time you make changes, the API's version must be incremented in the YAML file.
    Uploading
    Upload the new API definition using the golem api upload command:
    golem api definition update api.yaml
    (Use golem api definition new api.yaml the first time)
    Deleting the previous deployment
    Before deploying the new API version, the previous deployment must be deleted using the golem api deployment delete command:
    golem api deployment delete my-definition/0.0.1
    Deploying
    To try out the actual API, you also have to deploy it using the golem api deploy command:
    golem api deployment deploy my-definition/0.0.2
    Breaking the component APIs
    When an API is using a component's exported interface, it is not possible to deploy a new version of that component if it is breaking that used interface (golem app deploy will fail). To resolve this, delete the deployment first as shown above.
    Last updated on March 28, 2025
    Plugins
    Setup
    
  section: Develop overview
  char_count: 2906
  approx_token_count: 727
- id_parent: 15
  title: Setup
  url: https://learn.golem.cloud/rust-language-guide/setup
  content: |
    Rust Language Guide
    Setup
    Setup Rust
    Creating Golem components in Rust requires installing the latest stable compiler, enabling the WASM target and installing the supported version of cargo-component.
    Installing Rust
    Use the official guide
    (opens in a new tab)
    to install the latest stable version of the Rust compiler.
    For MacOS the recommended way is using rustup by running the following installation script:
    $ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Enabling WebAssembly targets
    With rust and rustup installed, the next step is to enable the WebAssembly support by running:
    $ rustup target add wasm32-wasip1
    To verify if this step was successful, run:
    $ rustup target list --installed | grep wasm32-wasip1
    wasm32-wasip1
    Installing cargo-component
    The last step is installing the cargo-component extension for Rust's cargo build tool. This will enable a set of subcommands for cargo which allows compiling Rust projects into WebAssembly components, which are ready to be uploaded to Golem.
    ⚠️
    Golem requires a specific version of cargo-component. Please make sure the correct version is installed with the commands described below.
    Install the version 0.20.0 of cargo-component with cargo itself:
    $ cargo install --force --locked cargo-component@0.20.0
    Verify that the correct version is installed:
    $ cargo component --version
    cargo-component-component 0.20.0 (2e497ee 2025-01-07)
    Please refer to the cargo-component website
    (opens in a new tab)
    for more information.
    Last updated on March 28, 2025
    Language Guides
    Defining Components
    
  section: Rust language guide
  char_count: 1560
  approx_token_count: 390
- id_parent: 16
  title: Defining components
  url: https://learn.golem.cloud/rust-language-guide/defining-components
  content: |
    Rust Language Guide
    Defining Components
    Defining Golem Components in Rust
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the Rust template:
    golem app new my-app rust
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new rust my-component
    Specification-first approach
    Golem and the Rust toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem (or cargo component new --lib) contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    The first time a component is compiled (see the Building Components page for details), a bindings.rs file gets generated in the src directory. This module contains the Rust definitions of all the data types and interfaces defined in the WIT file(s).
    To implement the specification written in WIT, the Rust code must implement some of these generated traits and export them using a macro defined in the generated bindings module.
    Exporting top-level functions
    WIT allows exporting one or more top-level functions in the world section, for example:
    package golem:demo;
     
    world example {
        export hello-world: func() -> string;
    }
    To implement this function in Rust, the following steps must be taken:
    make sure the generated bindings module is imported
    define an empty struct representing our component
    implement the generated Guest trait for this struct
    call the export! macro
    Let's see in code:
    // make sure the generated `bindings` module is imported
    #[allow(warnings)]
    mod bindings;
     
    // define an empty struct representing our component
    struct Component;
     
    // implement the generated `Guest` trait for this struct
    impl bindings::Guest for Component {
        fn hello_world() -> String {
            "Hello, World!".to_string()
        }
    }
     
    // call the `export!` macro
    bindings::export!(Component with_types_in bindings);
    ⚠️
    Note that in WIT, identifiers are using the kebab-case naming convention, while Rust uses the snake_case convention. The generated bindings map between the two automatically.
    Exporting interfaces
    WIT supports defining and exporting whole interfaces, coupling together multiple functions and possibly custom data types.
    Take the following example:
    package golem:demo;
     
    interface api {
      add: func(value: u64);
      get: func() -> u64;
    }
     
    world example {
      export api;
    }
    This is equivalent to having the two exported functions directly exported from the world section, so the implementation is Rust is once again requires to implement the Guest trait from the generated bindings module:
    #[allow(warnings)]
    mod bindings;
     
    struct Component;
     
    impl bindings::exports::golem::demo::api::Guest for Component {
        fn add(value: u64) {
            todo!();
        }
     
        fn get() -> u64 {
            todo!();
        }
    }
     
    bindings::export!(Component with_types_in bindings);
    See the Managing state section below to learn the recommended way of managing state in Golem components, which is required to implement these two functions.
    Exporting resources
    The WIT format supports defining and exporting resources - entities defined by their constructor function and the available methods on them.
    Golem supports exporting these resources as part of the worker's API.
    The following example modifies the previously seen counter example to define it as a resource, getting the counter's name as a constructor parameter:
    package golem:demo;
     
    interface api {
      resource counter {
        constructor(name: string);
        add: func(value: u64);
        get: func() -> u64;
      }
    }
     
    world example {
      export api;
    }
    Resources can have multiple instances within a worker. Their constructor returns a handle which is then used to call the methods on the resource. Learn more about how resources can be implicitly created and invoked through Golem's APIs in the Invocations page.
    To implement the above defined WIT resource in Rust a few new steps must be taken:
    define a struct representing the resource - it can contain data!
    implement the trait generated as the resource's interface for this struct
    specify this type in the Guest trait's implementation
    Let's see in code:
    #[allow(warnings)]
    mod bindings;
     
    use std::cell::RefCell;
     
    // define a struct representing the resource
    struct Counter {
        name: String,
        value: RefCell<u64>,
    }
     
    // implement the trait generated as the resource's interface for this struct
    impl bindings::exports::golem::demo::api::GuestCounter for Counter {
        fn new(name: String) -> Self {
            Self {
                name,
                value: RefCell::new(0),
            }
        }
     
        fn add(&self, value: u64) {
            *self.value.borrow_mut() += value;
        }
     
        fn get(&self) -> u64 {
            *self.value.borrow()
        }
    }
     
    struct Component;
     
    impl bindings::exports::golem::demo::api::Guest for Component {
        type Counter = crate::Counter;
    }
     
    bindings::export!(Component with_types_in bindings);
    Note that the generated trait for the resource is passing non-mutable self references (&self) to the methods, so the resource's internal state must be wrapped in a RefCell to allow mutation.
    Data types defined in WIT
    The WIT specifications contains some primitive and higher level data types and also allows defining custom data types which can be used as function parameters and return values on the exported functions, interfaces and resources.
    The following table shows an example of each WIT data type and its corresponding Rust type:
    WIT type Rust type
    bool bool
    s8, s16, s32, s64 i8, i16, i32, i64
    u8, u16, u32, u64 u8, u16, u32, u64
    f32, f64 f32, f64
    char char
    string String
    list<string> Vec<String>
    option<u64> Option<u64>
    result<s32, string> Result<i32, String>
    result<_, string> Result<(), String>
    result Result<(), ()>
    tuple<u64, string, char> (u64, String, char)
    record user { id: u64, name: string } struct User { id: u64, name: String }
    variant color { red, green, blue, rgb(u32) } enum Color { Red, Green, Blue, Rgb(u32) }
    enum color { red, green, blue } enum Color { Red, Green, Blue }
    flags access { read, write, lst } bitflags! { pub struct Access: u8 { const READ = 1 << 0; const WRITE = 1 << 1; const LST = 1 << 2; }}
    Worker configuration
    It is often required to pass configuration values to workers when they are started.
    In general Golem supports three different ways of doing this:
    Defining a list of string arguments passed to the worker, available as command line arguments
    Defining a list of key-value pairs passed to the worker, available as environment variables.
    Using resource constructors to pass configuration values to the worker.
    Command line arguments
    The command line arguments associated with the Golem worker can be accessed in Rust using the standard env::args() function:
    for arg in std::env::args() {
        println!("{}", arg);
    }
    Command line arguments can only be specified when a worker is explicitly created and they are are empty by default, including in cases when the worker was implicitly created by an invocation.
    Environment variables
    Environment variables can be accessed in Rust using the standard env::var() function:
    let value = std::env::var("KEY").expect("KEY was not specified");
    Environment variables can be specified when a worker is explicitly created, but there are some environment variables that are always set by Golem:
    GOLEM_WORKER_NAME - the name of the worker
    GOLEM_COMPONENT_ID - the ID of the worker's component
    GOLEM_COMPONENT_VERSION - the version of the component used for this worker
    In addition to these, when using Worker to Worker communication, workers created by remote calls inherit the environment variables of the caller.
    This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of workers.
    Resource constructors
    As explained earlier, Golem workers can export resources and these resources can have constructor parameters.
    Although resources can be used in many ways, one pattern for Golem is only create a single instance of the exported resource in each worker, and use it to pass configuration values to the worker. This is supported by Golem's worker invocation syntax directly, allowing to implicitly create workers and the corresponding resource by a single invocation as described on the Invocations page.
    Managing state
    Golem workers are stateful. There are two major techniques to store and manipulate state in a Golem worker implemented in Rust:
    Using a global thread_local! variable with RefCell
    Using resources and RefCell
    Note that wrapping the state in RefCell is necessary in both cases to allow mutation.
    Using a global thread_local! variable with RefCell
    When exporting top-level functions or functions defined in WIT interfaces, the worker state is global. In Rust it is not possible to have mutable global state in safe code so the recommended workaround is to use the thread_local! macro.
    Note that Golem workers are always single threaded - the thread_local! macro is used here is just a convenient way to define global state without requiring use of any additional crates or unsafe code.
    The following example implements the previously defined counter worker using a thread_local! variable:
    #[allow(warnings)]
    mod bindings;
     
    struct State {
        total: u64,
    }
     
    thread_local! {
        static STATE: RefCell<State> = RefCell::new(State {
            total: 0,
        });
    }
     
    struct Component;
     
    impl bindings::exports::golem::demo::api::Guest for Component {
        fn add(value: u64) {
            STATE.with_borrow_mut(|state| state.total += value);
        }
     
        fn get() -> u64 {
            STATE.with_borrow(|state| state.total)
        }
    }
     
    bindings::export!(Component with_types_in bindings);
    Using resources and RefCell
    When exporting a WIT resource, it is possible to have a per-instance RefCell holding the resource's state, as it was shown above in the Exporting resources section.
    Logging
    Anything written to the standard output or standard error streams by a Golem worker is captured and can be observed using the worker connect API or the golem worker connect command.
    The log crate https://crates.io/crates/log
    (opens in a new tab)
    can be used for advanced logging by using the wasi-logger implementation https://crates.io/crates/wasi-logger
    (opens in a new tab)
    .
    This crate requires a one-time initialization step to set up the logger. The easiest way to do this is to expose a dedicated init function from the worker that can be called externally to initialize the worker. If this is not acceptable, the initialization can be done in a OnceCell protected static field, and each exported function must access this field to ensure the logger is initialized.
    The following example demonstrates how to use the wasi-logger crate to log messages:
    Add the wasi-logger and log crates to the Cargo.toml file:
    log = { version = "0.4.22", features = ["kv"] } # the `kv` feature is optional
    wasi-logger = { version = "0.1.2", features = ["kv"] }
    Then expose an initialization function in the worker:
    impl Guest for Component {
        fn init() {
            wasi_logger::Logger::install().expect("failed to install wasi_logger::Logger");
            log::set_max_level(log::LevelFilter::Trace);
        }
        // ...
    }
    After calling init, all calls to log::info!, etc. will be properly captured by Golem and available through the worker connect API.
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Rust language guide
  char_count: 11889
  approx_token_count: 2973
- id_parent: 17
  title: Building components
  url: https://learn.golem.cloud/rust-language-guide/building-components
  content: |
    Rust Language Guide
    Building Components
    Building Golem Components in Rust
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    IDE support
    Any IDE supporting Rust can be used, however for creating the result WASM file, the cargo component build command must be used instead of the usual cargo build command that the IDE might use under the hood.
    When using rust-analyzer, read the following section of the cargo-component documentation about how to configure it properly: https://github.com/bytecodealliance/cargo-component#using-rust-analyzer
    (opens in a new tab)
    Under the hood
    Under the hood the golem tool performs a single call of the cargo component build command:
    $ cargo component build
    Generating bindings for example (src/bindings.rs)
     Compiling example v0.1.0 (/Users/golem/tmp/doc-temp/example)
     Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.33s
     Creating component target/wasm32-wasip1/debug/example.wasm
    The target/wasm32-wasip1/debug/example.wasm file is a WebAssembly component ready to be uploaded to Golem.
    It is recommended to compile a release build of the component before deploying it to Golem as it is more optimized and smaller in size:
    $ cargo component build --release
    Generating bindings for example (src/bindings.rs)
     Compiling example v0.1.0 (/Users/golem/tmp/doc-temp/example)
     Finished `release` profile [optimized] target(s) in 0.33s
     Creating component target/wasm32-wasip1/release/example.wasm
    ⚠️
    Make sure the Creating component ... line is printed. Some previous versions of cargo-component failed silently in some cases, skipping the last part of packaging the built WebAssembly module into a component.
    It is possible to verify that the result .wasm is a valid WebAssembly component by using the wasm-tools CLI tool and running:
    $ wasm-tools print target/wasm32-wasip1/release/example.wasm --skeleton
    The top-level node must be component and not module.
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Rust language guide
  char_count: 2424
  approx_token_count: 606
- id_parent: 18
  title: Next steps
  url: https://learn.golem.cloud/rust-language-guide/next-steps
  content: |
    Rust Language Guide
    Next Steps
    Next steps
    After setting up the Rust development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Making HTTP requests from a Golem component
    Learn how to send HTTP requests from a Golem component written in Rust.
    Control durability guarantees
    Check how the Rust Golem SDK can control various durability settings of Golem.
    Automatic retries
    Learn about Golem's retry mechanism and how it can be customized.
    Transactions
    Use the higher level transactions library to implement the Saga pattern.
    Promises
    Create and use promises to await external events from within a running worker.
    Using WASI interfaces
    See what low-level WASI interfaces are available and how they can be used from Rust.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    HTTP client
    
  section: Rust language guide
  char_count: 1042
  approx_token_count: 261
- id_parent: 19
  title: Http
  url: https://learn.golem.cloud/rust-language-guide/http
  content: |
    Rust Language Guide
    HTTP client
    HTTP requests in Rust
    Golem implements the WASI HTTP
    (opens in a new tab)
    interfaces so any library built on this specification can be used from Golem components to communicate with external services.
    Currently there is only one such Rust library available, a fork of the popular reqwest library provided by the Golem team: https://github.com/golemcloud/reqwest/tree/update-april-2025
    (opens in a new tab)
    Adding as a dependency
    To use it, add the following dependency to your component's Cargo.toml:
    [dependencies]
    reqwest = { git = "https://github.com/golemcloud/reqwest", branch = "update-april-2025", features = ["json"] }
    Optionally add serde and serde_json to take advantage of reqwest's JSON support:
    serde = { version = "1.0.203", features = ["derive"] }
    serde_json = "1.0.117"
    Making a request
    The fork provides the same API as the official reqwest library's blocking API, documented here
    (opens in a new tab)
    .
    In the following example we make a POST request sending a JSON payload and parsing the response as JSON using derived codecs by serde.
    First let's define the request and response body types:
    use serde::{Deserialize, Serialize};
     
    #[derive(Clone, Debug, Serialize, Deserialize)]
    struct ExampleRequest {
        name: String,
        amount: u32,
        comments: Vec<String>,
    }
     
    #[derive(Clone, Debug, Serialize, Deserialize)]
    struct ExampleResponse {
        percentage: f64,
        message: Option<String>,
    }
    Then in the worker's implementation we can use reqwest in the following way (proper error handling omitted for brevity):
    use reqwest::*;
     
    // ...
     
    let client = Client::builder().build().expect("Failed to create client");
     
    let request_body = ExampleRequest {
        name: "Something".to_string(),
        amount: 42,
        comments: vec!["Hello".to_string(), "World".to_string()],
    };
     
    let response: Response = client
        .post(&format!("http://example.com:8080/post-example"))
        .json(&request_body)
        .header("X-Test", "Golem")
        .basic_auth("some", Some("body"))
        .send()
        .expect("Request failed");
     
    let status = response.status();
    let body = response
        .json::<ExampleResponse>()
        .expect("Invalid response");
     
    println!("Received {:?} {:?}", status, body);
    Last updated on April 29, 2025
    Next Steps
    Durability
    
  section: Rust language guide
  char_count: 2271
  approx_token_count: 568
- id_parent: 20
  title: Durability
  url: https://learn.golem.cloud/rust-language-guide/durability
  content: |
    Rust Language Guide
    Durability
    Control durability guarantees from Rust
    Golem provides a set of functions components can call to control details of the durable execution engine. For components implemented in Rust there is a Rust crate published] at https://crates.io/crates/golem-rust
    (opens in a new tab)
    providing a set of idiomatic Rust wrappers for these functions.
    Adding as a dependency
    To use the Golem Rust library, add the following dependency to your component's Cargo.toml:
    golem-rust = { version = "1.3.0" }
    General concepts
    The library allows controlling four main aspects of the durable execution engine: the current persistence level, the idempotence mode, defining atomic regions and changing retry policies (discussed in the next page).
    All these features are regional - they can be changed for a section of the code within a single exported function. To make this easy to use in Rust, the library provides a pair of functions for each feature:
    the functions starting with use_ return a guard, which resets the property when dropped
    the functions starting with with_ take a closure and apply the property only for the duration of the closure
    Persistence level
    The persistence level can be one of the following:
    Level Description
    PersistNothing Turns off persistence for a section. In case the worker is recovered or restarted, all the side-effecting functions will be reexecuted
    PersistRemoteSideEffects Persists all the side-effects that are affecting the outside world. In case of recovery the side-effects won't be reexecuted and the persisted results will be used.
    Smart The default setting; Let Golem decide what to persist to optimize performance
    To change the persistence level for a section of the code, use the one of the use_persistence_level or `with_persistence_level functions:
    with_persistence_level(PersistenceLevel::PersistNothing, || {
        remote_side_effect();
    });
     
    // or
     
    let _guard = use_persistence_level(PersistenceLevel::PersistNothing);
    remote_side_effect();
    Idempotence mode
    Golem assumes that HTTP requests are idempotent by default. This means that in case of a failure, if the system cannot determine whether the request successfully reached the target or not, it will be retried. This behavior can be changed using the use_idempotence_mode and with_idempotence_mode functions:
    with_idempotence_mode(enabled, || {
       remote_side_effect();
    });
     
    // or
     
    let _guard = use_idempotence_mode(enabled);
    remote_side_effect();
    With disabled idempotence mode, in case Golem cannot determine if the request was sent or not, it won't retry it but the worker will fail.
    Atomic regions
    By default side effects are persisted and retried one by one. It is possible to group them together into atomic regions, in which case the execution is retried for some reason (the worker failed or interrupted within the region), all the side effects will be reexecuted.
    The golem-rust library exposes the mark_atomic_operation and atomically functions to do this:
    atomically(|| {
        remote_side_effect_1();
        remote_side_effect_2();
    });
     
    // or
     
    let _guard = mark_atomic_operation();
    remote_side_effect_1();
    remote_side_effect_2();
    Commit oplog
    The oplog_commit function waits until the oplog is committed to its persistent storage. The function takes a single argument, replicas, with the desired number of storage replicas the worker's journal is replicated to. The function will block until the oplog is committed to the specified number of replicas, or, if this number is larger than the available number of replicas, until it is written to all the replicas.
    Last updated on March 28, 2025
    HTTP client
    Retries
    
  section: Rust language guide
  char_count: 3637
  approx_token_count: 910
- id_parent: 21
  title: Retries
  url: https://learn.golem.cloud/rust-language-guide/retries
  content: |
    Rust Language Guide
    Retries
    Control the retry policy from Rust
    Using Golem's retry mechanism
    Golem applies a retry mechanism to all workers. In case of a failure, Golem will automatically recover the worker to the point before the failure and retry the operation. An exponential backoff and an upper limit on the number of retries are applied.
    If the maximum number of retries is reached, the worker will be marked as failed and no further invocations will be possible on it.
    This mechanism is automatic and applied to all kind of failures. To rely on it, just let the Rust code panic.
    Customizing the retry policy
    The retry policy which controls the maximum number of retries and the exponential backoff is a global configuration of the Golem servers, but it can be customized for each worker.
    For Rust we need to use the golem-rust crate to do so. First add it to the dependencies in your Cargo.toml:
    [dependencies]
    golem-rust = { version = "1.3.0" }
    Then use the use_retry_policy or with_retry_policy functions to temporarily change the retry policy, either until the returned guard is dropped (the use_ variant) or for the provided closure (the with_ variant).
    let _guard = use_retry_policy(RetryPolicy {
                max_attempts: 10,
                min_delay: Duration::from_secs(1),
                max_delay: Duration::from_secs(1),
                multiplier: 1.0,
                max_jitter_factory: None
            });
    // ...
     
    // or
     
    with_retry_policy(RetryPolicy {
                max_attempts: 10,
                min_delay: Duration::from_secs(1),
                max_delay: Duration::from_secs(1),
                multiplier: 1.0,
                max_jitter_factory: None
            }, || {
        // ...
    });
    The RetryPolicy type itself is originated from Golem's WIT definition in the following way:
    /// Configures how the executor retries failures
    record retry-policy {
        /// The maximum number of retries before the worker becomes permanently failed
        max-attempts: u32,
        /// The minimum delay between retries (applied to the first retry)
        min-delay: duration,
        /// The maximum delay between retries
        max-delay: duration,
        /// Multiplier applied to the delay on each retry to implement exponential backoff
        multiplier: f64
    }
    Last updated on March 28, 2025
    Durability
    Transactions
    
  section: Rust language guide
  char_count: 2276
  approx_token_count: 569
- id_parent: 22
  title: Transactions
  url: https://learn.golem.cloud/rust-language-guide/transactions
  content: |
    Rust Language Guide
    Transactions
    High level transactions in Rust
    On top of the durability controls and retry controls, the golem-rust crate (https://crates.io/crates/golem-rust
    (opens in a new tab)
    ) also provides a high level library for defining transactions supporting compensation actions in case of getting reverted.
    Although Golem's automatic retry policies and low level atomic regions provide a lot of power automatically, many times a set of external operations such as HTTP requests needs to be executed transactionally; if one of the operations fails, the whole transaction need to be rolled back by executing some compensation actions.
    The golem-rust crate provides support for two different types of transactions:
    fallible transactions are only dealing with domain errors
    infallible transactions must always succeed, and Golem applies its active retry policy to it
    Fallible transactions
    Many times external operations (such as HTTP calls to remote hosts) need to be executed transactionally. If some of the operations failed the transaction need to be rolled back - compensation actions need to undo whatever the already successfully performed operations did.
    A fallible transaction only deals with domain errors. Within the transaction every operation that succeeds gets recorded. If an operation fails, all the recorded operations get compensated in reverse order before the transaction block returns with a failure.
    A fallible transaction can be executed using the fallible_transaction function, by passing a closure that can execute operations on the open transaction (see below).
    Infallible transactions
    An infallible transaction must always succeed - in case of a failure or interruption, it gets retried. If there is a domain error, the compensation actions are executed before the retry.
    An infallible transaction can be executed using the infallible_transaction function, by passing a closure that can execute operations on the open transaction (see below).
    Operations
    Both transaction types require the definition of operations.
    It is defined with the following trait:
    /// Represents an atomic operation of the transaction which has a rollback action.
    ///
    /// Implement this trait and use it within a `transaction` block.
    /// Operations can also be constructed from closures using `operation`.
    pub trait Operation: Clone {
        type In: Clone;
        type Out: Clone;
        type Err: Clone;
     
        /// Executes the operation which may fail with a domain error
        fn execute(&self, input: Self::In) -> Result<Self::Out, Self::Err>;
     
        /// Executes a compensation action for the operation.
        fn compensate(&self, input: Self::In, result: Self::Out) -> Result<(), Self::Err>;
    }
    There are multiple ways to define an operation:
    Implement the trait manually
    Use the operation function to create an operation from a pair of closures
    pub fn operation<In: Clone, Out: Clone, Err: Clone>(
        execute_fn: impl Fn(In) -> Result<Out, Err> + 'static,
        compensate_fn: impl Fn(In, Out) -> Result<(), Err> + 'static,
    ) -> impl Operation<In = In, Out = Out, Err = Err>
    Use the golem_operation macro
    The #[golem_operation(compensation=xyz)] annotation can be applied to a function that takes any number of inputs, and returns a Result. The compensation parameter must point to another function which can have one of the following forms:
    no parameter
    single parameter, getting the result of the successful operation
    multiple parameters where the first one is the result of the successful operation, and the rest of them are the inputs of the operation
    When using this macro, it generates associated functions for the transaction so they can be directly called within the transaction in the following way:
    #[golem_operation(compensation = compensation_step)]
    fn transaction_step(step: u64) -> Result<bool, String> {
        println!("Step {step}");
        Ok(remote_call(step))
    }
     
    fn compensation_step(_: bool, step: u64) -> Result<(), String> {
        println!("Compensating step {step}");
        remote_call_undo(step);
        Ok(())
    }
     
    fallible_transaction(|tx| {
        tx.transaction_step(1)?;
        tx.transaction_step(2)?;
        Ok(11)
    })?
    Last updated on March 28, 2025
    Retries
    Promises
    
  section: Rust language guide
  char_count: 4178
  approx_token_count: 1045
- id_parent: 23
  title: Promises
  url: https://learn.golem.cloud/rust-language-guide/promises
  content: |
    Rust Language Guide
    Promises
    Working with Golem Promises in Rust
    Golem promises provide a way for Golem workers to wait on an external condition. The worker creates the promise and somehow sends its identifier to the external system responsible for completing the promise. Then the worker can await the promise, being suspended until the external system completes the promise using Golem's REST API.
    It is also possible to complete a promise from within a Golem worker using the Golem SDK.
    When a promise is completed, an arbitrary byte array can be attached to it as a payload - this data is returned to the awaiting worker when is continues execution.
    In Rust the easiest way to work with promises is to use the golem-rust library.
    Adding as a dependency
    To use the Golem Rust library, add the following dependency to your component's Cargo.toml:
    golem-rust = { version = "1.3.0" }
    Creating a promise
    To create a promise simply call the create_promise function:
    use golem_rust::bindings::golem::api::host::create_promise;
     
    let promise_id = create_promise();
    The returned value is a PromiseId, defined as the following:
    /// A promise ID is a value that can be passed to an external Golem API to complete that promise
    /// from an arbitrary external source, while Golem workers can await for this completion.
    #[derive(Clone)]
    pub struct PromiseId {
        pub worker_id: WorkerId,
        pub oplog_idx: OplogIndex,
    }
     
    /// An index into the persistent log storing all performed operations of a worker
    pub type OplogIndex = u64;
     
    /// Represents a Golem worker
    #[derive(Clone)]
    pub struct WorkerId {
        pub component_id: ComponentId,
        pub worker_name: String,
    }
     
    /// Represents a Golem component
    #[derive(Clone, Copy)]
    pub struct ComponentId {
        pub uuid: Uuid,
    }
    Note that although this Uuid is a generated type from the WIT specification, the golem-rust crate provides From and Into implementations to convert it to the uuid crate's Uuid type.
    There are also From and Into implementations to convert ComponentId to Uuid, and Display and FromStr implementations for all the ID types.
    Deleting a promise
    If a promise is no longer used, it can be deleted with
    use golem_rust::bindings::golem::api::host::delete_promise;
    delete_promise(&promise_id);
    Awaiting a promise
    To await a promise, use the await_promise function:
    use golem_rust::bindings::golem::api::host::await_promise;
    let payload = await_promise(&promise_id);
    The resulting payload is a Vec<u8> containig the data attached to the promise on completion.
    There is a helper function that immediately deserializes the payload with serde_json:
    use golem_rust::await_promise_json;
    let payload: ExamplePayload = await_promise_json(&promise_id)?;
    Completing a promise from within a worker
    To complete a promise from within a worker, use the complete_promise function:
    use golem_rust::bindings::golem::api::host::complete_promise;
    complete_promise(&promise_id, &payload);
    where &payload has the type &[u8].
    There is a helper function that serializes the payload with serde_json:
    use golem_rust::complete_promise_json;
    complete_promise_json(&promise_id, &ExamplePayload { field: "value" })?;
    Completing a promise from an external source
    To see how to use the promise ID to complete a promise through the external REST API, check the REST API documentation.
    Last updated on March 28, 2025
    Transactions
    Updating Workers
    
  section: Rust language guide
  char_count: 3367
  approx_token_count: 842
- id_parent: 24
  title: Updating
  url: https://learn.golem.cloud/rust-language-guide/updating
  content: |
    Rust Language Guide
    Updating Workers
    Updating workers to newer versions of Rust components
    As described in the general Workers page, each worker runs on a specific version of the component it is based on, but it is possible to update a worker to a different version of the same component.
    Automatic update
    The automatic update mode has no Rust-specific details and works as it is described in the general Workers page.
    Manual snapshot-based update
    Sometimes the change between two component versions is so large that the only solution to migrate worker's state to a new version is to manually implement this state transfer.
    This is done by implementing a save-snapshot function in the old component and a load-snapshot function in the new component. The snapshot is an array of bytes and it is the responsibility of the user to ensure that the snapshot is compatible between the two versions.
    These functions are defined in the golem:api WIT package and must be explicitly exported from the component's world.
    Implementing the save snapshot function
    The save-snapshot function must be explicitly exported from the component's world in it's WIT file:
    package golem:demo;
     
    interface api {
      // ...
    }
     
    world update-test-v3 {
      export golem:api/save-snapshot@1.1.0;
     
      export api;
    }
    This requires manually adding all the WIT dependencies Golem provides to the component's wit/deps subdirectory, and importing some of them in the Cargo.toml file.
    Step 1: copy all the WIT dependencies
    First copy the whole contents of https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    to the component's wit/deps directory.
    Step 2: add the relevant dependencies to the Cargo.toml
    Add the following dependencies to the Cargo.toml file:
    [package.metadata.component.target.dependencies]
    "golem:api" = { path = "wit/deps/golem" }
    "golem:rpc" = { path = "wit/deps/wasm-rpc" }
    "wasi:clocks" = { path = "wit/deps/clocks" }
    "wasi:io" = { path = "wit/deps/io" }
    "wasi:http" = { path = "wit/deps/http" }
    "wasi:random" = { path = "wit/deps/random" }
    "wasi:cli" = { path = "wit/deps/cli" }
    "wasi:filesystem" = { path = "wit/deps/filesystem" }
    "wasi:sockets" = { path = "wit/deps/sockets" }
    Step 3: export the save-snapshot function
    Add the following line to the component's world in its main WIT file:
    export golem:api/save-snapshot@1.1.0;
    Step 4: implement the save-snapshot function in Rust
    An example implementation that just writes out an empty array of bytes:
    struct Component;
     
    use crate::bindings::exports::golem::api::save_snapshot;
     
    impl save_snapshot::Guest for Component {
        fn save() -> Vec<u8> {
            let mut result = Vec::new();
            // ...
            result
        }
    }
    Implementing the load snapshot function
    Implementing the load-snapshot function in the new component requires the same prerequisites as the save-snapshot function.
    Once the WIT dependencies are set up, export the load-snapshot function in the following way:
    export golem:api/load-snapshot@1.1.0;
    and then implement it in Rust:
    use crate::bindings::exports::golem::api::{load_snapshot};
     
    struct Component;
     
    impl load_snapshot::Guest for Component {
        fn load(_bytes: Vec<u8>) -> Result<(), String> {
            Err("Invalid snapshot".to_string())
        }
    }
    Note that the load-snapshot function can fail, indicating that it cannot load a previously saved snapshot. When the upgrade logic detects this, it reverts the worker to the previous version.
    If the snapshot can be loaded, the load-snapshot function must set up the worker's global state and return with Ok(()).
    Last updated on March 28, 2025
    Promises
    WASI
    
  section: Rust language guide
  char_count: 3597
  approx_token_count: 900
- id_parent: 25
  title: Wasi
  url: https://learn.golem.cloud/rust-language-guide/wasi
  content: |
    Rust Language Guide
    WASI
    Using WASI interfaces from Rust
    Golem implements and exports a subset of the WASI
    (opens in a new tab)
    interfaces, as well as its own runtime interfaces.
    The Golem Rust SDK (See https://crates.io/crates/golem-rust
    (opens in a new tab)
    ) provides idiomatic wrappers on a subset of these interfaces, and the Rust standard library is implemented on by another subset, but it is also possible to use the generated bindings directly.
    WIT specifications
    The full set of WIT specifications Golem implements is available in the following public repository:
    https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    The following table lists all packages provided by Golem:
    Package Description
    golem:api Golem's Runtime API
    golem:rpc Provides support for Worker to Worker communication
    wasi:blobstore Interface for storing and retrieving large binary data
    wasi:cli Interface for environment variables and standard I/O
    wasi:clocks Interface for querying the system time
    wasi:filesystem Interface for working with files and directories
    wasi:http Interface for making HTTP requests
    wasi:io Interface for working with futures and streams
    wasi:keyvalue Interface for storing and retrieving key-value pairs - only partially implemented
    wasi:logging Interface for logging messages
    wasi:random Interface for generating random numbers
    wasi:sockets Interface for working with TCP and UDP sockets (currently not supporting durable execution)
    Bindings
    It is possible to manually add these WIT specifications to a Rust component using cargo-component, but it is recommended to use the golem-rust and golem-wasm-rpc libraries instead.
    golem-rust reexports all the bindings generated for the above listed interfaces
    golem-wasm-rpc contains the bindings and the higher level implementation of the golem:rpc interface
    Additional Golem runtime APIs
    This section describes Golem-specific functionalities which are available through the Golem runtime API but does not have an idiomatic Rust wrapper in the golem-rust library yet.
    Generate an idempotency key
    Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.
    It is guaranteed that this idempotency key will always be the same (per occurrence) even if the worker is restarted due to a crash.
    First add the uuid crate to the Cargo.toml file:
    [dependencies]
    uuid = "1.8.0"
    Then generate the idempotency key:
    use golem_rust::generate_idempotency_key;
     
    let key: uuid::Uuid = generate_idempotency_key().into();
    Get worker metadata
    It is possible to query metadata for Golem workers. This metadata is defined by the following WIT record:
    record worker-metadata {
        worker-id: worker-id,
        args: list<string>,
        env: list<tuple<string, string>>,
        status: worker-status,
        component-version: u64,
        retry-count: u64
    }
     
    enum worker-status {
        /// The worker is running an invoked function
        running,
        /// The worker is ready to run an invoked function
        idle,
        /// An invocation is active but waiting for something (sleeping, waiting for a promise)
        suspended,
        /// The last invocation was interrupted but will be resumed
        interrupted,
        /// The last invocation failed and a retry was scheduled
        retrying,
        /// The last invocation failed and the worker can no longer be used
        failed,
        /// The worker exited after a successful invocation and can no longer be invoked
        exited,
    }
    There are two exported functions to query worker metadata:
    get_self_metadata returns the metadata for the current worker
    get_worker_metadata returns the metadata for a specific worker given by it's WorkerId
    Enumerate workers
    Worker enumeration is a feature of Golem available both through the public HTTP API and using the WIT interfaces.
    ⚠️
    Enumerating workers of a component is a slow operation and should not be used as part of the application logic.
    The following example demonstrates how to enumerate workers API:
    use golem_rust::bindings::golem::api::host::*;
     
    let filter = Some(WorkerAnyFilter {
        filters: vec![WorkerAllFilter {
            filters: vec![WorkerPropertyFilter::Status(WorkerStatusFilter {
                comparator: FilterComparator::Equal,
                value: WorkerStatus::Idle,
            })],
        }]
    });
    let mut workers: Vec<WorkerMetadata> = Vec::new();
    let getter = GetWorkers::new(component_id, &filter, true);
    loop {
        match getter.get_next() {
            Some(values) => {
                workers.extend(values);
            }
            None => break,
        }
    }
    The third parameter of the GetWorkers::new constructor enables precise mode. In this mode Golem will calculate the latest metadata for each returned worker, otherwise it uses only the last cached values.
    Update a worker
    To trigger update for a given worker from one component version to another, use the update_worker function:
    use golem_rust::bindings::golem::api::host::{update_worker, UpdateMode};
     
    update_worker(worker_id, target_version, UpdateMode::Automatic);
    To learn more about updating workers, see the updating workers page.
    The WASI Key-Value store interface
    Although Golem workers can store their state completely in their own memory, it is possible to use the wasi:keyvalue interface to store key-value pairs in a Golem managed key value storage.
    This can be useful if state needs to be shared between different workers or if the size of this state is too large to be stored in memory.
    The WASI Blob Store interface
    The wasi:blobstore interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the worker's memory.
    Last updated on March 28, 2025
    Updating Workers
    Setup
    
  section: Rust language guide
  char_count: 5770
  approx_token_count: 1443
- id_parent: 26
  title: Setup
  url: https://learn.golem.cloud/ccpp-language-guide/setup
  content: |
    C/C++ Language Guide
    Setup
    Setup development environment for C/C++
    To write Golem components in C or C++, a couple of common WebAssembly tools need to be installed, as well as the latest version of the WASM SDK.
    Install WebAssembly tooling
    First of all, to install wasm-tools via cargo, you need to install the latest stable version of Rust. The recommended way to do so is using https://rustup.rs
    (opens in a new tab)
    :
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Install wasm-tools
    cargo install --force --locked  wasm-tools@1.223.0
    Confirm the installation:
    wasm-tools --version
    wasm-tools 1.223.0
    Install wit-bindgen
    cargo install --force --locked wit-bindgen-cli@0.37.0
    Confirm the installation:
    wit-bindgen --version
    wit-bindgen-cli 0.37.0
    ⚠️
    Golem requires a specific version of wasm-tools and wit-bindgen. Please make sure the correct version is installed with the commands described above.
    Install WASI SDK 25.0
    Download and extract WASI SDK 25.0
    (opens in a new tab)
    somewhere. In the examples we assume that the WASI_SDK_PATH environment variable is set up pointing to the extracted SDK.
    The SDK contains a version of Clang that can compile to WebAssembly modules, which can be converted into Golem components using the wit-bindgen and wasm-tools command line tools.
    Last updated on March 28, 2025
    WASI
    Defining Components
    
  section: Ccpp language guide
  char_count: 1521
  approx_token_count: 381
- id_parent: 27
  title: Defining components
  url: https://learn.golem.cloud/ccpp-language-guide/defining-components
  content: |
    C/C++ Language Guide
    Defining Components
    Defining Golem Components in C
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the C template:
    golem app new my-app c
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new c my-component
    Specification-first approach
    Golem and the C/C++ toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    The first time a component is compiled (see the Building Components page for details), a couple of files (example.c, example.h and example_component_type.o if the component name was example) get generated in the src directory. This module contains the C definitions of all the data types and interfaces defined in the WIT file(s).
    To implement the specification written in WIT, the C code must implement some of these generated exported functions defined in the generated header file.
    Exporting top-level functions
    WIT allows exporting one or more top-level functions in the world section, for example:
    package golem:demo;
     
    world example {
        export hello-world: func() -> string;
    }
    To implement this function in C, the following steps must be taken:
    include the generated header example.h
    implement the exported function in C
    Let's see in code:
    // include the generated header
    #include "example.h"
     
    // implement the exported function
    void example_hello_world(example_string_t *ret) {
        example_string_set(ret, "Hello, World!");
    }
    ⚠️
    Note that in WIT, identifiers are using the kebab-case naming convention, while C uses the snake_case convention. The generated bindings map between the two automatically.
    Exporting interfaces
    WIT supports defining and exporting whole interfaces, coupling together multiple functions and possibly custom data types.
    Take the following example:
    package golem:demo;
     
    interface api {
      add: func(value: u64);
      get: func() -> u64;
    }
     
    world example {
      export api;
    }
    This is equivalent to having the two exported functions directly exported from the world section, so the implementation in C is once again requires to implement the two exported functions defined in the generated header:
     
    #include "example.h"
     
    // Component state
    static uint64_t total = 0;
     
    // Implementation of the exported functions.
    void exports_golem_demo_api_add(uint64_t value) {
      total += value;
    }
     
    uint64_t exports_golem_demo_api_get() {
      return total;
    }
    See the Managing state section below to learn the recommended way of managing state in Golem components, which is required to implement these two functions.
    Exporting resources
    The WIT format supports defining and exporting resources - entities defined by their constructor function and the available methods on them.
    Golem supports exporting these resources as part of the worker's API.
    The following example modifies the previously seen counter example to define it as a resource, getting the counter's name as a constructor parameter:
    package golem:demo;
     
    interface api {
      resource counter {
        constructor(name: string);
        add: func(value: u64);
        get: func() -> u64;
      }
    }
     
    world example {
      export api;
    }
    Resources can have multiple instances within a worker. Their constructor returns a handle which is then used to call the methods on the resource. Learn more about how resources can be implicitly created and invoked through Golem's APIs in the Invocations page.
    To implement the above defined WIT resource in C a few new steps must be taken:
    define a struct representing the resource - it can contain data!
    implement constructor, methods and destructor for the resource
    Let's see in code:
    // we need malloc, free and memcpy for the example
    #include <stdlib.h>
    #include <string.h>
     
    #include "example.h"
     
    // Define the counter resource's underlying data type
    struct exports_golem_demo_api_counter_t {
        example_string_t name;
        uint64_t value;
    };
     
    // Implement the constructor that allocates memory for the counter struct and stores the counter's name in it
    exports_golem_demo_api_own_counter_t exports_golem_demo_api_constructor_counter(example_string_t *name) {
        exports_golem_demo_api_counter_t* instance = (exports_golem_demo_api_counter_t*)malloc(sizeof(exports_golem_demo_api_counter_t));
        instance->name.len = name->len;
        instance->name.ptr = (uint8_t*)malloc(name->len);
        memcpy(instance->name.ptr, name->ptr, name->len);
        exports_golem_demo_api_own_counter_t own = exports_golem_demo_api_counter_new(instance);
        return own;
    }
     
    // Implement the methods
    void exports_golem_demo_api_method_counter_add(exports_golem_demo_api_borrow_counter_t self, uint64_t value) {
        self->value += value;
    }
     
    uint64_t exports_golem_demo_api_method_counter_get(exports_golem_demo_api_borrow_counter_t self) {
        return self->value;
    }
     
    // Implement the destructor
    void exports_golem_demo_api_counter_destructor(exports_golem_demo_api_counter_t *rep) {
        example_string_free(&rep->name);
    }
      Data types defined in WIT
    The WIT specifications contains some primitive and higher level data types and also allows defining custom data types which can be used as function parameters and return values on the exported functions, interfaces and resources.
    The following table shows an example of each WIT data type and its corresponding C type:
    WIT type C type
    bool bool
    s8, s16, s32, s64 int8_t, int16_t, int32_t, int64_t
    u8, u16, u32, u64 uint8_t, uint16_t, uint32_t, uint64_t
    f32, f64 float, double
    char uint32_t
    string Generated custom string type (example_list_string_t)
    list<string> typedef struct { example_string_t *ptr; size_t len; } example_list_string_t;
    option<u64> typedef struct { bool is_some; uint64_t val; } example_option_u64_t;
    result<s32, string> typedef struct { bool is_err; union { int32_t ok; example_string_t err; } val; } example_result_s32_string_t;
    result<_, string> typedef struct { bool is_err; union { example_string_t err; } val; } example_result_s32_string_t;
    result typedef struct { bool } is_err; } example_result_void_void_t;
    tuple<u64, string, char> typedef struct { uint64_t f0; example_string_t f1; uint32_t f2; } example_tuple3_u64_string_char32_t;
    record user { id: u64, name: string } typedef struct exports_golem_demo_api_user_t { uint64_t id; example_string_t name; } exports_golem_demo_api_user_t;
    variant color { red, green, blue, rgb(u32) } typedef struct exports_golem_demo_api_color_t { uint8_t tag; union { uint32_t rgb; } val; } exports_golem_demo_api_color_t; with #defines for the tags
    enum color { red, green, blue } typedef uint8_t exports_golem_demo_api_color_t; with #defines for the cases
    flags access { read, write, lst } typedef uint8_t exports_golem_demo_api_access_t with #defines for the bit masks
    Worker configuration
    It is often required to pass configuration values to workers when they are started.
    In general Golem supports three different ways of doing this:
    Defining a list of string arguments passed to the worker, available as command line arguments
    Defining a list of key-value pairs passed to the worker, available as environment variables.
    Using resource constructors to pass configuration values to the worker.
    Command line arguments
    The command line arguments associated with the Golem worker can be accessed by calling using the wasi:cli/environment@0.2.0 WIT interface's get-arguments function.
    This requires putting the wit/deps folder from github.com/golemcloud/golem-wit/tree/main/wit/deps in the project's wit/deps directory, and then importing this interface to the component's world:
    world example {
        import wasi:cli/environment@0.2.0;
        // ...
    }
    Then from the C code, it can be called as:
    example_list_string_t args;
    wasi_cli_environment_get_arguments(&args);
    Command line arguments can only be specified when a worker is explicitly created and they are are empty by default, including in cases when the worker was implicitly created by an invocation.
    Environment variables
    Environment variables can be accessed in C using the standard getenv function:
    printf("KEY=%s\n", getenv("KEY"));
    Environment variables can be specified when a worker is explicitly created, but there are some environment variables that are always set by Golem:
    GOLEM_WORKER_NAME - the name of the worker
    GOLEM_COMPONENT_ID - the ID of the worker's component
    GOLEM_COMPONENT_VERSION - the version of the component used for this worker
    In addition to these, when using Worker to Worker communication, workers created by remote calls inherit the environment variables of the caller.
    This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of workers.
    Resource constructors
    As explained earlier, Golem workers can export resources and these resources can have constructor parameters.
    Although resources can be used in many ways, one pattern for Golem is only create a single instance of the exported resource in each worker, and use it to pass configuration values to the worker. This is supported by Golem's worker invocation syntax directly, allowing to implicitly create workers and the corresponding resource by a single invocation as described on the Invocations page.
    Managing state
    Golem workers are stateful. There are two major techniques to store and manipulate state in a Golem worker implemented in C:
    Using global variables
    Using resources and storing state in the resource's struct
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Ccpp language guide
  char_count: 10082
  approx_token_count: 2521
- id_parent: 28
  title: Building components
  url: https://learn.golem.cloud/ccpp-language-guide/building-components
  content: |
    C/C++ Language Guide
    Building Components
    Building Golem Components in C
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Under the hood
    Under the hood, building Golem components written in C involves a few steps.
    In details, building the component requires the following steps:
    Generate the C bindings from the WIT files
    $ wit-bindgen c --autodrop-borrows yes ./wit
    Generating "example.c"
    Generating "example.h"
    Generating "example_component_type.o"
    Compile the C code
    Include all your source files and additionally the generated .c and .o files and use the clang provided as part of the WASM SDK:
    $ $WASI_SDK_PATH/bin/clang --sysroot $WASI_SDK_PATH/share/wasi-sysroot  main.c example.c example_component_type.o -o example.module.wasm
    Package it into a WASM component
    The resulting example.module.wasm is a WebAssembly module, not a component. To be able to use it as a Golem component, use wasm-tools to package the module as a component:
    $ wasm-tools component new example.module.wasm -o example.wasm --adapt adapters/tier1/wasi_snapshot_preview1.wasm
    Note that the adapters/tier1/wasi_snapshot_preview1.wasm file is placed in the project's directory when using golem new to create the new project.
    If needed, it can be manually downloaded from https://github.com/golemcloud/golem-wit/blob/main/adapters/tier1/wasi_snapshot_preview1.wasm
    (opens in a new tab)
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Ccpp language guide
  char_count: 1883
  approx_token_count: 471
- id_parent: 29
  title: Next steps
  url: https://learn.golem.cloud/ccpp-language-guide/next-steps
  content: |
    C/C++ Language Guide
    Next Steps
    Next steps
    After setting up the C development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Making HTTP requests from a Golem component
    Learn how to send HTTP requests from a Golem component written in C/C++.
    Control durability guarantees
    Check how the Golem runtime API can control various durability settings of Golem.
    Automatic retries
    Learn about Golem's retry mechanism and how it can be customized.
    Promises
    Create and use promises to await external events from within a running worker.
    Using WASI interfaces
    See what low-level WASI interfaces are available and how they can be used from C/C++.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    HTTP client
    
  section: Ccpp language guide
  char_count: 959
  approx_token_count: 240
- id_parent: 30
  title: Http
  url: https://learn.golem.cloud/ccpp-language-guide/http
  content: |
    C/C++ Language Guide
    HTTP client
    HTTP requests in C/C++
    Golem implements the WASI HTTP
    (opens in a new tab)
    interfaces so any library built on this specification can be used from Golem components to communicate with external services.
    The only way to make HTTP requests from a C/C++ code currently is to use these WASI HTTP interfaces directly.
    Example
    The following example shows how to make a POST request with JSON request and response bodies using the generated WASI HTTP bindings directly from C.
    This example is available as an example to be used with golem new called c-example-http.
    Defining the request
    Headers
    The first step to do is to create a fields resource, which is going to hold the outgoing request headers. We can initialize this resource by passing a list of string tuples holding the initial set of headers, and there are host functions for manipulating this list if needed.
    First let's make two helper functions for filling c_example_http_string_t (the string type generated for our binding - it's prefix is coming from the example world's name which was c-example-http in this example) from a constant null-terminated string, and have a similar one that does the same for wasi_http_types_field_value_t, the type that holds header values in the WASI HTTP API.
    void set_string(c_example_http_string_t* ret, const char* str) {
        ret->ptr = (uint8_t*)str;
        ret->len = strlen(str);
    }
     
    void set_string_field(wasi_http_types_field_value_t* ret, const char* str) {
        ret->ptr = (uint8_t*)str;
        ret->len = strlen(str);
    }
    With these helper functions define the outgoing headers:
    wasi_http_types_own_fields_t headers;
    wasi_http_types_header_error_t headers_err;
    c_example_http_list_tuple2_field_key_field_value_t entries;
    entries.ptr = malloc(2 * sizeof(c_example_http_tuple2_field_key_field_value_t));
    entries.len = 2;
    set_string(&entries.ptr[0].f0, "Content-Type");
    set_string_field(&entries.ptr[0].f1, "application/json");
    set_string(&entries.ptr[1].f0, "Accept");
    set_string_field(&entries.ptr[1].f1, "application/json");
     
    if (!wasi_http_types_static_fields_from_list(&entries, &headers, &headers_err)) {
        // Failed to create header list
        return;
    }
    Request properties
    Using this headers resource, the next step is to create an outgoing request and set properties such as the URL and method. The request properties are managed by an outgoing-request resource, which can be created by passing the headers to its constructor:
    wasi_http_types_own_outgoing_request_t request = wasi_http_types_constructor_outgoing_request(headers);
    Use the this resource's methods to set the method, the path, the scheme and the authority of the request:
    wasi_http_types_method_t method;
    method.tag = WASI_HTTP_TYPES_METHOD_POST;
    if (!wasi_http_types_method_outgoing_request_set_method(
        wasi_http_types_borrow_outgoing_request(request),
        &method
    )) {
        // Failed to set method
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
     
    c_example_http_string_t path;
    set_string(&path, "/post");
    if (!wasi_http_types_method_outgoing_request_set_path_with_query(
        wasi_http_types_borrow_outgoing_request(request),
        &path
    )) {
        // Failed to set path
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
     
    wasi_http_types_scheme_t scheme;
    scheme.tag = WASI_HTTP_TYPES_SCHEME_HTTPS;
    if (!wasi_http_types_method_outgoing_request_set_scheme(
        wasi_http_types_borrow_outgoing_request(request),
        &scheme
    )) {
        // Failed to set scheme
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
     
    c_example_http_string_t authority;
    set_string(&authority, "httpbin.org");
    if (!wasi_http_types_method_outgoing_request_set_authority(
        wasi_http_types_borrow_outgoing_request(request),
        &authority
    )) {
        // Failed to set authority
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
    Outgoing request body
    The last step before sending the request is to write the outgoing request body. For that we open the request's body and then acquire an output-stream for it, use it for writing the body, and finally mark the body as finished.
    wasi_http_types_own_outgoing_body_t out_body;
    if (!wasi_http_types_method_outgoing_request_body(wasi_http_types_borrow_outgoing_request(request), &out_body)) {
        // Failed to get outgoing body
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
     
    wasi_http_types_own_output_stream_t out_body_stream;
    if (!wasi_http_types_method_outgoing_body_write(wasi_http_types_borrow_outgoing_body(out_body), &out_body_stream)) {
        // Failed to get outgoing body stream
        wasi_http_types_outgoing_body_drop_own(out_body);
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
    In this example let's write a JSON object containing a single field count which holds a dynamic value coming from a global variable called total:
    wasi_io_streams_stream_error_t stream_err;
     
    c_example_http_list_u8_t body_data;
    body_data.ptr = malloc(256);
    sprintf((char*)body_data.ptr, "{ \"count\": %llu }", total);
    body_data.len = strlen((char*)body_data.ptr);
    Write this data to the output stream:
    if (!wasi_io_streams_method_output_stream_blocking_write_and_flush(
        wasi_io_streams_borrow_output_stream(out_body_stream), &body_data, &stream_err)) {
        // Failed to write body
        wasi_io_streams_output_stream_drop_own(out_body_stream);
        wasi_http_types_outgoing_body_drop_own(out_body);
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
     
    wasi_io_streams_output_stream_drop_own(out_body_stream);
    And mark the body as finished:
    wasi_http_types_error_code_t err;
    if (!wasi_http_types_static_outgoing_body_finish(out_body, NULL, &err)) {
        // Failed to finish body
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
    Sending the request
    Finally the request is ready to be sent:
    Setting request options
    Before sending the request, optionally some request options can be set which control various timeouts:
    wasi_http_types_own_request_options_t request_options = wasi_http_types_constructor_request_options();
    wasi_http_types_duration_t timeout = 5000000000; // 5 seconds (in ns)
     
    if (!wasi_http_types_method_request_options_set_connect_timeout(
        wasi_http_types_borrow_request_options(request_options),
        &timeout
    )) {
        // Failed to set connect timeout
        wasi_http_types_request_options_drop_own(request_options);
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
     
    if (!wasi_http_types_method_request_options_set_first_byte_timeout(
        wasi_http_types_borrow_request_options(request_options),
        &timeout
    )) {
        // Failed to set first byte timeout
        wasi_http_types_request_options_drop_own(request_options);
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
     
    if (!wasi_http_types_method_request_options_set_between_bytes_timeout(
        wasi_http_types_borrow_request_options(request_options),
        &timeout
    )) {
        // Failed to set between-bytes timeout
        wasi_http_types_request_options_drop_own(request_options);
        wasi_http_types_outgoing_request_drop_own(request);
        return;
    }
    Sending the request
    Finally everything is prepared to send the request:
    wasi_http_outgoing_handler_own_future_incoming_response_t future_response;
    wasi_http_outgoing_handler_error_code_t err_code;
    if (!wasi_http_outgoing_handler_handle(request, &request_options, &future_response, &err_code)) {
        // Failed to send request
        return;
    }
    Reading the response
    Awaiting the response
    The return value of wasi_http_outgoing_handler_handle is a future which needs to be awaited. To do so, we need to implement the following logic:
    Check if the future is ready by calling get on it, and use the result if it is available
    If the future is not ready, call poll to await it
    Repeat until it is completed
    The following while loop demonstrates this logic:
    bool got_response = false;
    wasi_http_types_own_incoming_response_t response;
     
    while (!got_response) {
        wasi_http_types_result_result_own_incoming_response_error_code_void_t res;
        if (wasi_http_types_method_future_incoming_response_get(wasi_http_types_borrow_future_incoming_response(future_response), &res)) {
            if (!res.is_err && !res.val.ok.is_err) {
                // Got a response
                response = res.val.ok.val.ok;
                got_response = true;
            } else if (!res.is_err && res.val.ok.is_err) {
                // Returned with an error code (res.val.ok.val.err.tag)
                wasi_http_types_future_incoming_response_drop_own(future_response);
                return;
            } else {
                // Returned with an error
                wasi_http_types_future_incoming_response_drop_own(future_response);
                return;
            }
        } else {
            // No result yet, polling
     
            wasi_http_types_own_pollable_t pollable = wasi_http_types_method_future_incoming_response_subscribe(
                wasi_http_types_borrow_future_incoming_response(future_response)
            );
            wasi_io_poll_list_borrow_pollable_t pollable_list;
            pollable_list.len = 1;
            pollable_list.ptr = malloc(sizeof(wasi_io_poll_borrow_pollable_t));
            pollable_list.ptr[0] = wasi_io_poll_borrow_pollable(pollable);
     
            c_example_http_list_u32_t poll_result;
            wasi_io_poll_poll(&pollable_list, &poll_result);
            wasi_io_poll_pollable_drop_own(pollable);
        }
    }
    Note that it is possible to poll multiple futures simultaneously but here we are not taking advantage of that.
    Once this loop exits, response holds the incoming response.
    Reading the response properties
    The response immediately has headers and status code available, for example the following code reads the status code:
    wasi_http_types_status_code_t status = wasi_http_types_method_incoming_response_status(
        wasi_http_types_borrow_incoming_response(response)
    );
    Reading the response body
    The response body is a stream and needs to be read similarly to how the request body was written.
    First, open the incoming body stream:
    wasi_http_types_own_incoming_body_t incoming_body;
    if (!wasi_http_types_method_incoming_response_consume(wasi_http_types_borrow_incoming_response(response), &incoming_body)) {
        // Failed to consume response
        wasi_http_types_incoming_response_drop_own(response);
        return;
    }
     
    wasi_http_types_own_input_stream_t incoming_body_stream;
    if (!wasi_http_types_method_incoming_body_stream(wasi_http_types_borrow_incoming_body(incoming_body), &incoming_body_stream)) {
        // Failed to get body stream
        wasi_http_types_incoming_body_drop_own(incoming_body);
        wasi_http_types_incoming_response_drop_own(response);
        return;
    }
    Then use the input-stream API to read chunks from this stream until it's fully consumed:
    bool eof = false;
    uint8_t *full_body = malloc(0);
    uint64_t len = 0;
     
    while (!eof) {
        c_example_http_list_u8_t chunk;
        wasi_io_streams_stream_error_t stream_err;
        if (wasi_io_streams_method_input_stream_blocking_read(wasi_io_streams_borrow_input_stream(incoming_body_stream), 1024, &chunk, &stream_err)) {
            len += chunk.len;
            full_body = realloc(full_body, len);
            memcpy(full_body + len - chunk.len, chunk.ptr, chunk.len);
        } else {
            if (stream_err.tag == WASI_IO_STREAMS_STREAM_ERROR_CLOSED) {
                eof = true;
            } else {
                set_string(ret, "Failed to read from body stream");
                wasi_io_streams_input_stream_drop_own(incoming_body_stream);
                wasi_http_types_incoming_body_drop_own(incoming_body);
                wasi_http_types_incoming_response_drop_own(response);
                return;
            }
        }
    }
     
    wasi_io_streams_input_stream_drop_own(incoming_body_stream);
    wasi_http_types_incoming_body_drop_own(incoming_body);
    wasi_http_types_incoming_response_drop_own(response);
    After this loop quits, full_body contains the full response body which has len bytes.
    Last updated on March 28, 2025
    Next Steps
    Durability
    
  section: Ccpp language guide
  char_count: 11914
  approx_token_count: 2979
- id_parent: 31
  title: Durability
  url: https://learn.golem.cloud/ccpp-language-guide/durability
  content: |
    C/C++ Language Guide
    Durability
    Control durability guarantees from C/C++
    Golem provides a set of functions components can call to control details of the durable execution engine.
    Adding as a dependency
    To use Golem's runtime API, add all the WIT files from https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    in the project's wit/deps directory, and then importing this interface to the component's world:
    world example {
        import golem:api/host@1.1.0;
        // ...
    }
    The golem new examples for C automatically create the wit/deps directory for you, except the c-actor-minimal one.
    General concepts
    The library allows controlling four main aspects of the durable execution engine: the current persistence level, the idempotence mode, defining atomic regions and changing retry policies (discussed in the next page).
    All these features are regional - they can be changed for a section of the code within a single exported function.
    As in C/C++ we are directly invoking the runtime API's functions, these regions must be enforced by the user manually.
    Persistence level
    The persistence level can be one of the following:
    Level Description
    GOLEM_API_HOST_PERSISTENCE_LEVEL_PERSIST_NOTHING Turns off persistence for a section. In case the worker is recovered or restarted, all the side-effecting functions will be reexecuted
    GOLEM_API_HOST_PERSISTENCE_LEVEL_PERSIST_REMOTE_SIDE_EFFECTS Persists all the side-effects that are affecting the outside world. In case of recovery the side-effects won't be reexecuted and the persisted results will be used.
    GOLEM_API_HOST_PERSISTENCE_LEVEL_SMART The default setting; Let Golem decide what to persist to optimize performance
    To change the persistence level for a section of the code, use the golem_api_host_get_oplog_persistence_level function to get the current one, and the golem_api_host_set_oplog_persistence_level function to set a new value:
    golem_api_host_persistence_level_t previous;
    golem_api_host_get_oplog_persistence_level(&previous);
     
    golem_api_host_persistence_level_t current;
    current.tag = GOLEM_API_HOST_PERSISTENCE_LEVEL_PERSIST_NOTHING;
    golem_api_host_set_oplog_persistence_level(&current);
    // ...
    golem_api_host_set_oplog_persistence_level(&previous);
    Idempotence mode
    Golem assumes that HTTP requests are idempotent by default. This means that in case of a failure, if the system cannot determine whether the request successfully reached the target or not, it will be retried. This behavior can be changed using the golem_api_host_set_idempotence_mode function:
    bool idempotence_mode = golem_api_host_get_idempotence_mode();
    golem_api_host_set_idempotence_mode(false);
    // ...
    golem_api_host_set_idempotence_mode(idempotence_mode);
    With disabled idempotence mode, in case Golem cannot determine if the request was sent or not, it won't retry it but the worker will fail.
    Atomic regions
    By default side effects are persisted and retried one by one. It is possible to group them together into atomic regions, in which case the execution is retried for some reason (the worker failed or interrupted within the region), all the side effects will be reexecuted.
    To define an atomic region, use the golem_api_host_mark_begin_operation and golem_api_host_mark_end_operation functions:
    golem_api_host_oplog_index_t begin = golem_api_host_mark_begin_operation();
    // ...
    golem_api_host_mark_end_operation(begin);
    Commit oplog
    The golem_api_host_oplog_commit function waits until the oplog is committed to its persistent storage. The function takes a single argument, replicas, with the desired number of storage replicas the worker's journal is replicated to. The function will block until the oplog is committed to the specified number of replicas, or, if this number is larger than the available number of replicas, until it is written to all the replicas.
    Last updated on March 28, 2025
    HTTP client
    Retries
    
  section: Ccpp language guide
  char_count: 3888
  approx_token_count: 972
- id_parent: 32
  title: Retries
  url: https://learn.golem.cloud/ccpp-language-guide/retries
  content: |
    C/C++ Language Guide
    Retries
    Control the retry policy from C/C++
    Using Golem's retry mechanism
    Golem applies a retry mechanism to all workers. In case of a failure, Golem will automatically recover the worker to the point before the failure and retry the operation. An exponential backoff and an upper limit on the number of retries are applied.
    If the maximum number of retries is reached, the worker will be marked as failed and no further invocations will be possible on it.
    This mechanism is automatic and applied to all kind of failures. To rely on it, just let the C code fail (for example by calling abort()).
    Customizing the retry policy
    The retry policy which controls the maximum number of retries and the exponential backoff is a global configuration of the Golem servers, but it can be customized for each worker.
    Once the golem:api/host@1.1.0 interface is imported in the WIT file (see the previous page for more information), the retry policy can be controlled with the golem_api_host_get_retry_policy and golem_api_host_set_retry_policy functions.
    golem_api_host_retry_policy_t previous;
    golem_api_host_get_retry_policy(&previous);
     
    golem_api_host_retry_policy_t current;
    current.max_attempts = 10;
    current.min_delay = 1000000000; // 1s
    current.max_delay = 1000000000; // 1s
    current.multiplier = 1;
    current.max_jitter_factor.is_some = false;
    golem_api_host_get_retry_policy(&current);
     
    // ...
     
    golem_api_host_get_retry_policy(&previous);
    The golem_api_host_retry_policy_t type itself is originated from Golem's WIT definition in the following way:
    /// Configures how the executor retries failures
    record retry-policy {
        /// The maximum number of retries before the worker becomes permanently failed
        max-attempts: u32,
        /// The minimum delay between retries (applied to the first retry)
        min-delay: duration,
        /// The maximum delay between retries
        max-delay: duration,
        /// Multiplier applied to the delay on each retry to implement exponential backoff
        multiplier: f64,
        /// The maximum amount of jitter to add to the delay
        max-jitter-factor: option<f64>
    }
    Last updated on March 28, 2025
    Durability
    Promises
    
  section: Ccpp language guide
  char_count: 2158
  approx_token_count: 540
- id_parent: 33
  title: Promises
  url: https://learn.golem.cloud/ccpp-language-guide/promises
  content: |
    C/C++ Language Guide
    Promises
    Working with Golem Promises in C/C++
    Golem promises provide a way for Golem workers to wait on an external condition. The worker creates the promise and somehow sends its identifier to the external system responsible for completing the promise. Then the worker can await the promise, being suspended until the external system completes the promise using Golem's REST API.
    It is also possible to complete a promise from within a Golem worker using the Golem SDK.
    When a promise is completed, an arbitrary byte array can be attached to it as a payload - this data is returned to the awaiting worker when is continues execution.
    In C/C++ the promise API can be used by directly importing and using the Golem runtime API.
    Adding as a dependency
    To use Golem's runtime API, add all the WIT files from https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    in the project's wit/deps directory, and then importing this interface to the component's world:
    world example {
        import golem:api/host@1.1.0;
        // ...
    }
    The golem new examples for C automatically create the wit/deps directory for you, except the c-actor-minimal one.
    Creating a promise
    To create a promise simply call the golem_api_host_create_promise function:
    golem_api_host_promise_id_t promise_id;
    golem_api_host_create_promise(&promise_id);
    The returned value, golem_api_host_promise_id_t, is defined as the following:
    // UUID
    typedef struct golem_api_host_uuid_t {
      uint64_t   high_bits;
      uint64_t   low_bits;
    } golem_api_host_uuid_t;
     
    // Represents a Golem component
    typedef struct golem_api_host_component_id_t {
      golem_api_host_uuid_t   uuid;
    } golem_api_host_component_id_t;
     
    // Represents a Golem worker
    typedef struct golem_api_host_worker_id_t {
      golem_api_host_component_id_t   component_id;
      example_string_t   worker_name;
    } golem_api_host_worker_id_t;
     
    // A promise ID is a value that can be passed to an external Golem API to complete that promise
    // from an arbitrary external source, while Golem workers can await for this completion.
    typedef struct golem_api_host_promise_id_t {
      golem_api_host_worker_id_t   worker_id;
      golem_api_host_oplog_index_t   oplog_idx;
    } golem_api_host_promise_id_t;
    Deleting a promise
    If a promise is no longer used, it has to be deleted with
    golem_api_host_promise_id_t promise_id;
    // .. set up promise_id ..
    golem_api_host_delete_promise(&promise_id);
    ⚠️
    The golem_api_host_promise_id_t value just a promise identifier. Dropping it from the stack or deleting from the heap does not delete the underlying promise in the Golem runtime.
    Awaiting a promise
    To await a promise, use the golem_api_host_await_promise function:
    golem_api_host_promise_id_t promise_id;
    // .. set up promise_id ..
    example_list_u8_t payload; // will be filled by the call
    golem_api_host_await_promise(&promise_id, &payload);
    The resulting payload is a struct containing a len length and a pointer to len number of bytes, containig the data attached to the promise on completion.
    Completing a promise from within a worker
    To complete a promise from within a worker, use the golem_api_host_complete_promise function:
    golem_api_host_promise_id_t promise_id;
    example_list_u8_t payload;
    // .. set up promise_id and payload ..
    golem_api_host_complete_promise(&promise_id, &payload);
    Completing a promise from an external source
    To see how to use the promise ID to complete a promise through the external REST API, check the REST API documentation.
    Last updated on March 28, 2025
    Retries
    Updating Workers
    
  section: Ccpp language guide
  char_count: 3542
  approx_token_count: 886
- id_parent: 34
  title: Updating
  url: https://learn.golem.cloud/ccpp-language-guide/updating
  content: |
    C/C++ Language Guide
    Updating Workers
    Updating workers to newer versions of C/C++ components
    As described in the general Workers page, each worker runs on a specific version of the component it is based on, but it is possible to update a worker to a different version of the same component.
    Automatic update
    The automatic update mode has no C/C++-specific details and works as it is described in the general Workers page.
    Manual snapshot-based update
    Sometimes the change between two component versions is so large that the only solution to migrate worker's state to a new version is to manually implement this state transfer.
    This is done by implementing a save-snapshot function in the old component and a load-snapshot function in the new component. The snapshot is an array of bytes and it is the responsibility of the user to ensure that the snapshot is compatible between the two versions.
    These functions are defined in the golem:api WIT package and must be explicitly exported from the component's world.
    Implementing the save snapshot function
    The save-snapshot function must be explicitly exported from the component's world in it's WIT file:
    package golem:demo;
     
    interface api {
      // ...
    }
     
    world update-test-v3 {
      export golem:api/save-snapshot@1.1.0;
     
      export api;
    }
    This requires manually adding all the WIT dependencies Golem provides to the component's wit/deps subdirectory, and importing some of them in the Cargo.toml file.
    Step 1: copy all the WIT dependencies
    First copy the whole contents of https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    to the component's wit/deps directory.
    The golem new examples for C automatically create the wit/deps directory for you, except the c-actor-minimal one.
    Step 2: export the save-snapshot function
    Add the following line to the component's world in its main WIT file:
    export golem:api/save-snapshot@1.1.0;
    Step 4: implement the save-snapshot function in C
    An example implementation that just writes out an empty array of bytes:
    void exports_golem_api_save_snapshot_save(example_list_u8_t *ret) {
        ret->len = 0;
        ret->ptr = (uint8_t*)malloc(0);
    }
    Implementing the load snapshot function
    Implementing the load-snapshot function in the new component requires the same prerequisites as the save-snapshot function.
    Once the WIT dependencies are set up, export the load-snapshot function in the following way:
    export golem:api/load-snapshot@1.1.0;
    and then implement it in C:
    bool exports_golem_api_load_snapshot_load(example_list_u8_t *bytes, example_string_t *err) {
        example_string_set(err, "Failed to load snapshot");
        return false;
    }
      Note that the load-snapshot function can fail, indicating that it cannot load a previously saved snapshot. When the upgrade logic detects this, it reverts the worker to the previous version.
    If the snapshot can be loaded, the load-snapshot function must set up the worker's global state based on bytes, and return with true.
    Last updated on March 28, 2025
    Promises
    WASI
    
  section: Ccpp language guide
  char_count: 3012
  approx_token_count: 753
- id_parent: 35
  title: Wasi
  url: https://learn.golem.cloud/ccpp-language-guide/wasi
  content: |
    C/C++ Language Guide
    WASI
    Using WASI interfaces from C/C++
    Golem implements and exports a subset of the WASI
    (opens in a new tab)
    interfaces, as well as its own runtime interfaces.
    The previous sections already introduced how to use a subset of these interfaces to control durability settings, make HTTP requests, and control retries or use promises.
    WIT specifications
    The full set of WIT specifications Golem implements is available in the following public repository:
    https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    The following table lists all packages provided by Golem:
    Package Description
    golem:api Golem's Runtime API
    golem:rpc Provides support for Worker to Worker communication
    wasi:blobstore Interface for storing and retrieving large binary data
    wasi:cli Interface for environment variables and standard I/O
    wasi:clocks Interface for querying the system time
    wasi:filesystem Interface for working with files and directories
    wasi:http Interface for making HTTP requests
    wasi:io Interface for working with futures and streams
    wasi:keyvalue Interface for storing and retrieving key-value pairs - only partially implemented
    wasi:logging Interface for logging messages
    wasi:random Interface for generating random numbers
    wasi:sockets Interface for working with TCP and UDP sockets (currently not supporting durable execution)
    Additional Golem runtime APIs
    This section describes some additional Golem-specific functionalities which are available through the Golem runtime API.
    Generate an idempotency key
    Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.
    It is guaranteed that this idempotency key will always be the same (per occurrence) even if the worker is restarted due to a crash.
    To generate the idempotency key:
    golem_api_host_uuid_t key;
    golem_api_host_generate_idempotency_key(&key);
    Get worker metadata
    It is possible to query metadata for Golem workers. This metadata is defined by the following WIT record:
    record worker-metadata {
        worker-id: worker-id,
        args: list<string>,
        env: list<tuple<string, string>>,
        status: worker-status,
        component-version: u64,
        retry-count: u64
    }
     
    enum worker-status {
        /// The worker is running an invoked function
        running,
        /// The worker is ready to run an invoked function
        idle,
        /// An invocation is active but waiting for something (sleeping, waiting for a promise)
        suspended,
        /// The last invocation was interrupted but will be resumed
        interrupted,
        /// The last invocation failed and a retry was scheduled
        retrying,
        /// The last invocation failed and the worker can no longer be used
        failed,
        /// The worker exited after a successful invocation and can no longer be invoked
        exited,
    }
    There are two exported functions to query worker metadata:
    get_self_metadata returns the metadata for the current worker
    get_worker_metadata returns the metadata for a specific worker given by it's golem_api_host_worker_id_t
    Enumerate workers
    Worker enumeration is a feature of Golem available both through the public HTTP API and using the WIT interfaces.
    ⚠️
    Enumerating workers of a component is a slow operation and should not be used as part of the application logic.
    Update a worker
    To trigger update for a given worker from one component version to another, use the golem_api_host_update_worker function:
    golem_api_host_worker_id_t worker_id;
    // .. set up worker_id ..
    golem_api_host_update_worker(&worker_id, target_version, GOLEM_API_HOST_UPDATE_MODE_AUTOMATIC);
    To learn more about updating workers, see the updating workers page.
    The WASI Key-Value store interface
    Although Golem workers can store their state completely in their own memory, it is possible to use the wasi:keyvalue interface to store key-value pairs in a Golem managed key value storage.
    This can be useful if state needs to be shared between different workers or if the size of this state is too large to be stored in memory.
    The WASI Blob Store interface
    The wasi:blobstore interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the worker's memory.
    Last updated on March 28, 2025
    Updating Workers
    Setup
    
  section: Ccpp language guide
  char_count: 4360
  approx_token_count: 1090
- id_parent: 36
  title: Setup
  url: https://learn.golem.cloud/python-language-guide/setup
  content: |
    Python Language Guide
    Setup
    Setup development environment for Python
    Python programs can be compiled into WASM components using the tool componentize-py. For Golem you should use our forked version of this tool, as it pins all its dependencies to the one required by Golem Cloud.
    First install Python 3 to your system and once you have access to the pip package manager, install componentize-py using:
    $ pip install componentize-py==0.16.0
     
    $ componentize-py --version
    componentize-py 0.16.0
    Install WebAssembly tooling for Worker to Worker communication
    Using Worker to Worker communication requires Rust and WASM tooling, because golem RPC client stubs are generated and implemented as Rust components.
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Last updated on March 28, 2025
    WASI
    Defining Components
    
  section: Python language guide
  char_count: 993
  approx_token_count: 249
- id_parent: 37
  title: Defining components
  url: https://learn.golem.cloud/python-language-guide/defining-components
  content: |
    Python Language Guide
    Defining Components
    Defining Golem Components in Python
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the Python template:
    golem app new my-app python
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new python my-component
    Limitations
    ⚠️
    Currently all imports must happen initialization-time, so every module used must be listed in the beginning of the main module.
    This limitation is being tracked as issue#23
    (opens in a new tab)
    .
    Specification-first approach
    Golem and the componentize-py toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    To implement the specification written in WIT, the Python code must implement some of these abstract classes.
    Exporting top-level functions
    WIT allows exporting one or more top-level functions in the world section, for example:
    package golem:demo;
     
    world py-example {
        export hello-world: func() -> string;
    }
    To implement this function in Python, the following steps must be taken:
    the module containing the base class to be implemented from the generated bindings needs to be imported
    implement the exported function as a method in Python of a class with the same name as the base class in the bindings
    Let's see in code:
    # import the binding module - it's name corresponds with the WIT world's name
    import py_example
     
    # implement the exported function as a method in Python
    class PyExample(py_example.PyExample):
        def hello_world(self) -> str:
            return "Hello World"
    ⚠️
    Note that in WIT, identifiers are using the kebab-case naming convention, while Python uses the snake_case convention for methods, and PascalCase for class names. The generated bindings map between the two automatically.
    Exporting interfaces
    WIT supports defining and exporting whole interfaces, coupling together multiple functions and possibly custom data types.
    Take the following example:
    package golem:demo;
     
    interface api {
      add: func(value: u64);
      get: func() -> u64;
    }
     
    world py-example {
      export api;
    }
    This is equivalent to having the two exported functions directly exported from the world section, so the implementation in Python is once again requires to implement the two exported functions as an implementation of an abstract class:
    import py_example
    from py_example import exports
     
    state: int = 0
     
    class Api(exports.Api):
        def add(self, value: int):
          global state
          state = state + value
     
        def get(self) -> int:
           global state
           return state
    See the Managing state section below to learn the recommended way of managing state in Golem components, which is required to implement these two functions.
    Exporting resources
    The WIT format supports defining and exporting resources - entities defined by their constructor function and the available methods on them.
    Golem supports exporting these resources as part of the worker's API.
    The following example modifies the previously seen counter example to define it as a resource, getting the counter's name as a constructor parameter:
    package golem:demo;
     
    interface api {
      resource counter {
        constructor(name: string);
        add: func(value: u64);
        get: func() -> u64;
      }
    }
     
    world py-example {
      export api;
    }
    Resources can have multiple instances within a worker. Their constructor returns a handle which is then used to call the methods on the resource. Learn more about how resources can be implicitly created and invoked through Golem's APIs in the Invocations page.
    To implement the above defined WIT resource in Python a few new steps must be taken:
    the exported interface and the resource itself has two separate abstract classes generated within the bindings module, both need to be imported and implemented
    the Counter class that implements the resource must have a constructor getting the name parameter
    the implementations module structure must reflect the generated binding's module structure. In this case, the Counter implementation must be placed in a module named api.
    Let's see in code:
    main.py
    import py_example
    from py_example import exports
     
    class Api(exports.Api):
        pass
      api.py
    import py_example
    import py_example.exports
    from py_example.exports import api
     
    class Counter(api.Counter):
        def __init__(self, name: str):
            self.name = name
            self.state = 0
     
        def add(self, value: int):
            self.state = self.state + value
     
        def get(self) -> int:
            return self.state
    Note that the Counter class can encapsulate it's own state, as every resource instance will be mapped to a corresponding instance of the Python class.
    Data types defined in WIT
    The WIT specifications contains some primitive and higher level data types and also allows defining custom data types which can be used as function parameters and return values on the exported functions, interfaces and resources.
    The following table shows an example of each WIT data type and the corresponding Python type it is mapped to:
    WIT type Python type
    bool bool
    s8, s16, s32, s64 int
    u8, u16, u32, u64 int
    f32, f64 float
    char str
    string str
    list<string> List[str]
    option<u64> Optional[int]
    result<s32, string> Result[int, str] in input position, where Result is part of the generated bindings. When used in return position, the success value is used and the error must be raised as an exception.
    tuple<u64, string, char> Tuple[int, str, str]
    record user { id: u64, name: string } @dataclass class named User with two fields id and name
    variant color { red, green, blue, rgb(u32) } Color = Union[ColorRed, ColorGreen, ColorBlue, ColorRgb] where each case is a @dataclass class
    enum color { red, green, blue } class Color(Enum): with upper-case cases
    flags access { read, write, lst } class Access(Flag): with upper-case flags
    Worker configuration
    It is often required to pass configuration values to workers when they are started.
    In general Golem supports three different ways of doing this:
    Defining a list of string arguments passed to the worker, available as command line arguments
    Defining a list of key-value pairs passed to the worker, available as environment variables.
    Using resource constructors to pass configuration values to the worker.
    Command line arguments
    The command line arguments associated with the Golem worker can be accessed by reading the standard Python sys.argv variable:
    import sys
    print(sys.argv)
    Command line arguments can only be specified when a worker is explicitly created and they are are empty by default, including in cases when the worker was implicitly created by an invocation.
    Environment variables
    Environment variables can be accessed in Python using the standard os.environ map:
    import os
    print(os.environ['KEY'])
    Environment variables can be specified when a worker is explicitly created, but there are some environment variables that are always set by Golem:
    GOLEM_WORKER_NAME - the name of the worker
    GOLEM_COMPONENT_ID - the ID of the worker's component
    GOLEM_COMPONENT_VERSION - the version of the component used for this worker
    In addition to these, when using Worker to Worker communication, workers created by remote calls inherit the environment variables of the caller.
    This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of workers.
    Resource constructors
    As explained earlier, Golem workers can export resources and these resources can have constructor parameters.
    Although resources can be used in many ways, one pattern for Golem is only create a single instance of the exported resource in each worker, and use it to pass configuration values to the worker. This is supported by Golem's worker invocation syntax directly, allowing to implicitly create workers and the corresponding resource by a single invocation as described on the Invocations page.
    Managing state
    Golem workers are stateful. There are two major techniques to store and manipulate state in a Golem worker implemented in Python:
    Using global variables
    Using resources and storing state in the resource's class
    Both techniques has been demonstrated in the code examples above.
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Python language guide
  char_count: 8872
  approx_token_count: 2218
- id_parent: 38
  title: Building components
  url: https://learn.golem.cloud/python-language-guide/building-components
  content: |
    Python Language Guide
    Building Components
    Building Golem Components in Python
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Under the hood
    Building Golem components written in Python involves two steps:
    Package the Python code into a WASM component
    The componentize subcommand of the componentize-py tool packages the Python code and the Python interpreter into a single WebAssembly component:
    $ componentize-py componentize main -o py_example.wasm
    Note that the componentize-py tool respects the VIRTUAL_ENV environment variable, so make sure to activate the virtualenv if there are any Python dependencies used by your component.
    Reducing the size of the component
    The output of compoenntize-py is large. It is possible to strip some parts of it to reduce the size by about 50% using the wasm-tools strip command:
    $ wasm-tools strip -a py_example.wasm -o py_example_stripped.wasm
    Generate the Python bindings from the WIT files
    The bindings subcommand of the componentize-py tool generates the module containing the generated bindings:
    $ componentize-py bindings generated_bindings
    This will generate bindings into the bindings directory. Make sure to not actually use these bindings to invoke imported functions, as they don't have any implementation.
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Python language guide
  char_count: 1780
  approx_token_count: 445
- id_parent: 39
  title: Next steps
  url: https://learn.golem.cloud/python-language-guide/next-steps
  content: |
    Python Language Guide
    Next Steps
    Next steps
    After setting up the Python development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Making HTTP requests from a Golem component
    Learn how to send HTTP requests from a Golem component written in Python.
    Control durability guarantees
    Check how the Golem runtime API can control various durability settings of Golem.
    Automatic retries
    Learn about Golem's retry mechanism and how it can be customized.
    Promises
    Create and use promises to await external events from within a running worker.
    Using WASI interfaces
    See what low-level WASI interfaces are available and how they can be used from Python.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    HTTP client
    
  section: Python language guide
  char_count: 967
  approx_token_count: 242
- id_parent: 40
  title: Http
  url: https://learn.golem.cloud/python-language-guide/http
  content: |
    Python Language Guide
    HTTP client
    HTTP requests in Python
    Golem implements the WASI HTTP
    (opens in a new tab)
    interfaces so any library built on this specification can be used from Golem components to communicate with external services.
    The only way to make HTTP requests from Python code currently is to use these WASI HTTP interfaces directly.
    Last updated on March 28, 2025
    Next Steps
    Durability
    
  section: Python language guide
  char_count: 398
  approx_token_count: 100
- id_parent: 41
  title: Durability
  url: https://learn.golem.cloud/python-language-guide/durability
  content: |
    Python Language Guide
    Durability
    Control durability guarantees from Python
    Golem provides a set of functions components can call to control details of the durable execution engine.
    Adding as a dependency
    To use Golem's runtime API, add all the WIT files from https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    in the project's wit/deps directory, and then importing this interface to the component's world:
    world example {
        import golem:api/host@1.1.0;
        // ...
    }
    The golem new examples for Python automatically create the wit/deps directory for you, except the py-actor-minimal one.
    General concepts
    The library allows controlling four main aspects of the durable execution engine: the current persistence level, the idempotence mode, defining atomic regions and changing retry policies (discussed in the next page).
    All these features are regional - they can be changed for a section of the code within a single exported function.
    As in Python we are directly invoking the runtime API's functions, these regions must be enforced by the user manually.
    Persistence level
    The persistence level can be one of the following:
    Level Description
    PersistenceLevel_PersistNothing Turns off persistence for a section. In case the worker is recovered or restarted, all the side-effecting functions will be reexecuted
    PersistenceLevel_PersistRemoteSideEffects Persists all the side-effects that are affecting the outside world. In case of recovery the side-effects won't be reexecuted and the persisted results will be used.
    PersistenceLevel_Smart The default setting; Let Golem decide what to persist to optimize performance
    To change the persistence level for a section of the code, use the get_oplog_persistence_level function to get the current one, and the set_oplog_persistence_level function to set a new value:
    import py_example
    import py_example.imports
    import py_example.imports.types
    import py_example.imports.host
    import py_example.exports
    import py_example.exports.api
    from py_example.imports.host import get_oplog_persistence_level, set_oplog_persistence_level, PersistenceLevel_PersistNothing
     
    old = get_oplog_persistence_level()
    try:
        set_oplog_persistence_level(PersistenceLevel_PersistNothing())
        # ...
    finally:
        set_oplog_persistence_level(old)
    Idempotence mode
    Golem assumes that HTTP requests are idempotent by default. This means that in case of a failure, if the system cannot determine whether the request successfully reached the target or not, it will be retried. This behavior can be changed using the set_idempotence_mode function:
    import py_example
    import py_example.imports
    import py_example.imports.types
    import py_example.imports.host
    import py_example.exports
    import py_example.exports.api
    from py_example.imports.host import get_idempotence_mode, set_idempotence_mode
     
    old = get_idempotence_mode()
    try:
        set_idempotence_mode(false)
        # ...
    finally:
        set_idempotence_mode(true)
    With disabled idempotence mode, in case Golem cannot determine if the request was sent or not, it won't retry it but the worker will fail.
    Atomic regions
    By default side effects are persisted and retried one by one. It is possible to group them together into atomic regions, in which case the execution is retried for some reason (the worker failed or interrupted within the region), all the side effects will be reexecuted.
    To define an atomic region, use the mark_begin_operation and mark_end_operation functions:
    import py_example
    import py_example.imports
    import py_example.imports.types
    import py_example.imports.host
    import py_example.exports
    import py_example.exports.api
    from py_example.imports.host import mark_begin_operation, mark_end_operation
     
    begin = mark_begin_operation()
    try:
        # ...
    finally:
        mark_end_operation(begin)
    Commit oplog
    The oplog_commit function waits until the oplog is committed to its persistent storage. The function takes a single argument, replicas, with the desired number of storage replicas the worker's journal is replicated to. The function will block until the oplog is committed to the specified number of replicas, or, if this number is larger than the available number of replicas, until it is written to all the replicas.
    Last updated on March 28, 2025
    HTTP client
    Retries
    
  section: Python language guide
  char_count: 4277
  approx_token_count: 1070
- id_parent: 42
  title: Retries
  url: https://learn.golem.cloud/python-language-guide/retries
  content: |
    Python Language Guide
    Retries
    Control the retry policy from Python
    Using Golem's retry mechanism
    Golem applies a retry mechanism to all workers. In case of a failure, Golem will automatically recover the worker to the point before the failure and retry the operation. An exponential backoff and an upper limit on the number of retries are applied.
    If the maximum number of retries is reached, the worker will be marked as failed and no further invocations will be possible on it.
    This mechanism is automatic and applied to all kind of failures. To rely on it, just let the Python code fail (raise an exception).
    Customizing the retry policy
    The retry policy which controls the maximum number of retries and the exponential backoff is a global configuration of the Golem servers, but it can be customized for each worker.
    Once the golem:api/host@1.1.0 interface is imported in the WIT file (see the previous page for more information), the retry policy can be controlled with the get_retry_policy and set_retry_policy functions.
    import py_example
    import py_example.imports
    import py_example.imports.types
    import py_example.imports.host
    import py_example.exports
    import py_example.exports.api
    from py_example.imports.host import get_retry_policy, set_retry_policy, RetryPolicy
     
    old = get_retry_policy()
    try:
        set_retry_policy(RetryPolicy(max_attempts=10, min_delay=1_000_000_000, max_delay=1_000_000_000, multiplier=1))
        # ...
    finally:
        set_retry_policy(old)
    // ...
     
    golem_api_host_get_retry_policy(&previous);
    The RetryPolicy type itself is originated from Golem's WIT definition in the following way:
    /// Configures how the executor retries failures
    record retry-policy {
        /// The maximum number of retries before the worker becomes permanently failed
        max-attempts: u32,
        /// The minimum delay between retries (applied to the first retry)
        min-delay: duration,
        /// The maximum delay between retries
        max-delay: duration,
        /// Multiplier applied to the delay on each retry to implement exponential backoff
        multiplier: f64,
        /// The maximum amount of jitter to add to the delay
        max-jitter-factor: option<f64>
    }
    In python each field is represented by an integer.
    Last updated on March 28, 2025
    Durability
    Promises
    
  section: Python language guide
  char_count: 2255
  approx_token_count: 564
- id_parent: 43
  title: Promises
  url: https://learn.golem.cloud/python-language-guide/promises
  content: |
    Python Language Guide
    Promises
    Working with Golem Promises in Python
    Golem promises provide a way for Golem workers to wait on an external condition. The worker creates the promise and somehow sends its identifier to the external system responsible for completing the promise. Then the worker can await the promise, being suspended until the external system completes the promise using Golem's REST API.
    It is also possible to complete a promise from within a Golem worker using the Golem SDK.
    When a promise is completed, an arbitrary byte array can be attached to it as a payload - this data is returned to the awaiting worker when is continues execution.
    In Python the promise API can be used by directly importing and using the Golem runtime API.
    Adding as a dependency
    To use Golem's runtime API, add all the WIT files from https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    in the project's wit/deps directory, and then importing this interface to the component's world:
    world example {
        import golem:api/host@1.1.0;
        // ...
    }
    The golem new examples for Python automatically create the wit/deps directory for you, except the c-actor-minimal one.
    Creating a promise
    To create a promise simply call the create_promise function:
    from py_example.imports.host import create_promise
     
    promise_id = create_promise()
    The returned value, PromiseId, is defined as the following:
    @dataclass
    class Uuid:
        """
        UUID
        """
        high_bits: int
        low_bits: int
     
    @dataclass
    class ComponentId:
        """
        Represents a Golem component
        """
        uuid: Uuid
     
    @dataclass
    class WorkerId:
        """
        Represents a Golem worker
        """
        component_id: ComponentId
        worker_name: str
     
    @dataclass
    class PromiseId:
        """
        A promise ID is a value that can be passed to an external Golem API to complete that promise
        from an arbitrary external source, while Golem workers can await for this completion.
        """
        worker_id: WorkerId
        oplog_idx: int
    Deleting a promise
    If a promise is no longer used, it has to be deleted with
    delete_promise(promise_id);
    Awaiting a promise
    To await a promise, use the await_promise function:
    payload = await_promise(promise_id)
    The resulting payload is a byte array (bytes) containig the data attached to the promise on completion.
    Completing a promise from within a worker
    To complete a promise from within a worker, use the complete_promise function:
    complete_promise(promise_id, str.encode("hello world"))
    Completing a promise from an external source
    To see how to use the promise ID to complete a promise through the external REST API, check the REST API documentation.
    Last updated on March 28, 2025
    Retries
    Updating Workers
    
  section: Python language guide
  char_count: 2706
  approx_token_count: 677
- id_parent: 44
  title: Updating
  url: https://learn.golem.cloud/python-language-guide/updating
  content: |
    Python Language Guide
    Updating Workers
    Updating workers to newer versions of Python components
    As described in the general Workers page, each worker runs on a specific version of the component it is based on, but it is possible to update a worker to a different version of the same component.
    Automatic update
    The automatic update mode has no Python-specific details and works as it is described in the general Workers page.
    Manual snapshot-based update
    Sometimes the change between two component versions is so large that the only solution to migrate worker's state to a new version is to manually implement this state transfer.
    This is done by implementing a save-snapshot function in the old component and a load-snapshot function in the new component. The snapshot is an array of bytes and it is the responsibility of the user to ensure that the snapshot is compatible between the two versions.
    These functions are defined in the golem:api WIT package and must be explicitly exported from the component's world.
    Last updated on March 28, 2025
    Promises
    WASI
    
  section: Python language guide
  char_count: 1060
  approx_token_count: 265
- id_parent: 45
  title: Wasi
  url: https://learn.golem.cloud/python-language-guide/wasi
  content: |
    Python Language Guide
    WASI
    Using WASI interfaces from Python
    Golem implements and exports a subset of the WASI
    (opens in a new tab)
    interfaces, as well as its own runtime interfaces.
    The previous sections already introduced how to use a subset of these interfaces to control durability settings, make HTTP requests, and control retries or use promises.
    WIT specifications
    The full set of WIT specifications Golem implements is available in the following public repository:
    https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    The following table lists all packages provided by Golem:
    Package Description
    golem:api Golem's Runtime API
    golem:rpc Provides support for Worker to Worker communication
    wasi:blobstore Interface for storing and retrieving large binary data
    wasi:cli Interface for environment variables and standard I/O
    wasi:clocks Interface for querying the system time
    wasi:filesystem Interface for working with files and directories
    wasi:http Interface for making HTTP requests
    wasi:io Interface for working with futures and streams
    wasi:keyvalue Interface for storing and retrieving key-value pairs - only partially implemented
    wasi:logging Interface for logging messages
    wasi:random Interface for generating random numbers
    wasi:sockets Interface for working with TCP and UDP sockets (currently not supporting durable execution)
    Additional Golem runtime APIs
    This section describes some additional Golem-specific functionalities which are available through the Golem runtime API.
    Generate an idempotency key
    Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.
    It is guaranteed that this idempotency key will always be the same (per occurrence) even if the worker is restarted due to a crash.
    To generate the idempotency key:
    key = generate_idempotency_key();
    Get worker metadata
    It is possible to query metadata for Golem workers. This metadata is defined by the following WIT record:
    record worker-metadata {
        worker-id: worker-id,
        args: list<string>,
        env: list<tuple<string, string>>,
        status: worker-status,
        component-version: u64,
        retry-count: u64
    }
     
    enum worker-status {
        /// The worker is running an invoked function
        running,
        /// The worker is ready to run an invoked function
        idle,
        /// An invocation is active but waiting for something (sleeping, waiting for a promise)
        suspended,
        /// The last invocation was interrupted but will be resumed
        interrupted,
        /// The last invocation failed and a retry was scheduled
        retrying,
        /// The last invocation failed and the worker can no longer be used
        failed,
        /// The worker exited after a successful invocation and can no longer be invoked
        exited,
    }
    There are two exported functions to query worker metadata:
    get_self_metadata returns the metadata for the current worker
    get_worker_metadata returns the metadata for a specific worker given by it's WorkerId
    Enumerate workers
    Worker enumeration is a feature of Golem available both through the public HTTP API and using the WIT interfaces.
    ⚠️
    Enumerating workers of a component is a slow operation and should not be used as part of the application logic.
    Update a worker
    To trigger update for a given worker from one component version to another, use the update_worker function:
    update_worker(worker_id, target_version, UpdateMode_Automatic())
    To learn more about updating workers, see the updating workers page.
    The WASI Key-Value store interface
    Although Golem workers can store their state completely in their own memory, it is possible to use the wasi:keyvalue interface to store key-value pairs in a Golem managed key value storage.
    This can be useful if state needs to be shared between different workers or if the size of this state is too large to be stored in memory.
    The WASI Blob Store interface
    The wasi:blobstore interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the worker's memory.
    Last updated on March 28, 2025
    Updating Workers
    Setup
    
  section: Python language guide
  char_count: 4194
  approx_token_count: 1049
- id_parent: 46
  title: Setup
  url: https://learn.golem.cloud/go-language-guide/setup
  content: |
    Go Language Guide
    Setup
    Setup Go
    Creating Golem components in Go requires using the latest version of the TinyGo compiler
    (opens in a new tab)
    and installing some common WebAssembly tooling.
    Installing TinyGo
    Use the official guide
    (opens in a new tab)
    to install the latest stable version of the TinyGo compiler.
    Note that TinyGo also requires Go to be installed too. Follow the recommended steps here
    (opens in a new tab)
    to download and install the latest recommended version.
    For MacOS TinyGo can be installed using brew:
    brew tap tinygo-org/tools
    brew install tinygo
    ⚠️
    The minimum versions assumed by the documentation and templates are the following:
    TinyGo: 0.37.0
    Go: 1.24.0
    Install WebAssembly tooling
    First of all, to install wasm-tools via cargo, you need to install the latest stable version of Rust. The recommended way to do so is using https://rustup.rs
    (opens in a new tab)
    :
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Install wasm-tools
    cargo install --force --locked  wasm-tools@1.227.1
    Confirm the installation:
    wasm-tools --version
    wasm-tools 1.227.1
    Last updated on April 22, 2025
    WASI
    Defining Components
    
  section: Go language guide
  char_count: 1316
  approx_token_count: 329
- id_parent: 47
  title: Defining components
  url: https://learn.golem.cloud/go-language-guide/defining-components
  content: |
    Go Language Guide
    Defining Components
    Defining Golem Components in Go
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the Go template:
    golem app new my-app go
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new go my-component
    Specification-first approach
    Golem and the Go toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    The first time a component is compiled (see the Building Components page for details), a couple of files get generated in a subdirectory named as your component. This go package contains the definitions of all the data types and interfaces defined in the WIT file(s).
    To implement the specification written in WIT, the Go code must implement some of these generated interfaces and set them explicitly in the init function.
    Exporting top-level functions
    WIT allows exporting one or more top-level functions in the world section, for example:
    package golem:demo;
     
    world go-example {
        include wasi:cli/imports@0.2.0;
     
        export hello-world: func() -> string;
    }
    ⚠️
    Note that currently tinygo requires including the wasi:cli/imports@0.2.0 world in the application's world.
    To implement this function in Go, the following steps must be taken:
    make sure the generated package is imported
    set the fields of the global Exports variable to the exported function implementations
    Let's see in code:
    package main
     
    // make sure the generated package is imported
    import (
     testgoinlinefunctions "app/components-go/golem-demo/binding/golem/demo-exports/go-example-inline-functions"
    )
     
    // wire the implementation
    func init() {
     testgoinlinefunctions.Exports.HelloWorld = func() string {
      return "Hello World!"
     }
    }
      ⚠️
    Note that in WIT, identifiers are using the kebab-case naming convention, while Go uses the PascalCase convention. The generated bindings map between the two automatically.
    Exporting interfaces
    WIT supports defining and exporting whole interfaces, coupling together multiple functions and possibly custom data types.
    Take the following example:
    package golem:demo;
     
    interface api {
      add: func(value: u64);
      get: func() -> u64;
    }
     
    world example {
      export api;
    }
    This is similar to having the two exported functions directly exported from the world section, but there is a corresponding Go interface generated that needs to be separately implemented and installed:
    package main
     
    import (
     testgoapi "app/components-go/golem-demo/binding/golem/demo-exports/test-go-api"
    )
     
    var counter uint64
     
    func Add(value uint64) {
     counter += value
    }
     
    func Get() uint64 {
     return counter
    }
     
    func init() {
     testgoapi.Exports.Add = Add
     testgoapi.Exports.Get = Get
    }
    See the Managing state section below to learn the recommended way of managing state in Golem components, which is required to implement these two functions.
    Exporting resources
    The WIT format supports defining and exporting resources - entities defined by their constructor function and the available methods on them.
    Golem supports exporting these resources as part of the worker's API.
    The following example modifies the previously seen counter example to define it as a resource, getting the counter's name as a constructor parameter:
    package golem:demo;
     
    interface api {
      resource counter {
        constructor(name: string);
        add: func(value: u64);
        get: func() -> u64;
      }
    }
     
    world example {
      export api;
    }
    Resources can have multiple instances within a worker. Their constructor returns a handle which is then used to call the methods on the resource. Learn more about how resources can be implicitly created and invoked through Golem's APIs in the Invocations page.
    To implement the above defined WIT resource in Go a few new steps must be taken:
    define a struct representing the resource - it can contain data!
    implement the interface generated as the resource's interface for this struct
    create a constructor
    create a global variable to store the resource instances
    and another to store the last used numeric identifier for these instances
    Let's see in code:
    package main
     
    import (
     testgoapi "app/components-go/golem-demo/binding/golem/demo-exports/test-go-api"
    )
     
    // struct representing an instance of the resource
    type Counter struct {
     name    string
     current uint64
    }
     
    func NewCounter(name string) *Counter {
     return &Counter{
      name:    name,
      current: 0,
     }
    }
     
    func (e *Counter) Add(value uint64) {
     e.current += value
    }
     
    func (e *Counter) Get() uint64 {
     return e.current
    }
     
    var counters = make(map[cm.Rep]*Counter)
    var lastId = cm.Rep(0)
     
    func init() {
     testgoapi.Exports.Counter.Constructor = func(name string) (result testgoapi.Counter) {
      counter := NewCounter(name)
      id := lastId + 1
      lastId = id
      counters[id] = counter
      return testgoapi.CounterResourceNew(id)
     }
     
     testgoapi.Exports.Counter.Destructor = func(id cm.Rep) {
      delete(counters, id)
     }
     
     testgoapi.Exports.Counter.Add = func(id cm.Rep, value uint64) {
      counters[id].Add(value)
     }
     
     testgoapi.Exports.Counter.Get = func(id cm.Rep) uint64 {
      return counters[id].Get()
     }
    }
    Data types defined in WIT
    The WIT specifications contains some primitive and higher level data types and also allows defining custom data types which can be used as function parameters and return values on the exported functions, interfaces and resources.
    The following table shows an example of each WIT data type and its corresponding Go type:
    WIT type Go type
    bool bool
    s8, s16, s32, s64 int8, int16, int32, int64
    u8, u16, u32, u64 uint8, uint16, uint32, uint64
    f32, f64 float32, float64
    char rune
    string string
    list<string> cm.List[string]
    option<u64> cm.Option[uint64]
    result<s32, string> cm.Result[Shape, int32, string]
    result<_, string> cm.Result[String, struct{}, String]
    tuple<u64, string, char> cm.Tuple3[uint64, string, rune]
    The generated bindings are using data types defined in the cm package. See the package's documentation
    (opens in a new tab)
    for more information.
    WIT records
    The following WIT record type:
    package golem:demo;
     
    interface api {
        record user {
            id: u64,
            name: string,
        }
    }
    Will generate the following Go struct:
    type User struct {
     _    cm.HostLayout `json:"-"`
     ID   uint64        `json:"id"`
     Name string        `json:"name"`
    }
    WIT variants
    The following WIT variant type:
    package golem:demo;
     
    interface api {
        variant color {
            red,
            green,
            blue,
            rgb(u32)
        }
    }
    Will generate the following Go enum:
    type ExportsGolemDemoApiColorKind inttype Color cm.Variant[uint8, uint32, uint32]
     
    // ColorRed returns a [Color] of case "red".
    func ColorRed() Color {
     var data struct{}
     return cm.New[Color](0, data)
    }
     
    // Red returns true if [Color] represents the variant case "red".
    func (self *Color) Red() bool {
     return self.Tag() == 0
    }
     
    // ColorGreen returns a [Color] of case "green".
    func ColorGreen() Color {
     var data struct{}
     return cm.New[Color](1, data)
    }
     
    // Green returns true if [Color] represents the variant case "green".
    func (self *Color) Green() bool {
     return self.Tag() == 1
    }
     
    // ColorBlue returns a [Color] of case "blue".
    func ColorBlue() Color {
     var data struct{}
     return cm.New[Color](2, data)
    }
     
    // Blue returns true if [Color] represents the variant case "blue".
    func (self *Color) Blue() bool {
     return self.Tag() == 2
    }
     
    // ColorRgb returns a [Color] of case "rgb".
    func ColorRgb(data uint32) Color {
     return cm.New[Color](3, data)
    }
     
    // Rgb returns a non-nil *[uint32] if [Color] represents the variant case "rgb".
    func (self *Color) Rgb() *uint32 {
     return cm.Case[uint32](self, 3)
    }
     
    var _ColorStrings = [4]string{
     "red",
     "green",
     "blue",
     "rgb",
    }
     
    // String implements [fmt.Stringer], returning the variant case name of v.
    func (v Color) String() string {
     return _ColorStrings[v.Tag()]
    }
    as well as a set of helper functions.
    WIT enums
    The following WIT enum type:
    package golem:demo;
     
    interface api {
        enum color {
            red,
            green,
            blue
        }
    }
    Will generate the following Go enum:
    type Color uint8
     
    const (
     ColorRed Color = iota
     ColorGreen
     ColorBlue
    )
     
    var _ColorStrings = [3]string{
     "red",
     "green",
     "blue",
    }
     
    // String implements [fmt.Stringer], returning the enum case name of e.
    func (e Color) String() string {
     return _ColorStrings[e]
    }
     
    // MarshalText implements [encoding.TextMarshaler].
    func (e Color) MarshalText() ([]byte, error) {
     return []byte(e.String()), nil
    }
     
    // UnmarshalText implements [encoding.TextUnmarshaler], unmarshaling into an enum
    // case. Returns an error if the supplied text is not one of the enum cases.
    func (e *Color) UnmarshalText(text []byte) error {
     return _ColorUnmarshalCase(e, text)
    }
     
    var _ColorUnmarshalCase = cm.CaseUnmarshaler[Color](_ColorStrings[:])
    and a set of helper functions.
    WIT flags
    The following WIT flags type:
    package golem:demo;
     
    interface api {
        flags access {
            read,
            write,
            lst
        }
    }
    Will generate the following Go bitflags:
    type Access uint8
     
    const (
     AccessRead Access = 1 << iota
     AccessWrite
     AccessLst
    )
    Worker configuration
    It is often required to pass configuration values to workers when they are started.
    In general Golem supports three different ways of doing this:
    Defining a list of string arguments passed to the worker, available as command line arguments
    Defining a list of key-value pairs passed to the worker, available as environment variables.
    Using resource constructors to pass configuration values to the worker.
    Command line arguments and environment variables
    First, make sure the Golem Go SDK is set up for the project.
    Then you can use the golem-go std package to initialize the standard library's environment at start of the component's methods:
    package main
     
    import (
     "fmt"
     "os"
     
     // import the std helper
     "github.com/golemcloud/golem-go/std"
     
     goexampleapi "golem/demo/go_example/bindings/go/example-example/go-example-api"
    )
     
    func HelloWorld() string {
        // initialize the std os package from the golem environment
     // this initialization has to be called at the start of the implementation methods
     std.Init(std.Packages{Os: true})
     
        // access command line arguments and environment variables through the standard packages
     fmt.Printf("args: %+v", os.Args)
     fmt.Printf("env: %+v", os.Environ())
     
     return "Hello, World!"
    }
     
    func init() {
     goexampleapi.Exports.HelloWorld = HelloWorld
    }
    Environment variables can be specified when a worker is explicitly created, but there are some environment variables that are always set by Golem:
    GOLEM_WORKER_NAME - the name of the worker
    GOLEM_COMPONENT_ID - the ID of the worker's component
    GOLEM_COMPONENT_VERSION - the version of the component used for this worker
    In addition to these, when using Worker to Worker communication, workers created by remote calls inherit the environment variables of the caller.
    This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of workers.
    Resource constructors
    As explained earlier, Golem workers can export resources and these resources can have constructor parameters.
    Although resources can be used in many ways, one pattern for Golem is only create a single instance of the exported resource in each worker, and use it to pass configuration values to the worker. This is supported by Golem's worker invocation syntax directly, allowing to implicitly create workers and the corresponding resource by a single invocation as described on the Invocations page.
    Managing state
    Golem workers are stateful. There are three major techniques to store and manipulate state in a Golem worker implemented in Go:
    Using a global variable
    Using fields in the implementation struct
    Using resources and storing state in the resource's struct
    All techniques were demonstrated above in the code examples.
    Last updated on April 22, 2025
    Setup
    Building Components
    
  section: Go language guide
  char_count: 12553
  approx_token_count: 3139
- id_parent: 48
  title: Building components
  url: https://learn.golem.cloud/go-language-guide/building-components
  content: |
    Go Language Guide
    Building Components
    Building Golem Components in Go
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Under the hood
    Building Golem components written in Go requires a series of steps.
    In details, building the component requires the following steps:
    Generate the Go bindings
    Use the wit-bindgen-go tool to generate the Go bindings from the WIT files:
    $ go get -tool go.bytecodealliance.org/cmd/wit-bindgen-go
    $ go tool wit-bindgen-go generate --out binding --world world-name ./wit
    Compile the Go code
    Using the TinyGo compiler, compile the Go code into a WebAssembly module:
    $ tinygo build -target=wasip2 -wit-package ./wit -wit-world world-name -tags=purego -o go_example.wasm main.go
    The resulting WASM file is a component ready to be uploaded to Golem.
    Reducing the component's size
    The generated component's size can be reduced by stripping some parts of it using the wasm-tools strip command:
    $ wasm-tools strip go_example.wasm -o go_example_stripped.wasm
    Last updated on April 22, 2025
    Defining Components
    Next Steps
    
  section: Go language guide
  char_count: 1501
  approx_token_count: 376
- id_parent: 49
  title: Next steps
  url: https://learn.golem.cloud/go-language-guide/next-steps
  content: |
    Go Language Guide
    Next Steps
    Next steps
    After setting up the Go development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Making HTTP requests from a Golem component
    Learn how to send HTTP requests from a Golem component written in Go.
    Control durability guarantees
    Check how the Go Golem SDK can control various durability settings of Golem.
    Automatic retries
    Learn about Golem's retry mechanism and how it can be customized.
    Transactions
    Use the higher level transactions library to implement the Saga pattern.
    Promises
    Create and use promises to await external events from within a running worker.
    Using WASI interfaces
    See what low-level WASI interfaces are available and how they can be used from Go.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    Setting up the Golem Go SDK
    
  section: Go language guide
  char_count: 1048
  approx_token_count: 262
- id_parent: 50
  title: Golem go sdk
  url: https://learn.golem.cloud/go-language-guide/golem-go-sdk
  content: |
    Go Language Guide
    Setting up the Golem Go SDK
    Setting up the Golem Go SDK
    ⚠️
    If the project was created with golem new, it already has the Golem Go SDK set up and these steps can be ignored.
    If setting up the Golem Go SDK
    (opens in a new tab)
    manually, the following steps are required:
    Add the Golem Go SDK as a dependency
    Add the following dependency to the project:
    $ go get github.com/golemcloud/golem-go
    Add all the supported WIT files into the project
    The project's wit/deps directory must contain all the WIT files from the golem-wit
    (opens in a new tab)
    repository.
    Importing WITs into the component's world:
    If the project's WIT file was like this:
    package golem:demo;
     
    world go-example {
      export api;
    }
    Modify it in the following way:
    package golem:demo;
     
    world go-example {
      import golem:api/host@1.1.6;
      import golem:rpc/types@0.2.0;
     
      import wasi:blobstore/blobstore;
      import wasi:blobstore/container;
      import wasi:cli/environment@0.2.0;
      import wasi:clocks/wall-clock@0.2.0;
      import wasi:clocks/monotonic-clock@0.2.0;
      import wasi:filesystem/preopens@0.2.0;
      import wasi:filesystem/types@0.2.0;
      import wasi:http/types@0.2.0;
      import wasi:http/outgoing-handler@0.2.0;
      import wasi:io/error@0.2.0;
      import wasi:io/poll@0.2.0;
      import wasi:io/streams@0.2.0;
      import wasi:keyvalue/eventual-batch@0.1.0;
      import wasi:keyvalue/eventual@0.1.0;
      import wasi:logging/logging;
      import wasi:random/random@0.2.0;
      import wasi:random/insecure@0.2.0;
      import wasi:random/insecure-seed@0.2.0;
      import wasi:sockets/ip-name-lookup@0.2.0;
      import wasi:sockets/instance-network@0.2.0;
     
      export api;
    }
    Last updated on April 22, 2025
    Next Steps
    HTTP client
    
  section: Go language guide
  char_count: 1678
  approx_token_count: 420
- id_parent: 51
  title: Http
  url: https://learn.golem.cloud/go-language-guide/http
  content: |
    Go Language Guide
    HTTP client
    HTTP requests in Go
    Golem implements the WASI HTTP
    (opens in a new tab)
    interfaces so any library built on this specification can be used from Golem components to communicate with external services.
    By using the Golem Go SDK, Go's built-in net/http package can be configured to use the WASI HTTP interfaces.
    To do so, Golem's custom Roundtrip implementation hast to be used. This can be done directly before making http requests:
    import (
     "net/http"
     
     "github.com/golemcloud/golem-go/roundtrip"
    )
     
    http.DefaultClient.Transport = roundtrip.WasiHttpTransport{};
    Or the convenience std package can be used at the start of component methods (which can also initialize commandline arguments and environment variable):
    package main
     
    import (
     "fmt"
     "net/http"
     "os"
     
     // import the std helper
     "github.com/golemcloud/golem-go/std"
     
     goexampleapi "golem/demo/go_example/bindings/go/example-example/go-example-api"
    )
     
    func HelloWorld() string {
      // initialize the standard library's os and http package from the golem environment
     // this initialization has to be called at the start of the implementation methods
     std.Init(std.Packages{
      Os: true,
      NetHttp: true,
     })
     
     // The standard http package can be used to make http requests
     _, _ = http.Get("https://host/endpoint")
     
     return "Hello, World!"
    }
     
    func init() {
     goexampleapi.SetGoExample(goexampleapi.NewGoExampleImpl())
    }
    Last updated on April 22, 2025
    Setting up the Golem Go SDK
    Durability
    
  section: Go language guide
  char_count: 1485
  approx_token_count: 372
- id_parent: 52
  title: Durability
  url: https://learn.golem.cloud/go-language-guide/durability
  content: |
    Go Language Guide
    Durability
    Control durability guarantees from Go
    Golem provides a set of functions components can call to control details of the durable execution engine. For components implemented in Go the Golem Go SDK provides a set of Go wrappers for these functions.
    Setting up the Golem Go SDK
    If the project was created with golem new, it already has the Golem Go SDK set up, otherwise follow the step at Setting up the Golem Go SDK
    General concepts
    The library allows controlling four main aspects of the durable execution engine: the current persistence level, the idempotence mode, defining atomic regions and changing retry policies (discussed in the next page).
    All these features are regional - they can be changed for a section of the code within a single exported function. To make this easy to use in Go, the library provides lower and higher level functions:
    the functions starting with Set and Get can be used to directly change the current mode of the engine
    the functions starting with With take a function parameter which will be executed with the requested mode, and then they restore the previous settings
    Persistence level
    The persistence level can be one of the following:
    Level Description
    PersistNothing Turns off persistence for a section. In case the worker is recovered or restarted, all the side-effecting functions will be reexecuted
    PersistRemoteSideEffects Persists all the side-effects that are affecting the outside world. In case of recovery the side-effects won't be reexecuted and the persisted results will be used.
    Smart The default setting; Let Golem decide what to persist to optimize performance
    To change the persistence level for a section of the code, use the one of the golemhost.SetPersistenceLevel or golemhost.WithPersistenceLevel functions:
    import (
     "github.com/golemcloud/golem-go/golemhost"
    )
     
    // Setting directly the persistence level
    golemhost.SetPersistenceLevel(golemhost.PersistenceLevelPersistNothing)
     
    // WithPersistenceLevel stores (using golemhost.GetPersistenceLevel) the current persistence level and
    // then restores it after running the provided function
    result, err = golemhost.WithPersistenceLevel(
     golemhost.PersistenceLevelPersistNothing,
     func() (string, error) {
      // this section runs PersistNothing level
      return "hello", nil
     },
    )
    Idempotence mode
    Golem assumes that HTTP requests are idempotent by default. This means that in case of a failure, if the system cannot determine whether the request successfully reached the target or not, it will be retried. This behavior can be changed using the golemhost.SetIdempotenceMode and golemhost.WithIdempotenceMode functions:
    import (
     "github.com/golemcloud/golem-go/golemhost"
    )
     
    // Setting directly the idempotence mode
    golemhost.SetIdempotenceMode(false)
     
    // WithIdempotenceMode stores (using golemhost.GetIdempotenceMode) the current idempotence mode and
    // then restores it after running the provided function
    result, err = golemhost.WithIdempotenceMode(
     false,
     func() (string, error) {
      // this section runs with idempotence mode disabled
      return "hello", nil
     },
    )
    With disabled idempotence mode, in case Golem cannot determine if the request was sent or not, it won't retry it but the worker will fail.
    Atomic regions
    By default, side effects are persisted and retried one by one. It is possible to group them together into atomic regions, in which case the execution is retried for some reason (the worker failed or interrupted within the region), all the side effects will be reexecuted.
    The golem-go library exposes the golemhost.MarkBeginOperation and golemhost.MarkEndOperation low level functions, and the higher level golemhost.Atomically function built on top of those to manage atomic regions.
    The golemhost.Atomically is preferred and recommended for handling atomic regions, as it guarantees to call the mark functions at the right time and with right values.
    import (
     "github.com/golemcloud/golem-go/golemhost"
    )
     
    result, err = golemhost.Atomically(func() (string, error) {
     firstResult, err := FirstSideEffect()
     if err != nil {
      return "", err
     }
     
     secondResult, err := SecondSideEffect(firstResult)
     if err != nil {
      return "", err
     }
     
     return secondResult, nil
    })
    Commit oplog
    The golemhost.OpLogCommit function waits until the oplog is committed to its persistent storage. The function takes a single argument, replicas, with the desired number of storage replicas the worker's journal is replicated to. The function will block until the oplog is committed to the specified number of replicas, or, if this number is larger than the available number of replicas, until it is written to all the replicas.
    Last updated on March 28, 2025
    HTTP client
    Retries
    
  section: Go language guide
  char_count: 4718
  approx_token_count: 1180
- id_parent: 53
  title: Retries
  url: https://learn.golem.cloud/go-language-guide/retries
  content: |
    Go Language Guide
    Retries
    Control the retry policy from Go
    Using Golem's retry mechanism
    Golem applies a retry mechanism to all workers. In case of a failure, Golem will automatically recover the worker to the point before the failure and retry the operation. An exponential backoff and an upper limit on the number of retries are applied.
    If the maximum number of retries is reached, the worker will be marked as failed and no further invocations will be possible on it.
    This mechanism is automatic and applied to all kind of failures. To rely on it, just let the Go code panic.
    Customizing the retry policy
    The retry policy which controls the maximum number of retries and the exponential backoff is a global configuration of the Golem servers, but it can be customized for each worker.
    The golem-go library provides the golemhost.SetRetryPolicy and golemhost.WithRetryPolicy functions to temporarily change the retry policy:
    import (
     "time"
     
     "github.com/golemcloud/golem-go/golemhost"
    )
     
    // Setting directly the retry policy
    golemhost.SetRetryPolicy(golemhost.RetryPolicy{
     MaxAttempts:    10,
     MinDelay:       100 * time.Millisecond,
     MaxDelay:       5 * time.Second,
     Multiplier:     3,
     MaxRetryFactor: nil,
    })
     
    // WithRetryPolicy stores (using golemhost.GetRetryPolicy) the current retry policy and
    // then restores it after running the provided function
    result, err = golemhost.WithRetryPolicy(
     golemhost.RetryPolicy{
      MaxAttempts:    4,
      MinDelay:       300 * time.Millisecond,
      MaxDelay:       3 * time.Second,
      Multiplier:     2,
      MaxRetryFactor: nil,
     },
     func() (string, error) {
      return "golem", nil
     },
    )
    The golemhost.RetryPolicy type itself is originated from Golem's WIT definition in the following way:
    /// Configures how the executor retries failures
    record retry-policy {
        /// The maximum number of retries before the worker becomes permanently failed
        max-attempts: u32,
        /// The minimum delay between retries (applied to the first retry)
        min-delay: duration,
        /// The maximum delay between retries
        max-delay: duration,
        /// Multiplier applied to the delay on each retry to implement exponential backoff
        multiplier: f64,
        /// The maximum amount of jitter to add to the delay
        max-jitter-factor: option<f64>
    }
    Last updated on March 28, 2025
    Durability
    Transactions
    
  section: Go language guide
  char_count: 2330
  approx_token_count: 583
- id_parent: 54
  title: Transactions
  url: https://learn.golem.cloud/go-language-guide/transactions
  content: |
    Go Language Guide
    Transactions
    High level transactions in Go
    On top of the durability controls and retry controls, the golem-go
    (opens in a new tab)
    library also provides a high level functions for defining transactions supporting compensation actions in case of getting reverted.
    Although Golem's automatic retry policies and low level atomic regions provide a lot of power automatically, many times a set of external operations such as HTTP requests needs to be executed transactionally; if one of the operations fails, the whole transaction need to be rolled back by executing some compensation actions.
    The golem-go library provides support for two different types of transactions:
    fallible transactions are only dealing with domain errors
    infallible transactions must always succeed, and Golem applies its active retry policy to it
    Fallible transactions
    Many times external operations (such as HTTP calls to remote hosts) need to be executed transactionally. If some of the operations failed the transaction need to be rolled back - compensation actions need to undo whatever the already successfully performed operations did.
    A fallible transaction only deals with domain errors. Within the transaction every operation that succeeds gets recorded. If an operation fails, all the recorded operations get compensated in reverse order before the transaction block returns with a failure.
    A fallible transaction can be executed using the transcation.WithFallible function, by passing a closure that can execute operations on the open transaction (see below).
    Infallible transactions
    An infallible transaction must always succeed - in case of a failure or interruption, it gets retried. If there is a domain error, the compensation actions are executed before the retry.
    An infallible transaction can be executed using the transaction.WithInfallible function, by passing a closure that can execute operations on the open transaction (see below).
    Operations
    Both transaction types require the definition of operations.
    It is defined with the following interface in the transcation package:
    type Operation[I any, O any] interface {
     Execute(I) (O, error)
     Compensate(I, O) error
    }
    There are two ways to define an operation:
    Implement the Operation interface manually
    Use the transaction.NewOperation function to create an operation from a pair of closures
    func NewOperation[I any, O any](
     execute func(I) (O, error),
     compensate func(I, O) error,
    ) Operation[I, O]
    Executing operations
    The defined operations can be executed in fallible or infallible mode:
    import "github.com/golemcloud/golem-go/golemhost/transaction"
     
    // example operation entity
    type Entity struct {
     ID string
    }
     
    // example transaction result
    type Result struct {
     entity1 Entity
     entity2 Entity
    }
     
    // example operation with compensation
    var op := transaction.NewOperation(
     // sample execute - create entity
     func(stepID int64) (Entity, error) {
      return Entity{ID: fmt.Sprintf("entity-%d", stepID)}, nil
     },
     // sample compensate - revert entity
     func(stepID int64, entity Entity) error {
      fmt.Printf("Reverting entity: %s, created at step: %d", entity.ID, stepID)
      return nil
     },
    )
     
    // with transaction.Fallible errors have to be handled and propagated
    result, err := transaction.Fallible(func(tx transaction.FallibleTx) (Result, error) {
     entity1, err := transaction.ExecuteFallible(tx, op, 1)
     if err != nil {
      return Result{}, err
     }
     
     entity2, err := transaction.ExecuteFallible(tx, op, 2)
     if err != nil {
      return Result{}, err
     }
     
     return Result{
      entity1: entity1,
      entity2: entity2,
     }, nil
    })
     
    // with transaction.Infallible no explicit error handling is needed, as it is handled by Golem retries
    result := transaction.Infallible(func(tx transaction.InfallibleTx) Result {
     entity1 := transaction.ExecuteInfallible(tx, op, 1)
     entity2 := transaction.ExecuteInfallible(tx, op, 2)
     
     return Result{
      entity1: entity1,
      entity2: entity2,
     }
    })
    Last updated on March 28, 2025
    Retries
    Promises
    
  section: Go language guide
  char_count: 3985
  approx_token_count: 997
- id_parent: 55
  title: Promises
  url: https://learn.golem.cloud/go-language-guide/promises
  content: |
    Go Language Guide
    Promises
    Working with Golem Promises in Go
    Golem promises provide a way for Golem workers to wait on an external condition. The worker creates the promise and somehow sends its identifier to the external system responsible for completing the promise. Then the worker can await the promise, being suspended until the external system completes the promise using Golem's REST API.
    It is also possible to complete a promise from within a Golem worker using the Golem SDK.
    When a promise is completed, an arbitrary byte array can be attached to it as a payload - this data is returned to the awaiting worker when is continues execution.
    In Go the promise API has idiomatic Go wrappers in the Golem Go SDK.
    Creating a promise
    To create a promise simply call the golemhost.NewPromise function:
    import "github.com/golemcloud/golem-go/golemhost"
     
    promiseID := golemhost.NewPromise()
    The returned value has the type golemhost.PromiseID, is defined as the following (including the nested types):
    // UUID, uses the commonly used google UUID module
    type ComponentID uuid.UUID
     
    // Represents a Golem component
    typedef struct golem_api_host_component_id_t {
      golem_api_host_uuid_t   uuid;
    } golem_api_host_component_id_t;
     
    // Represents a Golem worker
    type WorkerID struct {
     ComponentID ComponentID
     WorkerName  string
    }
     
    // A promise ID is a value that can be passed to an external Golem API to complete that promise
    // from an arbitrary external source, while Golem workers can await for this completion.
    type PromiseID struct {
     WorkerID WorkerID
     OplogIdx OpLogIndex
    }
    Deleting a promise
    If a promise is no longer used, it has to be deleted with:
    import "github.com/golemcloud/golem-go/golemhost"
     
    golemhost.DeletePromise(promiseID)
    Awaiting a promise
    To await a promise, use the golemhost.AwaitPromise or the golemhost.AwaitPromiseJSON() functions:
    import "github.com/golemcloud/golem-go/golemhost"
     
    // returns the raw payload as []byte
    bs := golemhost.AwaitPromise(promiseID)
     
    type ExmaplePayload struct {
     ID   int64  `json:"id"`
     Meta string `json:"meta,omitempty"`
    }
    var payload ExmaplePayload
    // requires a JSON unmarshall target and might return serialization errors
    err := golemhost.AwaitPromiseJSON(promiseID, &payload)
    Completing a promise from within a worker
    To complete a promise from within a worker, use the golemhost.CompletePromise of the golemhost.CompletePromiseJSON functions:
    import "github.com/golemcloud/golem-go/golemhost"
     
    // accepts the payload as []byte
    ok := golemhost.CompletePromise(promiseID, []byte{1, 2})
     
    type ExmaplePayload struct {
     ID   int64  `json:"id"`
     Meta string `json:"meta,omitempty"`
    }
    // accepts the payload as any JSON marshallable, and might return serialization errors
    ok, err := golemhost.CompletePromiseJSON(
     promiseID,
     ExmaplePayload{
      ID:   100,
      Meta: "meta data",
     },
    )
    Completing a promise from an external source
    To see how to use the promise ID to complete a promise through the external REST API, check the REST API documentation.
    Last updated on March 28, 2025
    Transactions
    Accessing worker metadata
    
  section: Go language guide
  char_count: 3082
  approx_token_count: 771
- id_parent: 56
  title: Worker metadata
  url: https://learn.golem.cloud/go-language-guide/worker-metadata
  content: |
    Go Language Guide
    Accessing worker metadata
    Accessing Worker Metadata
    Golem workers can access their own and other worker's metadata.
    In Go the worker metadata accessing functions have idiomatic Go wrappers in the Golem Go SDK.
    Worker Metadata
    Worker metadata is defined as the following types in the golemhost package:
    type ComponentID uuid.UUID
     
    type WorkerID struct {
     ComponentID ComponentID
     WorkerName  string
    }
     
    type WorkerMetadataEnvVar struct {
     Name  string
     Value string
    }
     
    type WorkerStatus int
     
    const (
     WorkerStatusRunning = iota
     WorkerStatusIdle
     WorkerStatusSuspended
     WorkerStatusInterrupted
     WorkerStatusRetrying
     WorkerStatusFailed
     WorkerStatusExited
    )
     
    type WorkerMetadata struct {
     WorkerId         WorkerID
     Args             []string
     Env              []WorkerMetadataEnvVar
     Status           WorkerStatus
     ComponentVersion uint64
     RetryCount       uint64
    }
    Get Self Metadata
    To access the metadata for the currently running worker use the golemhost.GetSelfMetadata function, which returns golemhost.WorkerMetadata:
    import (
     "fmt"
     
     "github.com/golemcloud/golem-go/golemhost"
    )
     
    workerMetadata := golemhost.GetSelfMetadata()
    fmt.Println(workerMetadata.WorkerId.WorkerName)
    Get Other Worker's Metadata
    Other worker's metadata can be accessed by using the golemhost.GetWorkerMetadata functions, which expects a golemhost.WorkerID, and returns *golemhost.WorkerMetadata:
    import (
     "fmt"
     
     "github.com/google/uuid"
     
     "github.com/golemcloud/golem-go/golemhost"
    )
     
    workerMetadata := golemhost.GetWorkerMetadata(
     golemhost.WorkerID{
      ComponentID: golemhost.ComponentID(uuid.MustParse("d6520ae9-33c9-47e2-8fe1-0da0e6e568ac")),
      WorkerName:  "worker-1",
     },
    )
    if workerMetadata != nil {
     fmt.Printf("Worker status: %d\n", workerMetadata.Status)
    } else {
     fmt.Printf("Worker not found")
    }
    Enumerate workers
    Worker enumeration is a feature of Golem available both through the public HTTP API and using the WIT interfaces, which have idiomatic Go wrappers in the SDK.
    ⚠️
    Enumerating workers of a component is a slow operation and should not be used as part of the application logic.
    The following example demonstrates how to enumerate workers by using some filters:
    import (
    )
    // returns []golemhost.WorkerMetadata
    results := golemhost.GetWorkers(
     golemhost.ComponentID(uuid.New()),
     &golemhost.WorkerAnyFilter{
      Filters: []golemhost.WorkerAllFilter{
       {
        Filters: []golemhost.WorkerFilter{
         {
          Name:           ptr.New("worker name"),
          NameComparator: golemhost.StringFilterComparatorLike,
         },
         {
          CreatedAt:           ptr.New(time.Now()),
          CreatedAtComparator: golemhost.FilterComparatorLessEqual,
         },
         {
          Version:           ptr.New[uint64](10),
          VersionComparator: golemhost.FilterComparatorNotEqual,
         },
         {
          Status:           ptr.New[golemhost.WorkerStatus](golemhost.WorkerStatusFailed),
          StatusComparator: golemhost.FilterComparatorEqual,
         },
         {
          Env: &golemhost.WorkerEnvFilter{
           Name:  "ENV_VAR",
           Value: "ENV_VAR_VALUE",
          },
          EnvComparator: golemhost.StringFilterComparatorEqual,
         },
        },
       },
      },
     },
    )
    Generate an idempotency key
    Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.
    It is guaranteed that this idempotency key will always be the same (per occurrence) even if the worker is restarted due to a crash.
    To generate and access an idempotency key use the golemhost.GenerateIdempotencyKey functions:
    import (
     "github.com/google/uuid"
     "github.com/golemcloud/golem-go/golemhost"
    )
    result := golemhost.GenerateIdempotencyKey() // returns uuid.UUID
    Last updated on March 28, 2025
    Promises
    Updating Workers
    
  section: Go language guide
  char_count: 3783
  approx_token_count: 946
- id_parent: 57
  title: Updating
  url: https://learn.golem.cloud/go-language-guide/updating
  content: |
    Go Language Guide
    Updating Workers
    Updating workers to newer versions of Go components
    As described in the general Workers page, each worker runs on a specific version of the component it is based on, but it is possible to update a worker to a different version of the same component.
    Automatic update
    The automatic update mode has no Go-specific details and works as it is described in the general Workers page.
    Manual snapshot-based update
    Sometimes the change between two component versions is so large that the only solution to migrate worker's state to a new version is to manually implement this state transfer.
    This is done by implementing a save-snapshot function in the old component and a load-snapshot function in the new component. The snapshot is an array of bytes and it is the responsibility of the user to ensure that the snapshot is compatible between the two versions.
    These functions are defined in the golem:api WIT package and must be explicitly exported from the component's world.
    Last updated on March 28, 2025
    Accessing worker metadata
    WASI
    
  section: Go language guide
  char_count: 1065
  approx_token_count: 267
- id_parent: 58
  title: Wasi
  url: https://learn.golem.cloud/go-language-guide/wasi
  content: |
    Go Language Guide
    WASI
    Using WASI interfaces from Go
    Golem implements and exports a subset of the WASI
    (opens in a new tab)
    interfaces, as well as its own runtime interfaces.
    The Golem Go SDK provides idiomatic wrappers on a subset of these interfaces, but it is also possible to use the generated bindings directly.
    WIT specifications
    The full set of WIT specifications Golem implements is available in the following public repository:
    https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    The following table lists all packages provided by Golem:
    Package Description
    golem:api Golem's Runtime API
    golem:rpc Provides support for Worker to Worker communication
    wasi:blobstore Interface for storing and retrieving large binary data
    wasi:cli Interface for environment variables and standard I/O
    wasi:clocks Interface for querying the system time
    wasi:filesystem Interface for working with files and directories
    wasi:http Interface for making HTTP requests
    wasi:io Interface for working with futures and streams
    wasi:keyvalue Interface for storing and retrieving key-value pairs - only partially implemented
    wasi:logging Interface for logging messages
    wasi:random Interface for generating random numbers
    wasi:sockets Interface for working with TCP and UDP sockets (currently not supporting durable execution)
    Additional Golem runtime APIs
    This section describes Golem-specific functionalities which are available through the Golem runtime API but does not have an idiomatic Go wrapper in the golem-go library yet.
    The WASI Blob Store interface
    The wasi:blobstore interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the worker's memory.
    Last updated on March 28, 2025
    Updating Workers
    Setup
    
  section: Go language guide
  char_count: 1824
  approx_token_count: 456
- id_parent: 59
  title: Setup
  url: https://learn.golem.cloud/js-language-guide/setup
  content: |
    JavaScript Language Guide
    Setup
    Setup development environment for JavaScript
    First install Node.js and npm to your system by following the official instructions
    (opens in a new tab)
    .
    Typescript programs can be compiled into WASM components using the componentize-js and jco npm packages. For Golem you should use our forked version of these tools, as they pin all the dependencies to the ones required by Golem Cloud, and they also include workarounds for some experimental features.
    These tools are using the StarlingMonkey
    (opens in a new tab)
    JavaScript engine to create WASM components from JavaScript.
    The tool packages can be installed globally, but we recommend adding them to your package.json.
    Projects created with golem new will reference the latest versions of the appropriate forked tools.
    In case you want setup you project manually, see the steps for using the Golem JavaScript SDK.
    Install WebAssembly tooling for Worker to Worker communication
    Using Worker to Worker communication requires Rust and WASM tooling, because golem RPC client stubs are generated and implemented as Rust components.
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Last updated on March 28, 2025
    WASI
    Defining Components
    
  section: Js language guide
  char_count: 1399
  approx_token_count: 350
- id_parent: 60
  title: Defining components
  url: https://learn.golem.cloud/js-language-guide/defining-components
  content: |
    JavaScript Language Guide
    Defining Components
    Defining Golem Components in JavaScript
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the JS template:
    golem app new my-app js
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new js my-component
    Specification-first approach
    Golem and the JavaScript toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    To implement the specification written in WIT, the JavaScript code must implement these interfaces and export them in main.js.
    Exporting top-level functions
    WIT allows exporting one or more top-level functions in the world section, for example:
    package golem:demo;
     
    world example {
        export hello-world: func() -> string;
    }
    To implement this function in JavaScript we simply have to export a function with matching names and types in main.js:
    export function helloWorld(): string {
      return "hello";
    }
    ⚠️
    Note that in WIT, identifiers are using the kebab-case naming convention, while JavaScript uses the PascalCase and camelCase convention. The generated bindings map between these are handled automatically.
    During componentization the exported objects and functions are checked against the wit world, eg. if the helloWorld function were not exported, we would get the following error:
    (jco componentize) ComponentError: Expected a JS export definition for 'helloWorld'
    Exporting interfaces
    WIT supports defining and exporting whole interfaces, coupling together multiple functions and possibly custom data types.
    Take the following example:
    package golem:demo;
     
    interface api {
      add: func(value: u64);
      get: func() -> u64;
    }
     
    world example {
      export api;
    }
    This is similar to having the two exported functions directly exported from the world section, but now a matching JavaScript object needs to be exported:
    let state = BigInt(0)
     
    export const api = {
      add(value) {
        console.log(`Adding ${value} to the counter`)
        state += value
      },
      get() {
        return state
      },
    }
    During componentization the exported objects and functions are checked against the wit world, eg. if the get function were not part of the api objects, we would get an error similar to this:
    Exception while pre-initializing: (new Error(main.js source does not export a golem:component/api get function as expected by the world.
    Try defining it on the interface alias api:
        export const api = {
            get () {}
        };,
        "main.bindings.js", 73))
    See the Managing state section below to learn the recommended way of managing state in Golem components, which is required to implement these two functions.
    Exporting resources
    The WIT format supports defining and exporting resources - entities defined by their constructor function and the available methods on them.
    Golem supports exporting these resources as part of the worker's API.
    The following example modifies the previously seen counter example to define it as a resource, getting the counter's name as a constructor parameter:
    package golem:demo;
     
    interface api {
      resource counter {
        constructor(name: string);
        add: func(value: u64);
        get: func() -> u64;
      }
    }
     
    world example {
      export api;
    }
    Resources can have multiple instances within a worker. Their constructor returns a handle which is then used to call the methods on the resource. Learn more about how resources can be implicitly created and invoked through Golem's APIs in the Invocations page.
    To implement the above defined WIT resource in JavaScript a few new steps must be taken:
    define a class representing the resource - it can contain data!
    implement the interface generated as the resource's interface for this class named CounterInstance
    implement the constructor on the component class as defined by the interface CounterStatic
    Let's see in code:
    class Counter {
      name
      state = BigInt(0)
     
      constructor(name) {
        this.name = name
      }
     
      add(value) {
        this.state += value
      }
     
      get() {
        return this.state
      }
    }
     
    export const api = {
      Counter: Counter,
    }
    Data types defined in WIT
    The WIT specifications contains some primitive and higher level data types and also allows defining custom data types which can be used as function parameters and return values on the exported functions, interfaces and resources.
    The following table shows an example of each WIT data type and its corresponding Javascript type:
    WIT Type Javascript Type Notes
    bool boolean
    u8, s8, u16, s16, u32, s32, f32, f64 number
    u64, s64 bigint
    char string Represents a single Unicode character
    string string
    list<T> T[] For most types
    list<u8> Uint8Array Special case for byte arrays
    tuple<T1, T2, ...> [T1, T2, ...]
    record interface Fields become properties
    variant union of interfaces Each case becomes an interface with a tag and optional val
    enum union of string literals
    option<T> T | null If T can be represented as null
    option<T> Option<T> If T cannot be represented as null
    result<T, E> Result<T, E>
    result<_, string> Result<void, string>
    flags interface Each flag becomes an optional boolean property
    resource class Methods become class methods
    The Result type above is expected to be a discriminated union:
    const okResult = { tag: "ok", val: "hello" }
    const errorResult = { tag: "err", val: "error" }
    WIT records
    The following WIT record type:
    package golem:demo;
     
    interface api {
        record user {
            id: u64,
            name: string,
        }
    }
    Will expect the following JavaScript object:
    const user = {
      id: BigInt(1),
      name: "name",
    }
    WIT variants
    The following WIT variant type:
    package golem:demo;
     
    interface api {
        variant color {
            red,
            green,
            blue,
            rgb(string)
        }
    }
    Will expect a JavaScript tagged union:
    const colorRed = {"tag": "red"};
    const colorRgb = {"tag": "rgb", val: "#ff00ff"};
    WIT enums
    The following WIT enum type:
    package golem:demo;
     
    interface api {
        enum color {
            red,
            green,
            blue
        }
    }
    Will expect a JavaScript string matching the above enum cases:
    const color = "green";
    WIT flags
    The following WIT flags type:
    package golem:demo;
     
    interface api {
        flags access {
            read,
            write,
            lst
        }
    }
    Will expect a JavaScript object:
    const access = {
      read: true,
      write: false,
      // some of the flags can be omitted, like `lst` in this example
    }
    Worker configuration
    It is often required to pass configuration values to workers when they are started.
    In general Golem supports three different ways of doing this:
    Defining a list of string arguments passed to the worker, available as command line arguments
    Defining a list of key-value pairs passed to the worker, available as environment variables.
    Using resource constructors to pass configuration values to the worker.
    Command line arguments and environment variables
    Command line arguments and environment variables are accessible through the generated bindings:
    import { getArguments, getEnvironment } from "wasi:cli/environment@0.2.0"
     
    const args = getArguments() // returns []string
    const env = getEnvironment() // returns [string, string][]
    Environment variables can be specified when a worker is explicitly created, but there are some environment variables that are always set by Golem:
    GOLEM_WORKER_NAME - the name of the worker
    GOLEM_COMPONENT_ID - the ID of the worker's component
    GOLEM_COMPONENT_VERSION - the version of the component used for this worker
    In addition to these, when using Worker to Worker communication, workers created by remote calls inherit the environment variables of the caller.
    This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of workers.
    Resource constructors
    As explained earlier, Golem workers can export resources and these resources can have constructor parameters.
    Although resources can be used in many ways, one pattern for Golem is only create a single instance of the exported resource in each worker, and use it to pass configuration values to the worker. This is supported by Golem's worker invocation syntax directly, allowing to implicitly create workers and the corresponding resource by a single invocation as described on the Invocations page.
    Managing state
    Golem workers are stateful. There are two major techniques to store and manipulate state in a Golem worker implemented in JavaScript:
    Using a global variable
    Using resources and storing state in the resource's class
    All techniques were demonstrated above in the code examples.
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Js language guide
  char_count: 9237
  approx_token_count: 2310
- id_parent: 61
  title: Building components
  url: https://learn.golem.cloud/js-language-guide/building-components
  content: |
    JavaScript Language Guide
    Building Components
    Building Golem Components in JavaScript
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Under the hood
    Building Golem components written in JavaScript requires a series of steps.
    If the project was created with golem app new, it already has a package.json that incorporates all the necessary steps as npm scripts to build the component, so it is enough to run:
    npm run componentize
    In details, building the component requires the following steps:
    Compile the JavaScript code to JavaScript
    The examples use rollup through an npm script:
    $ npm run build
    This will compile all the JavaScript sources into a single JavaScript file at out/main.js.
    Componentizing the JavaScript code
    The final step is componentizing, which involves:
    embedding our JavaScript code into the StarlingMonkey JS engine
    running Wizer pre-initialization, which pre-loads and parses our Javascript source in the JS engine
    creating the wasm output file for our component with it's interface exposed as a WebAssembly component usable by Golem.
    The example projects includes an npm script called componentize, which also includes the previous build step.
    $ npm run componentize
    The output wasm file with be created with the built component name, eg.: out/example.wasm.
    The above npm script will execute the following commands:
    $ npm run build && jco componentize -w wit -o out/example.wasm out/main.js
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Js language guide
  char_count: 1938
  approx_token_count: 485
- id_parent: 62
  title: Next steps
  url: https://learn.golem.cloud/js-language-guide/next-steps
  content: |
    JavaScript Language Guide
    Next Steps
    Next steps
    After setting up the JavaScript development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Making HTTP requests from a Golem component
    Learn how to send HTTP requests from a Golem component written in JavaScript.
    Control durability guarantees
    Check how the JavaScript Golem SDK can control various durability settings of Golem.
    Automatic retries
    Learn about Golem's retry mechanism and how it can be customized.
    Transactions
    Use the higher level transactions library to implement the Saga pattern.
    Promises
    Create and use promises to await external events from within a running worker.
    Using WASI interfaces
    See what low-level WASI interfaces are available and how they can be used from JavaScript.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    Setting up the Golem JS SDK
    
  section: Js language guide
  char_count: 1088
  approx_token_count: 272
- id_parent: 63
  title: Golem js sdk
  url: https://learn.golem.cloud/js-language-guide/golem-js-sdk
  content: |
    JavaScript Language Guide
    Setting up the Golem JS SDK
    Setting up the Golem JavaScript SDK
    ⚠️
    If the project was created with golem new, it already has the Golem JavaScript SDK set up and these steps can be ignored.
    The Golem JavaScript SDK is the same as the Golem TypeScript SDK. The published SDK is usable from JavaScript, as it is bundled as JavaScript.
    If setting up the Golem JavaScript SDK
    (opens in a new tab)
    manually, the following steps are required:
    Create a new project
    npm
    pnpm
    yarn
    bun
    npm init
    Ensure ESM is enabled
    In your package.json file, ensure the type is set to module.
    package.json
    {
      "type": "module"
    }
    Install Dev Dependencies
    The Golem JavaScript SDK currently relies on forked versions of jco
    (opens in a new tab)
    and componentize-js
    (opens in a new tab)
    .
    npm
    pnpm
    yarn
    bun
    npm install --save-dev @golemcloud/componentize-js @golemcloud/golem-ts @golemcloud/jco @rollup/plugin-node-resolve@^15.2.3 rollup@^4.18.0
    Add Rollup Config: rollup.config.mjs
    To silence rollup warnings, add WIT imports to the external array.
    rollup.config.mjs
    import resolve from "@rollup/plugin-node-resolve"
     
    export default {
      input: "src/main.js",
      output: {
        file: "out/main.js",
        format: "esm",
      },
      external: [
        "golem:api/host@1.1.0",
        "golem:rpc/types@0.1.0",
        "wasi:blobstore/blobstore",
        "wasi:blobstore/container",
        "wasi:cli/environment@0.2.0",
        "wasi:clocks/wall-clock@0.2.0",
        "wasi:clocks/monotonic-clock@0.2.0",
        "wasi:filesystem/preopens@0.2.0",
        "wasi:filesystem/types@0.2.0",
        "wasi:http/types@0.2.0",
        "wasi:http/outgoing-handler@0.2.0",
        "wasi:io/error@0.2.0",
        "wasi:io/poll@0.2.0",
        "wasi:io/streams@0.2.0",
        "wasi:keyvalue/eventual-batch@0.1.0",
        "wasi:keyvalue/eventual@0.1.0",
        "wasi:logging/logging",
        "wasi:random/random@0.2.0",
        "wasi:random/insecure@0.2.0",
        "wasi:random/insecure-seed@0.2.0",
        "wasi:sockets/ip-name-lookup@0.2.0",
        "wasi:sockets/instance-network@0.2.0",
      ],
      plugins: [resolve()],
    }
    Add scripts to package.json
    package.json
    {
      "scripts": {
        "build": "rollup --config",
        "componentize": "npm run build && jco componentize -w wit -o out/component_name.wasm out/main.js",
        "clean": "rm -rf out src/generated"
      }
    }
    build - Packages the Javascript into a single file.
    componentize - Bundles the Javascript into a WebAssembly module.
    clean - Cleans up the project by removing the generated files.
    Verify package.json
    Ensure the scripts and devDependencies sections are correct (versions may differ).
    package.json
    {
      "type": "module",
      "scripts": {
        "stub": "jco stubgen wit -o src/generated",
        "build": "rollup --config",
        "componentize": "npm run stub && npm run build && jco componentize -w wit -o out/component_name.wasm out/main.js",
        "clean": "rm -rf out src/generated"
      },
      "devDependencies": {
        "@golemcloud/componentize-js": "0.10.5-golem.3",
        "@golemcloud/golem-ts": "1.1.0",
        "@golemcloud/jco": "1.4.4-golem.1",
        "@rollup/plugin-node-resolve": "^15.2.3",
        "rollup": "^4.18.0"
      }
    }
    Add all the supported WIT files into the project
    The project's wit/deps directory must contain all the WIT files from the golem-wit
    (opens in a new tab)
    repository.
    Either clone the repository and copy the wit/deps directory into your project, or run the following command to download the WIT files:
    macOS/Linux
    Windows
    curl -L https://github.com/golemcloud/golem-wit/archive/refs/heads/main.zip | tar -xvf- -C . --strip-components=2 "golem-wit-main/wit/deps" && mkdir -p ./wit/deps && mv deps/* ./wit/deps/ && rm -rf deps/
    The resulting directory structure should look like this:
    src
    wit
    main.wit
    deps
    blobstore
    cli
    clocks
    filesystem
    golem
    http
    io
    keyvalue
    logging
    random
    sockets
    wasm-rpc
    Importing WITs into the component's world:
    If the project's WIT file was like this:
    package golem:demo;
     
    world ts-example {
      export api;
    }
    Modify it in the following way:
    package golem:demo;
     
    world ts-example {
      import golem:api/host@1.1.0;
      import golem:rpc/types@0.1.0;
     
      import wasi:blobstore/blobstore;
      import wasi:blobstore/container;
      import wasi:cli/environment@0.2.0;
      import wasi:clocks/wall-clock@0.2.0;
      import wasi:clocks/monotonic-clock@0.2.0;
      import wasi:filesystem/preopens@0.2.0;
      import wasi:filesystem/types@0.2.0;
      import wasi:http/types@0.2.0;
      import wasi:http/outgoing-handler@0.2.0;
      import wasi:io/error@0.2.0;
      import wasi:io/poll@0.2.0;
      import wasi:io/streams@0.2.0;
      import wasi:keyvalue/eventual-batch@0.1.0;
      import wasi:keyvalue/eventual@0.1.0;
      import wasi:logging/logging;
      import wasi:random/random@0.2.0;
      import wasi:random/insecure@0.2.0;
      import wasi:random/insecure-seed@0.2.0;
      import wasi:sockets/ip-name-lookup@0.2.0;
      import wasi:sockets/instance-network@0.2.0;
     
      export api;
    }
    Last updated on March 28, 2025
    Next Steps
    HTTP client
    
  section: Js language guide
  char_count: 4854
  approx_token_count: 1214
- id_parent: 64
  title: Http
  url: https://learn.golem.cloud/js-language-guide/http
  content: |
    JavaScript Language Guide
    HTTP client
    HTTP requests in JavaScript
    ⚠️
    Currently HTTP and fetch support is experimental. The Golem JavaScript SDK has temporary workarounds to make HTTP requests possible, but bugs and breaking changes are expected in this area.
    Golem implements the WASI HTTP
    (opens in a new tab)
    interfaces so any library built on this specification can be used from Golem components to communicate with external services.
    HTTP request can be made with the JavaScript standard builtin fetch function, but handling the asynchronous return values inside the synchronous component functions requires helpers from the Golem JavaScript SDK.
    The SDK
    (opens in a new tab)
    provides asyncToSync and asyncToSyncAsResult functions to wait for Promises.
    The asyncToSync function throws exceptions in case the Promise is failed, while the asyncToSyncAsResult returns a Result<T, E> type, which is defined in the SDK
    (opens in a new tab)
    .
    import { asyncToSync, asyncToSyncAsResult, Result } from "@golemcloud/golem-ts"
     
    // Using asyncToSyncAsResult to await for fetch results as Result
    const result = asyncToSyncAsResult(fetch("https://localhost:8080").then(result => result.text()))
     
    const text = result.match(
      text => text,
      err => {
        console.error(err)
        return "failed"
      }
    )
     
    // Using asyncToSync to await for fetch results which might throw exceptions in case of errors
    try {
      const text = asyncToSync(fetch("https://localhost:8080").then(result => result.text()))
    } catch (err) {
      console.log(err)
    }
    Last updated on March 28, 2025
    Setting up the Golem JS SDK
    Durability
    
  section: Js language guide
  char_count: 1591
  approx_token_count: 398
- id_parent: 65
  title: Durability
  url: https://learn.golem.cloud/js-language-guide/durability
  content: |
    JavaScript Language Guide
    Durability
    Control durability guarantees from JavaScript
    Golem provides a set of functions components can call to control details of the durable execution engine. For components implemented in JavaScript the Golem JavaScript SDK provides a set of JavaScript wrappers for these functions.
    Setting up the Golem JavaScript SDK
    If the project was created with golem new, it already has the Golem JavaScript SDK set up, otherwise follow the step at Setting up the Golem JavaScript SDK
    General concepts
    The library allows controlling four main aspects of the durable execution engine: the current persistence level, the idempotence mode, defining atomic regions and changing retry policies (discussed in the next page).
    All these features are regional - they can be changed for a section of the code within a single exported function. To make this easy to use in JavaScript, the library provides functions starting with with, they take a closure parameter which will be executed with the requested mode, and then they restore the previous settings.
    Persistence level
    The persistence level can be one of the following:
    Level Description
    PersistNothing Turns off persistence for a section. In case the worker is recovered or restarted, all the side-effecting functions will be reexecuted
    PersistRemoteSideEffects Persists all the side-effects that are affecting the outside world. In case of recovery the side-effects won't be reexecuted and the persisted results will be used.
    Smart The default setting; Let Golem decide what to persist to optimize performance
    To change the persistence level for a section of the code, use the withPersistenceLevel function:
    import { withPersistenceLevel } from "@golemcloud/golem-ts"
     
    const result = withPersistenceLevel({ tag: "persist-nothing" }, () => {
      // this closure runs in PersistNothing mode
      return "hello"
    })
    Idempotence mode
    Golem assumes that HTTP requests are idempotent by default. This means that in case of a failure, if the system cannot determine whether the request successfully reached the target or not, it will be retried. This behavior can be changed using the withIdempotenceMode function:
    import { withIdempotenceMode } from "@golemcloud/golem-ts"
     
    const result = withIdempotenceMode(false, () => {
      // this closure runs with idempotence mode disabled
      return "hello"
    })
    With disabled idempotence mode, in case Golem cannot determine if the request was sent or not, it won't retry it but the worker will fail.
    Atomic regions
    By default, side effects are persisted and retried one by one. It is possible to group them together into atomic regions, in which case the execution is retried for some reason (the worker failed or interrupted within the region), all the side effects will be reexecuted.
    The golem-ts library exports the atomically function for using atomic regions:
    import { atomically } from "@golemcloud/golem-ts"
     
    const result = atomically(() => {
      const firstResult = firstSideEffect()
      const secondResult = secondSideEffect(firstResult)
      return [firstResult, secondResult]
    })
    Commit oplog
    The oplogCommit function in "@golemcloud/golem-ts waits until the oplog is committed to its persistent storage. The function takes a single argument, replicas, with the desired number of storage replicas the worker's journal is replicated to. The function will block until the oplog is committed to the specified number of replicas, or, if this number is larger than the available number of replicas, until it is written to all the replicas.
    Last updated on March 28, 2025
    HTTP client
    Retries
    
  section: Js language guide
  char_count: 3587
  approx_token_count: 897
- id_parent: 66
  title: Retries
  url: https://learn.golem.cloud/js-language-guide/retries
  content: |
    JavaScript Language Guide
    Retries
    Control the retry policy from JavaScript
    Using Golem's retry mechanism
    Golem applies a retry mechanism to all workers. In case of a failure, Golem will automatically recover the worker to the point before the failure and retry the operation. An exponential backoff and an upper limit on the number of retries are applied.
    If the maximum number of retries is reached, the worker will be marked as failed and no further invocations will be possible on it.
    This mechanism is automatic and applied to all kind of failures. To rely on it, just throw an unhandled exception.
    Customizing the retry policy
    The retry policy which controls the maximum number of retries and the exponential backoff is a global configuration of the Golem servers, but it can be customized for each worker.
    The golem-ts library exports the withRetryPolicy function to temporarily change the retry policy:
    import { withRetryPolicy } from "@golemcloud/golem-ts"
     
    // Durations are expected as nanoseconds
    const result = withRetryPolicy(
      {
        maxAttempts: 3,
        minDelay: BigInt(100 * 1000 * 1000), // 100 milliseconds
        maxDelay: BigInt(2 * 1000 * 1000 * 1000), // 2 seconds
        multiplier: 1.5,
        maxJitterFactor: null,
      },
      () => {
        // this closure runs with the custom retry policy
        return "hello"
      }
    )
    The RetryPolicy interface required by withRetryPolicy is generated from Golem's WIT definition:
    /// Configures how the executor retries failures
    record retry-policy {
        /// The maximum number of retries before the worker becomes permanently failed
        max-attempts: u32,
        /// The minimum delay between retries (applied to the first retry)
        min-delay: duration,
        /// The maximum delay between retries
        max-delay: duration,
        /// Multiplier applied to the delay on each retry to implement exponential backoff
        multiplier: f64,
        /// The maximum amount of jitter to add to the delay
        max-jitter-factor: option<f64>
    }
    Last updated on March 28, 2025
    Durability
    Transactions
    
  section: Js language guide
  char_count: 2018
  approx_token_count: 505
- id_parent: 67
  title: Transactions
  url: https://learn.golem.cloud/js-language-guide/transactions
  content: |
    JavaScript Language Guide
    Transactions
    High level transactions in JavaScript
    On top of the durability controls and retry controls, the golem-ts
    (opens in a new tab)
    library also provides a high level functions for defining transactions supporting compensation actions in case of getting reverted.
    Although Golem's automatic retry policies and low level atomic regions provide a lot of power automatically, many times a set of external operations such as HTTP requests needs to be executed transactionally; if one of the operations fails, the whole transaction need to be rolled back by executing some compensation actions.
    The golem-ts library provides support for two different types of transactions:
    fallible transactions are only dealing with domain errors
    infallible transactions must always succeed, and Golem applies its active retry policy to it
    Fallible transactions
    Many times external operations (such as HTTP calls to remote hosts) need to be executed transactionally. If some of the operations failed the transaction need to be rolled back - compensation actions need to undo whatever the already successfully performed operations did.
    A fallible transaction only deals with domain errors. Within the transaction every operation that succeeds gets recorded. If an operation fails, all the recorded operations get compensated in reverse order before the transaction block returns with a failure.
    A fallible transaction can be executed using the fallibleTransaction function, by passing a closure that can execute operations on the open transaction (see below).
    Infallible transactions
    An infallible transaction must always succeed - in case of a failure or interruption, it gets retried. If there is a domain error, the compensation actions are executed before the retry.
    An infallible transaction can be executed using the infallibleTransaction function, by passing a closure that can execute operations on the open transaction (see below).
    Operations
    Both transaction types require the definition of operations.
    As documentation, here is the TypeScript interface that operations has to match:
    /**
     * Represents an atomic operation of the transaction which has a rollback action.
     *
     * Implement this interface and use it within a `transaction` block.
     * Operations can also be constructed from closures using `operation`.
     */
    export interface Operation<In, Out, Err> {
      /**
       * The action to execute.
       * @param input - The input to the operation.
       * @returns The result of the operation.
       */
      execute(input: In): Result<Out, Err>
      /**
       * Compensation to perform in case of failure.
       * Compensations should not throw errors.
       * @param input - The input to the operation.
       * @param result - The result of the operation.
       * @returns The result of the compensation.
       */
      compensate(input: In, result: Out): Result<void, Err>
    }
    In JavaScript there are two ways to define an operation that matches the above interface:
    Implement the Operation interface manually
    const op = {
      execute(input) {
        // execute operation, then return success
        return Result.ok({ id: "value" })
        // or error
        // return Result.err("error");
      },
      compensate(input, result) {
        // revert operation, then return success
        return Result.unit()
        // or error
        // return Result.err("error");
      },
    }
    Use the operation function to create an operation from a pair of closures
    const op = operation(
      input => {
        // execute operation, then return success
        return Result.ok({ id: "value" })
        // or error
        // return Result.err("error");
      },
      (input, result) => {
        return Result.unit()
        // or error
        // return Result.err("error");
      }
    )
    Executing operations
    The defined operations can be executed in fallible or infallible mode:
    import { fallibleTransaction, infallibleTransaction, operation, Result } from "@golemcloud/golem-ts"
     
    // example operation with compensation
    const op = operation(
      idx => {
        // the operation / side effect
        return Result.ok("id-" + idx)
      },
      (id, idx) => {
        // compensation
        console.log(`reverting ${id}, ${idx}`)
        return Result.unit()
      }
    )
     
    // with fallibleTransaction errors have to be handled and propagated using the Result type
    const resultFallible = fallibleTransaction(tx => {
      return tx
        .execute(op, 1)
        .flatMap(firstId => tx.execute(op, 2).map(secondId => [firstId, secondId]))
    })
     
    // with infallibleTransaction no explicit error handling is needed, as it is handled by Golem retries
    const resultInfallible = infallibleTransaction(tx => {
      const firstId = tx.execute(op, 1)
      const secondId = tx.execute(op, 1)
      return [firstId, secondId]
    })
    Last updated on March 28, 2025
    Retries
    Promises
    
  section: Js language guide
  char_count: 4698
  approx_token_count: 1175
- id_parent: 68
  title: Promises
  url: https://learn.golem.cloud/js-language-guide/promises
  content: |
    JavaScript Language Guide
    Promises
    Working with Golem Promises in JavaScript
    Golem promises provide a way for Golem workers to wait on an external condition. The worker creates the promise and somehow sends its identifier to the external system responsible for completing the promise. Then the worker can await the promise, being suspended until the external system completes the promise using Golem's REST API.
    It is also possible to complete a promise from within a Golem worker using the Golem SDK.
    When a promise is completed, an arbitrary byte array can be attached to it as a payload - this data is returned to the awaiting worker when is continues execution.
    In JavaScript the promise API has idiomatic JavaScript wrappers in the Golem JavaScript SDK.
    Creating a promise
    To create a promise simply call the createPromise function:
    import { createPromise, PromiseId } from "@golemcloud/golem-ts"
     
    const promiseId = createPromise()
    The returned value has the following shape:
    // A promise ID is a value that can be passed to an external Golem API to complete that promise
    // from an arbitrary external source, while Golem workers can await for this completion.
    const promiseId = {
      // Represents the worker
      workerId: {
        // Represents the component
        componentId: {
          uuid: {
            highBits: BigInt(0),
            lowBits: BigInt(0),
          },
        },
        workerName: "worker-name",
      },
      oplogIdx: BigInt(0),
    }
    Deleting a promise
    If a promise is no longer used, it has to be deleted with:
    import { deletePromise } from "@golemcloud/golem-ts"
     
    deletePromise(promiseId)
    Awaiting a promise
    To await a promise, use the awaitPromise functions, which returns the promise result as a byte array payload. Here's an example that awaits a promise, then decodes the payload from JSON format:
    import { awaitPromise } from "@golemcloud/golem-ts"
     
    const byteArrayPayload = awaitPromise(promiseId) // returns Uint8Array;
    const payload = JSON.parse(new TextDecoder().decode(byteArrayPayload))
    Completing a promise from within a worker
    To complete a promise from within a worker, use the completePromise function. The following example completes a promise with a value encoded as JSON:
    import { completePromise } from "@golemcloud/golem-ts"
     
    const payload = {
      id: "value",
      meta: "data",
    }
    const byteArrayPayload = new TextEncoder().encode(JSON.stringify(payload)) // create Uint8Array payload;
    const success = completePromise(promiseId, byteArrayPayload) // returns boolean;
    Completing a promise from an external source
    To see how to use the promise ID to complete a promise through the external REST API, check the REST API documentation.
    Last updated on March 28, 2025
    Transactions
    Updating Workers
    
  section: Js language guide
  char_count: 2706
  approx_token_count: 677
- id_parent: 69
  title: Updating
  url: https://learn.golem.cloud/js-language-guide/updating
  content: |
    JavaScript Language Guide
    Updating Workers
    Updating workers to newer versions of JavaScript components
    As described in the general Workers page, each worker runs on a specific version of the component it is based on, but it is possible to update a worker to a different version of the same component.
    Automatic update
    The automatic update mode has no JavaScript-specific details and works as it is described in the general Workers page.
    Manual snapshot-based update
    Sometimes the change between two component versions is so large that the only solution to migrate worker's state to a new version is to manually implement this state transfer.
    This is done by implementing a save-snapshot function in the old component and a load-snapshot function in the new component. The snapshot is an array of bytes and it is the responsibility of the user to ensure that the snapshot is compatible between the two versions.
    These functions are defined in the golem:api WIT package and must be explicitly exported from the component's world.
    Last updated on March 28, 2025
    Promises
    WASI
    
  section: Js language guide
  char_count: 1072
  approx_token_count: 268
- id_parent: 70
  title: Wasi
  url: https://learn.golem.cloud/js-language-guide/wasi
  content: |
    JavaScript Language Guide
    WASI
    Using WASI interfaces from JavaScript
    Golem implements and exports a subset of the WASI
    (opens in a new tab)
    interfaces, as well as its own runtime interfaces.
    The Golem JavaScript SDK provides idiomatic wrappers on a subset of these interfaces, but it is also possible to use the generated bindings directly.
    WIT specifications
    The full set of WIT specifications Golem implements is available in the following public repository:
    https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    The following table lists all packages provided by Golem:
    Package Description
    golem:api Golem's Runtime API
    golem:rpc Provides support for Worker to Worker communication
    wasi:blobstore Interface for storing and retrieving large binary data
    wasi:cli Interface for environment variables and standard I/O
    wasi:clocks Interface for querying the system time
    wasi:filesystem Interface for working with files and directories
    wasi:http Interface for making HTTP requests
    wasi:io Interface for working with futures and streams
    wasi:keyvalue Interface for storing and retrieving key-value pairs - only partially implemented
    wasi:logging Interface for logging messages
    wasi:random Interface for generating random numbers
    wasi:sockets Interface for working with TCP and UDP sockets (currently not supporting durable execution)
    Bindings
    The JavaScript bindings for the WASI and Golem-specific interfaces are provided in the golem:api/host@0.2.0 module. You can import and use these bindings in your JavaScript code.
    Additional Golem runtime APIs
    This section describes Golem-specific functionalities which are available through the Golem runtime API.
    Generate an idempotency key
    Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.
    It is guaranteed that this idempotency key will always be the same (per occurrence) even if the worker is restarted due to a crash.
    To generate an idempotency key:
    import { generateIdempotencyKey } from "golem:api/host@1.1.0"
     
    const key = generateIdempotencyKey()
    Get worker metadata
    It is possible to query metadata for Golem workers. This metadata includes information such as worker ID, arguments, environment variables, status, component version, and retry count.
    There are two exported functions to query worker metadata:
    getSelfMetadata() returns the metadata for the current worker
    getWorkerMetadata(workerId) returns the metadata for a specific worker given by its workerId
    Enumerate workers
    Worker enumeration is a feature of Golem available both through the public HTTP API and using the WIT interfaces.
    ⚠️
    Enumerating workers of a component is a slow operation and should not be used as part of the application logic.
    The following example demonstrates how to use the worker enumeration API:
    import { GetWorkers } from "golem:api/host@1.1.0"
     
    const componentId = {
      /* ... */
    }
     
    const filter = {
      filters: [
        {
          filters: [
            {
              tag: "status",
              val: {
                comparator: "equal",
                value: "idle",
              },
            },
          ],
        },
      ],
    }
     
    const workers = []
    const getter = new GetWorkers(componentId, filter, true)
     
    let batch
    while ((batch = getter.getNext()) !== undefined) {
      workers.push(...batch)
    }
     
    console.log("Retrieved workers:", workers)
    The third parameter of the GetWorkers constructor enables precise mode. In this mode, Golem will calculate the latest metadata for each returned worker; otherwise, it uses only the last cached values.
    Update a worker
    To trigger an update for a given worker from one component version to another, use the updateWorker function:
    import { updateWorker } from "golem:api/host@1.1.0"
     
    const workerId = {
      /* ... */
    }
     
    const targetVersion = 1n
     
    updateWorker(workerId, targetVersion, "automatic")
    To learn more about updating workers, see the updating workers page in the documentation.
    The WASI Key-Value store interface
    Although Golem workers can store their state completely in their own memory, it is possible to use the wasi:keyvalue interface to store key-value pairs in a Golem managed key value storage.
    This can be useful if state needs to be shared between different workers or if the size of this state is too large to be stored in memory.
    The WASI Blob Store interface
    The wasi:blobstore interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the worker's memory.
    Last updated on March 28, 2025
    Updating Workers
    Setup
    
  section: Js language guide
  char_count: 4632
  approx_token_count: 1158
- id_parent: 71
  title: Setup
  url: https://learn.golem.cloud/ts-language-guide/setup
  content: |
    TypeScript Language Guide
    Setup
    Setup development environment for TypeScript
    First install Node.js and npm to your system by following the official instructions
    (opens in a new tab)
    .
    Typescript programs can be compiled into WASM components using the componentize-js and jco npm packages. For Golem you should use our forked version of these tools, as they pin all the dependencies to the ones required by Golem Cloud, and they also include workarounds for some experimental features.
    These tools are using the StarlingMonkey
    (opens in a new tab)
    JavaScript engine to create WASM components from JavaScript.
    The tool packages can be installed globally, but we recommend adding them to your package.json.
    Projects created with golem new will reference the latest versions of the appropriate forked tools.
    In case you want setup you project manually, see the steps for using the Golem TypeScript SDK.
    Install WebAssembly tooling for Worker to Worker communication
    Using Worker to Worker communication requires Rust and WASM tooling, because golem RPC client stubs are generated and implemented as Rust components.
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Last updated on March 28, 2025
    WASI
    Defining Components
    
  section: Ts language guide
  char_count: 1399
  approx_token_count: 350
- id_parent: 72
  title: Defining components
  url: https://learn.golem.cloud/ts-language-guide/defining-components
  content: |
    TypeScript Language Guide
    Defining Components
    Defining Golem Components in TypeScript
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the TS template:
    golem app new my-app ts
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new ts my-component
    Specification-first approach
    Golem and the TypeScript toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    The first time a component is compiled (see the Building Components page for details), a couple of files get generated in a subdirectory named src/generated. The generated sources contain the definitions of all the data types and interfaces defined in the WIT file(s) as TypeScript types and interfaces.
    To implement the specification written in WIT, the TypeScript code must implement some of these generated interfaces and export them in main.ts.
    Exporting top-level functions
    WIT allows exporting one or more top-level functions in the world section, for example:
    package golem:demo;
     
    world example {
        export hello-world: func() -> string;
    }
    To implement this function in TypeScript we simply have to export a function with matching names and types in main.ts:
    export function helloWorld(): string {
      return "hello"
    }
    ⚠️
    Note that in WIT, identifiers are using the kebab-case naming convention, while TypeScript uses the PascalCase and camelCase convention. The generated bindings map between these are handled automatically.
    Exporting interfaces
    WIT supports defining and exporting whole interfaces, coupling together multiple functions and possibly custom data types.
    Take the following example:
    package golem:demo;
     
    interface api {
      add: func(value: u64);
      get: func() -> u64;
    }
     
    world example {
      export api;
    }
    This is similar to having the two exported functions directly exported from the world section, but there is a corresponding TypeScript interface generated that needs to be separately implemented and exported:
    import { Api } from "./generated/example.js"
     
    let state = BigInt(0)
     
    export const api: Api = {
      add(value: bigint) {
        console.log(`Adding ${value} to the counter`)
        state += value
      },
      get(): bigint {
        return state
      },
    }
    Using the generated interfaces also helps during development, as it can guide IDEs and the TypeScript compiler to create the expected exports.
    See the Managing state section below to learn the recommended way of managing state in Golem components, which is required to implement these two functions.
    Exporting resources
    The WIT format supports defining and exporting resources - entities defined by their constructor function and the available methods on them.
    Golem supports exporting these resources as part of the worker's API.
    The following example modifies the previously seen counter example to define it as a resource, getting the counter's name as a constructor parameter:
    package golem:demo;
     
    interface api {
      resource counter {
        constructor(name: string);
        add: func(value: u64);
        get: func() -> u64;
      }
    }
     
    world example {
      export api;
    }
    Resources can have multiple instances within a worker. Their constructor returns a handle which is then used to call the methods on the resource. Learn more about how resources can be implicitly created and invoked through Golem's APIs in the Invocations page.
    To implement the above defined WIT resource in TypeScript a few new steps must be taken:
    define a class representing the resource - it can contain data!
    implement the interface generated as the resource's interface for this class named CounterInstance
    implement the constructor on the component class as defined by the interface CounterStatic
    ⚠️
    The CounterStatic interface cannot be implemented by the Counter class, but the constructor in Counter will be checked against the new method defined in CounterStatic.
    Let's see in code:
    import { Api, CounterInstance, CounterStatic } from "./generated/example.js"
     
    class Counter implements CounterInstance {
      name: string
      state = BigInt(0)
     
      constructor(name: string) {
        this.name = name
      }
     
      add(value: bigint): void {
        this.state += value
      }
     
      get(): bigint {
        return this.state
      }
    }
     
    export const api: Api = {
      Counter: Counter,
    }
    Data types defined in WIT
    The WIT specifications contains some primitive and higher level data types and also allows defining custom data types which can be used as function parameters and return values on the exported functions, interfaces and resources.
    The following table shows an example of each WIT data type and its corresponding TypeScript type:
    WIT Type Typescript Type Notes
    bool boolean
    u8, s8, u16, s16, u32, s32, f32, f64 number
    u64, s64 bigint
    char string Represents a single Unicode character
    string string
    list<T> T[] For most types
    list<u8> Uint8Array Special case for byte arrays
    tuple<T1, T2, ...> [T1, T2, ...]
    record interface Fields become properties
    variant union of interfaces Each case becomes an interface with a tag and optional val
    enum union of string literals
    option<T> T | null If T can be represented as null
    option<T> Option<T> If T cannot be represented as null
    result<T, E> Result<T, E>
    result<_, string> Result<void, string>
    flags interface Each flag becomes an optional boolean property
    resource class Methods become class methods
    Note: The Option and Result types are automatically included in the generated TypeScript if they are detected in the WIT interface.
    They are defined as follows:
    export type Option<T> = { tag: "none" } | { tag: "some"; val: T }
    export type Result<T, E> = { tag: "ok"; val: T } | { tag: "err"; val: E }
    WIT records
    The following WIT record type:
    package golem:demo;
     
    interface api {
        record user {
            id: u64,
            name: string,
        }
    }
    Will generate the following TypeScript interface:
    export interface User {
      id: bigint
      name: string
    }
    WIT variants
    The following WIT variant type:
    package golem:demo;
     
    interface api {
        variant color {
            red,
            green,
            blue,
            rgb(u32),
            hex-color(string),
        }
    }
    Will generate the following TypeScript discriminated union:
    export type Color = ColorRed | ColorGreen | ColorBlue | ColorRgb;
    export interface ColorRed {
      tag: 'red',
    }
    export interface ColorGreen {
      tag: 'green',
    }
    export interface ColorBlue {
      tag: 'blue',
    }
    export interface ColorRgb {
      tag: 'rgb',
      val: number,
    }
    export interface ColorHexColor {
      tag: 'hex-color',
      val: string,
    }
    WIT enums
    The following WIT enum type:
    package golem:demo;
     
    interface api {
        enum color {
            red,
            green,
            blue
        }
    }
    Will generate the following Typescript union:
    export type Color = 'red' | 'green' | 'blue';
    and a set of helper functions.
    WIT flags
    The following WIT flags type:
    package golem:demo;
     
    interface api {
        flags access {
            read,
            write,
            lst
        }
    }
    Will generate the following TypeScript interface:
    export interface Access {
      read?: boolean
      write?: boolean
      lst?: boolean
    }
    Worker configuration
    It is often required to pass configuration values to workers when they are started.
    In general Golem supports three different ways of doing this:
    Defining a list of string arguments passed to the worker, available as command line arguments
    Defining a list of key-value pairs passed to the worker, available as environment variables.
    Using resource constructors to pass configuration values to the worker.
    Command line arguments and environment variables
    Command line arguments and environment variables are accessible through the generated bindings:
    import { getArguments, getEnvironment } from "wasi:cli/environment@0.2.0"
     
    const args: string[] = getArguments()
    const env: [string, string][] = getEnvironment()
    Environment variables can be specified when a worker is explicitly created, but there are some environment variables that are always set by Golem:
    GOLEM_WORKER_NAME - the name of the worker
    GOLEM_COMPONENT_ID - the ID of the worker's component
    GOLEM_COMPONENT_VERSION - the version of the component used for this worker
    In addition to these, when using Worker to Worker communication, workers created by remote calls inherit the environment variables of the caller.
    This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of workers.
    Resource constructors
    As explained earlier, Golem workers can export resources and these resources can have constructor parameters.
    Although resources can be used in many ways, one pattern for Golem is only create a single instance of the exported resource in each worker, and use it to pass configuration values to the worker. This is supported by Golem's worker invocation syntax directly, allowing to implicitly create workers and the corresponding resource by a single invocation as described on the Invocations page.
    Managing state
    Golem workers are stateful. There are two major techniques to store and manipulate state in a Golem worker implemented in TypeScript:
    Using a global variable
    Using resources and storing state in the resource's class
    All techniques were demonstrated above in the code examples.
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Ts language guide
  char_count: 9878
  approx_token_count: 2470
- id_parent: 73
  title: Building components
  url: https://learn.golem.cloud/ts-language-guide/building-components
  content: |
    TypeScript Language Guide
    Building Components
    Building Golem Components in TypeScript
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Under the hood
    Building Golem components written in TypeScript requires a series of steps.
    If the project was created with golem new, it already has a package.json that incorporates all the necessary steps as npm scripts to build the component, so it is enough to run:
    $ npm run componentize
    In details, building the component requires the following steps:
    Generate the TypeScript bindings
    For generating the binding we use the Golem fork of jco and componentize-js. When using the golem examples, these dependencies are included in package.json, and an npm script called stub is also defined:
    $ npm run stub
    The generated binding will placed in the src/generated directory.
    The above run command will execute the following commands:
    $ jco stubgen wit -o src/generated
    And requires the following dev dependencies:
    {
      "devDependencies": {
        "@golemcloud/componentize-js": "0.10.2-golem.1",
        "@golemcloud/jco": "1.4.0-golem.1"
      }
    }
    Compile the TypeScript code to JavaScript
    The examples use rollup through an npm script to compile TypeScript to JavaScript:
    $ npm run build
    This will compile all the TypeScript sources into a single JavaScript file at out/main.js.
    Componentizing the JavaScript code
    The final step is componentizing, which involves:
    embedding our JavaScript code into the StarlingMonkey JS engine
    running Wizer pre-initialization, which pre-loads and parses our Javascript source in the JS engine
    creating the wasm output file for our component with it's interface exposed as a WebAssembly component usable by Golem.
    The example projects includes an npm script called componentize, which also includes the previous stub and build steps.
    $ npm run componentize
    The output wasm file with be created with the built component name, eg.: out/example.wasm.
    The above npm script will execute the following commands:
    $ npm run stub && npm run build && jco componentize -w wit -o out/example.wasm out/main.js
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Ts language guide
  char_count: 2578
  approx_token_count: 645
- id_parent: 74
  title: Next steps
  url: https://learn.golem.cloud/ts-language-guide/next-steps
  content: |
    TypeScript Language Guide
    Next Steps
    Next steps
    After setting up the TypeScript development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Making HTTP requests from a Golem component
    Learn how to send HTTP requests from a Golem component written in TypeScript.
    Control durability guarantees
    Check how the TypeScript Golem SDK can control various durability settings of Golem.
    Automatic retries
    Learn about Golem's retry mechanism and how it can be customized.
    Transactions
    Use the higher level transactions library to implement the Saga pattern.
    Promises
    Create and use promises to await external events from within a running worker.
    Using WASI interfaces
    See what low-level WASI interfaces are available and how they can be used from TypeScript.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    Setting up the Golem TypeScript SDK
    
  section: Ts language guide
  char_count: 1096
  approx_token_count: 274
- id_parent: 75
  title: Golem ts sdk
  url: https://learn.golem.cloud/ts-language-guide/golem-ts-sdk
  content: |
    TypeScript Language Guide
    Setting up the Golem TypeScript SDK
    Setting up the Golem TypeScript SDK
    ⚠️
    If the project was created with golem new, it already has the Golem TypeScript SDK set up and these steps can be ignored.
    If setting up the Golem TypeScript SDK
    (opens in a new tab)
    manually, the following steps are required:
    Create a new project
    npm
    pnpm
    yarn
    bun
    npm init
    Ensure ESM is enabled
    In your package.json file, ensure the type is set to module.
    package.json
    {
      "type": "module"
    }
    Install Dev Dependencies
    The Golem TypeScript SDK currently relies on forked versions of jco
    (opens in a new tab)
    and componentize-js
    (opens in a new tab)
    .
    npm
    pnpm
    yarn
    bun
    npm install --save-dev @golemcloud/componentize-js @golemcloud/golem-ts @golemcloud/jco @rollup/plugin-node-resolve@^15.2.3 rollup-plugin-typescript2@^0.36.0 @types/node@^20.14.2 rollup@^4.18.0 tslib@^2.6.3 typescript@^5.4.5
    Add Rollup Config: rollup.config.mjs
    To silence rollup warnings, add WIT imports to the external array.
    rollup.config.mjs
    import typescript from "rollup-plugin-typescript2"
    import resolve from "@rollup/plugin-node-resolve"
     
    export default {
      input: "src/main.ts",
      output: {
        file: "out/main.js",
        format: "esm",
      },
      external: [
        "golem:api/host@1.1.0",
        "golem:rpc/types@0.1.0",
        "wasi:blobstore/blobstore",
        "wasi:blobstore/container",
        "wasi:cli/environment@0.2.0",
        "wasi:clocks/wall-clock@0.2.0",
        "wasi:clocks/monotonic-clock@0.2.0",
        "wasi:filesystem/preopens@0.2.0",
        "wasi:filesystem/types@0.2.0",
        "wasi:http/types@0.2.0",
        "wasi:http/outgoing-handler@0.2.0",
        "wasi:io/error@0.2.0",
        "wasi:io/poll@0.2.0",
        "wasi:io/streams@0.2.0",
        "wasi:keyvalue/eventual-batch@0.1.0",
        "wasi:keyvalue/eventual@0.1.0",
        "wasi:logging/logging",
        "wasi:random/random@0.2.0",
        "wasi:random/insecure@0.2.0",
        "wasi:random/insecure-seed@0.2.0",
        "wasi:sockets/ip-name-lookup@0.2.0",
        "wasi:sockets/instance-network@0.2.0",
      ],
      plugins: [resolve(), typescript()],
    }
    Add Typescript Config: tsconfig.json
    tsconfig.json
    {
      "$schema": "https://json.schemastore.org/tsconfig",
      "compilerOptions": {
        "skipLibCheck": true,
        "target": "ES2020",
        "noEmit": true,
        "lib": ["ES2020"],
        "types": ["node"],
        "moduleResolution": "bundler",
        "checkJs": false,
        "strict": true,
        "noUncheckedIndexedAccess": true,
        "noImplicitOverride": true
      },
      "exclude": ["node_modules"],
      "include": ["src/**/*.ts"]
    }
    Add scripts to package.json
    Add the following scripts to your package.json:
    package.json
    {
      "scripts": {
        "stub": "jco stubgen wit -o src/generated",
        "build": "rollup --config",
        "componentize": "npm run stub && npm run build && jco componentize -w wit -o out/component_name.wasm out/main.js",
        "clean": "rm -rf out src/generated"
      }
    }
    stub - Generates the TypeScript declaration (.d.ts) files containing stubs for the WIT files.
    build - Compiles the TypeScript code into JavaScript.
    componentize - Bundles the JavaScript code into a WebAssembly module.
    clean - Cleans up the project by removing the generated files.
    Verify package.json
    Ensure the scripts and devDependencies sections are correct (versions may differ).
    package.json
    {
      "type": "module",
      "scripts": {
        "stub": "jco stubgen wit -o src/generated",
        "build": "rollup --config",
        "componentize": "npm run stub && npm run build && jco componentize -w wit -o out/component_name.wasm out/main.js",
        "clean": "rm -rf out src/generated"
      },
      "devDependencies": {
        "@golemcloud/componentize-js": "0.10.5-golem.3",
        "@golemcloud/golem-ts": "1.1.0",
        "@golemcloud/jco": "1.4.4-golem.1",
        "@rollup/plugin-node-resolve": "^15.2.3",
        "rollup-plugin-typescript2": "^0.36.0",
        "@types/node": "^20.14.2",
        "rollup": "^4.18.0",
        "tslib": "^2.6.3"
      }
    }
    Add all the supported WIT files into the project
    The project's wit/deps directory must contain all the WIT files from the golem-wit
    (opens in a new tab)
    repository.
    Either clone the repository and copy the wit/deps directory into your project, or run the following command to download the WIT files:
    macOS/Linux
    Windows
    curl -L https://github.com/golemcloud/golem-wit/archive/refs/heads/main.zip | tar -xvf- -C . --strip-components=2 "golem-wit-main/wit/deps" && mkdir -p ./wit/deps && mv deps/* ./wit/deps/ && rm -rf deps/
    The resulting directory structure should look like this:
    src
    wit
    main.wit
    deps
    blobstore
    cli
    clocks
    filesystem
    golem
    http
    io
    keyvalue
    logging
    random
    sockets
    wasm-rpc
    Importing WITs into the component's world:
    If the project's WIT file was like this:
    package golem:demo;
     
    world ts-example {
      export api;
    }
    Modify it in the following way:
    package golem:demo;
     
    world ts-example {
      import golem:api/host@1.1.0;
      import golem:rpc/types@0.1.0;
     
      import wasi:blobstore/blobstore;
      import wasi:blobstore/container;
      import wasi:cli/environment@0.2.0;
      import wasi:clocks/wall-clock@0.2.0;
      import wasi:clocks/monotonic-clock@0.2.0;
      import wasi:filesystem/preopens@0.2.0;
      import wasi:filesystem/types@0.2.0;
      import wasi:http/types@0.2.0;
      import wasi:http/outgoing-handler@0.2.0;
      import wasi:io/error@0.2.0;
      import wasi:io/poll@0.2.0;
      import wasi:io/streams@0.2.0;
      import wasi:keyvalue/eventual-batch@0.1.0;
      import wasi:keyvalue/eventual@0.1.0;
      import wasi:logging/logging;
      import wasi:random/random@0.2.0;
      import wasi:random/insecure@0.2.0;
      import wasi:random/insecure-seed@0.2.0;
      import wasi:sockets/ip-name-lookup@0.2.0;
      import wasi:sockets/instance-network@0.2.0;
     
      export api;
    }
    Run stub script
    This will generate Typescript declaration files in the src/generated directory, for all imported WIT interfaces.
    npm
    pnpm
    yarn
    bun
    npm run stub
    Last updated on March 28, 2025
    Next Steps
    HTTP client
    
  section: Ts language guide
  char_count: 5800
  approx_token_count: 1450
- id_parent: 76
  title: Http
  url: https://learn.golem.cloud/ts-language-guide/http
  content: |
    TypeScript Language Guide
    HTTP client
    HTTP requests in TypeScript
    ⚠️
    Currently HTTP and fetch support is experimental. The Golem TypeScript SDK has temporary workarounds to make HTTP requests possible, but bugs and breaking changes are expected in this area.
    Golem implements the WASI HTTP
    (opens in a new tab)
    interfaces so any library built on this specification can be used from Golem components to communicate with external services.
    HTTP request can be made with the JavaScript standard builtin fetch function, but handling the asynchronous return values inside the synchronous component functions requires helpers from the Golem TypeScript SDK.
    The SDK
    (opens in a new tab)
    provides asyncToSync and asyncToSyncAsResult functions to wait for Promises.
    The asyncToSync function throws exceptions in case the Promise is failed, while the asyncToSyncAsResult returns a Result<T, E> type, which is defined in the SDK
    (opens in a new tab)
    .
    import { asyncToSync, asyncToSyncAsResult, Result } from "@golemcloud/golem-ts"
     
    // Using asyncToSyncAsResult to await for fetch results as Result
    const result: Result<string> = asyncToSyncAsResult(
      fetch("https://localhost:8080").then(result => result.text())
    )
     
    const text = result.match(
      text => text,
      err => {
        console.error(err)
        return "failed"
      }
    )
     
    // Using asyncToSync to await for fetch results which might throw exceptions in case of errors
    try {
      const text = asyncToSync(fetch("https://localhost:8080").then(result => result.text()))
    } catch (err) {
      console.log(err)
    }
    Last updated on March 28, 2025
    Setting up the Golem TypeScript SDK
    Durability
    
  section: Ts language guide
  char_count: 1619
  approx_token_count: 405
- id_parent: 77
  title: Durability
  url: https://learn.golem.cloud/ts-language-guide/durability
  content: |
    TypeScript Language Guide
    Durability
    Control durability guarantees from TypeScript
    Golem provides a set of functions components can call to control details of the durable execution engine. For components implemented in TypeScript the Golem Typescript SDK provides a set of TypeScript wrappers for these functions.
    Setting up the Golem TypeScript SDK
    If the project was created with golem new, it already has the Golem TypeScript SDK set up, otherwise follow the step at Setting up the Golem TypeScript SDK
    General concepts
    The library allows controlling four main aspects of the durable execution engine: the current persistence level, the idempotence mode, defining atomic regions and changing retry policies (discussed in the next page).
    All these features are regional - they can be changed for a section of the code within a single exported function. To make this easy to use in TypeScript, the library provides functions starting with with, they take a closure parameter which will be executed with the requested mode, and then they restore the previous settings.
    Persistence level
    The persistence level can be one of the following:
    Level Description
    PersistNothing Turns off persistence for a section. In case the worker is recovered or restarted, all the side-effecting functions will be reexecuted
    PersistRemoteSideEffects Persists all the side-effects that are affecting the outside world. In case of recovery the side-effects won't be reexecuted and the persisted results will be used.
    Smart The default setting; Let Golem decide what to persist to optimize performance
    To change the persistence level for a section of the code, use the withPersistenceLevel function:
    import { withPersistenceLevel } from "@golemcloud/golem-ts"
     
    const result: string = withPersistenceLevel({ tag: "persist-nothing" }, () => {
      // this closure runs in PersistNothing mode
      return "hello"
    })
    Idempotence mode
    Golem assumes that HTTP requests are idempotent by default. This means that in case of a failure, if the system cannot determine whether the request successfully reached the target or not, it will be retried. This behavior can be changed using the withIdempotenceMode function:
    import { withIdempotenceMode } from "@golemcloud/golem-ts"
     
    const result: string = withIdempotenceMode(false, () => {
      // this closure runs with idempotence mode disabled
      return "hello"
    })
    With disabled idempotence mode, in case Golem cannot determine if the request was sent or not, it won't retry it but the worker will fail.
    Atomic regions
    By default, side effects are persisted and retried one by one. It is possible to group them together into atomic regions, in which case the execution is retried for some reason (the worker failed or interrupted within the region), all the side effects will be reexecuted.
    The golem-ts library exports the atomically function for using atomic regions:
    import { atomically } from "@golemcloud/golem-ts"
     
    const result: [string, string] = atomically(() => {
      const firstResult: string = firstSideEffect()
      const secondResult: string = secondSideEffect(firstResult)
      return [firstResult, secondResult]
    })
    Commit oplog
    The oplogCommit function in "@golemcloud/golem-ts waits until the oplog is committed to its persistent storage. The function takes a single argument, replicas, with the desired number of storage replicas the worker's journal is replicated to. The function will block until the oplog is committed to the specified number of replicas, or, if this number is larger than the available number of replicas, until it is written to all the replicas.
    Last updated on March 28, 2025
    HTTP client
    Retries
    
  section: Ts language guide
  char_count: 3637
  approx_token_count: 910
- id_parent: 78
  title: Retries
  url: https://learn.golem.cloud/ts-language-guide/retries
  content: |
    TypeScript Language Guide
    Retries
    Control the retry policy from TypeScript
    Using Golem's retry mechanism
    Golem applies a retry mechanism to all workers. In case of a failure, Golem will automatically recover the worker to the point before the failure and retry the operation. An exponential backoff and an upper limit on the number of retries are applied.
    If the maximum number of retries is reached, the worker will be marked as failed and no further invocations will be possible on it.
    This mechanism is automatic and applied to all kind of failures. To rely on it, just throw an unhandled exception.
    Customizing the retry policy
    The retry policy which controls the maximum number of retries and the exponential backoff is a global configuration of the Golem servers, but it can be customized for each worker.
    The golem-ts library exports the withRetryPolicy function to temporarily change the retry policy:
    import { withRetryPolicy } from "@golemcloud/golem-ts"
     
    // Durations are expected as nanoseconds
    const result: string = withRetryPolicy(
      {
        maxAttempts: 3,
        minDelay: BigInt(100 * 1000 * 1000), // 100 milliseconds
        maxDelay: BigInt(2 * 1000 * 1000 * 1000), // 2 seconds
        multiplier: 1.5,
        maxJitterFactor: null,
      },
      () => {
        // this closure runs with the custom retry policy
        return "hello"
      }
    )
    The RetryPolicy interface required by withRetryPolicy is generated from Golem's WIT definition:
    /// Configures how the executor retries failures
    record retry-policy {
        /// The maximum number of retries before the worker becomes permanently failed
        max-attempts: u32,
        /// The minimum delay between retries (applied to the first retry)
        min-delay: duration,
        /// The maximum delay between retries
        max-delay: duration,
        /// Multiplier applied to the delay on each retry to implement exponential backoff
        multiplier: f64,
        /// The maximum amount of jitter to add to the delay
        max-jitter-factor: option<f64>
    }
    Last updated on March 28, 2025
    Durability
    Transactions
    
  section: Ts language guide
  char_count: 2026
  approx_token_count: 507
- id_parent: 79
  title: Transactions
  url: https://learn.golem.cloud/ts-language-guide/transactions
  content: |
    TypeScript Language Guide
    Transactions
    High level transactions in TypeScript
    On top of the durability controls and retry controls, the golem-ts
    (opens in a new tab)
    library also provides a high level functions for defining transactions supporting compensation actions in case of getting reverted.
    Although Golem's automatic retry policies and low level atomic regions provide a lot of power automatically, many times a set of external operations such as HTTP requests needs to be executed transactionally; if one of the operations fails, the whole transaction need to be rolled back by executing some compensation actions.
    The golem-ts library provides support for two different types of transactions:
    fallible transactions are only dealing with domain errors
    infallible transactions must always succeed, and Golem applies its active retry policy to it
    Fallible transactions
    Many times external operations (such as HTTP calls to remote hosts) need to be executed transactionally. If some of the operations failed the transaction need to be rolled back - compensation actions need to undo whatever the already successfully performed operations did.
    A fallible transaction only deals with domain errors. Within the transaction every operation that succeeds gets recorded. If an operation fails, all the recorded operations get compensated in reverse order before the transaction block returns with a failure.
    A fallible transaction can be executed using the fallibleTransaction function, by passing a closure that can execute operations on the open transaction (see below).
    Infallible transactions
    An infallible transaction must always succeed - in case of a failure or interruption, it gets retried. If there is a domain error, the compensation actions are executed before the retry.
    An infallible transaction can be executed using the infallibleTransaction function, by passing a closure that can execute operations on the open transaction (see below).
    Operations
    Both transaction types require the definition of operations.
    It is defined with the following interface:
    /**
     * Represents an atomic operation of the transaction which has a rollback action.
     *
     * Implement this interface and use it within a `transaction` block.
     * Operations can also be constructed from closures using `operation`.
     */
    export interface Operation<In, Out, Err> {
      /**
       * The action to execute.
       * @param input - The input to the operation.
       * @returns The result of the operation.
       */
      execute(input: In): Result<Out, Err>
      /**
       * Compensation to perform in case of failure.
       * Compensations should not throw errors.
       * @param input - The input to the operation.
       * @param result - The result of the operation.
       * @returns The result of the compensation.
       */
      compensate(input: In, result: Out): Result<void, Err>
    }
    There are two ways to define an operation:
    Implement the Operation interface manually
    Use the operation function to create an operation from a pair of closures
    export declare function operation<In, Out, Err>(
      execute: (input: In) => Result<Out, Err>,
      compensate: (input: In, result: Out) => Result<void, Err>
    ): Operation<In, Out, Err>
    Executing operations
    The defined operations can be executed in fallible or infallible mode:
    import { fallibleTransaction, infallibleTransaction, operation, Result } from "@golemcloud/golem-ts"
     
    // example operation with compensation
    const op = operation(
      (idx: number) => {
        // the operation / side effect
        return Result.ok("id-" + idx)
      },
      (id, idx) => {
        // compensation
        console.log(`reverting ${id}, ${idx}`)
        return Result.unit()
      }
    )
     
    // with fallibleTransaction errors have to be handled and propagated using the Result type
    const resultFallible = fallibleTransaction(tx => {
      return tx
        .execute(op, 1)
        .flatMap(firstId => tx.execute(op, 2).map(secondId => [firstId, secondId]))
    })
     
    // with infallibleTransaction no explicit error handling is needed, as it is handled by Golem retries
    const resultInfallible = infallibleTransaction(tx => {
      const firstId = tx.execute(op, 1)
      const secondId = tx.execute(op, 1)
      return [firstId, secondId]
    })
    Last updated on March 28, 2025
    Retries
    Promises
    
  section: Ts language guide
  char_count: 4194
  approx_token_count: 1049
- id_parent: 80
  title: Promises
  url: https://learn.golem.cloud/ts-language-guide/promises
  content: |
    TypeScript Language Guide
    Promises
    Working with Golem Promises in TypeScript
    Golem promises provide a way for Golem workers to wait on an external condition. The worker creates the promise and somehow sends its identifier to the external system responsible for completing the promise. Then the worker can await the promise, being suspended until the external system completes the promise using Golem's REST API.
    It is also possible to complete a promise from within a Golem worker using the Golem SDK.
    When a promise is completed, an arbitrary byte array can be attached to it as a payload - this data is returned to the awaiting worker when is continues execution.
    In TypeScript the promise API has idiomatic TypeScript wrappers in the Golem TypeScript SDK.
    Creating a promise
    To create a promise simply call the createPromise function:
    import { createPromise, PromiseId } from "@golemcloud/golem-ts"
     
    const promiseId: PromiseId = createPromise()
    The returned value has the type PromiseId, and defined as the following (including the nested types):
    export type OplogIndex = bigint
     
    export interface Uuid {
      highBits: bigint
      lowBits: bigint
    }
     
    // Represents a Component
    export interface ComponentId {
      uuid: Uuid
    }
     
    // Represents a Worker
    export interface WorkerId {
      componentId: ComponentId
      workerName: string
    }
     
    // A promise ID is a value that can be passed to an external Golem API to complete that promise
    // from an arbitrary external source, while Golem workers can await for this completion.
    export interface PromiseId {
      workerId: WorkerId
      oplogIdx: OplogIndex
    }
    Deleting a promise
    If a promise is no longer used, it has to be deleted with:
    import { deletePromise, PromiseId } from "@golemcloud/golem-ts"
     
    deletePromise(promiseId)
    Awaiting a promise
    To await a promise, use the awaitPromise functions, which returns the promise result as a byte array payload. Here's an example that awaits a promise, then decodes the payload from JSON format:
    import { awaitPromise, PromiseId } from "@golemcloud/golem-ts"
     
    const byteArrayPayload: Uint8Array = awaitPromise(promiseId)
    const payload = JSON.parse(new TextDecoder().decode(byteArrayPayload))
    Completing a promise from within a worker
    To complete a promise from within a worker, use the completePromise function. The following example completes a promise with a value encoded as JSON:
    import { completePromise, PromiseId } from "@golemcloud/golem-ts"
     
    const payload = {
      id: "value",
      meta: "data",
    }
    const byteArrayPayload: Uint8Array = new TextEncoder().encode(JSON.stringify(payload))
    const success: boolean = completePromise(promiseId, byteArrayPayload)
    Completing a promise from an external source
    To see how to use the promise ID to complete a promise through the external REST API, check the REST API documentation.
    Last updated on March 28, 2025
    Transactions
    Updating Workers
    
  section: Ts language guide
  char_count: 2859
  approx_token_count: 715
- id_parent: 81
  title: Updating
  url: https://learn.golem.cloud/ts-language-guide/updating
  content: |
    TypeScript Language Guide
    Updating Workers
    Updating workers to newer versions of TypeScript components
    As described in the general Workers page, each worker runs on a specific version of the component it is based on, but it is possible to update a worker to a different version of the same component.
    Automatic update
    The automatic update mode has no TypeScript-specific details and works as it is described in the general Workers page.
    Manual snapshot-based update
    Sometimes the change between two component versions is so large that the only solution to migrate worker's state to a new version is to manually implement this state transfer.
    This is done by implementing a save-snapshot function in the old component and a load-snapshot function in the new component. The snapshot is an array of bytes and it is the responsibility of the user to ensure that the snapshot is compatible between the two versions.
    These functions are defined in the golem:api WIT package and must be explicitly exported from the component's world.
    Last updated on March 28, 2025
    Promises
    WASI
    
  section: Ts language guide
  char_count: 1072
  approx_token_count: 268
- id_parent: 82
  title: Wasi
  url: https://learn.golem.cloud/ts-language-guide/wasi
  content: |
    TypeScript Language Guide
    WASI
    Using WASI interfaces from TypeScript
    Golem implements and exports a subset of the WASI
    (opens in a new tab)
    interfaces, as well as its own runtime interfaces.
    The Golem TypeScript SDK provides idiomatic wrappers on a subset of these interfaces, but it is also possible to use the generated bindings directly.
    WIT specifications
    The full set of WIT specifications Golem implements is available in the following public repository:
    https://github.com/golemcloud/golem-wit/tree/main/wit/deps
    (opens in a new tab)
    The following table lists all packages provided by Golem:
    Package Description
    golem:api Golem's Runtime API
    golem:rpc Provides support for Worker to Worker communication
    wasi:blobstore Interface for storing and retrieving large binary data
    wasi:cli Interface for environment variables and standard I/O
    wasi:clocks Interface for querying the system time
    wasi:filesystem Interface for working with files and directories
    wasi:http Interface for making HTTP requests
    wasi:io Interface for working with futures and streams
    wasi:keyvalue Interface for storing and retrieving key-value pairs - only partially implemented
    wasi:logging Interface for logging messages
    wasi:random Interface for generating random numbers
    wasi:sockets Interface for working with TCP and UDP sockets (currently not supporting durable execution)
    Bindings
    The TypeScript bindings for the WASI and Golem-specific interfaces are provided in the golem:api/host@1.1.0 module. You can import and use these bindings in your TypeScript code.
    Additional Golem runtime APIs
    This section describes Golem-specific functionalities which are available through the Golem runtime API.
    Generate an idempotency key
    Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.
    It is guaranteed that this idempotency key will always be the same (per occurrence) even if the worker is restarted due to a crash.
    To generate an idempotency key:
    import { generateIdempotencyKey } from "golem:api/host@1.1.0"
     
    const key: Uuid = generateIdempotencyKey()
    Get worker metadata
    It is possible to query metadata for Golem workers. This metadata is defined by the WorkerMetadata interface:
    interface WorkerMetadata {
      workerId: WorkerId
      args: string[]
      env: [string, string][]
      status: WorkerStatus
      componentVersion: bigint
      retryCount: bigint
    }
    There are two exported functions to query worker metadata:
    getSelfMetadata() returns the metadata for the current worker
    getWorkerMetadata(workerId: WorkerId) returns the metadata for a specific worker given by its WorkerId
    Enumerate workers
    Worker enumeration is a feature of Golem available both through the public HTTP API and using the WIT interfaces.
    Warning: Enumerating workers of a component is a slow operation and should not be used as part of the application logic.
    The following example demonstrates how to use the worker enumeration API:
    import {
      ComponentId,
      GetWorkers,
      WorkerAnyFilter,
      WorkerMetadata,
      WorkerStatusFilter,
    } from "golem:api/host@1.1.0"
     
    const filter: WorkerAnyFilter = {
      filters: [
        {
          filters: [
            {
              tag: "status",
              val: {
                comparator: "equal",
                value: "idle",
              } satisfies WorkerStatusFilter,
            },
          ],
        },
      ],
    }
     
    const componentId: ComponentId = {
      /* ... */
    }
    const workers: WorkerMetadata[] = []
    const getter = new GetWorkers(componentId, filter, true)
     
    let batch: WorkerMetadata[] | undefined
    while ((batch = getter.getNext()) !== undefined) {
      workers.push(...batch)
    }
    The third parameter of the GetWorkers constructor enables precise mode. In this mode, Golem will calculate the latest metadata for each returned worker; otherwise, it uses only the last cached values.
    Update a worker
    To trigger an update for a given worker from one component version to another, use the updateWorker function:
    import { updateWorker, WorkerId, ComponentVersion } from "golem:api/host@0.2.0"
     
    const workerId: WorkerId = {
      /* ... */
    }
     
    const targetVersion: ComponentVersion = 1n
     
    updateWorker(workerId, targetVersion, "automatic")
    To learn more about updating workers, see the updating workers page in the documentation.
    The WASI Key-Value store interface
    Although Golem workers can store their state completely in their own memory, it is possible to use the wasi:keyvalue interface to store key-value pairs in a Golem managed key value storage.
    This can be useful if state needs to be shared between different workers or if the size of this state is too large to be stored in memory.
    The WASI Blob Store interface
    The wasi:blobstore interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the worker's memory.
    Last updated on March 28, 2025
    Updating Workers
    Setup
    
  section: Ts language guide
  char_count: 4937
  approx_token_count: 1235
- id_parent: 83
  title: Setup
  url: https://learn.golem.cloud/experimental-languages/zig-language-guide/setup
  content: |
    Experimental Languages
    Zig
    Setup
    Setup development environment for Zig
    To write Golem components in Zig, a couple of common WebAssembly tools need to be installed, as well as the latest Zig compiler.
    Install WebAssembly tooling
    First of all, to install wasm-tools via cargo, you need to install the latest stable version of Rust. The recommended way to do so is using https://rustup.rs
    (opens in a new tab)
    :
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Install wasm-tools
    cargo install --force --locked  wasm-tools@1.223.0
    Confirm the installation:
    wasm-tools --version
    wasm-tools 1.223.0
    Install wit-bindgen
    cargo install --force --locked wit-bindgen-cli@0.37.0
    Confirm the installation:
    wit-bindgen --version
    wit-bindgen-cli 0.37.0
    ⚠️
    Golem requires a specific version of wasm-tools, and wit-bindgen. Please make sure the correct version is installed with the commands described above.
    Install Zig
    Install the latest Zig compiler using the official instructions
    (opens in a new tab)
    . The documentation and examples were created using Zig 0.13.
    Last updated on March 28, 2025
    WASI
    Defining Components
    
  section: Experimental languages
  char_count: 1290
  approx_token_count: 323
- id_parent: 84
  title: Defining components
  url: https://learn.golem.cloud/experimental-languages/zig-language-guide/defining-components
  content: |
    Experimental Languages
    Zig
    Defining Components
    Defining Golem Components in Zig
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the Zig template:
    golem app new my-app zig
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new zig my-component
    Specification-first approach
    Golem and the Zig (and C/C++) toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    The first time a component is compiled (see the Building Components page for details), a couple of files (example.c, example.h and example_component_type.o if the component name was example) get generated in the src/bindings directory. This module contains the C definitions of all the data types and interfaces defined in the WIT file(s).
    To implement the specification written in WIT, the Zig code must implement some of these generated exported functions defined in the generated header file.
    As currently there is no Zig-specific binding generator, for more details, check the C/C++ guide for defining components.
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Experimental languages
  char_count: 1792
  approx_token_count: 448
- id_parent: 85
  title: Building components
  url: https://learn.golem.cloud/experimental-languages/zig-language-guide/building-components
  content: |
    Experimental Languages
    Zig
    Building Components
    Building Golem Components in Zig
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Under the hood
    Building Golem components written in Zig involves a few steps.
    If the project was created with golem new, it already has a build.zig file that incorporates all the necessary steps to build the component, so it is enough to run:
    $ zig build
    In details, building the component requires the following steps:
    Generate the C bindings from the WIT files
    const bindgen = b.addSystemCommand(&.{ "wit-bindgen", "c", "--autodrop-borrows", "yes", "./wit", "--out-dir", "src/bindings" });
    Use the WASM32/WASI target
    const wasm = b.addExecutable(.{ .name = "main", .root_source_file = b.path("src/main.zig"), .target = b.resolveTargetQuery(.{
        .cpu_arch = .wasm32,
        .os_tag = .wasi,
    }), .optimize = optimize });
    Include the generated C bindings
    const binding_root = "src/bindings";
    var binding_root_dir = try std.fs.cwd().openDir(binding_root, .{ .iterate = true});
    defer binding_root_dir.close();
    var it = try binding_root_dir.walk(b.allocator);
    while (try it.next()) |entry| {
        switch (entry.kind) {
            .file => {
                const path = b.pathJoin(&.{ binding_root, entry.path });
                if (std.mem.endsWith(u8, entry.basename, ".c")) {
                    wasm.addCSourceFile(.{ .file = b.path(path), .flags = &.{} });
                } else if (std.mem.endsWith(u8, entry.basename, ".o")) {
                    wasm.addObjectFile(b.path(path));
                }
            },
            else => continue,
        }
    }
     
    wasm.addIncludePath(b.path(binding_root));
    wasm.linkLibC();
     
    wasm.step.dependOn(&bindgen.step);
    Package it into a WASM component
    The resulting WASM file is a WebAssembly module, not a component. To be able to use it as a Golem component, use wasm-tools to package the module as a component:
    const adapter = b.option([]const u8, "adapter", "Path to the Golem Tier1 WASI adapter") orelse "adapters/tier1/wasi_snapshot_preview1.wasm";
    const out = try std.fmt.allocPrint(b.allocator, "zig-out/bin/{s}", .{wasm.out_filename});
    const component = b.addSystemCommand(&.{ "wasm-tools", "component", "new", out, "-o", "zig-out/bin/component.wasm", "--adapt", adapter });
    component.step.dependOn(&wasm.step);
     
    b.installArtifact(wasm);
    b.getInstallStep().dependOn(&component.step);
    Note that the adapters/tier1/wasi_snapshot_preview1.wasm file is placed in the project's directory when using golem new to create the new project.
    If needed, it can be manually downloaded from https://github.com/golemcloud/golem-wit/blob/main/adapters/tier1/wasi_snapshot_preview1.wasm
    (opens in a new tab)
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Experimental languages
  char_count: 3152
  approx_token_count: 788
- id_parent: 86
  title: Next steps
  url: https://learn.golem.cloud/experimental-languages/zig-language-guide/next-steps
  content: |
    Experimental Languages
    Zig
    Next Steps
    Next steps
    After setting up the Zig development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Note that as there is no Zig-specific Golem SDK and binding generator, the lineked pages below refer to the C/C++ language guide.
    Making HTTP requests from a Golem component
    Learn how to send HTTP requests from a Golem component written in C/C++.
    Control durability guarantees
    Check how the Golem runtime API can control various durability settings of Golem.
    Automatic retries
    Learn about Golem's retry mechanism and how it can be customized.
    Promises
    Create and use promises to await external events from within a running worker.
    Using WASI interfaces
    See what low-level WASI interfaces are available and how they can be used from C/C++.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    Setup
    
  section: Experimental languages
  char_count: 1091
  approx_token_count: 273
- id_parent: 87
  title: Setup
  url: https://learn.golem.cloud/experimental-languages/scalajs-language-guide/setup
  content: |
    Experimental Languages
    Scala.js
    Setup
    Setup development environment for Scala.js
    To write Golem components in Scala.js, a special version of wit-bindgen needs to be installed, as well as the sbt build tool and Node.js and npm.
    Install WebAssembly tooling
    First of all, to install wit-bindgen-scalajs via cargo, you need to install the latest stable version of Rust. The recommended way to do so is using https://rustup.rs
    (opens in a new tab)
    :
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Install wit-bindgen-scalajs
    cargo install --git https://github.com/vigoo/wit-bindgen-scalajs wit-bindgen-cli --locked
    Confirm the installation:
    wit-bindgen-scalajs --version
    wit-bindgen-cli 0.37.0 (f30fdae38 2025-02-23)
    ⚠️
    Golem requires a specific version of wasm-tools, and wit-bindgen. Please make sure the correct version is installed with the commands described above.
    Install Node.js and npm
    Install Node.js and npm to your system by following the official instructions
    (opens in a new tab)
    .
    Install sbt
    Follow the official instructions
    (opens in a new tab)
    to install sbt.
    Last updated on March 28, 2025
    Next Steps
    Defining Components
    
  section: Experimental languages
  char_count: 1319
  approx_token_count: 330
- id_parent: 88
  title: Defining components
  url: https://learn.golem.cloud/experimental-languages/scalajs-language-guide/defining-components
  content: |
    Experimental Languages
    Scala.js
    Defining Components
    Defining Golem Components in Scala.js
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the Scala.js template:
    golem app new my-app scalajs
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new scalajs my-component
    Specification-first approach
    Golem and the Scala.js toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    When a component is compiled (see the Building Components page for details), a couple of scala packages get generated in the target/<scala version>/src_managed directory. These packages contains the Scala definitions of all the data types and interfaces defined in the WIT file(s).
    To implement the specification written in WIT, the Scala.js code must implement some of these generated exported traits with proper @JSExport annotations.
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Experimental languages
  char_count: 1627
  approx_token_count: 407
- id_parent: 89
  title: Building components
  url: https://learn.golem.cloud/experimental-languages/scalajs-language-guide/building-components
  content: |
    Experimental Languages
    Scala.js
    Building Components
    Building Golem Components in Scala.js
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Experimental languages
  char_count: 661
  approx_token_count: 166
- id_parent: 90
  title: Next steps
  url: https://learn.golem.cloud/experimental-languages/scalajs-language-guide/next-steps
  content: |
    Experimental Languages
    Scala.js
    Next Steps
    Next steps
    After setting up the Scala.js development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Note that as Scala.js support is experimental, not all the features are documented yet. Please refer to one of the fully supported language guides (such as Rust) to learn more.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    Setup
    
  section: Experimental languages
  char_count: 639
  approx_token_count: 160
- id_parent: 91
  title: Setup
  url: https://learn.golem.cloud/experimental-languages/moonbit-language-guide/setup
  content: |
    Experimental Languages
    MoonBit
    Setup
    Setup development environment for MoonBit
    To write Golem components in MoonBit, a couple of common WebAssembly tools need to be installed, as well as the latest MoonBit compiler.
    Install WebAssembly tooling
    First of all, to install wasm-tools via cargo, you need to install the latest stable version of Rust. The recommended way to do so is using https://rustup.rs
    (opens in a new tab)
    :
    Install Rust
    Install rustup
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    Install the latest stable version of Rust
    rustup install stable && rustup default stable
    Add the WASI target
    rustup target add wasm32-wasip1
    Install wasm-tools
    cargo install --force --locked  wasm-tools@1.223.0
    Confirm the installation:
    wasm-tools --version
    wasm-tools 1.223.0
    Install wit-bindgen
    cargo install --force --locked wit-bindgen-cli@0.40.0
    Confirm the installation:
    wit-bindgen --version
    wit-bindgen-cli 0.40.0
    ⚠️
    Golem requires a specific version of wasm-tools, and wit-bindgen. Please make sure the correct version is installed with the commands described above.
    Install MoonBit
    Install the latest MoonBit compiler using the official instructions
    (opens in a new tab)
    . The documentation and examples were created using MoonBit 0.1.20250310.
    Last updated on March 28, 2025
    Next Steps
    Defining Components
    
  section: Experimental languages
  char_count: 1332
  approx_token_count: 333
- id_parent: 92
  title: Defining components
  url: https://learn.golem.cloud/experimental-languages/moonbit-language-guide/defining-components
  content: |
    Experimental Languages
    MoonBit
    Defining Components
    Defining Golem Components in MoonBit
    Creating a project
    Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.
    To get started from scratch, first create a new application using the MoonBit template:
    golem app new my-app moonbit
    cd my-app
    An application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:
    golem component new
    Then create a new component using the chosen template:
    golem component new moonbit my-component
    Specification-first approach
    Golem and the MoonBit toolchain currently requires defining the component's interface using the WebAssembly Interface Type (WIT) format. See the official documentation of this format
    (opens in a new tab)
    for reference.
    Each new project generated with golem contains a wit directory with at least one .wit file defining a world. This world can contain exports (exported functions and interfaces) and these exports will be the compiled Golem component's public API.
    The first time a component is compiled (see the Building Components page for details), a couple of files get generated in the ffi, gen, interface and world directories. This module contains the MoonBit definitions of all the data types and interfaces defined in the WIT file(s).
    To implement the specification written in WIT, the MoonBit code must implement some of these generated exported functions defined in the generated files.
    Last updated on March 28, 2025
    Setup
    Building Components
    
  section: Experimental languages
  char_count: 1619
  approx_token_count: 405
- id_parent: 93
  title: Building components
  url: https://learn.golem.cloud/experimental-languages/moonbit-language-guide/building-components
  content: |
    Experimental Languages
    MoonBit
    Building Components
    Building Golem Components in MoonBit
    Building Golem components having an application manifest is straightforward, just use the golem command line interface:
    golem app build
    If the project was created using golem app new as recommended, the golem app build command will always work as expected.
    The result of the golem app build command is a WebAssembly component file ready to be uploaded to Golem. It does not have to be specified explicitly, as the golem tool will automatically find the correct file when doing for example:
    golem component add
    Regenerating the stubs
    A custom command is provided to regenerate the stubs to be implemented:
    golem app regenerate-stubs
    This command will rewrite the stub code in the source directory, removing any existing change into it! Make sure the previous code is copied elsewhere before running this command. It is not mandatory to ever run this command, but then when the exported WIT interface changes, the changes will have to be reflected manually in the source code.
    Under the hood
    Building Golem components written in MoonBit involves a few steps.
    Generating bindings
    The first step is to generate bindings using wit-bindgen moonbit.
    Building the component
    Building the component into core WASM module using moon build --target wasm.
    Embedding the WIT specification
    Before converting the resulting WASM module into a Golem component, the WIT specification is embedded in a custom section using wasm-tools component embed.
    Converting to a Golem component
    Finally the WASM module is converted into a component using wasm-tools component new.
    Last updated on March 28, 2025
    Defining Components
    Next Steps
    
  section: Experimental languages
  char_count: 1698
  approx_token_count: 425
- id_parent: 94
  title: Next steps
  url: https://learn.golem.cloud/experimental-languages/moonbit-language-guide/next-steps
  content: |
    Experimental Languages
    MoonBit
    Next Steps
    Next steps
    After setting up the MoonBit development environment and learning the basic steps writing a Golem component and building them, please consider learning about the following topics:
    Note that as MoonBit support is experimental, not all the features are documented yet. Please refer to one of the fully supported language guides (such as Rust) to learn more.
    Call other workers from a worker
    Worker to Worker communication
    Set up the worker's filesystem
    Worker filesystem
    Share WIT packages between components
    Shared WIT packages
    Last updated on March 28, 2025
    Building Components
    Shared WIT Packages
    
  section: Experimental languages
  char_count: 650
  approx_token_count: 163
- id_parent: 95
  title: Shared wit packages
  url: https://learn.golem.cloud/common-language-guide/shared-wit-packages
  content: |
    Common Guides
    Shared WIT Packages
    Shared WIT packages
    When having multiple components in an application, we often want to share some of the WIT types between them. The application template used by golem app new contains a predefined way to add these shared packages.
    Create a new package
    The application's root directory has a wit directory, initially only containing an empty common.wit file. This file is just there to satisfy the requirements of some build tools, such as wit-bindgen. It should not be modified.
    Instead, create a new package in a subdirectory of wit/deps, for example wit/deps/shared/shared.wit. Each subdirectory of wit/deps must contain one particular package, but these packages can consist of multiple WIT files.
    For example the shared.wit file can define an interface with a few data types:
    package myapp:shared;
     
    interface types {
        type name = string;
        record user {
            id: u64;
            name: name;
        }
    }
    Importing the shared package
    To import this shared package into one or more of the component's WIT files, just add an import statement to the component's world like in the following example:
    package myapp:component1;
     
    // ...
     
    world component1 {
        import myapp:shared/types;
     
        // ...
    }
    and use the use statement to import members of the shared interface into another one:
    interface api {
        use myapp:shared/types.{name, user};
     
        // ...
    }
    There is no other steps required - golem app build will automatically find the shared package and wire everything together as expected.
    Sharing code between components depending on shared WIT packages
    The application templates contain predefined "shared" libraries for most supported languages which can be used to shared code between components.
    These are located in the common-* directories, where * is the language. For example, the common-rust directory contains additional Rust crate that can be added as dependencies to the component implementations.
    When using shared WIT packages like above, it makes sense to write shared code depending on the bindings generated from these shared WIT packages. For example, there could be a JSON codec implemented for the above defined user record type which we want to use in multiple components.
    Doing so requires setting up a custom binding generation step, which depends on the language being used:
    Rust
    First add the wit-bindgen crate as a dependency to your shared crate under the common-rust directory:
    [dependencies]
    wit-bindgen = "0.37.0"
    Then use the binding generator macro pointing to the shared WIT package, for example:
    use wit_bindgen::generate;
     
    generate!({
        path: "../../wit",
        inline: r#"
        package common:inline;
     
        world common {
            import myapp:shared/types;
        }
        "#,
        // additional_derives: [serde::Deserialize, serde::Serialize],
        generate_all,
        generate_unused_types: true
    });
     
    use crate::myapp::shared::types::*;
    Last updated on March 28, 2025
    Next Steps
    Worker to Worker Communication
    
  section: Common language guide
  char_count: 2981
  approx_token_count: 746
- id_parent: 96
  title: Rpc
  url: https://learn.golem.cloud/common-language-guide/rpc
  content: |
    Common Guides
    Worker to Worker Communication
    Worker to Worker communication
    See the Worker to Worker communication page for a general overview of how workers can invoke each other in Golem.
    Setting up
    For doing worker to worker communication between Golem components, all the components involved should be defined in the same application created with the golem app new command. Once the application is created the components can be added using golem component new.
    Creating a project with two components
    A project building two Golem components where one can call the other can be set up with the following primary steps:
    Create the two components
    First create two components using the techniques described in the "defining components" page for the chosen language.
    Rust
    TypeScript
    Go
    Python
    C
    JavaScript
    Zig
    MoonBit
    Scala.js
    Defining Rust components
    In the following example snippets we will use the following component names:
    example:caller the component that will call another component
    example:provider the component that provides some API that example:caller will call
    Set up the dependencies between the components
    In the root golem.yaml file add a dependencies section:
    dependencies:
      example:caller:
        - target: example:provider
          type: wasm-rpc
    The type field can be one of the following:
    wasm-rpc: Worker to Worker communication using dynamic linking. This is the default and recommended option. The resulting component will import client functions for connecting to the other worker, and these imports will be resolved by Golem automatically when the worker starts.
    static-wasm-rpc: Worker to Worker communication using static linking. In this case the client gets generated as Rust source code, and compiled and linked statically with your component. Using this option can be useful for debugging but otherwise deprecated and requires a working Rust toolchain on your computer.
    Check it works by running golem app build in the root directory of the application, which should build all the components.
    Sometimes it can be useful for a component to depend on itself:
    Different workers of the same component can communicate with each other
    A worker can schedule a call for later for another worker, or even itself
    For this just use the same component name in the target field of the dependencies section.
    Import the generated client in the caller component
    When defining RPC dependencies like above, the golem app build command will automatically generate client WIT interfaces for all the target components, and import them into the components that are dependent on them.
    For example with the above setup, in the end the following import would be added in the example:caller component's WIT world:
    package example:caller;
     
    world example-caller {
        import example:provider-client/example-provider-client;
        // ...
    }
    Note that the wit directory of each component remains untouched and should only be modified by the user. These automatic imports are generated in the wit-generated directory and should not be modified manually.
    The exact name to be imported depends on what package and component names were used when creating the target component.
    In this example the package name was example:provider. This gives the generated client package example:provider-client with an exported interface example-provider-client.
    Start implementing the components
    With this the workspace is set up, and the generated clients can be used from the caller component to call the target component, as it is described in the next section.
    Once the code is written, just use golem app build to build all the components.
    Writing blocking remote calls
    For each exported function in the target component, the generated client contains two exported variants:
    A blocking variant, prefixed with blocking-, which does not return until the remote worker finished processing the call.
    A non-blocking variant, which returns a pollable result immediately (unless for remote functions without any return value, in which case it just triggers the invocation but does not return anything)
    To use the blocking variants we need to construct a resource from the generated client, passing the remote Golem URI of the target worker to the constructor.
    Taking the default template as the target component, which has the following exported interface:
    package example:provider;
     
    interface example-providerapi {
      add: func(value: u64);
      get: func() -> u64;
    }
     
    world example-provider {
      export example-provider-api;
    }
    The generated client will contain the following functions:
    package example:provider-client;
     
    interface example-provider-client {
      use wasi:io/poll@0.2.0.{ pollable as wasi-io-pollable };
      use wasi:clocks/wall-clock@0.2.0.{ datetime as wasi-clocks-datetime };
      use golem:rpc/types@0.2.0.{ worker-id as golem-rpc-worker-id, cancellation-token as golem-rpc-cancellation-token };
     
      resource future-get-result {
        subscribe: func() -> pollable;
        get: func() -> option<u64>;
      }
      resource example-provider-api {
        constructor(worker-name: string);
        custom: static func(worker-id: golem-rpc-worker-id) -> example-provider-api;
     
        blocking-add: func(value: u64);
        add: func(value: u64);
        schedule-add: func(value: u64, scheduled-for: wasi-clocks-datetime) -> golem-rpc-cancellation-token;
     
        blocking-get: func() -> u64;
        get: func() -> future-get-result;
        schedule-get: func(scheduled-for: wasi-clocks-datetime) -> golem-rpc-cancellation-token;
      }
     
    }
     
    world wasm-rpc-client-example-provider {
      export example-provider-client;
    }
    If the targeted component is ephemeral, the interface is slightly different: there is no need to pass a worker name to the constructor, and the custom constructor just takes a component-id.
    To use this generated example-providerapi resource, the following steps are needed in the caller component (example:caller in the example):
    Import the generated types
    The generated bindings for the generated stubs need to be imported in the module where the remote procedure calls are made.
    As this import is automatically added to the caller component, we can import the generated bindings in our source code to be able to call the example:provider workers:
    Rust
    TypeScript
    Go
    Python
    C
    JavaScript
    Zig
    MoonBit
    Scala.js
    use crate::bindings::example::provider_client::example_provider_client::ExampleProviderApi;
    Deciding which constructor to use
    Each generated client resource has two constructors:
    The default one (new) takes a worker name string for durable components, and nothing for ephemeral components.
    The custom one (custom) is a static method that takes a worker ID for durable components, or a component ID for ephemeral components.
    When using the default constructors, Golem assumes that the target component's name is the one specified in the app manifest (in our example: example:provider). This is always true if the application was deployed using the golem app deploy command. The custom constructor is there for advanced use cases where you want to target a separately deployed component with a different name and you know its identifier.
    Note that if the client is for a remote resource (and not for the remote component's top-level exports), the constructors will also require passing the resource's constructors beside the ones defining the RPC target, such as the worker name.
    Construct and use the API resource
    In our example the example:provider is a durable component, so the ExampleProviderApi resource can be constructed by passing a worker name and then used to call the remote functions.
    Rust
    TypeScript
    Go
    Python
    C
    JavaScript
    Zig
    MoonBit
    Scala.js
    let remote_api = ExampleProviderApi::new("worker-1");
    remote_api.blocking_add(3);
    Writing non-blocking remote calls
    Using the non-blocking variants of the generated stub functions requires the same steps as the blocking variants, but the returned value is a special future which needs to be subscribed to and polled using the low-level WASI poll interface.
    The following snippet demonstrates how to get the value of three counters simultaneously, assuming that counter1, counter2 and counter3 are all insteances of the generated stub's Api resource:
    Rust
    TypeScript
    Go
    Python
    C
    JavaScript
    Zig
    MoonBit
    Scala.js
    let remote_api1 = new ExampleRustApi("worker-1");
    let remote_api2 = new ExampleRustApi("worker-2");
    let remote_api3 = new ExampleRustApi("worker-3");
     
    // Making the non-blocking calls
    let future_value1 = remote_api1.get();
    let future_value2 = remote_api2.get();
    let future_value3 = remote_api3.get();
     
    let futures = &[&future_value1, &future_value2, &future_value3];
     
    // Subscribing to get the results
    let poll_value1 = future_value1.subscribe();
    let poll_value2 = future_value2.subscribe();
    let poll_value3 = future_value3.subscribe();
     
    let mut values = [0u64; 3];
    let mut remaining = vec![&poll_value1, &poll_value2, &poll_value3];
    let mut mapping = vec![0, 1, 2];
     
    // Repeatedly poll the futures until all of them are ready
    while !remaining.is_empty() {
        let poll_result = bindings::wasi::io::poll::poll(&remaining);
     
        // poll_result is a list of indexes of the futures that are ready
        for idx in &poll_result {
            let counter_idx = mapping[*idx as usize];
            let future = futures[counter_idx];
            let value = future
                .get()
                .expect("future did not return a value because after marked as completed");
            values[counter_idx] = value;
        }
     
        // Removing the completed futures from the list
        remaining = remaining
            .into_iter()
            .enumerate()
            .filter_map(|(idx, item)| {
                if poll_result.contains(&(idx as u32)) {
                    None
                } else {
                    Some(item)
                }
            })
            .collect();
     
        // Updating the index mapping
        mapping = mapping
            .into_iter()
            .enumerate()
            .filter_map(|(idx, item)| {
                if poll_result.contains(&(idx as u32)) {
                    None
                } else {
                    Some(item)
                }
            })
            .collect();
    }
     
    // values contains the results of the three calls
    Deploying the resulting components
    To build deployable WASM files of the involved components, use
    golem app build
    and upload them using
    golem app deploy
    Last updated on March 28, 2025
    Shared WIT Packages
    WASI HTTP Incoming Handler
    
  section: Common language guide
  char_count: 10347
  approx_token_count: 2587
- id_parent: 97
  title: Wasi http
  url: https://learn.golem.cloud/common-language-guide/wasi-http
  content: |
    Common Guides
    WASI HTTP Incoming Handler
    WASI HTTP Incoming handler
    If you have a wasm component that exports the wasi:http/incoming-handler@0.2.x world, you can easily deploy your application to Golem. This tutorial will walk you through deploying such an application to Golem.
    Let's assume that we have an application written in any supported language that implements the following world:
    package golem:example;
     
    world api {
      import wasi:http/types@0.2.3;
      export wasi:http/incoming-handler@0.2.3;
    }
    and we want to deploy this under the GET /api route on our domain.
    The way we are going to do this using Golem is by defining an api-definition with the http handler binding type.
    Building and uploading the component
    The first step is to create a new Golem component implementing the incoming handler interface. The golem command line interface contains templates for several supported languages, using the template name wasi-http.
    Create an app and add a new component using one the templates:
    Rust
    Go
    Python
    JavaScript
    golem app new my-app rust
    cd my-app
    golem component new rust/wasi-http golem:example
    You can now go ahead and adjust the logic of your component. Once you are done, you can build and deploy it to Golem:
    golem app deploy
    Defining the API
    The next step is to define the api. This is done by writing an api definition for our api. For our example this would look like this:
    id: example-api
    version: "0.1.0"
    draft: true
    routes:
      - method: Get
        path: "/api"
        binding:
          bindingType: http-handler
          component:
            name: "golem:example" # name of the component you uploaded
    Save the above to a file 'api.yaml'.
    Uploading and deploying the API
    Next the api needs to be uploaded and deployed to Golem. This can be done using the CLI with the following two commands:
    Register the api definition with Golem and make it available for other commands:
    golem api definition add api.yaml
    {
      "id": "example-api",
      "version": "0.1.0",
      "routes": [
        {
          "method": "Get",
          "path": "/api",
          "security": null,
          "binding": {
            "component": {
              "name": "golem:example",
              "version": 0
            },
            "workerName": null,
            "idempotencyKey": null,
            "response": null,
            "bindingType": "http-handler",
            "responseMappingInput": null,
            "workerNameInput": {
              "types": {}
            },
            "idempotencyKeyInput": null,
            "corsPreflight": null,
            "responseMappingOutput": null
          }
        }
      ],
      "draft": true,
      "createdAt": "2025-01-29T19:31:54.328610228Z"
    }
    Deploy the api to our target host (localhost in this example):
    golem api deployment deploy --definition example-api/0.1.0 --host localhost:9006
    {
      "apiDefinitions": [
        {
          "id": "example-api",
          "version": "0.1.0"
        }
      ],
      "site": {
        "host": "localhost:9006",
        "subdomain": null
      },
      "createdAt": "2025-01-29T19:31:54.369756Z"
    }
    Invoking the API
    This concludes the process of uploading a component that implements the wasi:http/incoming-handler to Golem. The API is now being served and will respond to http requests on the configure route.
    http localhost:9006/api
    "Hello, I'm a durable teapot."
    Last updated on March 28, 2025
    Worker to Worker Communication
    Worker Filesytem
    
  section: Common language guide
  char_count: 3279
  approx_token_count: 820
- id_parent: 98
  title: Worker filesystem
  url: https://learn.golem.cloud/common-language-guide/worker-filesystem
  content: |
    Common Guides
    Worker Filesytem
    Worker Filesystem
    Each worker runs in a sandboxed filesystem. Both the / path and the current working directory of a worker point to the root of this sandboxed filesystem. There is no way for a worker to access files outside its own filesystem.
    To interact with the worker filesytem, you normally just need to use your regular filesystem apis. The language specific tooling will take care of translating these to invocations of the wasi:filesystem
    (opens in a new tab)
    api which is implemented by Golem.
    Example
    This section assumes that you have a Golem project with an app manifest. If you don't have one yet, please follow the guide and then continue here.
    This example will walk you through creating a worker that will interact with its sandboxed filesystem.
    Defining the component
    We begin by adding a new component to our application:
    Rust
    TypeScript
    Go
    Python
    C
    JavaScript
    Zig
    MoonBit
    Scala.js
    golem component new rust example:filesystem
    Adjust the wit file defining the component so we have a convenient entrypoint. This will just be used to invoke the component, so feel free to name the functions as you like.
    diff --git a/components-rust/example-filesystem/wit/example-filesystem.wit b/components-rust/example-filesystem/wit/example-filesystem.wit
    index 65b5dda..e56b6e8 100644
    --- a/components-rust/example-filesystem/wit/example-filesystem.wit
    +++ b/components-rust/example-filesystem/wit/example-filesystem.wit
    @@ -3,8 +3,7 @@ package example:filesystem;
     // See https://component-model.bytecodealliance.org/design/wit.html for more details about the WIT syntax
     
     interface example-filesystem-api {
    -  add: func(value: u64);
    -  get: func() -> u64;
    +  run: func();
    +  get-contents: func() -> string;
     }
     
     world example-filesystem {
    Finally we need to adjust the implementation of the component to write a file when invoked:
    Rust
    TypeScript
    Go
    Python
    C
    JavaScript
    Zig
    MoonBit
    Scala.js
    mod bindings;
     
    use crate::bindings::exports::example::filesystem_exports::example_filesystem_api::Guest;
     
    struct Component;
     
    impl Guest for Component {
        fn run() {
            std::fs::write("/foobar.txt", "Hello, World!").unwrap()
        }
        fn get_contents() -> String {
            std::fs::read_to_string("/foobar.txt").unwrap()
        }
    }
     
    bindings::export!(Component with_types_in bindings);
    Invoking the worker
    Once we have defined the component, we can the deploy the component and invoke a worker using the Golem cli:
    golem app deploy example:filesystem
    golem worker invoke example:filesystem/test-worker 'example:filesystem-exports/example-filesystem-api.{run}()'
    As part of the invocation, the worker performed the side effect of writing a file in its sandboxed filesystem. This file will persist and can be used in all future invocations. For example:
    golem worker invoke example:filesystem/test-worker 'example:filesystem-exports/example-filesystem-api.{get-contents}()'
    Invocation results in WAVE format:
      - "Hello, World!"
    Initial File System
    This section builds on the project and Golem state created in the example project.
    The Initial File System (IFS) refers to all files that are present in the worker filesystem before the worker is started. These can include configuration files, static assets and other things that you want to include with your worker.
    The IFS is configured on the level of a component, meaning that all workers created from a given component + version will always start with the same filesystem. To configure the IFS, include a files section in your golem.yaml
    ⚠️
    If you are using profiles in your golem.yaml, you currently have to include the files section in each of your profiles when overriding.
    components:
      example:filesystem:
        template: rust
        profiles:
          debug:
            files:
            - sourcePath: ./files/foo.txt
              targetPath: /foobar.txt
              permissions: read-write
            - sourcePath: ./files/bar.txt
              targetPath: /bar.txt
              permissions: read-only
          release:
            files:
            - sourcePath: ./files/foo.txt
              targetPath: /foobar.txt
              permissions: read-write
            - sourcePath: ./files/bar.txt
              targetPath: /bar.txt
              permissions: read-only
    After deploying the component, any new workers created will have the file /foobar.txt (and ./foobar.txt as the worker is starting the root) available to them. The file /bar.txt on the other hand is only available for reading. Trying to open the file for writing will fail with a language-dependent error.
    echo "I'm already here" > ./files/foobar.txt
    golem app deploy example:filesystem
    golem worker invoke example:filesystem/test-worker-2 'example:filesystem-exports/example-filesystem-api.{get-contents}()'
    Invocation results in WAVE format:
      - "I\'m already here\n"
    Updating a worker
    Updating a worker that uses IFS requires some special consideration depending on the update mode you choose:
    Automatic updates: When using automatic updates the old worker invocations are replayed on top of the new IFS. This means that the worker should produce exactly the same results and side effects as it did with the old IFS. For example, changing the format of a file will work without issues, but changing a file that gets read by the worker and returned to the user will likely lead to divergence. In such cases a manual update might be necessary.
    Manual updates: When using manual updates, you are responsible for saving and restoring the content of files in the worker filesystem. You can use the golem:api/save-snapshot function to persist the files and later restore / migrate them using golem:api/load-snapshot.
    Externally accessing worker files
    You can use file-server worker bindings to automatically deploy a REST API that allows accessing the files on a worker filesystem.
    Last updated on March 28, 2025
    WASI HTTP Incoming Handler
    Deploy
    
  section: Common language guide
  char_count: 5850
  approx_token_count: 1463
- id_parent: 99
  title: Deploy
  url: https://learn.golem.cloud/deploy
  content: |
    Deploy
    Deployment
    Golem Services are distributed as Docker images. They are available in Golem Services Docker Hub
    (opens in a new tab)
    . Each Docker image is built for OS/ARCH-s:
    linux/amd64
    linux/arm64
    Services are using following types of storage:
    Relational Database (RDB) - PostgreSQL
    (opens in a new tab)
    or SQLite (mainly for testing purposes)
    Redis
    (opens in a new tab)
    Blob storage - Shared File System or S3
    Golem Services
    Following sections provide a description of each service.
    Component Service
    golem-component-service
    (opens in a new tab)
    is a component registry/management service. Service is using RDB and Blob storage as data storage.
    See also: configuration
    (opens in a new tab)
    , environment variables
    (opens in a new tab)
    , docker image
    (opens in a new tab)
    Worker Service
    golem-worker-service
    (opens in a new tab)
    providing APIs and API Gateway functionality for workers and act like routing service for worker executors. Service is using RDB as data storage.
    See also: configuration
    (opens in a new tab)
    , environment variables
    (opens in a new tab)
    , docker image
    (opens in a new tab)
    Worker Executor
    golem-worker-executor
    (opens in a new tab)
    is responsible for running the workers which belongs to assigned shards. Service is using Redis and Blob storage as data storage.
    See also: configuration
    (opens in a new tab)
    , environment variables
    (opens in a new tab)
    , docker image
    (opens in a new tab)
    Shard Manager
    golem-shard-manager
    (opens in a new tab)
    is a single node in charge of maintaining the worker executors shards assignments, only one instance can be alive at any given time. Service is using Redis as data storage. See also: configuration
    (opens in a new tab)
    , environment variables
    (opens in a new tab)
    , docker image
    (opens in a new tab)
    Component Compilation Service
    golem-component-compilation-service
    (opens in a new tab)
    is sidecar service responsible for compiling components. Service is using Blob storage as data storage.
    See also: configuration
    (opens in a new tab)
    , environment variables
    (opens in a new tab)
    , docker image
    (opens in a new tab)
    Golem Router
    golem-router
    (opens in a new tab)
    is nginx
    (opens in a new tab)
    Golem APIs proxy.
    See also: configuration
    (opens in a new tab)
    , docker image
    (opens in a new tab)
    Deployment Variants
    For deployment variants, see the following sections:
    Docker
    Kubernetes
    Golem Cloud
    Last updated on March 28, 2025
    Worker Filesytem
    Docker
    
  section: Deploy
  char_count: 2427
  approx_token_count: 607
- id_parent: 100
  title: Docker
  url: https://learn.golem.cloud/deploy/docker
  content: |
    Deploy
    Docker
    Deploy using Docker
    To get started we recommend using the Docker Compose file from the Golem Docker examples
    (opens in a new tab)
    . You will need to have Docker
    (opens in a new tab)
    and Docker Compose
    (opens in a new tab)
    installed on your system.
    Once you have Docker Compose installed, you can make use of docker-compose file in Golem repository to spin up Golem.
    Terminal
    # Download an example docker-compose file along with .env file that has a few common configurations
    curl -O https://raw.githubusercontent.com/golemcloud/golem/main/docker-examples/published-postgres/compose.yaml -O  https://raw.githubusercontent.com/golemcloud/golem/main/docker-examples/published-postgres/.env
     
    # Start Golem with backend storage as PostgreSQL and Redis
    docker compose -f compose.yaml up
    You may need to modify it to suit your needs.
    Troubleshooting
    If you are running into any port conflicts you can modify the .env
    (opens in a new tab)
    file that was downloaded as part of the above curl command.
    It has come to our note that, in some cases, the docker compose result in the following error:
    error getting credentials - err: exec: "docker-credential-desktop": executable file not found in $PATH, out: `
    In this situation, the best possible solution is to rename credsStore to credStore in the .docker/config.json file.
    If you still face issues, try the sqlite version of the docker-compose file:
    docker compose -f docker-compose-sqlite.yaml up
    Accessing Golem APIs
    Golem APIs are exposed on port 9881 by default. Worker API Gateway endpoint is exposed under port 9006.
    Last updated on March 28, 2025
    Deploy
    Kubernetes
    
  section: Deploy
  char_count: 1626
  approx_token_count: 407
- id_parent: 101
  title: Kubernetes
  url: https://learn.golem.cloud/deploy/kubernetes
  content: |
    Deploy
    Kubernetes
    Deploy to Kubernetes
    To get started we recommend using the Golem Helm Chart
    (opens in a new tab)
    . You will need to have Helm
    (opens in a new tab)
    and kubectl
    (opens in a new tab)
    installed locally and running kubernetes
    (opens in a new tab)
    cluster (for testing you can use Docker Desktop
    (opens in a new tab)
    or minikube
    (opens in a new tab)
    ).
    For quick start we recommend to download content of kube
    (opens in a new tab)
    directory from Golem repository
    (opens in a new tab)
    and run deploy.sh script:
    ./deploy.sh -n golem
    which will deploy Golem with Redis and PostgreSQL to kubernetes namespace golem. Kubernetes Persistent Volumes
    (opens in a new tab)
    are used to store Golem's data. Nginx ingress controller
    (opens in a new tab)
    is used to expose Golem APIs (http with port 80). For testing, you may need to change golem-cli configuration to use proper host and port. Worker API Gateway endpoint is exposed under port 9006.
    For production is preferable to use separate PostgreSQL cluster, Redis cluster and reliable Shared File System or S3 for Blob storage.
    See Golem Helm Chart values.yaml
    (opens in a new tab)
    and readme
    (opens in a new tab)
    for more details.
    Last updated on March 28, 2025
    Docker
    Golem Cloud
    
  section: Deploy
  char_count: 1236
  approx_token_count: 309
- id_parent: 102
  title: Golem cloud
  url: https://learn.golem.cloud/deploy/golem-cloud
  content: |
    Deploy
    Golem Cloud
    Deploy to Golem Cloud
    Golem Cloud is hosted version of Golem. It is easiest and fastest way to run Golem workers, in the cloud, at scale, without any infrastructure setup or maintenance required.
    Golem Cloud can be managed by:
    Web management console
    (opens in a new tab)
    golem-cloud-cli
    REST API
    Last updated on March 28, 2025
    Kubernetes
    Invoke
    
  section: Deploy
  char_count: 363
  approx_token_count: 91
- id_parent: 103
  title: Invoke
  url: https://learn.golem.cloud/invoke
  content: |
    Invoke
    Invoke workers
    Learn how to invoke workers using:
    The HTTP API
    The CLI
    By mapping to a custom API
    Last updated on March 28, 2025
    Golem Cloud
    HTTP
    
  section: Invoke
  char_count: 152
  approx_token_count: 38
- id_parent: 104
  title: Http
  url: https://learn.golem.cloud/invoke/http
  content: |
    Invoke
    HTTP
    Invoke through the REST API
    The Golem REST API exposes two endpoints for invoking workers. See the OSS or Cloud Worker REST API reference for details. These endpoints provide a direct, low level API for calling the exported functions of the workers. They use a special JSON format for encoding WASM values and types. It is possible, and recommended, to create custom HTTP APIs for exposing workers to the world.
    Endpoints
    Invoke durable workers
    The invoke endpoint enqueues an invocation for the given worker and returns immediately.
    POST /v1/components/{component_id}/workers/{worker_name}/invoke?function={function_name}
    This POST request invokes the worker called worker_name of the component identified by component_id (a UUID), calling the function function_name. Read the function name syntax page to learn how the function names are mapped.
    The body of the POST request must be a JSON object containing a single field called params, which is an array of typed JSON values. The format of typed JSON values is described below.
    Invoke and await durable workers
    The invoke-and-await endpoint enqueues an invocation for a given worker and then awaits its completion, returning the successful result value or failure in the response body.
    POST /v1/components/{component_id}/workers/{worker_name}/invoke-and-await?function={function_name}
    This POST request invokes the worker called worker_name of the component identified by component_id (a UUID), calling the function function_name. Read the function name syntax page to learn how the function names are mapped.
    The body of the POST request must be a JSON object containing a single field called params, which is an array of typed JSON values. The format of typed JSON values is described below.
    The response body is a JSON object with a single field result, containing the invoked function's result encoded as a typed JSON value.
    Ephemeral workers
    For ephemeral workers, as they get automatically created and only live for a single invocation, no worker name is needed in the URI. Otherwise the endpoints work the same:
    POST /v1/components/{component_id}/invoke?function={function_name}
    POST /v1/components/{component_id}/invoke-and-await?function={function_name}
    Implicit worker and resource creation
    If the invoked worker does not exist, it is automatically created by the invocation.
    When using the resource constructor syntax (see the function name syntax page), if the resource with the given constructor parameters does not exist yet, it is automatically created by the invocation.
    Cancelling pending invocations
    As invocations are executed sequentially, it is possible to cancel a pending invocation before it starts executing. This can be done using the cancel invocation endpoint:
    DELETE /v1/components/{component_id}/workers/{worker_name}/invocations/{idempotency_key}
    Typed JSON values
    Typed JSON values are JSON objects with two fields:
    typ describes the type of the value
    value is the actual value
    The invocation API does not require type information beside the values, but providing it makes the invocation much faster. Invocations without provided type information are intended to be used only for testing, as they involve gathering the missing information for each invocation separately.
    Value format
    Read the JSON-WAVE Mapping page to see how every WebAssembly value is encoded in JSON.
    Getting the type
    When constructing invocation requests, the easiest way to get the type part of the request body is to get the component metadata using the REST API:
    GET /v1/components/{component_id}/latest
    This request returns the metadata of the latest version of the component given by its identifier (a UUID). This metadata lists all the exported functions and their expected parameter types. These parameter types encode type information in the same format as the invocation API, so it is possible to copy them when constructing invocations.
    Note that it is not recommended to do this dynamically; the client using the invocation API should target a specific component version, with parameter types known in advance.
    Type format
    The following OpenAPI fragment defines the exact format of the typ fields:
    AnalysedResourceMode:
      type: string
      enum:
        - Owned
        - Borrowed
    AnalysedType:
      discriminator:
        propertyName: type
        mapping:
          Variant: "#/components/schemas/AnalysedType_TypeVariant"
          Result: "#/components/schemas/AnalysedType_TypeResult"
          Option: "#/components/schemas/AnalysedType_TypeOption"
          Enum: "#/components/schemas/AnalysedType_TypeEnum"
          Flags: "#/components/schemas/AnalysedType_TypeFlags"
          Record: "#/components/schemas/AnalysedType_TypeRecord"
          Tuple: "#/components/schemas/AnalysedType_TypeTuple"
          List: "#/components/schemas/AnalysedType_TypeList"
          Str: "#/components/schemas/AnalysedType_TypeStr"
          Chr: "#/components/schemas/AnalysedType_TypeChr"
          F64: "#/components/schemas/AnalysedType_TypeF64"
          F32: "#/components/schemas/AnalysedType_TypeF32"
          U64: "#/components/schemas/AnalysedType_TypeU64"
          S64: "#/components/schemas/AnalysedType_TypeS64"
          U32: "#/components/schemas/AnalysedType_TypeU32"
          S32: "#/components/schemas/AnalysedType_TypeS32"
          U16: "#/components/schemas/AnalysedType_TypeU16"
          S16: "#/components/schemas/AnalysedType_TypeS16"
          U8: "#/components/schemas/AnalysedType_TypeU8"
          S8: "#/components/schemas/AnalysedType_TypeS8"
          Bool: "#/components/schemas/AnalysedType_TypeBool"
          Handle: "#/components/schemas/AnalysedType_TypeHandle"
      type: object
      oneOf:
        - $ref: "#/components/schemas/AnalysedType_TypeVariant"
        - $ref: "#/components/schemas/AnalysedType_TypeResult"
        - $ref: "#/components/schemas/AnalysedType_TypeOption"
        - $ref: "#/components/schemas/AnalysedType_TypeEnum"
        - $ref: "#/components/schemas/AnalysedType_TypeFlags"
        - $ref: "#/components/schemas/AnalysedType_TypeRecord"
        - $ref: "#/components/schemas/AnalysedType_TypeTuple"
        - $ref: "#/components/schemas/AnalysedType_TypeList"
        - $ref: "#/components/schemas/AnalysedType_TypeStr"
        - $ref: "#/components/schemas/AnalysedType_TypeChr"
        - $ref: "#/components/schemas/AnalysedType_TypeF64"
        - $ref: "#/components/schemas/AnalysedType_TypeF32"
        - $ref: "#/components/schemas/AnalysedType_TypeU64"
        - $ref: "#/components/schemas/AnalysedType_TypeS64"
        - $ref: "#/components/schemas/AnalysedType_TypeU32"
        - $ref: "#/components/schemas/AnalysedType_TypeS32"
        - $ref: "#/components/schemas/AnalysedType_TypeU16"
        - $ref: "#/components/schemas/AnalysedType_TypeS16"
        - $ref: "#/components/schemas/AnalysedType_TypeU8"
        - $ref: "#/components/schemas/AnalysedType_TypeS8"
        - $ref: "#/components/schemas/AnalysedType_TypeBool"
        - $ref: "#/components/schemas/AnalysedType_TypeHandle"
    AnalysedType_TypeBool:
      allOf:
        - type: object
          properties:
            type:
              example: Bool
              type: string
              enum:
                - Bool
          required:
            - type
        - $ref: "#/components/schemas/TypeBool"
    AnalysedType_TypeChr:
      allOf:
        - type: object
          properties:
            type:
              example: Chr
              type: string
              enum:
                - Chr
          required:
            - type
        - $ref: "#/components/schemas/TypeChr"
    AnalysedType_TypeEnum:
      allOf:
        - type: object
          properties:
            type:
              example: Enum
              type: string
              enum:
                - Enum
          required:
            - type
        - $ref: "#/components/schemas/TypeEnum"
    AnalysedType_TypeF32:
      allOf:
        - type: object
          properties:
            type:
              example: F32
              type: string
              enum:
                - F32
          required:
            - type
        - $ref: "#/components/schemas/TypeF32"
    AnalysedType_TypeF64:
      allOf:
        - type: object
          properties:
            type:
              example: F64
              type: string
              enum:
                - F64
          required:
            - type
        - $ref: "#/components/schemas/TypeF64"
    AnalysedType_TypeFlags:
      allOf:
        - type: object
          properties:
            type:
              example: Flags
              type: string
              enum:
                - Flags
          required:
            - type
        - $ref: "#/components/schemas/TypeFlags"
    AnalysedType_TypeHandle:
      allOf:
        - type: object
          properties:
            type:
              example: Handle
              type: string
              enum:
                - Handle
          required:
            - type
        - $ref: "#/components/schemas/TypeHandle"
    AnalysedType_TypeList:
      allOf:
        - type: object
          properties:
            type:
              example: List
              type: string
              enum:
                - List
          required:
            - type
        - $ref: "#/components/schemas/TypeList"
    AnalysedType_TypeOption:
      allOf:
        - type: object
          properties:
            type:
              example: Option
              type: string
              enum:
                - Option
          required:
            - type
        - $ref: "#/components/schemas/TypeOption"
    AnalysedType_TypeRecord:
      allOf:
        - type: object
          properties:
            type:
              example: Record
              type: string
              enum:
                - Record
          required:
            - type
        - $ref: "#/components/schemas/TypeRecord"
    AnalysedType_TypeResult:
      allOf:
        - type: object
          properties:
            type:
              example: Result
              type: string
              enum:
                - Result
          required:
            - type
        - $ref: "#/components/schemas/TypeResult"
    AnalysedType_TypeS16:
      allOf:
        - type: object
          properties:
            type:
              example: S16
              type: string
              enum:
                - S16
          required:
            - type
        - $ref: "#/components/schemas/TypeS16"
    AnalysedType_TypeS32:
      allOf:
        - type: object
          properties:
            type:
              example: S32
              type: string
              enum:
                - S32
          required:
            - type
        - $ref: "#/components/schemas/TypeS32"
    AnalysedType_TypeS64:
      allOf:
        - type: object
          properties:
            type:
              example: S64
              type: string
              enum:
                - S64
          required:
            - type
        - $ref: "#/components/schemas/TypeS64"
    AnalysedType_TypeS8:
      allOf:
        - type: object
          properties:
            type:
              example: S8
              type: string
              enum:
                - S8
          required:
            - type
        - $ref: "#/components/schemas/TypeS8"
    AnalysedType_TypeStr:
      allOf:
        - type: object
          properties:
            type:
              example: Str
              type: string
              enum:
                - Str
          required:
            - type
        - $ref: "#/components/schemas/TypeStr"
    AnalysedType_TypeTuple:
      allOf:
        - type: object
          properties:
            type:
              example: Tuple
              type: string
              enum:
                - Tuple
          required:
            - type
        - $ref: "#/components/schemas/TypeTuple"
    AnalysedType_TypeU16:
      allOf:
        - type: object
          properties:
            type:
              example: U16
              type: string
              enum:
                - U16
          required:
            - type
        - $ref: "#/components/schemas/TypeU16"
    AnalysedType_TypeU32:
      allOf:
        - type: object
          properties:
            type:
              example: U32
              type: string
              enum:
                - U32
          required:
            - type
        - $ref: "#/components/schemas/TypeU32"
    AnalysedType_TypeU64:
      allOf:
        - type: object
          properties:
            type:
              example: U64
              type: string
              enum:
                - U64
          required:
            - type
        - $ref: "#/components/schemas/TypeU64"
    AnalysedType_TypeU8:
      allOf:
        - type: object
          properties:
            type:
              example: U8
              type: string
              enum:
                - U8
          required:
            - type
        - $ref: "#/components/schemas/TypeU8"
    AnalysedType_TypeVariant:
      allOf:
        - type: object
          properties:
            type:
              example: Variant
              type: string
              enum:
                - Variant
          required:
            - type
        - $ref: "#/components/schemas/TypeVariant"
    Last updated on March 28, 2025
    Invoke
    CLI
    
  section: Invoke
  char_count: 12163
  approx_token_count: 3041
- id_parent: 105
  title: Cli
  url: https://learn.golem.cloud/invoke/cli
  content: |
    Invoke
    CLI
    Invoke using Golem CLI
    The golem command line interface exposes one invocation subcommand:
    golem worker invoke triggers a function invocation on a worker and awaits its result
    golem worker invoke --enqueue just enqueues an invocation and returns immediately
    Specifying what to invoke
    The command requires specifying which worker to invoke, and the name of the function.
    There are multiple options for selecting the worker:
    Durable workers identified by a component ID and a worker name:
    worker-name
    component-name/worker-name
    project-name/component-name/worker-name
    account-name/project-name/component-name/worker-name
    Ephemeral workers identified by just a component:
    -
    component-name/-
    project-name/component-name/-
    account-name/project-name/component-name/-
    Note that you can only omit the component name if it can be inferred from the context, for example if the current directory is a component directory or the application root with a single component only.
    The function to be invoked is selected by the second parameter. Read the invocation function name syntax page for more information about the possible function names.
    Encoding parameters
    The CLI requires you to encode the function parameters using the WebAssembly Value Encoding
    (opens in a new tab)
    with one or more parameters following the function name (one for each invocation parameter).
    Getting results
    When using invoke without the --enqueue flag, the CLI awaits the result of the invocation and prints the result value to the standard output. By default it uses the text format, in which case it prints the result value using the WebAssembly Value Encoding
    (opens in a new tab)
    .
    This can be changed with --format json or --format yaml to print the invocation result in JSON or YAML, using the mapping described on the JSON WAVE Mapping page.
    Logs
    Both invocation commands accept an optional --connect flag for conneting to the invoked worker's event stream and showing its logs. This works the same as running a separate golem worker connect command during the invocation. The logs consists of everything the worker writes to its standard output and standard error, as well as through the WASI Logging API.
    The --connect option's output (and also the connect subcommand) can be customized with the following parameters:
    --format text|json|yaml for different encodings of the log lines
    --colors=yes|no to enable/disable colors for the text format
    --show-timestamps=yes|no to enable/disable showing timestamps for each log line
    --show-level=yes|no to enable/disable showing the log level (or stdout/stderr) for each log line
    Cancelling pending invocations
    As invocations are executed sequentially, it is possible to cancel a pending invocation before it starts executing. This can be done using the command line interface by running the worker cancel-invocation subcommand:
    golem worker cancel-invocation <component-name>/<worker-name> --idempotency-key <idempotency-key>
    Last updated on March 28, 2025
    HTTP
    Making Custom APIs
    
  section: Invoke
  char_count: 3007
  approx_token_count: 752
- id_parent: 106
  title: Making custom apis
  url: https://learn.golem.cloud/invoke/making-custom-apis
  content: |
    Invoke
    Making Custom APIs
    Making custom APIs
    The Worker Gateway service not only exposes the low-level REST API for invocations but also provides a way to define fully customizable HTTP APIs. Future versions will support other protocols as well such as gRPC or GraphQL.
    For reference, see the API Definition Reference page.
    API Development Workflow
    Define an API Definition: Learn how to create a new API definition.
    Register or Upload the API Definition: Register or upload your API definition to the platform.
    Deploy the API Definition: Deploy your API to make it accessible.
    Try Out the Deployed API: Test the functionality of your deployed API.
    Update API Definitions and Deployments: Make changes to existing APIs and redeploy.
    Set Up API Authentication: Configure authentication mechanisms for your API.
    Configure CORS for the API Gateway: Set up Cross-Origin Resource Sharing (CORS) policies.
    Map Responses with Rib: Use Rib for customizing API response mappings.
    Automatic Documentation for Endpoints: Learn more on automatic spec generation based on Rib scripts.
    Constraints on Component Updates: Learn more on restrictions for updating components after deployment.
    Import OpenAPI Specifications: Convert OpenAPI specs into Golem API definitions.
    Integrate with External API Gateways: Connect your APIs to existing gateways.
    Troubleshoot Common Issues: Resolve potential problems with your APIs.
    Last updated on March 28, 2025
    CLI
    Define API definition
    
  section: Invoke
  char_count: 1461
  approx_token_count: 366
- id_parent: 107
  title: Define api definition
  url: https://learn.golem.cloud/invoke/making-custom-apis/define-api-definition
  content: |
    Invoke
    Making Custom APIs
    Define API definition
    Define an API definition
    To begin with, let's build an API over the functions in the shopping cart example (available via golem component new rust:example-shoping-cart example:cart):
    $ golem component get example:cart
    ...
    Exports:
     golem:component/api.{initialize-cart}(user-id: string)
     golem:component/api.{add-item}(item: record { product-id: string, name: string, price: f32, quantity: u32 })
     golem:component/api.{remove-item}(product-id: string)
     golem:component/api.{update-item-quantity}(product-id: string, quantity: u32)
     golem:component/api.{checkout}() -> variant { error(string), success(record { order-id: string }) }
     golem:component/api.{get-cart-contents}() -> list<record { product-id: string, name: string, price: f32, quantity: u32 }>
    Here is an example of an API definition, which we will use to expose an HTTP API over the function golem:component/api.{get-cart-contents}. We use Rib to define the API definition. Please refer to the Rib reference for more details on the syntax.
    id: my-shopping-cart-v1
    draft: true
    version: 0.0.4
    routes:
      - method: Get
        path: /v4/{user-id}/get-cart-contents
        binding:
          type: default
          component:
            name: "shopping-cart"
            version: 0
          response: |
            let user: u64 = request.path.user-id;
            let worker = instance("my-worker-${user}");
            let result = worker.get-cart-contents();
            {status: 200, body: result}
    Please use this as a reference instead of using it with zero changes. For example, you might need to give a different version, component etc (explained below). You can get the component details including name and version by running golem component list command.
    The API definition's fields have the following meaning:
    Field Description
    id This field represents the unique identifier for the API definition. In this case, it is set to "shopping-cart-v1".
    version This field indicates the version of the API definition. Here, it is set to "0.0.3".
    routes This field contains an array of route objects, each representing a specific endpoint definition.
    method Indicates the HTTP method associated with the route. In this example, it is set to "Get", indicating that this route handles GET requests.
    path Specifies the URL path pattern for the route. It may include path parameters enclosed in curly braces. Here, the path is /{user-id}/get-cart-contents, indicating that this route handles requests to retrieve the contents of a shopping cart for a specific user.
    binding This object contains information about how the request should be handled by the Golem worker.
    Golem Binding
    Let's break down the binding object.
    Field Description
    type Specifies the type of binding. Here, it is set to "default", indicating that the binding involves a Golem worker.
    component Specifies the component's name and version
    response The response field here is a Rib expression that allows you to call any worker function and manipulates its output.
    See the binding type reference for more details on the supported binding types.
    If your worker name is a constant, the you can simply make it a constant string such as "foo". Please note that it has to be quoted for it a valid Rib string. See the Rib reference for the full reference of the binding language.
    Ephemeral and Durable worker invocation
    The worker can be ephemeral or durable depending on whether you passed the worker-name argument into the instance function. You can find more details about the instance function in the Rib reference.
    In this example, the following Rib expression defines the request:
    let user: u64 = request.path.user-id;
    let worker = instance(my-worker-${user});
    let result = worker.get-cart-contents();
    {status: 200, body: result}
    The first line is about extracting the user-id from the path and assigning it to the variable user. Similarly you can extract the query parameters, headers and body from the request object. The request object is a Rib record that contains all the information about the HTTP request. Please find more information about the request object in the Rib reference.
    The second line is about creating a worker instance with the name my-worker-${user}. The third line is about calling the function get-cart-contents in the component, and it will be invoked against the worker my-worker-${user}. Note that the real fully qualified function name (the one that is listed in component metadata is golem:it/api.{get-cart-contents}) however, you can should use the shorter get-cart-contents as shown in the example. Please find more details about the instance function in the Rib reference.
    The third line assigns the result of the worker function to the variable result. The last line is a WASM record where you are mapping to the response. Here body is result itself. That means, we are not manipulating the result returned by the function, and simply forward it as response body. Status is 200. Sometimes you need to specify the type of such as 200: u64 to help out with the compiler
    Getting Data from an HTTP Request in Rib
    The request object is a record that contains all the information about the HTTP request. This object is automatically passed to the Rib script through gateway when an API is invoked. You can find more details about the request object in the Rib documentation, which covers how to look up the path, query, header and body parameters in a Http Request using Rib.
    Getting Started with Rib
    Please see the Rib reference to know more about Rib language.
    Last updated on April 14, 2025
    Making Custom APIs
    Register API definition
    
  section: Invoke
  char_count: 5595
  approx_token_count: 1399
- id_parent: 108
  title: Register api definition
  url: https://learn.golem.cloud/invoke/making-custom-apis/register-api-definition
  content: |
    Invoke
    Making Custom APIs
    Register API definition
    Upload API definition
    The API definitions can be uploaded to Golem using one of the following methods:
    Use the Golem CLI tool
    Use the Rest APIs
    Use Golem Console
    (opens in a new tab)
    (Only available in Golem Cloud)
    The following example uses golem to add a new API definition to the system.
    golem api definition new api-definition.json
    This API definition is still a draft since it is still not deployed yet. Once it is deployed you cannot further update this definition unless you change the version, to avoid breaking your public API.
    Last updated on March 28, 2025
    Define API definition
    Deploy API definition
    
  section: Invoke
  char_count: 661
  approx_token_count: 166
- id_parent: 109
  title: Deploy api definition
  url: https://learn.golem.cloud/invoke/making-custom-apis/deploy-api-definition
  content: |
    Invoke
    Making Custom APIs
    Deploy API definition
    Deploy the API Definition
    Using golem, deploying the API definition is straight forward.
    golem api deployment deploy my-shopping-cart-v1/0.0.4 --host localhost:9006
    The above command returns the following:
    {
      "apiDefinitions": [
        {
          "id": "my-shopping-cart-v1",
          "version": "0.0.4"
        }
      ],
      "site": {
        "host": "localhost:9006",
        "subdomain": null
      },
      "createdAt": "2024-10-31T07:36:47.497267721Z"
    }
    Here we deploy the definition and now the endpoints should be available at host localhost:9006. If you were following docker examples to spin up Golem, then the port has to be 9006. Refer to .env in docker-examples folder in Golem OSS.
    You can test the deployment now, by trying to call the endpoint defined in the API definition.
    Last updated on March 28, 2025
    Register API definition
    Invoke the deployed API
    
  section: Invoke
  char_count: 883
  approx_token_count: 221
- id_parent: 110
  title: Try out deployed api
  url: https://learn.golem.cloud/invoke/making-custom-apis/try-out-deployed-api
  content: |
    Invoke
    Making Custom APIs
    Invoke the deployed API
    Use the deployed API
    Given, you have successfully deployed, now you can try to invoke the following:
    curl -H "Accept: application/json" -X GET http://localhost:9006/v4/100/get-cart-contents
    []
    Here the worker-gateway identifies the user to be 100 and evaluates the worker-name expr to be my-worker-100 by evaluating workerName Rib expression.
    Once it identifies the worker-name, it goes on evaluating the response Rib expression which internally invokes the worker function function golem:it/api.{get-cart-contents} with empty parameters, and simply get the worker-response (which is a WASM value) and converts it to a proper Http Response.
    Last updated on March 28, 2025
    Deploy API definition
    Update API definitions and deployments
    
  section: Invoke
  char_count: 782
  approx_token_count: 196
- id_parent: 111
  title: Update api deployment
  url: https://learn.golem.cloud/invoke/making-custom-apis/update-api-deployment
  content: |
    Invoke
    Making Custom APIs
    Update API definitions and deployments
    Update API definitions and deployments
    Deploying multiple definitions to the same site
    Multiple API definitions can be deployed to a specific site (subdomain.domain), as far their routes don't conflict.
    Example: Let's say we have an API definition with ID/version my-shopping-cart/0.0.1 deployed in domain localhost:9006 , and we want to deploy another registered definition my-todo-app/0.0.1 to the same domain.
    golem api deployment deploy --host localhost:9006  my-todo-app/0.0.1
     
    API deployment on localhost:9006 with definition my-shopping-cart/0.0.1
    API deployment on localhost:9006 with definition my-todo-app/0.0.1
      Now all the routes are available under the same domain localhost:9006. If there are any conflicts between the routes of the two definitions, you will get a conflict error message.
    If you try to deploy an API definition with routes that are already deployed and live, then you will get a conflict error.
    Example:
    $ golem api deployment deploy --host localhost:9006 --definition my-todo-app/0.0.1
     
    API deployment definitions conflict error: /v1/healthcheck
    Update a deployed API definition without bumping up it's version
    Let's say you want to update the existing API definition that is already deployed without changing its version number.
    $ golem api definition update  my-shopping-cart --def-format my-shopping-cart.yaml
     
    API definition is not draft: my-shopping-cart
    API definition is not draft because the particular version is already deployed and you cannot update its routes and register with the same version. If the API definition is not in draft mode, and you tried to update the definition itself, then you will get an error message as shown above.
    Update a deployed API definition by bumping up it's version
    If you want to update the details of an API definition that is already deployed, you can bump up its version and registering it again. API Gateway will consider it as a new API definition, and allows you to deploy it as far as there are no conflicts with the existing routes.
    In the below example, lets assume we bumped up the version number from 0.0.1 to 0.0.2 in my-shopping-cart.yaml (and also updated its routes such that they don't conflict)
    $ golem api definition new  my-shopping-cart.yaml
    $ golem api deployment deploy --host localhost:9006 my-shopping-cart/0.0.2                          Tue 10 Dec 14:57:22 2024
     
    API deployment on localhost:9006 with definition my-shopping-cart/0.0.1
    API deployment on localhost:9006 with definition my-shopping-cart/0.0.2
    You can see both versions are running now in the same domain localhost:9006. You can list all the deployments in a domain for a particular API definition ID (my-shopping-cart) as given below
    curl -X GET 'http://localhost:9005/v1/api/deployments?api-definition-id=my-shopping-cart'
    [
      {
        "apiDefinitions": [
          {
            "id": "my-shopping-cart",
            "version": "0.0.1"
          },
          {
            "id": "my-shopping-cart",
            "version": "0.0.2"
          }
        ],
        "createdAt": "2024-12-10T04:21:54.872613+00:00",
        "site": {
          "host": "localhost:9006",
          "subdomain": null
        }
      }
    ]
    As mentioned earlier, if you try to deploy a new version of an existing API definition or a completely new API definition, with conflicting routes, you will get a conflict error message during deployment. At this point, you can update the routes in the new API definition and try and deploy it again.
    Last updated on March 28, 2025
    Invoke the deployed API
    Make APIs Secure
    
  section: Invoke
  char_count: 3559
  approx_token_count: 890
- id_parent: 112
  title: Authentication
  url: https://learn.golem.cloud/invoke/making-custom-apis/authentication
  content: |
    Invoke
    Making Custom APIs
    Make APIs Secure
    Authentication in API Gateway
    Golem API gateway has built-in authentication support to identify users using OpenID protocol. This allows you to refer to the claims such as request.auth.email (as an example) once authenticated in your Rib expression. You can choose to get pass this information into the worker function that exist in the Rib expression, and do further logic with it. Currently, this is tested with Google Identity connector.
    You can register your app with Google Identity Provider and get a client-id and client-secret for your app that is to be exposed through golem API gateway.
    Setup Security for your API routes in Golem
    Register your app with Google Identity Provider and get a client-id and client-secret.
    Here is the direct link to register your app with Google Identity Provider
    (opens in a new tab)
    Here you can register your app with a name, and most importantly a redirect URL. A typical example of a redirect url is https://mydomain.com/auth/callback, where mydomain.com is the domain in which you will be deploying your API definition in Golem. For testing with OSS version, most probably this can be a localhost, and you can register your test application with http://localhost:9006/auth/callback. The /auth/callback part is just an example and it can be anything, as far as it doesn't collide with any of your other paths.
    Once you have setup the app-name, redirect-urls, you should be getting a client-id, client-secret from Google Identity Provider in return. We call these details "Api Security Scheme" in Golem API Gateway.
    Register your API Security Scheme with your app's client-id and client-secret with Golem
    Make sure you name your security scheme uniquely, and provide the client-id, client-secret and redirect-url as given below.
     
    golem api security-scheme create
      --scheme.id shopping-cart-security-scheme
      --provider.type google
      --client.id $GOOGLE_CLIENT_ID
      --client.secret $GOOGLE_CLIENT_SECRET
      --redirect.url http://localhost:9006/auth/callback
      --scopes openid,email,profile
    Make sure to specify your API definition that consist of the routes of your app with the security scheme id.
    This is more or less inspired from open OpenAPI spec, however Golem is doing some heavy lifting here such that you only need to specify the security scheme id and nothing else. If you are using OpenAPI spec, you can choose to provide additional details such OpenID connect URL but it will simply be discared by Golem but it can be useful for your own documentation purposes.
    id: my-todo-api
    version: 0.0.1
    draft: true
    security:
    - my-unique-security-scheme
    routes:
    - method: Get
      path: /foo/{user-id}
      security: my-unique-security-scheme
      binding:
        type: wit-worker
        component:
          name: "my-todo-api"
          version: 0
        response: |
          let email: string = request.auth.email;
          email
    The list of security schemes at the root level is optional in the API definition. You can choose to have it or not.
    However, to enable security for a route, you need to specify security scheme under each route (similar to a typical OpenAPI spec). In the above example, the security scheme is my-unique-security-scheme. This is the same id that you have registered with Golem API Gateway in the previous step.
    The response mapping Rib script is expecting an email field in request authentication, which will be available in the context if the user is authenticated. More on this below. Before that, let's register and deploy the above API definition stored in api_definition.yaml file.
    Register the API definition
    As explained in previous sections, register the API definition using cloud console or golem.
    golem api definition add api_definition.yaml  --def-format yaml
    Deploy the API definition
    golem api deployment deploy --host localhost:9006 --definition my-todo-api/0.0.1
    With this setup, your route is accessible only by authenticated users who have logged in with Google Identity Provider.
    Testing the authenticated endpoint in Golem
    In your browser, you can try to access the endpoint with the following URL:
    http://localhost:9006/foo/1
    This should redirect you to Google Identity Provider login page, and once you login, you should be redirected back to the original URL which is http://localhost:9006/foo/1
    (opens in a new tab)
    which will now have the claims of the user in the request context, which you can lookup using Rib script using request.auth.name or request.auth.email etc. The claims available depends on the identity provider you are using.
    If you are using Google Identity Provider, you can expect email, name etc should be available in the request context. We will be exposing claims available in a later release of Golem to make things easier for you.
    Redirects and Cookies
    Internally, there are a couple of redirects that's going on when you access the protected endpoint. The first redirect is to the Google Identity Provider login page as explained below, and internally this is followed by identity provider hitting the redirect URL ( which is exposed on your behalf by Golem API gateway) with all the details of the user. This is followed by another redirect to the original URL that you tried to access, and this time the session-id, tokens/secrets set in a secure Cookie, which your browser will resend. Once the browser sends the cookie, Golem API gateway will validate the cookie and allow you to access the protected endpoint.
    We will be adding more support for various clients and usecases in future releases based on the user feedback.
    Unexposed CallBack Endpoint
    Note that the callback endpoint is exposed automatically based on the re-direct url specified in the API security scheme. Users cannot customise or add these call back endpoints manually. This is to avoid any security issues that may arise due to misconfiguration of the callback endpoint.
    Last updated on April 5, 2025
    Update API definitions and deployments
    Setting up CORS
    
  section: Invoke
  char_count: 5963
  approx_token_count: 1491
- id_parent: 113
  title: Cors
  url: https://learn.golem.cloud/invoke/making-custom-apis/cors
  content: |
    Invoke
    Making Custom APIs
    Setting up CORS
    Setting up CORS in API Gateway
    Setting up CORS in API Gateway is simple. Simply specify the preflight request endpoint for your resource, and all the operations under the resource will be CORS-enabled. This approach is largely inspired by AWS API Gateway.
    Here is an example of how to set up CORS for your API definition.
        id: users-api
        version: 0.0.1
        createdAt: 2024-08-21T07:42:15.696Z
        routes:
        - method: Options
          path: /users/{user-id}
          binding:
            bindingType: cors-preflight
        - method: Get
          path: /users/{user-id}
          binding:
            response: |
              {status: 200, body: "Hello World"}
    Here, we define the preflight request endpoint for /users/{user-id} as the OPTIONS method. This is used by browsers to check if the actual request is allowed. Registering this API definition will ensure that the other operations (in the above example, GET) will also be CORS-enabled with the required headers in the response.
    We can define a custom response for the preflight request as well using Rib as given below
        id: users-api
        version: 0.0.1
        createdAt: 2024-08-21T07:42:15.696Z
        routes:
        - method: Options
          path: /users/{user-id}
          binding:
          bindingType: cors-preflight
          response: |
            {
              Access-Control-Allow-Origin: "*",
              Access-Control-Allow-Methods: "GET, POST, PUT, DELETE, OPTIONS",
              Access-Control-Allow-Headers: "Content-Type, Authorization",
              Access-Control-Expose-Headers: "Content-Length, X-Requested-With",
              Access-Control-Allow-Credentials: true,
              Access-Control-Max-Age: 86400u64
            }
        - method: Get
          path: /users/{user-id}
          binding:
          response: |
            {status: 200, body: "Hello World"}
    Last updated on March 28, 2025
    Make APIs Secure
    Request Response Transformation using Rib
    
  section: Invoke
  char_count: 1898
  approx_token_count: 475
- id_parent: 114
  title: Rib in api definition
  url: https://learn.golem.cloud/invoke/making-custom-apis/rib-in-api-definition
  content: |
    Invoke
    Making Custom APIs
    Request Response Transformation using Rib
    Using Rib in API definition
    Rib can be used in the API definition to define the response of an API endpoint. The response field in the API definition is a Rib script that is executed to generate the response for the API endpoint.
    With Rib, it is also possible to lookup values from the request context, such as request path, query variables, headers, and JWT token claims.
    Response Mapping
    The response field under each binding is written using Rib to call the worker function, manipulate its results, and return a value that's understandable for each protocol we use. If the protocol is HTTP, the result of Rib is converted to an HTTP response.
    Example: Below is a Rib script where the result type is a record with two fields: status and body, along with headers, which correspond to the status code, response headers, and body in an HTTP response.
     
     let result = golem:it/api.{get-cart-contents}();
     { status: 200u64, body: result, headers: { Content-Type: "application/json" } }
      Example API definition with more Rib scripts
    Here is a more complex example of an API definition with multiple routes and and more complex Rib scripts under response field. Certain fields are omitted for brevity.
    id: my-shopping-cart-v2
    draft: true
    version: 2.0.11
    routes:
      - method: Get
        path: "/{user-id}/get-cart-contents"
        binding:
          response: |
            let worker = instance();
            let result = worker.get-cart-contents();
            {status: 200u64, body: result}
      - method: Post
        path: "/{user-id}/initialize-cart"
        binding:
          response: |
            let empty: list<u16> = [];
            let worker = instance("my-worker-${request.path.user-id}");
            worker.initialize-cart(request.path.user-id);
            {status: 200u64, body: empty}
      - method: Post
        path: "/{user-id}/add-item"
        binding:
          response: |
            let worker = instance("my-worker-${request.path.user-id}");
            let quantity: f64 = request.body.quantity;
            let product_id: u64 = request.body.product-id;
            let name: string = request.body.name;
            let price: f64 = request.body.price;
            let input = {product-id: product_id, name: name, price: price, quantity: quantity};
            worker.add-item(input);
            {status: 200u64, body: success}
      - method: Post
        path: "/{user-id}/checkout"
        binding:
          response: |
            let worker = instance("my-worker-${request.path.user-id}");
            let result = worker.checkout();
            let status = 200u64;
            let body =  match result { success(resp) => resp.order-id, error(msg) => msg };
            {status: status, body: body}
    Most of the above examples are self explanatory, but worth pointing out a few details.
    Passing parameters to worker functions
    For example, in the initialize-cart endpoint, we pass the user-id from the request path to the worker function.
     
    golem:it/api.{initialize-cart}(request.path.user-id)
      Here Rib compiler knows the requirement of initialize-cart function and infers that request.path.user-id should be u64. This is a hint, that Rib is aware of the types in the code. In places where it find hard to infer these types, you may face some compile time errors (when uploading API definition), and the best solution is to be explicit about types. For example
    let user_id: u64 = request.path.user-id;
    golem:it/api.{initialize-cart}(user_id)
      Handling response from worker functions
    There are various possibilities here to manipulate the data using Rib language, such as selecting only a particular field from the result of the function invocation. Say for example, the result is a WASM result which can be ok or err. In this case you can have a complex Rib expression as below
    let result = golem:it/api.{get-cart-contents}();
     
    let response_status = match result {
      ok(_) => 200u32,
      err(_) => 400u32
    };
     
    let response_body = match result {
      ok(result) => result,
      err(msg) => msg
    }
     
    {status: response_status, body: response_body}
      The result of the Rib expression is whatever the result of the last line/expression in the above Rib program, similar to many programming languages. Note, the last line of Rib is not ending with a ;.
    Lookup up values from the request context
    Rib allow to look up the values of request path or query variables using request.path.* syntax. For request body, you can use request.body.* syntax. Similarly for headers it is request.headers.* If security is enabled, then you can also look up the JWT token claims using request.auth.*, such as request.auth.email to get the email of the user. This is already shown in most of the examples above.
    Last updated on March 28, 2025
    Setting up CORS
    Import OpenAPI Spec as API Definition
    
  section: Invoke
  char_count: 4733
  approx_token_count: 1184
- id_parent: 115
  title: Import openapi spec
  url: https://learn.golem.cloud/invoke/making-custom-apis/import-openapi-spec
  content: |
    Invoke
    Making Custom APIs
    Import OpenAPI Spec as API Definition
    Support to import OpenAPI spec
    Until now, we used the native API definition format of Golem. Golem allows you to import API definition in OpenAPI spec format too. This is because, users may have already written an OpenAPI spec for their endpoints for various purposes. By adding extra details of into the same spec, we can use it as an API definition. Internally it gets converted to the Worker Gateway's native format of API definition, discussed in the beginning of this documentation.
    The main advantage of this feature is the re-usability of the same endpoint definitions across your system. For example, you can use the same file now to register with Golem's Worker Gateway and register with another external API gateway. More on this below. However once deployed, it returns native format then onwards, and updates needs to be done in the native format.
    openapi: 3.0.0
    info:
      title: MyOpenAPISpec
      version: 1.0.2
    x-golem-api-definition-id: my-shopping-cart-v1
    x-golem-api-definition-version: 0.0.7
    paths:
      /{user-id}/get-cart-contents:
        get:
          x-golem-worker-bridge:
            component-id: dba38841-013a-49fa-a1dc-064949832f0c
            component-version: 0
            response: |
              let worker = instance("foo");
              let x = worker.checkout();
              let status: u64 = 200;
              let headers = {ContentType: "json", userid: "foo"};
              let body = "foo";
              {headers: headers, body: body, status: status}
          summary: Get Cart Contents
          description: Get the contents of a user's cart
          parameters:
            - name: user-id
              in: path
              required: true
              schema:
                type: string
          responses:
            200:
              description: OK
              content:
                application/json:
                  schema:
                    $ref: "#/components/schemas/CartItem"
            404:
              description: Contents not found
    components:
      schemas:
        CartItem:
          type: object
          properties:
            id:
              type: string
            name:
              type: string
            price:
              type: number
    To import OpenAPI spec using Golem CLI,
    golem api definition import open_api.json
    This will return
    {
      "id": "my-shopping-cart-v1",
      "version": "0.0.7",
      "routes": [
        {
          "method": "Get",
          "path": "/{user-id}/get-cart-contents",
          "binding": {
            "component": {
              "name": "my-shopping-cart",
              "version": 0
            },
            "idempotencyKey": null,
            "response": "let worker = instance(\"foo\"); let x = worker.checkout();\nlet status: u64 = 200;\n{headers: {ContentType: \"json\", userid: \"foo\"}, body: \"foo\", status: status}",
            "responseMappingInput": {
              "types": {}
            },
            "workerNameInput": {
              "types": {}
            },
            "idempotencyKeyInput": null
          }
        }
      ],
      "draft": true,
      "createdAt": "2024-10-31T08:56:02.412860043Z"
    }
    Last updated on April 5, 2025
    Request Response Transformation using Rib
    Integrating with external API Gateways
    
  section: Invoke
  char_count: 3087
  approx_token_count: 772
- id_parent: 116
  title: External api gateways
  url: https://learn.golem.cloud/invoke/making-custom-apis/external-api-gateways
  content: |
    Invoke
    Making Custom APIs
    Integrating with external API Gateways
    Integrating worker-gateway with existing API Gateways
    Note that, while the Golem's Worker Gateway is a powerful tool for defining and managing API endpoints, it is not a full-fledged API Gateway. However, it can be used conjunction with existing API Gateways, allowing you to leverage the capabilities of both systems. For example, you can use Golem's Worker Gateway to define and manage the worker bindings for your API endpoints, while using an API Gateway to handle other aspects of API management, such as authentication, rate limiting, and monitoring. In this scenario, the third party API Gateway would route incoming requests to Golem based on the defined endpoints, allowing Golem's Worker Gateway to handle the request processing and response generation.
    Tyk
    This section shows how to integrate with Tyk API gateway
    (opens in a new tab)
    .
    Note that Tyk allows users to upload OpenAPI spec similar to Golem. You can upload the same OpenAPI spec with worker-gateway info to Tyk, with 1 more extra information which is servers block with the value of the URL of the Golem Worker Gateway (which is the URL of the worker-service service in docker), that tells the Tyk API gateway of Tyk to route the request to worker-gateway.
    Please note, the above set up will work depending on how you installed Tyk. If you installed Tyk in the same network as worker-gateway, you can use the localhost as servers.
    If you are using a separate docker network with Tyk, you will need to give the machine IP address to reach the Worker Gateway URL.
    openapi: 3.0.0
    x-golem-api-definition-version: 0.0.3
    x-golem-api-definition-id: shopping-cart-v1
    info:
      title: Sample API
      version: 1.0.2
    servers:
      - url: http://ip-address-of-your-local-machine:9881
    paths:
      /{user-id}/get-cart-contents:
        x-golem-worker-bridge:
          component-id: dba38841-013a-49fa-a1dc-064949832f0c
          component-version: 0
          response: |
            let worker = instance("foo");
            let x = worker.checkout();
            let status: u64 = 200;
            {headers : {ContentType: "json", userid: "foo"}, body: "foo", status: status}
        get:
          summary: Get Cart Contents
          description: Get the contents of a user's cart
          parameters:
            - name: user-id
              in: path
              required: true
              schema:
                type: string
          responses:
            200:
              description: OK
              content:
                application/json:
                  schema:
                    $ref: "#/components/schemas/CartItem"
            404:
              description: Contents not found
    components:
      schemas:
        CartItem:
          type: object
          properties:
            id:
              type: string
            name:
              type: string
            price:
              type: number
      The difference here is we added the server's block. You can include this servers block from the beginning so that it's exactly the same OpenAPI spec which you used to upload to Golem as well as Tyk.
    Install Tyk
    Terminal
    git clone https://github.com/TykTechnologies/tyk-gateway-docker
    cd tyk-gateway-docker
    docker-compose up
    Registration with Tyk
    Let's say we saved the above json as open_api.json
    Terminal
    curl -X POST http://localhost:8080/tyk/apis/oas/import --header 'x-tyk-authorization: foo' --header 'Content-Type: text/plain' -d @open_api.json
      Reload the Tyk API Gateway, otherwise the API is not deployed with Tyk yet, so this is an important step. Note that, if you are encountering issues following these steps, please refer to Tyk documentations.
    curl -H "x-tyk-authorization: foo" -s http://localhost:8080/tyk/reload/group
      Note that Tyk is now running at 8080, and now requests has to go into 8080 and not the Golem Worker Gateway.
    Terminal
    curl -X GET http://localhost:9006/adam/get-cart-contents
    FAQ
    How does worker service know which API definition to pick for a given endpoint?
    When a request comes in, worker-service looks at the host in the request and matches it with the site in the deployment. If there is a deployment corresponding to the site, it picks the API definition ID and version from the deployment and gets the API definition, to further process the request
    Last updated on March 28, 2025
    Import OpenAPI Spec as API Definition
    Constraints on Component updates after API deployment
    
  section: Invoke
  char_count: 4324
  approx_token_count: 1081
- id_parent: 117
  title: Component constraints
  url: https://learn.golem.cloud/invoke/making-custom-apis/component-constraints
  content: |
    Invoke
    Making Custom APIs
    Constraints on Component updates after API deployment
    Constraints on Components after API deployment
    Please note that, once you have deployed an API using a specific component-version, then you may not be able to update the component-version (ex: golem component deploy) unless the arguments to the functions used in the Rib script in the deployed API definition is backward compatible.
    If there are conflicts (i.e, backward incompatible) then you will get a conflict report message, which details especially the missing functions and conflicting functions, where conflicting functions detail about existing parameter types, new parameter types, existing return type, and new return type.
    Last updated on March 28, 2025
    Integrating with external API Gateways
    Automatic API Spec Inference
    
  section: Invoke
  char_count: 813
  approx_token_count: 204
- id_parent: 118
  title: Spec inference
  url: https://learn.golem.cloud/invoke/making-custom-apis/spec-inference
  content: |
    Invoke
    Making Custom APIs
    Automatic API Spec Inference
    Automatic Inference of required inputs for API Endpoint based on Rib script
    Now that, we registered API definitions, and deployed them. As you have seen Rib script in the response field or worker name may try to look up values from the request context. This is auto documented and you can see them in the response when you register an API definition Golem Console provides a more user-friendly way to see these inputs.
    Here is a sample response when you register an API definition, where it holds the required data in the input http request.
    {
      "id": "my-shopping-cart-v1",
      "version": "0.0.4",
      "routes": [
        {
          "method": "Get",
          "path": "/v4/{user-id}/get-cart-contents",
          "binding": {
            "component": {
              "name": "shopping-cart",
              "version": 0
            },
            "workerName": "let user: u64 = request.path.user-id;\n\"my-worker-${user}\"",
            "idempotencyKey": null,
            "response": "let result = golem:it/api.{get-user-name}();\n{status: 200u64, body: result}",
            "responseMappingInput": {
              "types": {
                "request": {
                  "type": "Record",
                  "fields": [
                    {
                      "name": "path",
                      "typ": {
                        "type": "Record",
                        "fields": [
                          {
                            "name": "user-id",
                            "typ": {
                              "type": "U64"
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "request": {
                  "type": "Record",
                  "fields": [
                    {
                      "name": "path",
                      "typ": {
                        "type": "Record",
                        "fields": [
                          {
                            "name": "user-id",
                            "typ": {
                              "type": "U64"
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            },
            "responseMappingOutput": {
               "type": "Record",
               "fields": [
                  {
                    "name": "status",
                    "typ": {
                      "type": "U64"
                    }
                  },
                  {
                     "name": "body",
                      "typ": {
                        "type": "Str"
                      }
                  }
                ]
            },
            "idempotencyKeyInput": null
          }
        }
      ],
      "draft": true,
      "createdAt": "2024-10-31T07:40:16.239763054Z"
    }
    In the above response, you can see the responseMappingInput field which holds the required input for the Rib script in the response field, as well as workerNameInput which holds the required input for the Rib script in the workerName field.
    Automatic inference of output types for API Endpoint based on Rib script
    In the same example above, it infers the output types of the response mapping Rib script as well. In near future, these auto inferred inputs and outputs can be used to generate OpenAPI spec for the API that is deployed in Golem.
    Last updated on April 5, 2025
    Constraints on Component updates after API deployment
    Trouble Shooting
    
  section: Invoke
  char_count: 3413
  approx_token_count: 854
- id_parent: 119
  title: Trouble shooting
  url: https://learn.golem.cloud/invoke/making-custom-apis/trouble-shooting
  content: |
    Invoke
    Making Custom APIs
    Trouble Shooting
    Watch out for errors during deployment
    Route conflict errors during deployment
    Please note the following: If you already deployed an API definition before with the same path /{user-id}/get-cart-contents, then you will receive a conflict error as given below.
    Terminal
    API deployment definitions conflict error: /{user-id}/get-cart-contents
    This implies, when you update the version, you have to update the path as well, such as /v5/{user-id}/get-cart-contents under the path field in route.
    Watch out for more errors during API definition and deployment updates
    Please read through how to update API definitions and deployments to understand possible errors and how to manage them.
    BadRequest errors when invoking the API with inputs
    If your API's implementation (Rib script which internally calls workers) gets a wrong input (Example: wrong types in http request), it produces a BadRequest. This makes Golem Gateway much more type safe than a typical Gateway where it always routes to the backend regardless of wrong inputs.
    Here is an example:
    let user: u64 = request.path.user-id;
    let my-worker = instance("my-worker-${user}");
    my-worker.add-cart(request.body.product);
    Here we expect the request body to have a product field, with all the fields of the record type that add-cart function expects. If the request body is wrong, we get a bad request error as shown below.
    >
    * Request completely sent off
    < HTTP/1.1 400 Bad Request
    < access-control-allow-origin: *
    < content-length: 392
    < date: Tue, 10 Dec 2024 03:42:54 GMT
    <
    * Connection #1 to host localhost left intact
    Input request details don't match the requirements for rib expression to execute: Invalid value for the key path.
    Error: Invalid value for the key product. Error: Expected function parameter type is u64. But found string.
    Requirements. Record(TypeRecord { fields: [NameTypePair { name: "product-id", typ: U64)%
     Last updated on March 28, 2025
    Automatic API Spec Inference
    Debug
    
  section: Invoke
  char_count: 1994
  approx_token_count: 499
- id_parent: 120
  title: Debug
  url: https://learn.golem.cloud/debug
  content: |
    Debug
    Debug workers
    There are many scenarios where looking into a worker's state can be useful. It is possible that a worker ran into a failed state, for example. Although transient errors are automatically retried, it is possible that a worker gets permantently failed due to a programming error. It is also possible that the worker is running, but not behaving as expected.
    There are several tools available in Golem to help in these situations.
    Querying the worker state
    By querying the worker state you can get some basic information about whether the worker is running, is suspended or failed, how many pending invocations it has, and what was the error message if it failed.
    To query the worker state using the golem command line tool, you can use the following command:
    golem worker get <worker_id>
    Getting the worker's logs
    A worker can log messages in various ways:
    Writing to the standard output (stdout)
    Writing to the standard error (stderr)
    Using the log function provided by WASI logging interface
    All of these log sources are preserved and can be examined in live by connecting to the worker:
    golem worker connect <worker_id>
    There are also parameters for invocation that capture logs of the worker while an invocation is running. For more information see the CLI worker reference.
    Getting a worker's oplog
    The oplog of a worker is a journal of all the operations and events happened during the worker's lifetime. It is possible to retrieve a worker's oplog, as well as to filter it with search expressions.
    To get the whole oplog of a worker, you can use the following command:
    golem worker oplog <worker_id>
    See the CLI worker reference for more information about how to search the oplog. One debugging scenario can be to look for all oplog entries belonging to a given idempotency key that was provided with an invocation that did not behave as expected. Another can be looking for occurrences of external HTTP requests or log entries.
    Applying changes to a worker
    If the available information is not enough, it often helps to add more log lines to the worker. Recompiling the worker, updating the component and then updating the faulty worker will always succeed, if the only change was adding or removing log lines.
    Reverting changes to a worker
    The final tool available is reverting the worker. This can be done in two different ways:
    Undoing a given number of invocations. In this case we specify a number (N), and the last N invocations will be treated as if they never happened. The worker's state will be restored to the point before these last N invocations.
    Reverting to a specific oplog index. A more advanced use case is to revert the worker to a specific point in the oplog. This can be used to force rerunning some side effects such as external HTTP requests or database operations.
    To revert a worker using the golem command line interface, you can use the following command:
    golem worker revert <worker_id> --number-of-invocations 3
    or
    golem worker revert <worker_id> --last-oplog-index 12345
    Last updated on March 28, 2025
    Trouble Shooting
    Persistence
    
  section: Debug
  char_count: 3085
  approx_token_count: 772
- id_parent: 121
  title: Persistence
  url: https://learn.golem.cloud/operate/persistence
  content: |
    Operate
    Persistence
    Persistence
    Introduction
    The Golem Worker Executor uses a set of storage layers for persisting worker state and everything related to the execution of workers. This page gives an overview of what is stored where, as well as some pointers for extending Golem OSS with new storage implementations.
    Storage types
    The worker executor requires three types of storage backends:
    A blob storage for storing and retrieving arbitrary sized binary blobs
    A key-value storge with some extra requirements for set/sorted-set-like operations
    An indexed storage for an append-only, indexable store for the worker's operation log (oplog)
    Currently Golem provides the following implementations, configurable through the worker executor's config file:
    Storage type Implementations
    Blob storage S3, file system, in-memory
    Key-values storage Redis, in-memory
    Indexed storage Redis (streams), in-memory
    Compilation cache
    The Golem component service stores the component WASM files in its own storage layer (configured to be either S3 or a persistent volume) and exposes them through its download API for the worker executor. The WASM files need to be compiled to native code before execution, which is a time-consuming task. To reduce the time required for instantiating workers, these compiled binaries are cached in the worker executor's blob storage.
    The component compilation service is a special, horizontally scalable component of the Golem system which shares this storage with worker executors and is capable of precompiling components before they are being used by any of the executors.
    Oplog
    Running workers continously persist operations into the worker's oplog. The oplog is append-only (persisted entries are never modified) and it is indexable (during the recovery of a worker it is read from the earliest entry to the latest one). The oplog is stored in multiple configurable layers. The default configuration is the following:
    The primary oplog layer uses the indexed storage. This is the one where running worker's entries are appended to
    There is a secondary layer that is also persisted to the indexed storage, but on this level each entry holds a compressed set of oplog entries.
    A tertiary layer holds even larger chunks of compressed oplog entries and stores them in the blob storage.
    Oplogs are continuously moved towards the lower layers to prevent the primary oplog storage (Redis) from getting full. Workers which were not active for a while are fully stored in the blob storage only.
    In addition to the above, there are oplog entries holding user-defined data (such as invocation parameters). As these user-defined payloads can have an arbitrary size, the worker executor has to protect its storage layer against putting too large entries into the primary oplog. For this reason large payloads are written to the blob storage and the corresponding oplog entry only stores a reference to them. Payloads below a configurable limit are stored inline in the oplog entry.
    Configuration
    The [oplog] section of the worker executor configuration allows customizing the above described behavior.
    The default configuration is the following:
    [oplog]
    archive_interval = "1day"
    blob_storage_layers = 1
    entry_count_limit = 1024
    indexed_storage_layers = 2
    max_operations_before_commit = 128
    max_payload_size = 65536
    These options have the following meaning:
    Option Description
    archive_interval The period after the old sections of the oplog get moved to one layer down in the layered oplog storage
    blob_storage_layers The number of archive layers using the blob storage
    indexed_storage_layers The total number of layers (one primary + archives) using the indexed storage
    entry_count_limit The number of oplog entries triggering the archivation of a chunk to the lower oplog layer
    max_operations_before_commit The number of non-critical oplog entries that can be buffered before committed to the oplog
    max_payload_size The maximum size of user-defined payloads that can be stored inline in an oplog entry
    Worker metadata
    The oplog is the primary source of truth for everything we need to store about a worker, but for performance reasons the key value store is also used to store aggregated worker metadata for workers. This metadata is not always completely up-to-date; it store the last oplog index it was calculated from, and its latest version can be reproduced by reading and processing the newer oplog entries. For workers which has no longer data in the primary oplog, we don't store worker metadata either. When these workers have to be recovered, their metadata is reconstructed by reading the whole archived oplog.
    Promises and schedules
    The worker executor also stores promise information in its key-value storage. This is simply an entry for each created Golem promise, storing it's completion state. Internally Golem also uses scheduled promise completion (for example for waking up workers after long sleeps). These scheduled events are also stored in the key-value storage.
    WASI Blob store and Key Value store
    Golem implements (partially) the WASI Blob Store
    (opens in a new tab)
    and WASI Key-Value Store
    (opens in a new tab)
    proposals. These interfaces allow workers to store blobs and key-value data in the worker executor's configured blob storage and key-value storage layers.
    Adding new storage implementations
    The open-source version of Golem can be easily extended to support alternative databases than the built-in Redis and S3 implementations. Take a look at the following traits:
    BlobStorage
    (opens in a new tab)
    KeyValueStorage
    (opens in a new tab)
    IndexedStorage
    (opens in a new tab)
    Last updated on March 28, 2025
    Debug
    Metrics
    
  section: Operate
  char_count: 5663
  approx_token_count: 1416
- id_parent: 122
  title: Metrics
  url: https://learn.golem.cloud/operate/metrics
  content: |
    Operate
    Metrics
    Metrics
    Overview
    Every Golem service exposes Prometheus metrics on its HTTP interface. The metrics are available at the /metrics endpoint for scraping.
    Beside the service-specific metrics each service exports a single counter called version_info in which the labels hold service-specific information. The currently available labels are:
    Label Description
    version The version of the service
    Service-specific metrics
    Component Service
    Component service exposes the following Prometheus metrics:
    Metric Type Labels Description
    poem_request_count counter http.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message Counts every request on the HTTP interface
    poem_errors_count counter http.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message Counts failed requests on the HTTP interface
    poem_request_duration_ms histogram http.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message Measures the duration of handling requests on the HTTP interface
    api_success_seconds histogram api, api_type Measures the duration of successfully serving API requests (both HTTP and gRPC)
    api_failure_seconds histogram api, api_type Measures the duration of failed API requests (both HTTP and gRPC)
    grpc_api_active_streams gauge Number of open incoming gRPC streams
    http_api_active_streams gauge Number of open incoming HTTP streams
    Component Compilation Service
    Component compilation service exposes the following Prometheus metrics:
    Metric Type Labels Description
    cache_size gauge cache Current maximal capacity of the cache
    cache_hit_total counter cache Number of cache hits
    cache_miss_total counter cache Number of cache misses
    cache_eviction_total counter cache, trigger Number of cache evictions
    component_compilation_queue_length gauge Number of compilation requests enqueued
    compilation_time_seconds histogram Time to compile a WASM compnent to native code
    Shard Manager
    Shard manager exposes the following Prometheus metrics:
    Metric Type Labels Description
    api_success_seconds histogram api, api_type Measures the duration of successfully serving API requests (both HTTP and gRPC)
    api_failure_seconds histogram api, api_type Measures the duration of failed API requests (both HTTP and gRPC)
    grpc_api_active_streams gauge Number of open incoming gRPC streams
    http_api_active_streams gauge Number of open incoming HTTP streams
    external_call_success_seconds histogram target, op Dureation of successful outgoing calls
    external_call_response_size_bytes histogram target, op Size of the response of outgoing calls
    external_call_retry_total counter target, op Number of failed outgoing calls that got retried
    external_call_failure_total counter target, op Number of failed outgoing calls not to be retried
    redis_success_seconds histogram svc, api, cmd Duration of successful Redis calls
    redis_failure_total counter svc, api, cmd Number of failed Redis calls
    redis_serialized_size_bytes histogram svc, entity Size of serialized Redis entities
    redis_deserialized_size_bytes histogram svc, entity Size of deserialized Redis entities
    Worker Executor
    Worker executors expose the following Prometheus metrics:
    Metric Type Labels Description
    api_success_seconds histogram api, api_type Measures the duration of successfully serving API requests (both HTTP and gRPC)
    api_failure_seconds histogram api, api_type Measures the duration of failed API requests (both HTTP and gRPC)
    grpc_api_active_streams gauge Number of open incoming gRPC streams
    http_api_active_streams gauge Number of open incoming HTTP streams
    external_call_success_seconds histogram target, op Dureation of successful outgoing calls
    external_call_response_size_bytes histogram target, op Size of the response of outgoing calls
    external_call_retry_total counter target, op Number of failed outgoing calls that got retried
    external_call_failure_total counter target, op Number of failed outgoing calls not to be retried
    redis_success_seconds histogram svc, api, cmd Duration of successful Redis calls
    redis_failure_total counter svc, api, cmd Number of failed Redis calls
    redis_serialized_size_bytes histogram svc, entity Size of serialized Redis entities
    redis_deserialized_size_bytes histogram svc, entity Size of deserialized Redis entities
    cache_size gauge cache Current maximal capacity of the cache
    cache_hit_total counter cache Number of cache hits
    cache_miss_total counter cache Number of cache misses
    cache_eviction_total counter cache, trigger Number of cache evictions
    compilation_time_seconds histogram Time to compile a WASM compnent to native code
    event_total counter event Number of events produced by workers
    event_broadcast_total counter event Number of events broadcasted by the executor
    worker_executor_call_total counter api Number of calls to the worker layer
    promises_count_total counter Number of promises created
    promises_scheduled_complete_total counter Number of scheduled promise completions
    assigned_shard_count gauge Number of assigned shards
    create_worker_seconds histogram Time to create a new worker
    create_worker_failure_total counter error Number of failed worker creations
    invocation_total counter mode, outcome Number of invocations
    invocation_consumption_total histogram Amount of fuel consumed by an invocation
    allocated_memory_bytes histogram Amount of memory allocated by a single memory.grow instruction
    host_function_call_total counter interface, name Number of calls to specific host functions
    resume_worker_seconds histogram Time taken to resume a worker
    replayed_functions_count histogram Number of functions replayed per forker resumption
    oplog_svc_call_total counter api Number of calls to the oplog layer
    Worker Service
    Worker service exposes the following Prometheus metrics:
    Metric Type Labels Description
    poem_request_count counter http.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message Counts every request on the HTTP interface
    poem_errors_count counter http.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message Counts failed requests on the HTTP interface
    poem_request_duration_ms histogram http.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message Measures the duration of handling requests on the HTTP interface
    api_success_seconds histogram api, api_type Measures the duration of successfully serving API requests (both HTTP and gRPC)
    api_failure_seconds histogram api, api_type Measures the duration of failed API requests (both HTTP and gRPC)
    grpc_api_active_streams gauge Number of open incoming gRPC streams
    http_api_active_streams gauge Number of open incoming HTTP streams
    external_call_success_seconds histogram target, op Dureation of successful outgoing calls
    external_call_response_size_bytes histogram target, op Size of the response of outgoing calls
    external_call_retry_total counter target, op Number of failed outgoing calls that got retried
    external_call_failure_total counter target, op Number of failed outgoing calls not to be retried
    cache_size gauge cache Current maximal capacity of the cache
    cache_hit_total counter cache Number of cache hits
    cache_miss_total counter cache Number of cache misses
    cache_eviction_total counter cache, trigger Number of cache evictions
    Last updated on March 28, 2025
    Persistence
    Logs
    
  section: Operate
  char_count: 7382
  approx_token_count: 1846
- id_parent: 123
  title: Logs
  url: https://learn.golem.cloud/operate/logs
  content: |
    Operate
    Logs
    Logs
    Golem server logs
    Every Golem service emits structured logs with with configurable format and level. The default configuration for our dockerized builds is to log to the container's standard output using JSON format. Each service supports the same set of configuration keys controlling the logging behavior, which can be overwritten using environment variables.
    The default log level and filtering can be configured using the RUST_LOG environment variable, as described in the tracing-subscriber
    (opens in a new tab)
    crate's documentation. The simplest way to use this environment variable is to set a global log level, for example RUST_LOG=debug.
    The Golem specific config keys are the following:
    [tracing]
    console = false
    dtor_friendly = false
    file_name = "worker-executor.log"
    file_truncate = true
     
    [tracing.file]
    ansi = false
    compact = false
    enabled = false
    json = true
    json_flatten = true
    json_flatten_span = true
    pretty = false
    span_events_active = false
    span_events_full = false
    without_time = false
     
    [tracing.stdout]
    ansi = true
    compact = false
    enabled = true
    json = false
    json_flatten = true
    json_flatten_span = true
    pretty = false
    span_events_active = false
    span_events_full = false
    without_time = false
    Overwriting config
    To overwrite any of the above config keys using environment variables, use the GOLEM_ prefix and the __ separator for levels. For example to disable logging to the standard output, and instead enable logging to a file, set the following two variables:
    GOLEM_TRACING__FILE__ENABLED=true
    GOLEM_TRACING__STDOUT__ENABLED=false
    Configurable options
    The top-level tracing block allows setting the file name and truncate behavior for file logging, as well as enabling connection to tokio-console
    (opens in a new tab)
    .
    For both file and stdout logging, a set of boolean flags control the format of the emitted log lines:
    Flag Description
    ansi Use ANSI colors for the output
    compact Use the compact formatter.
    enabled Enables logging to file or stdout
    json Use JSON logging
    json_flatten Flatten event metadata
    json_flatten_span Flatten nested span fields
    pretty Use the pretty formatter
    span_events_active Emit one event per enter/exit of a span
    span_events_full Emit one event at all points (new, enter, exit, drop)
    without_time Do not emit timestamps for the log entries
    Golem worker logs
    For logging from workers running on Golem, there are two options:
    Print log lines to the stdout and/or stderr channels of the worker
    Use the WASI Logging interface
    (opens in a new tab)
    Using the WASI Logging interface depends on the guest language - for example for Rust, there is a crate providing bindings for the standard log crate as described on the Building Components in Rust page.
    Getting worker logs
    Worker logs (both stdout/err and WASI logging entries) are persisted for each worker, and they can be watched in live by using the connect API. There are three ways to connect to a worker:
    Using golem
    Using the connect WebSocket API
    Using the Golem Console
    (opens in a new tab)
    (Golem Cloud only)
    To connect to a worker's log with golem, use either the golem worker connect command or the --connect flag when making an invocation. See the CLI documentation for more details.
    Last updated on March 28, 2025
    Metrics
    Metadata
    
  section: Operate
  char_count: 3267
  approx_token_count: 817
- id_parent: 124
  title: Metadata
  url: https://learn.golem.cloud/operate/metadata
  content: |
    Operate
    Metadata
    Metadata
    Services are using following types of storage:
    Relational Database (RDB) - PostgreSQL
    (opens in a new tab)
    or SQLite (mainly for testing purposes)
    Redis
    (opens in a new tab)
    Blob storage - Shared File System or S3
    Component Service
    Service is using RDB and Blob storage as data storage.
    RDB tables:
    Table Description
    components Components data - id, name
    component_versions Version specific components data - version, component metadata
    See RDB migrations
    (opens in a new tab)
    for more details.
    Blob storage is used to store components binary data.
    Worker Service
    Service is using RDB as data storage.
    RDB tables:
    Table Description
    api_definitions API definitions data
    api_deployments API deployments data
    See RDB migrations
    (opens in a new tab)
    for more details.
    Shard Manager
    Service is using Redis as data storage. Redis is used to store shard assignments. Shard assignments are stored in one record with key shard:shard_manager_state.
    Component Compilation Service
    Service is using Blob storage as data storage.
    Worker Executor
    See the persistence page for more details about how the worker state get persisted.
    Last updated on March 28, 2025
    Logs
    Invocation Context
    
  section: Operate
  char_count: 1196
  approx_token_count: 299
- id_parent: 125
  title: Invocation_context
  url: https://learn.golem.cloud/operate/invocation_context
  content: |
    Operate
    Invocation Context
    Invocation Context
    Golem associates an invocation context with each worker invocation. This invocation context consists of a stack of spans, each having a collection of attributes. Currently only string attributes are supported.
    The invocation context can be queried and manipulated (by adding custom spans with custom attributes) using Golem specific host functions.
    By default the invocation context's spans are not used by Golem for anything - it is just information propagated among workers to be used by either the workers, or oplog processor plugins installed to them. It is possible to reconstruct all information about invocation context from the oplog, so oplog processor plugins can be used for example to provide live traces of workers through OpenTelemetry.
    Automatic invocation context spans
    Incoming HTTP requests
    The root spans of an invocation are containing information depending on how that invocation was started. When invoking through the invocation REST API, W3C Trace Context
    (opens in a new tab)
    headers are automatically processed to set the root trace-id and parent span-id.
    When using custom APIs, the same headers are also taken into account by default, but it is also possible to write a custom Rib script per endpoint to extract more information from the HTTP requests and define custom span attributes with them.
    In both cases, when the invocation's trigger is a HTTP request, a spans is added with the following attributes:
    request.method
    request.uri
    request.remote_addr
    Invocations
    When an invocation reaches a worker, a new span is created containing the following attributes:
    name: span's name (invoke-exported-function)
    idempotency_key: unique identifier of the invocation
    function_name: the fully qualified function name
    worker_id: worker's id (consists of component ID and worker name)
    Outgoing HTTP requests
    Outgoing HTTP requests are also represented by their own automatic spans with the following attributes:
    name: span's name (outgoing-http-request)
    request.method: the outgoing request's HTTP method
    request.uri: the outgoing request's URI
    RPC calls
    RPC calls on the caller side are also represented by a custom spans. First a span is created when the underlying RPC resource is initialized, with the following attributes:
    name: span's name (rpc-connection)
    target_worker_id: the target worker's ID
    Within this span, a new span is created for each remote invocation, with the following attributes:
    name: span's name (rpc-invocation)
    function_name: the invoked function's fully qualified name
    idempotency_key: the unique identifier of the invocation
    Last updated on March 28, 2025
    Metadata
    CLI
    
  section: Operate
  char_count: 2662
  approx_token_count: 666
- id_parent: 126
  title: Cli
  url: https://learn.golem.cloud/cli
  content: |
    CLI
    Golem CLI Introduction
    Golem CLI is a command-line interface for interacting with Golem. Golem CLI allows users to upload their components, launch new workers based on these components and call functions on running workers.
    Golem CLI versions
    There are precompiled binaries of two variants of the CLI here:
    golem is the full version of the command line interface, including a locally runnable version of Golem itself.
    golem-cli is a lightweight version of the command line interface, requiring a running Golem cluster
    In this documentation we will use the golem command in the snippets.
    Installation
    There are two ways to install any of the above described versions of Golem CLI:
    Downloading a precompiled platform-specific binary
    Installing from source using Rust tooling
    Downloading precompiled binaries
    You can download the precompiled version of golem (and golem-cli) from the following pages:
    Golem CLI Releases
    We provide precompiled binaries for the following platforms:
    Mac arm64
    Mac x86_6
    Linux arm64
    Linux x86_64
    Windows x86_64
    Some platforms may protect by default from running these downloaded binaries. You may need to allow running them in your system settings.
    Installing from source
    It is also possible to build it from source for yourself using Rust tooling. Refer to the page about building Golem CLI for yourself for more information.
    Profiles
    The Golem CLI can have multiple profiles configured, each selecting a specific Golem cluster to connect to, as well as some settings like the default output format.
    See the Golem CLI profiles page for more information.
    Working with components
    Golem CLI can manage Golem Components. See the Golem CLI components page for details.
    Interacting with workers
    Golem CLI allows creating, invoking and observing Golem Workers. See the Golem CLI workers page for more information.
    Last updated on March 28, 2025
    Invocation Context
    Application Manifest
    
  section: Cli
  char_count: 1909
  approx_token_count: 478
- id_parent: 127
  title: App manifest
  url: https://learn.golem.cloud/cli/app-manifest
  content: |
    CLI
    Application Manifest
    Golem Application Manifest
    The Golem Application Manifest document format is used by golem, usually stored in files named golem.yaml, which can help working with components. Currently, the Application Manifest covers:
    defining components and their metadata, including:
    component type
    location of user defined and generated WIT folders
    location of built and composed WASM binaries
    build commands
    Initial File System
    defining component dependencies for using Worker to Worker communication
    building components
    deploying components
    The Application Manifest uses YAML format, see the reference for more information on the schema and for the field reference.
    Application Manifest Quickstart
    Application manifest documents can be explicitly passed as golem arguments, but the recommended way to use them is with auto discovery mode: when golem is called with an application manifest compatible command it keeps searching for golem.yaml documents in current working directory and parent directories. Once it found the top level golem.yaml document, more documents are searched using the includes field.
    Once all manifest documents are found, the paths in them are resolved based on their directory, and then the documents are merged. For the field specific merge rules see the field reference.
    Using composable templates
    Golem projects can be created with golem app new command. This creates a new application that may consist of multiple components. To add a new component to an existing application, use golem component new. E.g.: let's add a new c and ts component in a new and empty directory:
    golem app new app:component-a c
    cd app:component-a
    golem component new ts app:component-b
    When using the app new command, it will create:
    common directory for the given language (common-cpp and common-ts):
    this directory contains the languages specific Application Manifest Template, which defines how to build the components
    can be used for shared subprojects
    might contain other shared configurations
    directory for components for the given language (components-cpp and components-ts)
    directory called wit/deps for common WIT dependencies, and populates it with WASI and Golem packages
    depending on the language it might add common-adapters.
    Now that we added our components, let's use the app command list our project metadata:
    $ golem app
     
    Build, deploy application
     
    Usage: golem app [OPTIONS] <COMMAND>
     
    Commands:
      new     Create new application
      build   Build all or selected components in the application
      deploy  Deploy all or selected components in the application, includes building
      clean   Clean all components in the application or by selection
      help    Print this message or the help of the given subcommand(s)
     
    Options:
      -f, --format <FORMAT>
              Output format, defaults to text, unless specified by the selected profile
      -p, --profile <PROFILE>
              Select Golem profile by name
      -l, --local
              Select builtin "local" profile, to use services provided by the "golem server" command
      -c, --cloud
              Select builtin "cloud" profile to use Golem Cloud
      -a, --app-manifest-path <APP_MANIFEST_PATH>
              Custom path to the root application manifest (golem.yaml)
      -A, --disable-app-manifest-discovery
              Disable automatic searching for application manifests
      -b, --build-profile <BUILD_PROFILE>
              Select build profile
          --config-dir <CONFIG_DIR>
              Custom path to the config directory (defaults to $HOME/.golem)
      -v, --verbose...
              Increase logging verbosity
      -q, --quiet...
              Decrease logging verbosity
      -h, --help
              Print help
     
    Components:
      app:component-a
        Selected:     yes
        Source:       /Users/<...>/app-demo/components-cpp/app-component-a/golem.yaml
        Template:     cpp
        Profiles:     debug, release
      app:component-b
        Selected:     yes
        Source:       /Users/<...>/app-demo/components-ts/app-component-b/golem.yaml
        Template:     ts
     
    Custom commands:
      npm-install
    Because the ts components use npm, we have to use npm install before building the components. We can also see that this has a wrapper custom command in the manifest called npm-install. Let's use that, then build our components:
    $ golem app npm-install
    <..>
    $ golem app build
    Collecting sources
      Found sources: /Users/<...>/app-demo/common-cpp/golem.yaml, /Users/<...>/app-demo/common-ts/golem.yaml, /Users/<...>/app-demo/components-cpp/app-component-a/golem.yaml, /Users/<...>/app-demo/components-ts/app-component-b/golem.yaml, /Users/<...>/app-demo/golem.yaml
    Collecting components
      Found components: app:component-a, app:component-b
    Resolving application wit directories
      Resolving component wit dirs for app:component-a (/Users/<...>/app-demo/components-cpp/app-component-a/wit, /Users/<...>/app-demo/components-cpp/app-component-a/wit-generated)
      Resolving component wit dirs for app:component-b (/Users/<...>/app-demo/components-ts/app-component-b/wit, /Users/<...>/app-demo/components-ts/app-component-b/wit-generated)
    Selecting profiles, no profile was requested
      Selected default profile debug for app:component-a using template cpp
      Selected default build for app:component-b using template ts
    <...>
    Linking RPC
      Copying app:component-a without linking, no static WASM RPC dependencies were found
      Copying app:component-b without linking, no static WASM RPC dependencies were found
    Then we can check that the components are built:
    $ ls golem-temp/components
    app_component_a_debug.wasm app_component_b.wasm
    To deploy (add or update) or components we can use
    golem component deploy
    in the project root folder, and the CLI will add or update all or components.
    If we want to only update some components, we can do so by explicitly selecting them with the --component-name flag, or we can implicitly select them by changing our current working directory, e.g.:
    $ cd components-cpp
    $ golem app
    <...>
    Components:
      app:component-a
        Selected:     yes
        Source:       /Users/noise64/workspace/examples/app-demo/components-cpp/app-component-a/golem.yaml
        Template:     cpp
        Profiles:     debug, release
      app:component-b
        Selected:     no
        Source:       /Users/noise64/workspace/examples/app-demo/components-ts/app-component-b/golem.yaml
        Template:     ts
    <...>
    Notice, how only app:component-a is selected in the above example, the same selection logic is used when adding or updating components.
    Last updated on March 28, 2025
    CLI
    Components
    
  section: Cli
  char_count: 6489
  approx_token_count: 1623
- id_parent: 128
  title: Components
  url: https://learn.golem.cloud/cli/components
  content: |
    CLI
    Components
    Golem CLI Components
    Golem components are WASM components deployed to Golem for execution.
    To create, list, build and deploy components you can use golem component command.
    Creating a new component
    To create a new component in an application directory (previously created with golem app new) use the component new command in the following way:
    golem component new <template-name> <component-name>
    To see all the available component templates, just run the command without providing one.
    This command only modifies the source code of the application, does not create anything on the server.
    Building a component
    To build a component, use the component build command in the following way:
    golem component build <component-name>
    To build the whole application, use the app build command in the following way:
    golem app build
    Both commands accept a --build-profile <BUILD_PROFILE> argument. Some of the built-in templates define a separate release profile which creates a more optimized version of the components. Build profiles can be fully customized by editing the application manifest files.
    Deploying a component
    To deploy a component, use the component deploy or app deploy commands in the following way:
    golem component deploy <component-name>
    or
    golem app deploy <component-name>
    to deploy a specific component only.
    The output of the command will be something like the following:
    New component created with URN urn:component:d8bc9194-a4a2-4a57-8545-43408fc38799, version 0, and size of 89735 bytes.
    Component name: my-component.
    Exports:
            rpc:counters/api.{[constructor]counter}(name: string) -> handle<0>
            rpc:counters/api.{[method]counter.inc-by}(self: &handle<0>, value: u64)
            rpc:counters/api.{[method]counter.get-value}(self: &handle<0>) -> u64
            rpc:counters/api.{[method]counter.get-args}(self: &handle<0>) -> list<string>
            rpc:counters/api.{[method]counter.get-env}(self: &handle<0>) -> list<tuple<string, string>>
            rpc:counters/api.{inc-global-by}(value: u64)
            rpc:counters/api.{get-global-value}() -> u64
            rpc:counters/api.{get-all-dropped}() -> list<tuple<string, u64>>
            rpc:counters/api.{bug-wasm-rpc-i32}(in: variant { leaf }) -> variant { leaf }
            rpc:counters/api.{[drop]counter}(self: handle<0>)
    The returned output contains the following information:
    Component URN - URN for the new component. You can use this URN whenever you want to specify the component instead of component name.
    Component version - incremental component version - used for updating the workers.
    Component size - size of the wasm file - it is important for the storage limit in the hosted Golem Cloud.
    Exports - exported function you can call. You can copy function name (the part before parameters) to call the function. All Golem API expect function names in exactly this format. See the function name reference page for more details.
    To deploy all components of an application, use:
    golem app deploy
    To deploy the component based on the current directory, use:
    golem component deploy
    Ephemeral components
    Components created are durable by default. To create an ephemeral component instead, change the component's application manifest (golem.yaml) to contain:
    components:
      example:component:
        componentType: ephemeral
    Component search
    Using component name and the latest version
    If you want to get the latest version of the component using its name you can you can use the component get command.
    golem get example:component
    Using component name and specific version
    To get a specific version of a component, just pass the desired version number as well:
    golem get example:component 2
    Getting component list
    To get all component versions for specific component name you can use component list command with a given component name. Note if you are in a component's source directory, the command will automatically list that component's versions.
    golem component list example:component
    To get all component available you can use component list command this way:
    golem component list
    💡
    If you want to restrict component search to some specific project on Golem Cloud you can specify project via --project or --project-name option. It works for all commands that accept --component-name parameter.
    Updating component
    To update a component just run the component deploy (or app deploy) command again.
    If you want to trigger an update all worker to the new latest version right after creating this version you can use --try-update-workers option.
    It is possible to change the component's type (from durable to ephemeral, or from ephemeral to durable) when updating the component by changing the manifest file.
    Updating workers
    If you want to update all workers you can use component try-update-workers command.
    This command gets all workers for the component that are not using the latest version and triggers an update for them one by one:
    golem component try-update-workers example:component
    The update request is enqueued and processed by the workers asynchronously, golem cannot await for the update to finish.
    ⚠️
    Note that automatic worker update is not guaranteed to succeed, if the updated component differs too much from the previous one.
    💡
    You can use URL or --component-name instead.
    Redeploying workers
    During the development of a Golem Component, it is often necessary to quickly rebuild the code, update the component and just restart all the test workers from scratch to test the changes.
    This is different from updating the workers as they will loose their state, but it can speed up the feedback loop during development.
    This workflow is supported by the component redeploy command:
    golem component redeploy example:component
    This command deletes all workers that are not using the latest version of component and re-creates them with the same name, parameters and environment variables.
    💡
    You can use URL or --component-name instead.
    Last updated on March 28, 2025
    Application Manifest
    Workers
    
  section: Cli
  char_count: 5985
  approx_token_count: 1497
- id_parent: 129
  title: Workers
  url: https://learn.golem.cloud/cli/workers
  content: |
    CLI
    Workers
    Golem CLI Workers
    Using golem worker command you can:
    Start and stop worker
    Interrupt and resume workers
    Invoke worker function
    Get worker stdout, stderr and logs
    Update workers
    Search workers, get metadata, etc.
    Revert a worker to a previous state
    💡
    In all examples we are using component URN. You can use component URL or --component-name instead.
    Start new worker
    Even though workers can automatically start on the first invocation, it is possible to explicitly start a worker. This allows specifying command line arguments and environment variables for the worker.
    golem worker new example:counter/counter1 --env A=1 --env B=2 arg1 arg2
    You can see the URN for your new worker in command output. You can use URN whenever you want to specify worker instead of component and worker name.
    Get worker metadata
    Using worker name
    You can get worker metadata using worker name and (optionally prefixed by the component name, if it is not inferrable from the current context):
    golem worker get counter1
    golem worker get example:counter/counter1
    Search workers
    You can search for workers of some components using worker list command with repeated --filter argument.
    For instance lets find idle workers with component version older than 2 of the component example:counter:
    golem worker list --filter "status = Idle" --filter "version < 2" example:counter
    ⚠️
    Enumerating workers is a slow operation and should only be used for debugging an administrative tasks.
    Invoke functions
    The folowig section shows the basics of invoking workers through the CLI. See the dedicated invocation with CLI page for more details.
    Without waiting for result
    You can invoke worker function without waiting for function result using worker invoke --enqueue command:
    golem worker invoke --enqueue counter1 'rpc:counters/api.{inc-global-by}' 5
    Function parameters can be specified using repeated --arg parameters.
    Waiting for result
    You can invoke worker function and wait for result using worker invoke command:
    golem worker invoke counter1 'rpc:counters/api.{get-global-value}'
    Invocation results in WAVE format:
    - '5'
    Ephemeral workers
    Invoking ephemeral components does not require specifying the worker name, as Golem creates a new instance for each invocation. In this case only the component must be selected (if it is not inferred by the context), and the worker name must be -:
    golem worker invoke example:ephemeral-component/- 'demo:worker/api.{test}'
    Using idempotency key
    If you want to make sure function was called only once even if you called CLI multiple times (for instance due to retries on network errors) you can use --idempotency-key parameter for both invoke and invoke-and-await commands.
    You can use any string as idempotency key.
    Live streaming worker logs
    You can connect to your running worker and get logs using worker connect command this way:
    golem worker connect counter1
    You can also use --connect option on invoke command to connect to worker right after invoking the command.
    Worker update
    To update worker to some specific version of worker component you can use worker update this way:
    golem worker update counter1 --target-version 2 --mode auto
    You can also use worker update-many with the same --filter parameters as in worker list command to update multiple workers:
    golem worker update-many example:counter --filter 'version < 2' --target-version 2 --mode auto
    Interrupt and resume workers
    If you want to interrupt and later resume a long-running worker you can use interrupt and resume commands:
    golem worker interrupt counter1
    golem worker resume counter1
    Testing worker crash recovery
    There is a special command to simulate unexpected worker crush and recovery - worker simulated-crash. This command can be used for tests:
    golem worker simulated-crash counter1
    Stopping workers
    Idle worker are not actively consuming resources but they take storage as their state is persisted. A worker can be deleted using the worker delete command:
    golem worker delete counter1
    This command deletes worker state.
    Please note that even though the worker can be deleted this way it would be started again (with the fresh state) if used:
    golem worker delete counter1
    golem worker invoke counter1 'rpc:counters/api.{get-global-value}'
    Invocation results in WAVE format:
    - '0'
    Oplog query
    It is possible to query an existing worker's oplog for debugging purposes. To get the full oplog of a worker, use the worker oplog command the worker must be specified just like in other golem-cli worker commands:
    golem worker oplog counter1
    Any other form of identifying a worker can be used (URL syntax, separate component-id and worker name, etc).
    With the optional --from parameter it is possible to only get oplog entries after a certain oplog index:
    golem worker oplog counter1
    Oplog entries are indexed from 1, and the first entry is always a create entry that defines the initial state of the worker.
    Searching for oplog entries
    The same command can also be used to search for oplog entries, using the --query parameter. This parameter requries a query using lucene query syntax. The following syntax elements are supported:
    search terms looks for search AND terms
    AND, OR and NOT
    grouping using parentheses ()
    "quoted terms"
    regular expression matches using /regex/
    field:value to search for a specific information
    The terms and fields are interpreted in the following way:
    Oplog entry Matching queries
    Create create
    ImportedFunctionInvoked imported-function-invoked, match on invoked function's name, match on function arguments(), match on result value()
    ExportedFunctionInvoked exported-function-invoked, exported-function, match on invoked function's name, match on idempotency key, match on function arguments(*)
    ExportedFunctionCompleted exported-function-completed, exported-function, match on response value(*)
    Suspend suspend
    Error error, match on error message
    NoOp noop
    Jump jump
    Interrupted interrupted
    Exited exited
    ChangeRetryPolicy change-retry-policy
    BeginAtomicRegion begin-atomic-region
    EndAtomicRegion end-atomic-region
    BeginRemoteWrite begin-remote-write
    EndRemoteWrite end-remote-write
    PendingWorkerInvocation pending-worker-invocation, match on invoked function's name, match on idempotency key, match on function arguments(*)
    PendingUpdate pending-update, update, match on target version
    SuccessfulUpdate successful-update, update, match on target version
    FailedUpdate failed-update, update, match on target version, match on error details
    GrowMemory grow-memory
    CreateResource create-resource
    DropResource drop-resource
    DescribeResource describe-resource, match on resource name, match on resource parameters(*)
    Log log, match on context, match on message
    Restart restart
    ActivatePlugin activate-plugin
    DeactivatePlugin deactivate-plugin
    The cases marked with (*) can use the field:value syntax to look into the typed, structured parameter and result values.
    For example to look for oplog entries that contain parameters or return values of exported functions where any of these input/output values is a record having a field product-id with either value 123 or 456, we can use the following query:
    golem worker oplog --worker urn:worker:d8bc9194-a4a2-4a57-8545-43408fc38799/counter1 --query 'exported-function AND (product-id:123 OR product-id:456)'
    Reverting a worker
    It is possible to revert a worker to its previous state. This can be useful if a worker got into a failed state to make it usable again, or to undo some accidental invocations or updates.
    There are two possible ways to specify which state to revert to:
    By index: The index of the oplog entry to revert to. Use the oplog query command to check the worker's oplog and find the index of the desired state.
    By undoing the last invocations: The given number is the number of invocations to revert.
    To revert to a given oplog, use the worker revert command:
    golem worker revert counter1 --last-oplog-index 42
    To revert some of the last invocations, use the --number-of-invocations parameter instead:
    golem worker revert counter1 --number-of-invocations 3
    Last updated on March 28, 2025
    Components
    Profiles
    
  section: Cli
  char_count: 8099
  approx_token_count: 2025
- id_parent: 130
  title: Profiles
  url: https://learn.golem.cloud/cli/profiles
  content: |
    CLI
    Profiles
    Golem CLI Profiles
    Profiles are used for golem CLI configuration. Using different profiles you can use golem with multiple installations of an open source Golem and the hosted Golem Cloud at the same time.
    Interactive profile creation
    To start interactive profile creation run the following command:
    golem init
    If you want to specify a custom profile name for an interactive profile creation process - you can use the following command:
    golem profile init custom-name
    On the first step you'll see 3 options:
    Golem Default. Use this options for default local docker compose installation.
    Golem. Use this option in case of a customised Golem installation, i.e. a custom GOLEM_ROUTER_PORT in .env file.
    Golem Cloud. Use this option for a hosted version of Golem.
    With Golem Default the hosted Golem Cloud options there are no other specific configuration options. To specify a custom location for your local open source Golem installation - please use the Golem option.
    Non-interactive profile creation
    Hosted Golem Cloud profile
    To create a profile for a hosted Golem Cloud use the following command:
    golem profile add --set-active golem-cloud --default-format json my-profile-name
    This command creates a new Golem Cloud profile named my-profile-name with default output format json and sets it as a new active profile. If you want to keep default output format text - you can omit --default-format json part. If you don't want to make the new profile as the new active profile - you can omit --set-active.
    If you are using golem-cloud-cli binary you should omit profile type (golem-cloud) since golem-cloud-cli does not support other profile types:
    Terminal
    golem-cloud-cli profile add my-profile-name
    Local open source Golem
    To create a profile for your local open source Golem installation use the following command:
    golem profile add --set-active golem --component-url http://localhost:9881 my-oss-profile-name
    This command creates a new open source Golem profile named my-oss-profile-name with both component and worker service location as http://localhost:9881 and sets it as the new active profile.
    Additionally, you can specify --default-format option for json or yaml instead of human-readable text and --worker-url in case you want to have worker and component services on different locations.
    If you are using an open source specific golem - you should omit profile type (golem). If you are using a Golem Cloud specific golem-cloud-cli - you can't create an open source Golem profile.
    Profile authentication
    💡
    This is Golem Cloud specific part.
    To authentication your Golem Cloud profile you can run any command that requires authentication, i.e. you can run any command that wants to access Golem Cloud servers. The easiest way to authenticate your profile woutd be to run the following command:
    golem account get
    At the moment the only way to authenticate your account is to use Github Oauth2 authorization. Please follow the instructions in your terminal and authorize zivergetech organisation to use OAuth2:
    >>
    >>  Application requests to perform OAuth2
    >>  authorization.
    >>
    >>  Visit following URL in a browser:
    >>
    >>   ┏---------------------------------┓
    >>   ┃ https://github.com/login/device ┃
    >>   ┗---------------------------------┛
    >>
    >>  And enter following code:
    >>
    >>   ┏-----------┓
    >>   ┃ ADFC-A318 ┃
    >>   ┗-----------┛
    >>
    >>  Code will expire in 14 minutes at 15:15:27.
    >>
    Waiting...
    Account with id account-id for name Your Name with email your@email.com.
    Switch profiles
    To get the list of your profiles use the following command:
    golem profile list
    You'll get all available profiles with the active profile marked by *:
     * my-oss-profile-name
       my-profile-name
    To switch active profile use profile switch command:
    golem profile switch my-profile-name
    Golem profile configuration
    At the moment the only configurable option is default output format.
    To change the default output format for the current active profile you can use profile config format command this way:
    golem profile config format text
    Output formats
    There are 3 output formats:
    text - human-readable format
    json
    yaml
    Almost all commands can change output format based on --format option or default output format configured for the current active profile.
    Profile configuration files
    All golem configuration files are stored in .golem directory in your home directory. This includes the cached authentication token to your Golem Cloud profile. It is safe to remove $HOME/.golem directory in case of any issues with profiles - you will keep access to your Golem Cloud account as log as you have access to your Github account linked to your Golem Cloud account.
    Last updated on March 28, 2025
    Workers
    Permissions
    
  section: Cli
  char_count: 4718
  approx_token_count: 1180
- id_parent: 131
  title: Permissions
  url: https://learn.golem.cloud/cli/permissions
  content: |
    CLI
    Permissions
    Golem CLI Permissions
    This page only applies to the hosted Golem Cloud.
    Tokens
    Tokens are API keys that allow accessing Golem Cloud APIs from external services. The golem-cloud-cli tool allows managing these tokens. To manage them programmatically, check the token API.
    Listing existing tokens
    The following command lists all the tokens associated with your account:
    golem token list
    Creating a new token
    To create a new token, use the following command:
    golem token add
    New token created with id 08bc0eac-5c51-40a5-8bc6-5c8928efb475 and expiration date 2100-01-01 00:00:00 UTC.
    Please save this token secret, you can't get this data later:
    64cf566c-ed72-48e5-b786-b88aa0298fb4
    Optionally, an expiration date can be specified with --expires-at. If not specified, default expiration date is 2100-01-01 00:00:00 UTC.
    Deleting a token
    Each token has a token ID. Use the token delete command to remove a token using it's identifier:
    golem token delete 08bc0eac-5c51-40a5-8bc6-5c8928efb475
    Project sharing
    On Golem Cloud components are organized into projects.
    Listing projects
    Existing projects can be listed using the project list subcommand:
    golem project list
    Adding projects
    A new project can be created using project add. The command expects a project name and description:
    golem project add --project-name "Golem Demo" --project-description "A new project for demonstrating the project feature"
    When creating components or workers, the project can be specified with the --project-name flag. Every user has a default project which is used when no explicit project is specified.
    Sharing projects with other accounts
    Projects can be shared among multiple Golem Cloud accounts.
    To share a project, use the share subcommand:
    golem share --project-name "Golem Demo" --recipient-account-id 08bc0eac-5c51-40a5-8bc6-5c8928efb475 --project-actions ViewWorker --project-actions ViewComponent
    This example shares the "Golem Demo" project with the account identified by 08bc0eac-5c51-40a5-8bc6-5c8928efb475 and grants component and worker view permissions for it.
    💡
    Alternatively it is possible to create and manage project policies using the project-policy subcommand, and refer to these policies in the share command later.
    The following table lists all the actions that can be granted to a project:
    Action Description
    ViewComponent List, download and get metadata of components
    CreateComponent Create new components
    UpdateComponent Update existing components
    DeleteComponent Delete components
    ViewWorker List and get metadata of workers
    CreateWorker Create new workers
    UpdateWorker Update existing workers
    DeleteWorker Delete workers
    ViewProjectGrants List existing project grants
    CreateProjectGrants Grant more access for the project
    DeleteProjectGrants Revoke access for the project
    ViewApiDefinition View API definitions
    CreateApiDefinition Create new API definitions
    UpdateApiDefinition Update existing API definitions
    DeleteApiDefinition Delete API definitions
    Last updated on March 28, 2025
    Profiles
    Plugins
    
  section: Cli
  char_count: 3021
  approx_token_count: 756
- id_parent: 132
  title: Plugins
  url: https://learn.golem.cloud/cli/plugins
  content: |
    CLI
    Plugins
    Golem CLI Plugins
    Manage the available plugins
    To manage the plugins available for installation, use the golem plugin commands.
    See the Plugins page for general information about Golem plugins.
    List the available plugins
    To list the available plugins, use the golem plugin list command.
    golem plugin list
    Plugins can be installed to different scopes. By default the command lists the plugins installed in the global scope.
    Use the following options to list plugins in other scopes:
    --project <PROJECT_NAME>: List plugins installed in the given project's scope
    --component <COMPONENT_NAME>: List plugins installed in the given component's scope.
    Get information about a registered plugin
    To get more information about one of the available plugins, use the golem plugin get command:
    golem plugin get <PLUGIN_NAME> <PLUGIN_VERSION>
    Register a new plugin
    Plugins are identified by their name and version. To register a new plugin, use the golem plugin register command:
    golem plugin register <MANIFEST_PATH>
    The parameter should point to a plugin manifest YAML describing all the properties of the plugin.
    The plugin manifest
    The plugin manifest consists of the following required global fields:
    field name description
    name The name of the plugin
    version The version of the plugin
    description A short description of the plugin
    icon Path to the plugin's icon
    homepage URL to the plugin's homepage
    The details of the plugin are specified in the specs field, which is an object.
    The specs.type field specifies the type of the plugin. It can be one of the following:
    ComponentTransformer: The plugin is a component transformer plugin.
    OplogProcessor: The plugin is an oplog processor plugin.
    App: The plugin is an application plugin.
    Library: The plugin is a library plugin.
    The rest of the fields of the spec object depend on the plugin type.
    ComponentTransformer fields
    field name required description
    providedWitPackage No The path to the WIT file describing the extra provided interfaces the plugin adds
    jsonSchema No The path to the JSON schema file describing the plugin's configuration fields
    validateUrl Yes URL to the external component transformation service's validate endpoint
    transformUrl Yes URL to the external component transformation service's transform endpoint
    OplogProcessor fields
    field name required description
    component Yes The path to the oplog processor component (WASM)
    App fields
    field name required description
    component Yes The path to the application component (WASM)
    Library fields
    field name required description
    component Yes The path to the library component (WASM)
    Unregister a plugin
    To unregister an available plugin, use the following command:
    golem plugin unregister --plugin-name <PLUGIN-NAME> --version <PLUGIN-VERSION>
    Manage a component's plugins
    A subset of the registered plugins can be installed for a component using te golem component plugin commands.
    Get the installed plugins
    To get the list of installed plugins for a component, use the following command:
    golem component plugin get <COMPONENT-NAME> <VERSION>
    Install a plugin
    To install a plugin for a component, use the following command:
    golem component plugin install --plugin-name <PLUGIN_NAME> --plugin-version <PLUGIN_VERSION> --priority <PRIORITY> [COMPONENT_NAME]
    Many plugins require per-installation configuration. These are key-value pairs that can be passed as arguments to the install command as --param <KEY=VAL>.
    The priority is a number that determines the order in which plugins are applied.
    Uninstall a plugin
    To uninstall a plugin from a component, use the following command:
    golem component plugin uninstall --installation-id <INSTALLATION_ID> [COMPONENT_NAME]
    The installation ID is a unique identifier assigned every time a plugin is installed for a component. It is not enough to use the plugin name and version here, because one plugin can be installed multiple times (for exampel with different configuration) for a component.
    Updating a plugin's priority or configuration
    TODO
    Manage a project's plugins
    In Golem Cloud it is also possible to install plugins for a project. Every component created in the project will get the installed plugins from the project.
    Get the installed plugins
    To get the list of installed plugins for a project, use the following command:
    TODO
    Install a plugin
    To install a plugin for a project, use the following command:
    TODO
    Many plugins require per-installation configuration. These are key-value pairs that can be passed as arguments to the install command as --param <KEY=VAL>.
    The priority is a number that determines the order in which plugins are applied.
    Uninstall a plugin
    To uninstall a plugin from a project, use the following command:
    TODO
    The installation ID is a unique identifier assigned every time a plugin is installed for a component. It is not enough to use the plugin name and version here, because one plugin can be installed multiple times (for exampel with different configuration) for a component.
    Updating a plugin's priority or configuration
    TODO
    Controlling oplog processor plugins per worker
    If a component has oplog processors plugins installed, they can be dynamically activated or deactivated for each worker.
    Activating a plugin on a worker
    TODO
    Deactivating a plugin on a worker
    TODO
    Last updated on March 28, 2025
    Permissions
    Shell Completion
    
  section: Cli
  char_count: 5339
  approx_token_count: 1335
- id_parent: 133
  title: Shell completion
  url: https://learn.golem.cloud/cli/shell-completion
  content: |
    CLI
    Shell Completion
    Golem CLI Shell completion
    The golem completion command can be used to generate shell completions for many popular shells:
    bash
    elvish
    fish
    powershell
    zsh
    golem completion --generate bash
    The above command will generate and print the shell completion script to the standard output, redirect the output into a file to save the script. Consult your shell documentation about where to place it.
    After every golem update, it is advised to also regenerate the shell completion to always include all the latest commands and flags.
    Last updated on March 28, 2025
    Plugins
    Install from Source
    
  section: Cli
  char_count: 604
  approx_token_count: 151
- id_parent: 134
  title: Install from source
  url: https://learn.golem.cloud/cli/install-from-source
  content: |
    CLI
    Install from Source
    Golem CLI installation from source
    If the precompiled binaries are not available for your platform, or prefer to install from source, you can build it with the Rust toolchain,
    Prerequisites
    To build golem-cli you need to use cargo, Rust's build tool, and the build will require protoc, the protobuf
    (opens in a new tab)
    compiler.
    To get cargo on your system, we recommend using rustup
    (opens in a new tab)
    :
    Terminal
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    rustup install stable
    rustup default stable
    To install protoc see https://grpc.io/docs/protoc-installation/
    (opens in a new tab)
    . Make sure to install version 3.15 or higher.
    Installing golem-cli
    The golem-cli command is the more lightweight version of Golem's command line interface, that allows you to interact with a running Golem cluster but it does not have a built-in local version of Golem itself.
    To install golem-cli from source, use cargo install:
    cargo install golem-cli --locked
    This will create a binary file named golem-cli in the ~/.cargo/bin directory.
    Installing golem
    The golem binary is the full version of Golem's command line interface, containing everything golem-cli has and also has a built-in local version of Golem itself.
    The golem package is not published to crates.io
    (opens in a new tab)
    so in order to install it from source, follow the steps below.
    Clone the repository
    Clone the GitHub repository
    (opens in a new tab)
    :
    git clone https://github.com/golemcloud/golem-cli.git
    Install cargo-make
    Install cargo-make using cargo install:
    cargo install cargo-make --locked
    Build the project
    Build the project using cargo make:
    cargo make build
    Last updated on March 28, 2025
    Shell Completion
    Desktop
    
  section: Cli
  char_count: 1731
  approx_token_count: 433
- id_parent: 135
  title: Desktop
  url: https://learn.golem.cloud/desktop
  content: |
    Desktop
    Golem Desktop Introduction
    Golem Desktop provides a native application experience across Windows, Linux, and macOS. Since the application is currently unsigned, please follow the platform-specific instructions below to install it.
    Please note that the Golem Desktop application is only supported for the open source version of Golem.
    Download and Installation Instructions
    Windows
    macOS
    Linux
    Windows Installer
    Download the .exe installer from the release page
    (opens in a new tab)
    When you run the installer, Windows may show a SmartScreen warning
    Click "More info" and then "Run anyway" to proceed with installation
    Follow the on-screen instructions to complete installation
    ⚠️
    These instructions are for the unsigned version of Golem Desktop. Signed versions with proper verification will be available in future releases.
    Last updated on March 28, 2025
    Install from Source
    API Definitions
    
  section: Desktop
  char_count: 899
  approx_token_count: 225
- id_parent: 136
  title: Http api definitions
  url: https://learn.golem.cloud/http-api-definitions
  content: |
    API Definitions
    API Definitions reference
    Learn mor about API definitions:
    Worker binding types
    Last updated on March 28, 2025
    Desktop
    Worker Binding Types
    
  section: Http api definitions
  char_count: 155
  approx_token_count: 39
- id_parent: 137
  title: Worker binding types
  url: https://learn.golem.cloud/http-api-definitions/worker-binding-types
  content: |
    API Definitions
    Worker Binding Types
    Worker Binding Types
    Overview
    The Worker Binding Types are a collection of different ways that a worker can be exposed to the outside world as part of an api definition.
    To get a basic introduction of what api-definitions are and how bindings fit into them, please read the defining custom apis guide.
    Rib Scripts
    Bindings can execute code as part of various steps in the request lifecycle. All of these scripts use a scripting language called rib. You can find an introduction to the language here.
    Default Binding
    The default and most basic binding type that allows invoking workers in custom ways.
    Example:
    id: example-api
    version: 0.0.1
    createdAt: 2024-08-21T07:42:15.696Z
    routes:
      - method: Get
        # Define the path that the route will apply to. {var} patterns capture the path segments and make it available for scripts.
        path: /carts/{cart-id}/checkout
        binding:
          component:
            name: checkout-component
          # Use the variable captured from the path to resolve the worker to call
          worker-name: 'let name: string = request.path.cart-id; name'
          # Invoke functions on the worker to handle the request and construct the response
          response: |
            let response = golem:it/api.{{checkout}}();
            let status: u64 = 200;
            {{headers: {{ContentType: "json"}}, body: response, status: status}}
    Parameters:
    Parameter Required Type Description
    component.name true string Name of the component to invoke
    component.version false number Version of the component to invoke. If not provided, the latest version is used.
    workerName false rib Script used to compute the name of the worker that will be invoked. The script has access to the request input. If not provided, an ephemeral worker is used.
    idempotencyKey false rib Script used to compute the idempotency key. The script has access to the request input. If not provided an idempotency key will be generated.
    response true rib Script that is used to compute the response that will be returned to the user. The script has access to the request and worker inputs and can call worker functions. The result of the script has to be an object with status and optional headers and body fields.
    Cors Binding Type
    This binding type is used to add CORS support to an api. To use this binding type, install it to a separate route with the same path as your main api and an OPTIONS method. Any OPTIONS requests will be automatically answered with the configured cors headers.
    Any requests to your actual api will also include the CORS response headers.
    The documentation you are already familiar with CORS and what the function of each of the headers are. For more information regarding CORS, see the mdn docs
    (opens in a new tab)
    .
    Example:
    id: example-api
    version: 0.0.1
    createdAt: 2024-08-21T07:42:15.696Z
    routes:
      - method: Options
        path: /users/{user-id}
        binding:
          bindingType: cors-preflight
        # Another definition for the same route and a different method.
        # The cors-preflight binding will enable cors for this binding.
      - method: Get
        path: /users/{user-id}
        binding:
          component:
            name: example-component
          response: |
            {status: 200u64, body: "Hello World"}
    Parameters:
    Parameter Required Type Description
    allowOrigin false string Value of the Access-Control-Allow-Origin header. Defaults to "*" if not provided.
    allowMethods false string Value of the Access-Control-Allow-Methods header. Defaults to "GET, POST, PUT, DELETE, OPTIONS" if not provided.
    allowHeaders false string Value of the Access-Control-Allow-Headers header. Defaults to "Content-Type, Authorization" if not provided.
    exposeHeaders false string Value of the Access-Control-Expose-Headers.
    maxAge false string Value of the Access-Control-Max-Age header.
    allowCredentials false string Value of the Access-Control-Allow-Credentials header.
    File Server
    A binding type that is used to retrieve files from a workers filesystem. For read-write files the file is retrieved between running worker invocation, so users are guaranteed to not see any in-progress changes to files.
    For read-only files the files are retrieved from a separate datastore and not directly from the worker. This makes retrieving read-only files very cheap and allows it be used for serving static content.
    To learn more about the worker filesystem, check out the dedicated guide.
    Example:
    id: example-api
    version: 0.0.1
    createdAt: 2024-08-21T07:42:15.696Z
    routes:
      - method: Get
        # {+var} patterns capture all remaining path segments
        path: /workers/{worker-name}/files/{+file}
        binding:
          bindingType: file-server
          component:
            name: example-component
          workerName: 'let name: string = request.path.worker-name; name'
          # retrieve the path /files/${{file}} from the worker and return the content.
          response: 'let file: string = request.path.file; "/files/${{file}}"'
    Parameters:
    Parameter Required Type Description
    component.name true string Name of the component to invoke
    component.version false number Version of the component to invoke. If not provided, the latest version is used.
    workerName false rib Script used to compute the name of the worker that will be invoked. The script has access to the request input. If not provided, an ephemeral worker is used.
    idempotencyKey false rib Script used to compute the idempotency key. The script has access to the request input. If not provided an idempotency key will be generated.
    response true rib Script that is used to compute the file to retrieve and the response to send to users. See the dedicatedc section for more details.
    File Server Response Object
    The object returned from the response rib script warrants some extra mention. There are two different structures that are supported by golem:
    Returning a single string. The returned string is interepreted as an absolute path and looked up in the worker filesystem and returned with an inferred content type and a 200 status code. If the file does not exist, a 404 is returned instead.
    As an object. This object can have 3 different fields that are explained below:
    Field Required Rib Type Description
    headers false record Headers that should be included in the response.
    status false u64 Status code of the response. If not provided defaults to 200.
    file-path true string Path of the file that should be retrieved from the worker filesystem. If the file does not exist a 404 is returned
    Http Handler
    A binding type used for integrating with components that implement the wasi:http/proxy world. The binding will forward the incoming requests to the worker and return the responses back to the user.
    Example:
    id: example-api
    version: 0.0.1
    createdAt: 2024-08-21T07:42:15.696Z
    # Each user has it's own worker that directly implements the user api using wasi:http/incoming-handler.
    # Define routes to forward the traffic to the workers.
    routes:
      - method: Get
        path: /users/{user}
        binding:
          bindingType: http-handler
          component:
            name: user-component
            version: 0
          workerName: 'let name: string = request.path.user; name'
      - method: Get
        path: /users/{user}/{+user-route}
        binding:
          bindingType: http-handler
          component:
            name: user-component
            version: 0
          workerName: 'let name: string = request.path.user; name'
    Parameters:
    Parameter Required Type Description
    component.name true string Name of the component to invoke
    component.version false number Version of the component to invoke. If not provided, the latest version is used.
    workerName false rib Script used to compute the name of the worker that will be invoked. The script has access to the request input. If not provided, an ephemeral worker is used.
    idempotencyKey false rib Script used to compute the idempotency key. The script has access to the request input. If not provided an idempotency key will be generated.
    Last updated on March 28, 2025
    API Definitions
    Application Manifest
    
  section: Http api definitions
  char_count: 7975
  approx_token_count: 1994
- id_parent: 138
  title: App manifest
  url: https://learn.golem.cloud/app-manifest
  content: |
    Application Manifest
    Golem Application Manifest Reference
    JSON schema
    For the application manifest format we also publish JSON schemas. The current version (1.1.1) is available here
    (opens in a new tab)
    .
    The JSON schema is intended to be used with editors and IDEs, to help with base validation and code completion.
    Use the following YAML comments at the start of your golem.yaml documents to enable schema support:
    IntelliJ IDEA based products
    VSCode with YAML Language Support plugin
    # $schema: https://schema.golem.cloud/app/golem/1.1.1/golem.schema.json
    Note that on top of the above schema there are other checks performed by golem, see the field reference below for details.
    Loading of Application Manifest documents
    The Golem CLI commands that use Application Manifest start by searching for golem.yaml documents in the current and the parent directories. Once the top level manifest document is found, more manifests are searched based on the includes fields.
    After resolving relative paths in the documents they are merged, then component selection happens: this can be either explicit, by using --component-name CLI flags, or implicit, in which case only components defined in the directory - including subdirectories - from where the Golem CLI was executed are used.
    Application Manifest documents can also be explicitly passed to the CLI, using the --app flag. Note that when using explicit documents the includes field is not used, it is expected that all relevant documents are provided for the CLI.
    Build steps performed by the App Build command
    The golem app build command can be used to create Golem components. The command relies on build steps implemented partially in golem and partially defined by the component specific build properties.
    There are three main build steps.
    gen-rpc:
    Generates required client WIT packages for Worker to Worker communication based on components.<component-name>.sourceWit and dependencies.
    In case of static-wasm-rpc dependencies it also generates and builds the required client components.
    Generates components.<component-name>.generatedWit. using components.<component-name>.sourceWit, dependencies and witDeps.
    componentize:
    Builds the component using steps defined in components.<component-name>.build. The final binary should be created at components.<component-name>.componentWasm.
    Usually the steps involve binding generation from
    link-rpc:
    Links the componentized WASM binary with required client components. For static-wasm-rpc this means the client components generated during gen-rpc, for wasm-rpc these will be skipped, as the clients are generated dynamically on the server-side.
    By default, all the above three steps are executed when using golem app build, but they can be selected by using the --step flag. This is intended to be used for more complex setups, when one would like to integrate golem app build into another build tool.
    Template variables and functions
    The Application Manifest has some fields which are used as templates, these fields are marked as Templated in the field reference below. The templates are using minijinja
    (opens in a new tab)
    , which is a minimal templating engine based on Jinja2 syntax.
    Available template variables:
    component_name: contains the current component name in which the template is used
    Available naming related string transforming functions:
    to_snake_case
    to_kebab_case
    to_lower_camel_case
    to_pascal_case
    to_shouty_kebab_case
    to_shouty_snake_case
    to_snake_case
    to_title_case
    to_train_case
    to_upper_camel_case
    Example usage:
    build: tool-name build {{ component_name | to_snake_case }}.wasm
    Field reference
    includes
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of glob patterns that are used for adding search patterns for other Application Manifests when using auto discovery of them. The patterns are relative to the manifest document in which they are defined.
    The default search pattern is **/golem.yaml, which searches for golem.yaml documents in every subdirectory recursively. Templates and examples provided by Golem usually use more specific search patterns to make the lookups more efficient.
    The includes fields can be defined in one manifest only, usually in the project root directory. Defining it multiple times results in validation error.
    Example usage:
    includes:
    - components-dir/*/golem.yaml
    - custom-templates/golem-*.yaml
    tempDir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional path that overrides the default path of the default temporary directory (golem-temp) which is used for storing various intermediate artifacts.
    The path is relative to the manifest document in which they are defined.
    Example usage:
    tempDir: target/golem-temp
    witDeps
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of paths of directories where WIT dependency packages can be stored. The paths are relative to the manifest document in which they are defined.
    During component WIT generation these paths are checked for resolving missing dependencies. It is intended to be used for eliminating duplication of common dependencies and interfaces.
    The witDeps fields can be defined in one manifest only, usually in the project root directory. Defining it multiple times results in validation error.
    Example usage:
    witDeps:
    - wit-common/deps
    components
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional map of Golem components indexed by component-name-s used for defining components.
    The components field can be defined in multiple manifest documents, but the used component-name-s must be unique across all the used manifest documents. Using the same component-name more then once results in validation error.
    Example usage:
    components:
      pack-ns:component-name:
        sourceWit: # ...
        # ...
      pack:comp-b:
        sourceWit: # ...
        # ...
    components.<component-name>.template
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional template name which will be used for creating the component fields.
    The template name must be one of that are defined in templates.
    See templates and Template variable and functions for defining templates.
    Related fields:
    components.<component-name>.profiles.<profile-name>.template
    templates.<template-name>.profiles.<profile-name>.template
    templates.<template-name>.template
    components.<component-name>.componentType
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional string enum of component types, accepted values:
    durable(default value)
    available sinceJSON Schema:1.1.0|OSS CLI: 1.1.0|Cloud CLI: 1.1.0
    ephemeral
    available sinceJSON Schema:1.1.0|OSS CLI: 1.1.0|Cloud CLI: 1.1.0
    See Ephemeral vs Durable Workers for more information about component types.
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        componentType: durable
      pack-ns:component-name:
        # ...
        componentType: ephemeral
    Related fields:
    components.<component-name>.profiles.<profile-name>.componentType
    templates.<template-name>.profiles.<profile-name>.componentType
    templates.<template-name>.componentType
    components.<component-name>.files
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of files entries, which can be used for defining the Initial File System for the component.
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        files:
        - sourcePath: ./files/foo.txt
          targetPath: /files/foo.txt
          permissions: read-only
        - sourcePath: ./files/bar.txt
          targetPath: /files/bar.txt
          permissions: read-write
    Related fields:
    components.<component-name>.profiles.<profile-name>.files
    templates.<template-name>.profiles.<profile-name>.files
    templates.<template-name>.files
    components.<component-name>.files[*].sourcePath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required source path of the file to be added to the Initial File System. The path can be a file path relative to the manifest document or an URL.
    Related fields:
    components.<component-name>.profiles.<profile-name>.files[*].sourcePath
    templates.<template-name>.profiles.<profile-name>.files[*].sourcePath
    templates.<template-name>.files[*].sourcePath
    components.<component-name>.files[*].targetPath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required target path of the file in the Initial File System. The path must be an absolute path.
    Related fields:
    components.<component-name>.profiles.<profile-name>.files[*].targetPath
    templates.<template-name>.profiles.<profile-name>.files[*].targetPath
    templates.<template-name>.files[*].targetPath
    components.<component-name>.files[*].permissions
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional string enum which controls file permissions. Accepted values:
    read-only(default value)
    available sinceJSON Schema:1.1.0|OSS CLI: 1.1.0|Cloud CLI: 1.1.0
    read-write
    available sinceJSON Schema:1.1.0|OSS CLI: 1.1.0|Cloud CLI: 1.1.0
    Related fields:
    components.<component-name>.profiles.<profile-name>.files[*].permissions
    templates.<template-name>.profiles.<profile-name>.files[*].permissions
    templates.<template-name>.files[*].permissions
    components.<component-name>.sourceWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required directory path for the user defined component WIT directory.
    The path is relative to the manifest document in which the field is defined.
    The WIT directory can omit the deps folder if the required dependencies are available in some of the folders defined in witDeps.
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        sourceWit: wit
    Related fields:
    components.<component-name>.profiles.<profile-name>.sourceWit
    templates.<template-name>.profiles.<profile-name>.sourceWit
    templates.<template-name>.sourceWit
    components.<component-name>.generatedWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required directory path for the generated WIT directory created by the golem tooling, which handles exported interface extraction and includes resolved package and client dependencies.
    This directory is intended to be used as source for binding generation.
    The path is relative to the manifest document in which the field is defined.
    This folder is usually added to .gitignore, as it is generated as part of build.
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        generatedWit: wit-generated
    Related fields:
    components.<component-name>.profiles.<profile-name>.generatedWit
    templates.<template-name>.profiles.<profile-name>.generatedWit
    templates.<template-name>.generatedWit
    components.<component-name>.componentWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required file path which should point to the built component WASM file before linking.
    The path is relative to the manifest document in which the field is defined.
    This file is usually added to .gitignore, as it is created as part of build.
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        componentWasm: build/component.wasm
    Related fields:
    components.<component-name>.profiles.<profile-name>.componentWasm
    templates.<template-name>.profiles.<profile-name>.componentWasm
    templates.<template-name>.componentWasm
    components.<component-name>.linkedWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional file path which should point to the built component WASM file after linking.
    Defaults to golem-temp/linked-wasm/component-name.wasm, see tempDir.
    The path is relative to the manifest document in which the field is defined.
    This file is usually added to .gitignore, as it is created as part of build.
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        linkedWasm: golem-temp/component/component.wasm
    Related fields:
    components.<component-name>.profiles.<profile-name>.linkedWasm
    templates.<template-name>.profiles.<profile-name>.linkedWasm
    templates.<template-name>.linkedWasm
    components.<component-name>.build
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of build commands that creates components.<component-name>.componentWasm.
    Example usage:
    components:
      pack-ns:component-name:
        build:
        - command: bindgen-tool wit-generated
        - command: build-tool wit-generated component.wasm
    Related fields:
    components.<component-name>.profiles.<profile-name>.build
    templates.<template-name>.profiles.<profile-name>.build
    templates.<template-name>.build
    components.<component-name>.build[*].command
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required external command that will be used as a build step for creating components.<component-name>.componentWasm.
    Related fields:
    components.<component-name>.profiles.<profile-name>.build[*].command
    templates.<template-name>.profiles.<profile-name>.build[*].command
    templates.<template-name>.build[*].command
    components.<component-name>.build[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional directory path which will be used as working directory when executing components.<component-name>.build[*].command.
    The path is relative to the manifest document, and defaults to ..
    Related fields:
    components.<component-name>.profiles.<profile-name>.build[*].dir
    templates.<template-name>.profiles.<profile-name>.build[*].dir
    templates.<template-name>.build[*].dir
    components.<component-name>.build[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of directory paths which will be deleted before executing the command.
    The path is relative to components.<component-name>.build[*].dir.
    The rmdirs field is useful when a binding generator does not automatically clean stale bindings.
    Directories are not removed if the command is skipped because of up-to-date checks, see components.<component-name>.build[*].sources and components.<component-name>.build[*].targets.
    Directories are removed before executing components.<component-name>.build[*].mkdirs.
    Related fields:
    components.<component-name>.profiles.<profile-name>.build[*].rmdirs
    templates.<template-name>.profiles.<profile-name>.build[*].rmdirs
    templates.<template-name>.build[*].rmdirs
    components.<component-name>.build[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of directory paths which will be created before executing the command if they do not exists.
    The path is relative to components.<component-name>.build[*].dir.
    The mkdirs field is useful when a build of binding generator tool does not automatically create required nested folders.
    Directories are not created if the command is skipped because of up-to-date checks, see components.<component-name>.build[*].sources and components.<component-name>.build[*].targets.
    Directories are created after executing components.<component-name>.build[*].rmdirs.
    Related fields:
    components.<component-name>.profiles.<profile-name>.build[*].mkdirs
    templates.<template-name>.profiles.<profile-name>.build[*].mkdirs
    templates.<template-name>.build[*].mkdirs
    components.<component-name>.build[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of paths and globs which are used as sources for performing up-to-date checks.
    If defined then components.<component-name>.build[*].targets also have to be used.
    The up-to-date check
    skips executing components.<component-name>.build[*].command
    if all matching files defined by components.<component-name>.build[*].targets
    are newer then the matched files defined by sources.
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        build:
        - command: build-tool src-dir out.wasm
          sources:
          - src-dir/*
          targets:
          - out.wasm
    Related fields:
    components.<component-name>.profiles.<profile-name>.build[*].sources
    templates.<template-name>.profiles.<profile-name>.build[*].sources
    templates.<template-name>.build[*].sources
    components.<component-name>.build[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional list of paths and globs which are used as targets for performing up-to-date checks.
    If defined then components.<component-name>.build[*].sources also have to be used.
    See components.<component-name>.build[*].sources for up-to-date check details.
    Related fields:
    components.<component-name>.profiles.<profile-name>.build[*].targets
    templates.<template-name>.profiles.<profile-name>.build[*].targets
    templates.<template-name>.build[*].targets
    components.<component-name>.customCommands
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional map of component specific external commands, which are useful for defining e.g. one time installation or update related commands for the component.
    The commands can be executed using:
    golem app command-name
    Multiple components can use the same command-name, the above command will execute all matching commands in this case, both component specific and project ones.
    For defining project level custom commands see customCommands.
    The following command names cannot be used, as they are used by golem app itself:
    build
    clean
    Example usage:
    components:
      pack-ns:component-name:
        # ...
        customCommands:
          npm-install:
          - command: npm install
    Related fields:
    components.<component-name>.profiles.<profile-name>.customCommands
    templates.<template-name>.profiles.<profile-name>.customCommands
    templates.<template-name>.customCommands
    components.<component-name>.customCommands.<command-name>[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Component specific customCommands.<command-name>[*].dir.
    Related fields:
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].dir
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].dir
    templates.<template-name>.customCommands.<command-name>[*].dir
    components.<component-name>.customCommands.<command-name>[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Component specific customCommands.<command-name>[*].rmdirs.
    Related fields:
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].rmdirs
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].rmdirs
    templates.<template-name>.customCommands.<command-name>[*].rmdirs
    components.<component-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Component specific customCommands.<command-name>[*].mkdirs.
    Related fields:
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    templates.<template-name>.customCommands.<command-name>[*].mkdirs
    components.<component-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Component specific customCommands.<command-name>[*].mkdirs.
    Related fields:
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    templates.<template-name>.customCommands.<command-name>[*].mkdirs
    components.<component-name>.customCommands.<command-name>[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Component specific customCommands.<command-name>[*].sources.
    Related fields:
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].sources
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].sources
    templates.<template-name>.customCommands.<command-name>[*].sources
    components.<component-name>.customCommands.<command-name>[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Component specific customCommands.<command-name>[*].targets.
    Related fields:
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].targets
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].targets
    templates.<template-name>.customCommands.<command-name>[*].targets
    components.<component-name>.clean
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Component specific clean.
    Related fields:
    components.<component-name>.profiles.<profile-name>.clean
    templates.<template-name>.profiles.<profile-name>.clean
    templates.<template-name>.clean
    components.<component-name>.profiles
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional map of profiles, which can be used to provide multiple build profiles for a component, typically used for debug and release configurations.
    A profile contains the same fields as a component, expect for defaultProfile and profile itself.
    When profiles are defined for a component:
    components.<component-name>.defaultProfile must be defined,
    non-profile component fields should not be used on the component, apart from defaultProfile.
    When building, by default golem will use defaultProfile, unless a specific profile is requested and_ the component has a matching profile. E.g. the following command:
    golem app --build-profile release build
    will build components that have no profiles by using the non-profile component fields
    will use the release profile for components that are using profiles and have a profile named release
    will use the defaultProfile for components that using profiles, but do not have a profile named release
    Example usage:
    components:
      pack-ns:component-name:
        profiles:
          debug:
            build:
            - command: build-tool --debug out.wasm
          release:
            build:
            - command: build-tool --release out.wasm
        defaultProfile: release
    components.<component-name>.defaultProfile
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional profile name that defines which profile should be used.
    It must be defined when using components.<component-name>.profiles, and must be one of the profile names defined there.
    Related fields:
    components.<component-name>.profiles.<profile-name>.defaultProfile
    templates.<template-name>.profiles.<profile-name>.defaultProfile
    templates.<template-name>.defaultProfile
    components.<component-name>.profiles.<profile-name>.componentType
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.componentType.
    components.<component-name>.profiles.<profile-name>.files
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.files.
    components.<component-name>.profiles.<profile-name>.files[*].sourcePath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.files[*].sourcePath.
    components.<component-name>.profiles.<profile-name>.files[*].targetPath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.files[*].targetPath.
    components.<component-name>.profiles.<profile-name>.files[*].permissions
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.files[*].permissions.
    components.<component-name>.profiles.<profile-name>.sourceWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.sourceWit.
    components.<component-name>.profiles.<profile-name>.generatedWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.generatedWit.
    components.<component-name>.profiles.<profile-name>.componentWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.componentWasm.
    components.<component-name>.profiles.<profile-name>.linkedWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.linkedWasm.
    components.<component-name>.profiles.<profile-name>.build
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.build.
    components.<component-name>.profiles.<profile-name>.build[*].command
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.build[*].command.
    components.<component-name>.profiles.<profile-name>.build[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.build[*].dir.
    components.<component-name>.profiles.<profile-name>.build[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.build[*].rmdirs.
    components.<component-name>.profiles.<profile-name>.build[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.build[*].mkdirs.
    components.<component-name>.profiles.<profile-name>.build[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.build[*].sources.
    components.<component-name>.profiles.<profile-name>.build[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.build[*].targets.
    components.<component-name>.profiles.<profile-name>.customCommands
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.customCommands.
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.customCommands.<command-name>[*].dir.
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.customCommands.<command-name>[*].rmdirs.
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.customCommands.<command-name>[*].mkdirs.
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.customCommands.<command-name>[*].mkdirs.
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.customCommands.<command-name>[*].sources.
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.customCommands.<command-name>[*].targets.
    components.<component-name>.profiles.<profile-name>.clean
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Profile specific components.<component-name>.clean.
    dependencies
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional map of list of component dependencies, which can be used for defining WASM RPC connections between components.
    Example usage:
    components:
      pack-ns:component-a:
        # ...
      pack-ns:component-b:
        # ...
      pack-ns:component-c:
      # ...
    dependencies:
      pack-ns:component-a:
      - target: pack-ns:component-b
        type: wasm-rpc
      - target: pack-ns:component-c
        type: wasm-rpc
      pack-ns:component-b:
      - target: pack-ns:component-a
        type: wasm-rpc
      - target: pack-ns:component-b
        type: wasm-rpc
    dependencies.<component-name>[*].type
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required string enum, accepted values:
    wasm-rpc
    available sinceJSON Schema:1.1.0|OSS CLI: 1.1.0|Cloud CLI: 1.1.0
    Dynamic WASM RPC linking. The preferred method for linking.
    With this dependency type the linking happens on servers side, so there is no need for generating and creating WAM RPC clients.
    static-wasm-rpc
    available sinceJSON Schema:1.1.2|OSS CLI: 1.1.12|Cloud CLI: 1.1.2
    Static WASM RPC linking.
    With this dependency type the linking happens locally, so it requires Rust tooling.
    dependencies.<component-name>[*].target
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Required component-name, which defines the target of the dependency.
    Must be a defined component name.
    clean
    available since
    JSON Schema:
    1.1.1
    |
    OSS CLI:
    1.1.12
    |
    Cloud CLI:
    1.1.1
    Optional list of paths which are added as targets to the golem app clean command.
    The paths are relative to the manifest document.
    The clean command deletes the following paths:
    tempDir
    components.<component-name>.generatedWit
    components.<component-name>.linkedWasm
    build and custom command targets
    the paths defined in common and component specific clean fields.
    Related fields:
    components.<component-name>.clean
    customCommands
    available since
    JSON Schema:
    1.1.1
    |
    OSS CLI:
    1.1.12
    |
    Cloud CLI:
    1.1.1
    Optional map of custom external commands, which are useful for defining e.g. one time installation or update related project commands.
    The commands can be executed using:
    golem app command-name
    Components specific custom commands can use the same command-name, the above command will execute all matching commands in this case, both component specific and project ones.
    For defining component specific custom commands see components.<component-name>.customCommands.
    The following command names cannot be used, as they are used by golem app itself:
    build
    clean
    Example usage:
    customCommands:
      npm-install:
      - command: npm install
    customCommands.<command-name>[*].dir
    available since
    JSON Schema:
    1.1.1
    |
    OSS CLI:
    1.1.12
    |
    Cloud CLI:
    1.1.1
    Optional directory path which will be used as working directory when executing customCommands.<command-name>[*].command.
    The path is relative to the manifest document, and defaults to ..
    Related fields:
    components.<component-name>.customCommands.<command-name>[*].dir
    customCommands.<command-name>[*].rmdirs
    available since
    JSON Schema:
    1.1.1
    |
    OSS CLI:
    1.1.12
    |
    Cloud CLI:
    1.1.1
    Optional list of directory paths which will be deleted before executing the command.
    The path is relative to customCommands.<command-name>[*].dir.
    The rmdirs field is useful when a binding generator does not automatically clean stale bindings.
    Directories are not removed if the command is skipped because of up-to-date checks, see customCommands.<command-name>[*].sources and customCommands.<command-name>[*].targets.
    Directories are removed before executing customCommands.<command-name>[*].mkdirs.
    Related fields:
    components.<component-name>.customCommands.<command-name>[*].rmdirs
    customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.1
    |
    OSS CLI:
    1.1.12
    |
    Cloud CLI:
    1.1.1
    Optional list of directory paths which will be created before executing the command if they do not exists.
    The path is relative to customCommands.<command-name>[*].dir.
    The mkdirs field is useful when a build of binding generator tool does not automatically create required nested folders.
    Directories are not created if the command is skipped because of up-to-date checks, see customCommands.<command-name>[*].sources and customCommands.<command-name>[*].targets.
    Directories are created after executing customCommands.<command-name>[*].rmdirs.
    Related fields:
    components.<component-name>.customCommands.<command-name>[*].mkdirs
    customCommands.<command-name>[*].sources
    available since
    JSON Schema:
    1.1.1
    |
    OSS CLI:
    1.1.12
    |
    Cloud CLI:
    1.1.1
    Optional list of paths and globs which are used as sources for performing up-to-date checks.
    If defined then customCommands.<command-name>[*].targets also have to be used.
    The up-to-date check
    skips executing customCommands.<command-name>[*].command
    if all matching files defined by customCommands.<command-name>[*].targets
    are newer then the matched files defined by sources.
    Related fields:
    components.<component-name>.customCommands.<command-name>[*].sources
    customCommands.<command-name>[*].targets
    available since
    JSON Schema:
    1.1.1
    |
    OSS CLI:
    1.1.12
    |
    Cloud CLI:
    1.1.1
    Optional list of paths and globs which are used as targets for performing up-to-date checks.
    If defined then customCommands.<command-name>[*].sources also have to be used.
    See customCommands.<command-name>[*].sources for up-to-date check details.
    Related fields:
    components.<component-name>.customCommands.<command-name>[*].targets
    templates
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Optional map of named templates, which can be used in components.<component-name>.template.
    Templates help in extracting common build patterns and reuse them for multiple components.
    The templates field can be defined in multiple application manifest documents, but the template names must be unique.
    See Template variable and functions for more information about templating.
    Example usage:
    templates:
    my-template:
    sourceWit: wit
    componentWasm: build/{{component_name | to_snake_case}}
    # ...
    my-template-with-profiles:
    profiles:
    debug:
    # ...
    release:
    # ...
    components:
    pack-ns:component-a:
    template: my-template
    pack-ns:component-b:
    template: my-template
    sourceWit: custom-wit # override
    pack-ns:component-c:
    template: my-template-with-profiles
    profiles:
    debug:
    sourceWit: custom-wit # override
    templates.<template-name>.componentType
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.componentType.
    templates.<template-name>.files
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.files.
    templates.<template-name>.files[*].sourcePath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.files[*].sourcePath.
    templates.<template-name>.files[*].targetPath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.files[*].targetPath.
    templates.<template-name>.files[*].permissions
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.files[*].permissions.
    templates.<template-name>.sourceWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.sourceWit.
    templates.<template-name>.generatedWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.generatedWit.
    templates.<template-name>.componentWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.componentWasm.
    templates.<template-name>.linkedWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.linkedWasm.
    templates.<template-name>.build
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.build.
    templates.<template-name>.build[*].command
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.build[*].command.
    templates.<template-name>.build[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.build[*].dir.
    templates.<template-name>.build[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.build[*].rmdirs.
    templates.<template-name>.build[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.build[*].mkdirs.
    templates.<template-name>.build[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.build[*].sources.
    templates.<template-name>.build[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.build[*].targets.
    templates.<template-name>.customCommands
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.customCommands.
    templates.<template-name>.customCommands.<command-name>[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.customCommands.<command-name>[*].dir.
    templates.<template-name>.customCommands.<command-name>[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.customCommands.<command-name>[*].rmdirs.
    templates.<template-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.customCommands.<command-name>[*].mkdirs.
    templates.<template-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.customCommands.<command-name>[*].mkdirs.
    templates.<template-name>.customCommands.<command-name>[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.customCommands.<command-name>[*].sources.
    templates.<template-name>.customCommands.<command-name>[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.customCommands.<command-name>[*].targets.
    templates.<template-name>.clean
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.clean.
    templates.<template-name>.profiles
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.profiles.
    templates.<template-name>.profiles.<profile-name>
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated components.<component-name>.profiles.<profile-name>.
    templates.<template-name>.profiles.<profile-name>.componentType
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.componentType.
    templates.<template-name>.profiles.<profile-name>.files
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.files.
    templates.<template-name>.profiles.<profile-name>.files[*].sourcePath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.files[*].sourcePath.
    templates.<template-name>.profiles.<profile-name>.files[*].targetPath
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.files[*].targetPath.
    templates.<template-name>.profiles.<profile-name>.files[*].permissions
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.files[*].permissions.
    templates.<template-name>.profiles.<profile-name>.sourceWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.sourceWit.
    templates.<template-name>.profiles.<profile-name>.generatedWit
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.generatedWit.
    templates.<template-name>.profiles.<profile-name>.componentWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.componentWasm.
    templates.<template-name>.profiles.<profile-name>.linkedWasm
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.linkedWasm.
    templates.<template-name>.profiles.<profile-name>.build
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.build.
    templates.<template-name>.profiles.<profile-name>.build[*].command
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.build[*].command.
    templates.<template-name>.profiles.<profile-name>.build[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.build[*].dir.
    templates.<template-name>.profiles.<profile-name>.build[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.build[*].rmdirs.
    templates.<template-name>.profiles.<profile-name>.build[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.build[*].mkdirs.
    templates.<template-name>.profiles.<profile-name>.build[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.build[*].sources.
    templates.<template-name>.profiles.<profile-name>.build[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.build[*].targets.
    templates.<template-name>.profiles.<profile-name>.customCommands
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.<command-name>.
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].dir
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.<command-name>[*].dir.
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].rmdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.<command-name>[*].rmdirs.
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.<command-name>[*].mkdirs.
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.<command-name>[*].mkdirs.
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].sources
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.<command-name>[*].sources.
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].targets
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.customCommands.<command-name>[*].targets.
    templates.<template-name>.profiles.<profile-name>.clean
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    Templated and profile specific components.<component-name>.clean.
    templates.<template-name>.defaultProfile
    available since
    JSON Schema:
    1.1.0
    |
    OSS CLI:
    1.1.0
    |
    Cloud CLI:
    1.1.0
    String which selects the default profile for the template. Required if profiles are used. Must be one of the defined profile names in templates.<template-name>.profiles.
    Example usage:
    templates:
      rust:
        profiles:
          debug:
            # ...
          release:
            # ...
        defaultProfile: debug
    Fields and changes by releases
    available sinceJSON Schema:1.1.0|OSS CLI: 1.1.0|Cloud CLI: 1.1.0
    components
    components.<component-name>.build
    components.<component-name>.build[*].command
    components.<component-name>.build[*].dir
    components.<component-name>.build[*].mkdirs
    components.<component-name>.build[*].rmdirs
    components.<component-name>.build[*].sources
    components.<component-name>.build[*].targets
    components.<component-name>.clean
    components.<component-name>.componentType
    components.<component-name>.componentWasm
    components.<component-name>.customCommands
    components.<component-name>.customCommands.<command-name>[*].dir
    components.<component-name>.customCommands.<command-name>[*].mkdirs
    components.<component-name>.customCommands.<command-name>[*].rmdirs
    components.<component-name>.customCommands.<command-name>[*].sources
    components.<component-name>.customCommands.<command-name>[*].targets
    components.<component-name>.defaultProfile
    components.<component-name>.files
    components.<component-name>.files[*].permissions
    components.<component-name>.files[*].sourcePath
    components.<component-name>.files[*].targetPath
    components.<component-name>.generatedWit
    components.<component-name>.linkedWasm
    components.<component-name>.profiles
    components.<component-name>.profiles.<profile-name>.build
    components.<component-name>.profiles.<profile-name>.build[*].command
    components.<component-name>.profiles.<profile-name>.build[*].dir
    components.<component-name>.profiles.<profile-name>.build[*].mkdirs
    components.<component-name>.profiles.<profile-name>.build[*].rmdirs
    components.<component-name>.profiles.<profile-name>.build[*].sources
    components.<component-name>.profiles.<profile-name>.build[*].targets
    components.<component-name>.profiles.<profile-name>.clean
    components.<component-name>.profiles.<profile-name>.componentType
    components.<component-name>.profiles.<profile-name>.componentWasm
    components.<component-name>.profiles.<profile-name>.customCommands
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].dir
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].rmdirs
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].sources
    components.<component-name>.profiles.<profile-name>.customCommands.<command-name>[*].targets
    components.<component-name>.profiles.<profile-name>.files
    components.<component-name>.profiles.<profile-name>.files[*].permissions
    components.<component-name>.profiles.<profile-name>.files[*].sourcePath
    components.<component-name>.profiles.<profile-name>.files[*].targetPath
    components.<component-name>.profiles.<profile-name>.generatedWit
    components.<component-name>.profiles.<profile-name>.linkedWasm
    components.<component-name>.profiles.<profile-name>.sourceWit
    components.<component-name>.sourceWit
    components.<component-name>.template
    dependencies
    dependencies.<component-name>[*].target
    dependencies.<component-name>[*].type
    includes
    tempDir
    templates
    templates.<template-name>.build
    templates.<template-name>.build[*].command
    templates.<template-name>.build[*].dir
    templates.<template-name>.build[*].mkdirs
    templates.<template-name>.build[*].rmdirs
    templates.<template-name>.build[*].sources
    templates.<template-name>.build[*].targets
    templates.<template-name>.clean
    templates.<template-name>.componentType
    templates.<template-name>.componentWasm
    templates.<template-name>.customCommands
    templates.<template-name>.customCommands.<command-name>[*].dir
    templates.<template-name>.customCommands.<command-name>[*].mkdirs
    templates.<template-name>.customCommands.<command-name>[*].rmdirs
    templates.<template-name>.customCommands.<command-name>[*].sources
    templates.<template-name>.customCommands.<command-name>[*].targets
    templates.<template-name>.defaultProfile
    templates.<template-name>.files
    templates.<template-name>.files[*].permissions
    templates.<template-name>.files[*].sourcePath
    templates.<template-name>.files[*].targetPath
    templates.<template-name>.generatedWit
    templates.<template-name>.linkedWasm
    templates.<template-name>.profiles
    templates.<template-name>.profiles.<profile-name>
    templates.<template-name>.profiles.<profile-name>.build
    templates.<template-name>.profiles.<profile-name>.build[*].command
    templates.<template-name>.profiles.<profile-name>.build[*].dir
    templates.<template-name>.profiles.<profile-name>.build[*].mkdirs
    templates.<template-name>.profiles.<profile-name>.build[*].rmdirs
    templates.<template-name>.profiles.<profile-name>.build[*].sources
    templates.<template-name>.profiles.<profile-name>.build[*].targets
    templates.<template-name>.profiles.<profile-name>.clean
    templates.<template-name>.profiles.<profile-name>.componentType
    templates.<template-name>.profiles.<profile-name>.componentWasm
    templates.<template-name>.profiles.<profile-name>.customCommands
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].dir
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].mkdirs
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].rmdirs
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].sources
    templates.<template-name>.profiles.<profile-name>.customCommands.<command-name>[*].targets
    templates.<template-name>.profiles.<profile-name>.files
    templates.<template-name>.profiles.<profile-name>.files[*].permissions
    templates.<template-name>.profiles.<profile-name>.files[*].sourcePath
    templates.<template-name>.profiles.<profile-name>.files[*].targetPath
    templates.<template-name>.profiles.<profile-name>.generatedWit
    templates.<template-name>.profiles.<profile-name>.linkedWasm
    templates.<template-name>.profiles.<profile-name>.sourceWit
    templates.<template-name>.sourceWit
    witDeps
    available sinceJSON Schema:1.1.1|OSS CLI: 1.1.12|Cloud CLI: 1.1.1
    clean
    customCommands
    customCommands.<command-name>[*].dir
    customCommands.<command-name>[*].mkdirs
    customCommands.<command-name>[*].rmdirs
    customCommands.<command-name>[*].sources
    customCommands.<command-name>[*].targets
    available sinceJSON Schema:1.1.2|OSS CLI: 1.1.12|Cloud CLI: 1.1.2
    added enum value static-wasm-rpc todependencies.<component-name>[*].type
    Last updated on March 28, 2025
    Worker Binding Types
    Function names
    
  section: App manifest
  char_count: 50783
  approx_token_count: 12696
- id_parent: 139
  title: Function names
  url: https://learn.golem.cloud/function-names
  content: |
    Function names
    Function name syntax
    This section explains how to map the exported function names from the component's WIT definition to fully qualified names to be passed to the invocation API or CLI when invoking workers.
    Functions and interfaces
    The component has a WIT package, specified in the top of its WIT definition.
    For example if the component was generated using golem new without specifying a custom package name, it will be:
    package golem:component
    This package name can optionally specify a package version as well, such as:
    package golem:component@0.3.2
    The WIT definition should contain a single world (otherwise the world to be used have to be specified for the tools used during compilation). The name of this world does not matter for Golem - it won't be part of the function's fully qualified name.
    For example it can be:
    world my-component-world {
      // ...
    }
    This world can either export
    one or more interface
    or one or more functions directly
    The following example demonstrates both:
    package golem:component;
     
    interface api {
      record product-item {
        product-id: string,
        name: string,
        price: f32,
        quantity: u32,
      }
     
      add-item: func(item: product-item) -> ();
      remove-item: func(product-id: string) -> ();
    }
     
    world my-component-world {
      export api;
      export dump: func() -> result<string, string>;
    }
    The name of the interface(s) and function(s) are completely user defined, there are no rules to follow other than the syntax rules of WIT itself.
    In the above example we have 3 exported functions and we can refer to them with the following fully qualified names, consisting of the package name and the exported path:
    golem:component/api.{add-item}
    golem:component/api.{remove-item}
    golem:component.{dump}
    Note that the syntax is the same as the one used for the use statements in the WIT file.
    Resources
    WIT specifications also allow the definition of resources. These are constructed via special constructors, have methods, and can also have associated static functions. Golem supports exporting resources, enabling an alternative of having a separate worker for each entity. When exporting resources, a single worker may own an arbitrary number of instances of the exported resource, and the method invocations's first parameter must be the resource handle returned by the invoked constructor.
    There is a special naming syntax provided by Golem that makes it more convenient to invoke resource constructors and methods. Take the following example:
    package golem:component;
     
    interface api {
      resource counter {
        constructor(name: string);
        inc-by: func(value: u64);
        get-value: func() -> u64;
     
        merge-counters: static func(counter1: counter, counter2: counter, name: string) -> counter;
      }
    }
     
    world my-world {
      export api;
    }
    For this WIT specification, the following function names are valid when using Golem's invocation API or CLI:
    golem:component/api.{counter.new} - refers to the above defined constructor
    golem:component/api.{counter.inc-by}
    golem:component/api.{counter.get-value}
    golem:component/api.{counter.merge-counters}
    golem:component/api.{counter.drop} - special function that drops the instance while the worker continues running
    Implicit resource creation
    With the above described naming conventions it is possible to manually create instances of resources, and then use the returned resource handle to invoke methods on them.
    There is an easier way to work with resources in Golem, that assumes that a given resource instance is associated with the constructor parameters it is created with. This way it is possible to target a specific instance just by using the function name, and the resource instance will be automatically selected or created if it does not exist yet.
    To use this feature, pass the target constructor parameters in the function name's resource name part in parentheses. For example, with the above defined counter resource we can immediately create and a new counter and increment it by calling:
    golem:component/api.{counter("my-counter").inc-by}
    This will create a new counter instance with the name my-counter and increment it. If the counter with the name my-counter already exists, it will be used.
    The syntax for passing inlined parameters to the constructor is using the WebAssembly Value Encoding
    (opens in a new tab)
    .
    Last updated on March 28, 2025
    Application Manifest
    Golem Host Functions
    
  section: Function names
  char_count: 4399
  approx_token_count: 1100
- id_parent: 140
  title: Golem host functions
  url: https://learn.golem.cloud/golem-host-functions
  content: |
    Golem Host Functions
    Golem Host functions
    Golem provides three WIT packages of host functions for accessing Golem-specific functionality on top of the standard WebAssembly system interfaces.
    These three packages are:
    golem:api@1.1.6 - provides access to various aspects of Golem for the workers
    golem:rpc@0.2.0 - defines the types and functions serving the Worker to Worker communication in Golem
    golem:durability@1.2.0 - provides an API to implement custom durability in libraries
    Please check the language specific guidelines to learn the best way to work with these APIs in your language of choice:
    Rust
    Python
    Go
    C/C++
    TypeScript
    JavaScript
    Zig
    Scala.js
    MoonBit
    This page provides an overview of all the exported functions and types in a language-agnostic way.
    Types
    An oplog index points to a specific instruction in the worker's history:
    package golem:api@1.1.6;
     
    interface host {
        /// An index into the persistent log storing all performed operations of a worker
        type oplog-index = u64;
    }
    The worker id uniquely identifies a worker in the Golem system:
    package golem:rpc@0.2.0;
     
    interface types {
        /// Represents a Golem worker
        record worker-id {
            component-id: component-id,
            worker-name: string
        }
    }
    Components are identified by a component id which is in fact a UUID:
    package golem:rpc@0.2.0;
     
    interface types {
        /// Represents a Golem component
        record component-id {
            uuid: uuid,
        }
     
        /// UUID
        record uuid {
        high-bits: u64,
        low-bits: u64
        }
    }
    Component versions are unsigned integers:
    package golem:api@1.1.6;
     
    interface host {
        /// Represents a Golem component's version
        type component-version = u64;
    }
    Promises
    Types
    A promise is identified by a promise-id type consisting of the owner worker's identifier and a number that points to the create promise function in the worker's history:
    package golem:api@1.1.6;
     
    interface host {
        /// A promise ID is a value that can be passed to an external Golem API to complete that promise
        /// from an arbitrary external source, while Golem workers can await for this completion.
        record promise-id {
            worker-id: worker-id,
            oplog-idx: oplog-index,
        }
    }
    Functions
    The following functions define the promise API:
    Function name Definition Description
    create-promise func() -> promise-id Creates a new promise and returns its ID
    await-promise func(promise-id) -> list<u8> Suspends execution until the given promise gets completed, and returns the payload passed to the promise completion.
    complete-promise func(promise-id, list<u8>) Completes the given promise with the given payload. Returns true if the promise was completed, false if the promise was already completed. The payload is passed to the worker that is awaiting the promise.
    delete-promise func(promise-id) -> () Deletes the given promise.
    Worker metadata
    Types
    Worker metadata is described by the following WIT types:
    package golem:api@1.1.6;
     
    interface host {
        record worker-metadata {
            worker-id: worker-id,
            args: list<string>,
            env: list<tuple<string, string>>,
            status: worker-status,
            component-version: u64,
            retry-count: u64
        }
     
        enum worker-status {
            /// The worker is running an invoked function
            running,
            /// The worker is ready to run an invoked function
            idle,
            /// An invocation is active but waiting for something (sleeping, waiting for a promise)
            suspended,
            /// The last invocation was interrupted but will be resumed
            interrupted,
            /// The last invocation failed and a retry was scheduled
            retrying,
            /// The last invocation failed and the worker can no longer be used
            failed,
            /// The worker exited after a successful invocation and can no longer be invoked
            exited,
        }
    }
    Functions
    The following functions define the worker metadata API:
    Function name Definition Description
    get-worker-metadata func(worker-id) -> option<worker-metadata> Returns the metadata of a worker
    get-self-metadata func() -> worker-metadata Returns the metadata of the worker that calls this function
    Worker enumeration
    The worker enumeration API allows listing all the workers belonging to a specific component. This is a slow operation and should be used for maintenance tasks and not for the core business logic.
    Worker enumeration is a WIT resource, providing a method that returns a page of workers each time it is called:
    package golem:api@1.1.6;
     
    interface host {
        resource get-workers {
            constructor(component-id: component-id, filter: option<worker-any-filter>, precise: bool);
     
            get-next: func() -> option<list<worker-metadata>>;
        }
    }
    Once get-next returns none, the enumeration is done.
    There are two parameters for customizing the worker enumeration:
    Filters
    An optional filter parameter can be passed to the worker enumeration, with the following definition:
    package golem:api@1.1.6;
     
    interface host {
        record worker-any-filter {
            filters: list<worker-all-filter>
        }
    }
    The worker-any-filter matches workers that satisfy any of the listed filters.
    package golem:api@1.1.6;
     
    interface host {
        record worker-all-filter {
            filters: list<worker-property-filter>
        }
    }
    A worker-all-filter matches workers only that satisfy all of the listed filters.
    package golem:api@1.1.6;
     
    interface host {
        variant worker-property-filter {
            name(worker-name-filter),
            status(worker-status-filter),
            version(worker-version-filter),
            created-at(worker-created-at-filter),
            env(worker-env-filter)
        }
    }
    The worker-name-filter matches workers by one of their properties, such as the worker name, status, version, creation date or environment variables.
    Each of these variants take a filter record holding a value and a comparator:
    package golem:api@1.1.6;
     
    interface host {
        record worker-name-filter {
            comparator: string-filter-comparator,
            value: string
        }
     
        record worker-status-filter {
            comparator: filter-comparator,
            value: worker-status
        }
     
        record worker-version-filter {
            comparator: filter-comparator,
            value: u64
        }
     
        record worker-created-at-filter {
            comparator: filter-comparator,
            value: u64
        }
     
        record worker-env-filter {
            name: string,
            comparator: string-filter-comparator,
            value: string
        }
    }
    Where filter-comparator and string-filter-comparator are defined as:
    package golem:api@1.1.6;
     
    interface host {
        enum filter-comparator {
            equal,
            not-equal,
            greater-equal,
            greater,
            less-equal,
            less
        }
     
        enum string-filter-comparator {
            equal,
            not-equal,
            like,
            not-like
        }
    }
    Precise enumeration
    The precise flag switches the worker enumeration into a more costly variant which guarantees that every worker metadata returned is the latest one available at the time the result was generated.
    When precise is set to false, the enumeration returns the last cached worker metadata available for each worker, which may be lagging behind the actual state of the workers.
    Transactions and persistence control
    Golem's transaction API allows customizing the execution engine's durability and transactional behaviors. These are low level functions, which are wrapped by SDKs providing a higher level transaction API for each supported language.
    Types
    Retry policy is defined by the following record:
    package golem:api@1.1.6;
     
    interface host {
        /// Configures how the executor retries failures
        record retry-policy {
            /// The maximum number of retries before the worker becomes permanently failed
            max-attempts: u32,
            /// The minimum delay between retries (applied to the first retry)
            min-delay: duration,
            /// The maximum delay between retries
            max-delay: duration,
            /// Multiplier applied to the delay on each retry to implement exponential backoff
            multiplier: f64,
            /// The maximum amount of jitter to add to the delay
            max-jitter-factor: option<f64>
        }
    }
    It is possible to switch between persistence modes:
    package golem:api@1.1.6;
     
    interface host {
        /// Configurable persistence level for workers
        variant persistence-level {
            persist-nothing,
            persist-remote-side-effects,
            smart
        }
    }
    Functions
    The following functions define the transaction API:
    Function name Definition Description
    get-oplog-index func() -> oplog-index Returns the current position in the persistent op log
    set-oplog-index func(oplog-idx: oplog-index) -> () Makes the current worker travel back in time and continue execution from the given position in the persistent op log.
    oplog-commit func(replicas: u8) -> () Blocks the execution until the oplog has been written to at least the specified number of replicas, or the maximum number of replicas if the requested number is higher.
    mark-begin-operation func() -> oplog-index Marks the beginning of an atomic operation. In case of a failure within the region selected by mark-begin-operation and mark-end-operation, the whole region will be reexecuted on retry. The end of the region is when mark-end-operation is called with the returned oplog-index.
    mark-end-operation func(begin: oplog-index) -> () Commits this atomic operation. After mark-end-operation is called for a given index, further calls with the same parameter will do nothing.
    get-retry-policy func() -> retry-policy Gets the current retry policy associated with the worker
    set-retry-policy func(policy: retry-policy) -> () Overrides the current retry policy associated with the worker. Following this call, get-retry-policy will return the new retry policy.
    get-oplog-persistence-level func() -> persistence-level Gets the worker's current persistence level.
    set-oplog-persistence-level func(new-persistence-level: persistence-level) -> () Sets the worker's current persistence level. This can increase the performance of execution in cases where durable execution is not required.
    get-idempotence-mode func() -> bool Gets the worker's current idempotence mode.
    set-idempotence-mode func(idempotent: bool) -> () Sets the current idempotence mode. The default is true. True means side-effects are treated idempotent and Golem guarantees at-least-once semantics. In case of false the executor provides at-most-once semantics, failing the worker in case it is not known if the side effect was already executed.
    generate-idempotency-key func() -> uuid Generates a new idempotency key.
    Update
    The update API enables workers to trigger automatic or manual update of other workers.
    Types
    Automatic and manual updates are distinguished by the following enum:
    package golem:api@1.1.6;
     
    interface host {
        /// Describes how to update a worker to a different component version
        enum update-mode {
            /// Automatic update tries to recover the worker using the new component version
            /// and may fail if there is a divergence.
            automatic,
     
            /// Manual, snapshot-based update uses a user-defined implementation of the `save-snapshot` interface
            /// to store the worker's state, and a user-defined implementation of the `load-snapshot` interface to
            /// load it into the new version.
            snapshot-based
        }
    }
    Functions
    The following function defines the update API:
    Function name Definition Description
    update-worker func(worker-id: worker-id, target-version: component-version, mode: update-mode) -> () Initiates an update attempt for the given worker. The function returns immediately once the request has been processed, not waiting for the worker to get updated.
    Oplog search and query
    The oplog interface in golem:api provides functions to search and query the worker's persisted oplog.
    The interface defines a big variant data type called oplog-entry:
    package golem:api@1.1.6;
     
    interface host {
        variant oplog-entry {
            /// The initial worker oplog entry
            create(create-parameters),
            /// The worker invoked a host function
            imported-function-invoked(imported-function-invoked-parameters),
            /// The worker has been invoked
            exported-function-invoked(exported-function-invoked-parameters),
            /// The worker has completed an invocation
            exported-function-completed(exported-function-completed-parameters),
            /// Worker suspended
            suspend(datetime),
            /// Worker failed
            error(error-parameters),
            /// Marker entry added when get-oplog-index is called from the worker, to make the jumping behavior
            /// more predictable.
            no-op(datetime),
            /// The worker needs to recover up to the given target oplog index and continue running from
            /// the source oplog index from there
            /// `jump` is an oplog region representing that from the end of that region we want to go back to the start and
            /// ignore all recorded operations in between.
            jump(jump-parameters),
            /// Indicates that the worker has been interrupted at this point.
            /// Only used to recompute the worker's (cached) status, has no effect on execution.
            interrupted(datetime),
            /// Indicates that the worker has been exited using WASI's exit function.
            exited(datetime),
            /// Overrides the worker's retry policy
            change-retry-policy(change-retry-policy-parameters),
            /// Begins an atomic region. All oplog entries after `BeginAtomicRegion` are to be ignored during
            /// recovery except if there is a corresponding `EndAtomicRegion` entry.
            begin-atomic-region(datetime),
            /// Ends an atomic region. All oplog entries between the corresponding `BeginAtomicRegion` and this
            /// entry are to be considered during recovery, and the begin/end markers can be removed during oplog
            /// compaction.
            end-atomic-region(end-atomic-region-parameters),
            /// Begins a remote write operation. Only used when idempotence mode is off. In this case each
            /// remote write must be surrounded by a `BeginRemoteWrite` and `EndRemoteWrite` log pair and
            /// unfinished remote writes cannot be recovered.
            begin-remote-write(datetime),
            /// Marks the end of a remote write operation. Only used when idempotence mode is off.
            end-remote-write(end-remote-write-parameters),
            /// An invocation request arrived while the worker was busy
            pending-worker-invocation(pending-worker-invocation-parameters),
            /// An update request arrived and will be applied as soon the worker restarts
            pending-update(pending-update-parameters),
            /// An update was successfully applied
            successful-update(successful-update-parameters),
            /// An update failed to be applied
            failed-update(failed-update-parameters),
            /// Increased total linear memory size
            grow-memory(grow-memory-parameters),
            /// Created a resource instance
            create-resource(create-resource-parameters),
            /// Dropped a resource instance
            drop-resource(drop-resource-parameters),
            /// Adds additional information for a created resource instance
            describe-resource(describe-resource-parameters),
            /// The worker emitted a log message
            log(log-parameters),
            /// The worker's has been restarted, forgetting all its history
            restart(datetime),
            /// Activates a plugin
            activate-plugin(activate-plugin-parameters),
            /// Deactivates a plugin
            deactivate-plugin(deactivate-plugin-parameters),
            /// Revert a worker to a previous state
            revert(revert-parameters),
            /// Cancel a pending invocation
            cancel-invocation(cancel-invocation-parameters),
            /// Start a new span in the invocation context
            start-span(start-span-parameters),
            /// Finish an open span in the invocation context
            finish-span(finish-span-parameters),
            /// Set an attribute on an open span in the invocation context
            set-span-attribute(set-span-attribute-parameters),
        }
    }
    and two resources for querying a worker's oplog.
    the get-oplog resource enumerates through all entries of the oplog
    the search-oplog resource accepts a search expression and only returns the matching entries
    Both resources, once constructed, provide a get-next function that returns a chunk of oplog entries. Repeatedly calling this function goes through the whole data set, and eventually returns none.
    Durability
    The golem:durability package contains an API that can be leveraged by libraries to provide a custom durability implementation for their own API. This is the same interface that Golem uses under the hood to make the WASI interfaces durable. Golem applications are not supposed to use this package directly.
    Types
    The durable-function-type is a variant that categorizes a durable function in the following way:
    package golem:api@1.1.6;
     
    interface host {
        variant durable-function-type {
            /// The side-effect reads from the worker's local state (for example local file system,
            /// random generator, etc.)
            read-local,
            /// The side-effect writes to the worker's local state (for example local file system)
            write-local,
            /// The side-effect reads from external state (for example a key-value store)
            read-remote,
            /// The side-effect manipulates external state (for example an RPC call)
            write-remote,
            /// The side-effect manipulates external state through multiple invoked functions (for example
            /// a HTTP request where reading the response involves multiple host function calls)
            ///
            /// On the first invocation of the batch, the parameter should be `None` - this triggers
            /// writing a `BeginRemoteWrite` entry in the oplog. Followup invocations should contain
            /// this entry's index as the parameter. In batched remote writes it is the caller's responsibility
            /// to manually write an `EndRemoteWrite` entry (using `end_function`) when the operation is completed.
            write-remote-batched(option<oplog-index>)
        }
    }
    The durable-execution-state record provides information about the current execution state, and can be queried using the current-durable-execution-state function:
    package golem:api@1.1.6;
     
    interface host {
        record durable-execution-state {
            is-live: bool,
            persistence-level: persistence-level,
        }
    }
    Here the is-live field indicates whether the executor is currently replaying a worker's previously persisted state or side effects should be executed. The persistence-level is a user-configurable setting that can turn off persistence for certain sections of the code.
    The persisted-durable-function-invocation is a record holding all the information about one persisted durable function. This should be used during replay to simulate the side effect instead of actually running it.
    Functions
    The durability API consists of a couple of low-level functions that must be called in a correct way to make it work.
    The logic to be implemented is the following, in pseudocode:
    observe-function-call("interface", "function")
    state = current-durable-execution-state()
    if state.is-live {
      result = perform-side-effect(input)
      persist-typed-durable-function-invocation("function", encode(input), encode(result), durable-function-type)
    } else {
      // Execute the side effect
      persisted = read-persisted-durable-function-invocation()
      result = decode(persisted.response)
    }
    The input and result values must be encoded into value-and-type, the dynamic value representation from the golem:rpc package.
    In cases when a durable function's execution interleaves with other calls, the begin-durable-function and end-durable-function calls can be used to mark the beginning and end of the operation.
    Invocation context
    Golem associates an invocation context with each invocation, which contains various information depending on how the exported function was called. This context gets inherited when making further invocations via worker-to-worker communication, and it is also possible to define custom spans and associate custom attributes to it.
    The spans are not automatically sent to any tracing system but they can be reconstructed from the oplog, for example using oplog processor plugins, to provide real-time tracing information.
    To get the current invocation context, use the current-context host function:
    package golem:api@1.1.6;
     
    /// Invocation context support
    interface context {
        current-context: func() -> invocation-context;
    }
    The invocation-context itself is a resource with various methods for querying attributes of the invocation context:
    method description
    trace-id Returns the trace ID associated with the context, coming from either an external trace header or generated at the edge of Golem
    span-id Returns the span ID associated with the context
    parent Returns the parent invocation context, if any
    get-attribute Gets an attribute from the context by key
    get-attributes Gets all attributes from the context
    get-attribute-chain Gets all values of a given attribute from the current and parent contexts
    get-attribute-chains Get all attributes and their previous values
    trace-context-headers Gets the W3C Trace Context headers associated with the current invocation context
    Custom attributes can only be set on custom spans. First start a new span using start-span
    package golem:api@1.1.6;
     
    /// Invocation context support
    interface context {
        /// Starts a new `span` with the given name, as a child of the current invocation context
        start-span: func(name: string) -> span;
    }
    and then use the span resource's methods:
    method description
    started-at Returns the timestamp when the span was started
    set-attribute Sets an attribute on the span
    set-attributes Sets multiple attributes on the span
    finish Ends the current span
    Dropping the resource is equivalent to calling finish on the span.
    The custom spans are pushed onto the invocation context stack, so whenever an RPC call or HTTP call is made, their parent span(s) will include the user-defined custom spans as well as the rest of the invocation context.
    Last updated on March 28, 2025
    Function names
    JSON-WAVE Mapping
    
  section: Golem host functions
  char_count: 22396
  approx_token_count: 5599
- id_parent: 141
  title: Json wave mapping
  url: https://learn.golem.cloud/json-wave-mapping
  content: |
    JSON-WAVE Mapping
    JSON - WAVE mapping
    The invocation API uses a special JSON format to describe invocation parameters and results. As the parameter and result types are defined by the Web Assembly components, the natural way to encode parameter and return values is the WAVE (WebAssembly Value Encoding)
    (opens in a new tab)
    format.
    When using the REST API, the JSON-encoded values must be extended with a JSON-encoded type information as well. This is described in details in the Invoke via HTTP page.
    When using the CLI tool, it is possible to either use the WAVE format directly, or use this JSON format as described in details in the Invoke via CLI page.
    The following sections define how each WASM type and it's corresponding WAVE value encoding is mapped to Golem's value JSON format.
    Primitive types
    WIT type JSON type Description
    bool JSON boolean Primitive boolean type
    u8 JSON number Unsigned 8-bit integer
    s8 JSON number Signed 8-bit integer
    u16 JSON number Unsigned 16-bit integer
    s16 JSON number Signed 16-bit integer
    u32 JSON number Unsigned 32-bit integer
    s32 JSON number Signed 32-bit integer
    u64 JSON number Unsigned 64-bit integer
    s64 JSON number Signed 64-bit integer
    f32 JSON number 32-bit floating point number
    f64 JSON number 64-bit floating point number
    char JSON number UTF-8 character
    string JSON string String
    Tuples
    The following WIT type:
    tuple<u32, string, char>
    is encoded in WAVE as
    (1234, "hello world", 'g')
    and in JSON as an array of the items:
    [1234, "hello world", 103]
    Lists
    The following WIT type:
    list<string>
    is encoded in WAVE as
    ["one", "two", "three"]
    and in JSON as an array of the items:
    ["one", "two", "three"]
    Options
    The following WIT type:
    option<string>
    is encoded in WAVE by one of the following:
    "implicit some", some("explicit some"), none
    In the JSON representation we use null to reprsent none and the inner value if defined:
    "implicit some"
    null
    Results
    For the following WIT type:
    result<string, string>
    The WAVE representation is
    "implicit ok", ok("explicit ok"), err("explicit err")
    The result type is represented in JSON by an object with either an ok or an err field:
    { "ok": "explicit ok" }
    { "err": "explicit err" }
    If the type is unit in the WIT definition, the JSON representation should use null:
    result<_, string>
    { "ok": null }
    Handles
    Handles are identifying resources and returned by invoking resource constructors through the Golem invocation API. Handles are represented as strings in the JSON format and they are not supported by WAVE.
    Handles must not be constructed by hand, just forwarded to method invocations as they were returned from the constructors.
    Example handle value in JSON representation:
    "urn:worker:component-id/worker-name/resource-id"
    Records
    Records are a collection of named fields. The JSON representation uses the same names as they appear in the WIT definition:
    record {
        a: string,
        b: u32
    }
    An example WAVE encoding for such a record is:
    { a: "hello", b: 1234 }
    The JSON representation is just an object with the same field names:
    { "a": "hello", "b": 1234 }
    Variants
    Variants are encoded in JSON by an object with a single field, where the field's name matches one of the variant's cases:
    variant allowed-destinations {
        none,
        any,
        restricted(list<string>),
    }
    The WAVE encoding for such a variant is
    none, any, restricted(["one", "two", "three"])
    In JSON the object's single field encodes the case, and the value is null if it has no inner value in the type:
    { "none": null }
    { "any": null }
    { "restricted": ["one", "two", "three"] }
    Enums
    Enums are simply encoded by the case name as a JSON string.
    For example:
    enum {
        low,
        medium,
        high
    }
    The WAVE encoding for such an enum is:
    low, medium high
    and in JSON:
    "low"
    "medium"
    "high"
    Flags
    Flags represent a set of selected values.
    Take the following example WIT type:
    flags allowed-methods {
        get,
        post,
        put,
        delete,
    }
    The WAVE encoding lists zero or more elements of the flags within {}:
    {get, put}
    The JSON representation is an array of the selected values, each represented by a string:
    ["get", "put"]
    Last updated on March 28, 2025
    Golem Host Functions
    REST API
    
  section: Json wave mapping
  char_count: 4157
  approx_token_count: 1040
- id_parent: 142
  title: Rest api
  url: https://learn.golem.cloud/rest-api
  content: |
    REST API
    REST API
    The REST APIs are organized in two sections:
    Golem Open Source
    Golem Cloud
    Last updated on March 28, 2025
    JSON-WAVE Mapping
    Cloud
    
  section: Rest api
  char_count: 147
  approx_token_count: 37
- id_parent: 143
  title: Cloud rest api
  url: https://learn.golem.cloud/rest-api/cloud-rest-api
  content: |
    REST API
    Cloud
    Golem Cloud REST API
    The following pages are the reference of the Golem Cloud REST APIs:
    Account
    API Certificate
    API Definition
    API Deployment
    API Domain
    Component
    Limit
    Login
    Project Grant
    Project Policy
    Project
    Token
    Worker
    Last updated on March 28, 2025
    REST API
    Account
    
  section: Rest api
  char_count: 288
  approx_token_count: 72
- id_parent: 144
  title: Account
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/account
  content: |
    REST API
    Cloud
    Account
    Account API
    The account API allows users to query and manipulate their own account data.
    Get account
    Path Method Protected
    /v1/accounts/{account_id} GET Yes
    Retrieve an account for a given Account ID
    Example Response JSON
    {
      "id": "string",
      "name": "string",
      "email": "string",
      "planId": "b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d"
    }
    Update account
    Path Method Protected
    /v1/accounts/{account_id} PUT Yes
    Allows the user to change the account details such as name and email.
    Changing the planId is not allowed and the request will be rejected. The response is the updated account data.
    Example Request JSON
    {
      "name": "string",
      "email": "string"
    }
    Example Response JSON
    {
      "id": "string",
      "name": "string",
      "email": "string",
      "planId": "b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d"
    }
    Delete account
    Path Method Protected
    /v1/accounts/{account_id} DELETE Yes
    Delete an account.
    Example Response JSON
    {}
    Get account's plan
    Path Method Protected
    /v1/accounts/{account_id}/plan GET Yes
    Example Response JSON
    {
      "planId": "b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d",
      "planData": {
        "projectLimit": 0,
        "componentLimit": 0,
        "workerLimit": 0,
        "storageLimit": 0,
        "monthlyGasLimit": 0,
        "monthlyUploadLimit": 0
      }
    }
    Create account
    Path Method Protected
    /v1/accounts POST Yes
    Create a new account. The response is the created account data.
    Example Request JSON
    {
      "name": "string",
      "email": "string"
    }
    Example Response JSON
    {
      "id": "string",
      "name": "string",
      "email": "string",
      "planId": "b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d"
    }
    Account API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized request {"error":"string"}
    404 Account not found {"error":"string"}
    500 Internal server error {"error":"string"}
    Last updated on March 28, 2025
    Cloud
    API Certificate
    
  section: Rest api
  char_count: 1908
  approx_token_count: 477
- id_parent: 145
  title: Api certificate
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/api-certificate
  content: |
    REST API
    Cloud
    API Certificate
    Api Certificate API
    Gets one or all certificates for a given project
    Path Method Protected
    /v1/api/certificates GET Yes
    If certificate-id is not set, it returns all certificates associated with the project. If certificate-id is set, it returns a single certificate if it exists.
    Query Parameters
    Name Type Required Description
    project-id string Yes -
    certificate-id string No -
    Example Response JSON
    [
      {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
        "domainName": "string",
        "createdAt": "2019-08-24T14:15:22Z"
      }
    ]
    Creates a new certificate
    Path Method Protected
    /v1/api/certificates POST Yes
    A certificate is associated with a given Golem project and domain, and consists of a key pair.
    The created certificate will be associated with a certificate ID returned by this endpoint.
    Example Request JSON
    {
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "domainName": "string",
      "certificateBody": "string",
      "certificatePrivateKey": "string"
    }
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "domainName": "string",
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Deletes a certificate
    Path Method Protected
    /v1/api/certificates DELETE Yes
    Deletes the certificate associated with the given certificate ID and project ID.
    Query Parameters
    Name Type Required Description
    project-id string Yes -
    certificate-id string Yes -
    Example Response JSON
    "string"
    Api Certificate API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"message":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on March 28, 2025
    Account
    API Definition
    
  section: Rest api
  char_count: 1797
  approx_token_count: 450
- id_parent: 146
  title: Api definition
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/api-definition
  content: |
    REST API
    Cloud
    API Definition
    Api Definition API
    Upload an OpenAPI definition
    Path Method Protected
    /v1/api/definitions/{project_id}/import PUT Yes
    Uploads an OpenAPI JSON document and either creates a new one or updates an existing Golem API definition using it.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    List API definitions
    Path Method Protected
    /v1/api/definitions/{project_id} GET Yes
    Lists all API definitions associated with the project.
    Query Parameters
    Name Type Required Description
    api-definition-id string No -
    Example Response JSON
    [
      {
        "id": "string",
        "version": "string",
        "routes": [
          {
            "method": "Get",
            "path": "string",
            "security": "string",
            "binding": {
              "component": {
                "name": "string",
                "version": 0
              },
              "workerName": "string",
              "idempotencyKey": "string",
              "response": "string",
              "bindingType": "default",
              "responseMappingInput": {
                "types": {
                  "property1": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  },
                  "property2": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              },
              "workerNameInput": {
                "types": {
                  "property1": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  },
                  "property2": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              },
              "idempotencyKeyInput": {
                "types": {
                  "property1": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  },
                  "property2": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              },
              "corsPreflight": {
                "allowOrigin": "string",
                "allowMethods": "string",
                "allowHeaders": "string",
                "exposeHeaders": "string",
                "allowCredentials": true,
                "maxAge": 0
              },
              "responseMappingOutput": {
                "analysed_type": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            }
          }
        ],
        "draft": true,
        "createdAt": "2019-08-24T14:15:22Z"
      }
    ]
    Create a new API definition
    Path Method Protected
    /v1/api/definitions/{project_id} POST Yes
    Creates a new API definition described by Golem's API definition JSON document. If an API definition of the same version already exists, its an error.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Get an API definition
    Path Method Protected
    /v1/api/definitions/{project_id}/{id}/{version} GET Yes
    An API definition is selected by its API definition ID and version.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Update an existing API definition.
    Path Method Protected
    /v1/api/definitions/{project_id}/{id}/{version} PUT Yes
    Only draft API definitions can be updated.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Delete an API definition
    Path Method Protected
    /v1/api/definitions/{project_id}/{id}/{version} DELETE Yes
    Deletes an API definition by its API definition ID and version.
    Example Response JSON
    "string"
    Api Definition API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"message":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on April 5, 2025
    API Certificate
    API Deployment
    
  section: Rest api
  char_count: 14130
  approx_token_count: 3533
- id_parent: 147
  title: Api deployment
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/api-deployment
  content: |
    REST API
    Cloud
    API Deployment
    Api Deployment API
    Creates or updates a deployment
    Path Method Protected
    /v1/api/deployments/deploy POST Yes
    Deploys a set of API definitions to a site (specific host and subdomain).
    Example Request JSON
    {
      "apiDefinitions": [
        {
          "id": "string",
          "version": "string"
        }
      ],
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "site": {
        "host": "string",
        "subdomain": "string"
      }
    }
    Example Response JSON
    {
      "apiDefinitions": [
        {
          "id": "string",
          "version": "string"
        }
      ],
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "site": {
        "host": "string",
        "subdomain": "string"
      },
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Get one or more API deployments
    Path Method Protected
    /v1/api/deployments GET Yes
    If api-definition-id is not set, it lists all API deployments. If api-definition-id is set, returns a single API deployment.
    Query Parameters
    Name Type Required Description
    project-id string Yes -
    api-definition-id string Yes -
    Example Response JSON
    [
      {
        "apiDefinitions": [
          {
            "id": "string",
            "version": "string"
          }
        ],
        "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
        "site": {
          "host": "string",
          "subdomain": "string"
        },
        "createdAt": "2019-08-24T14:15:22Z"
      }
    ]
    Get API deployment by site
    Path Method Protected
    /v1/api/deployments/{site} GET Yes
    Gets an API deployment by the host name (optionally with a subdomain) it is deployed to.
    Example Response JSON
    {
      "apiDefinitions": [
        {
          "id": "string",
          "version": "string"
        }
      ],
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "site": {
        "host": "string",
        "subdomain": "string"
      },
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Delete API deployment by site
    Path Method Protected
    /v1/api/deployments/{site} DELETE Yes
    Deletes an API deployment by the host name (optionally with a subdomain) it is deployed to.
    Example Response JSON
    "string"
    Api Deployment API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"message":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on March 28, 2025
    API Definition
    API Domain
    
  section: Rest api
  char_count: 2247
  approx_token_count: 562
- id_parent: 148
  title: Api domain
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/api-domain
  content: |
    REST API
    Cloud
    API Domain
    Api Domain API
    Get all API domains
    Path Method Protected
    /v1/api/domains GET Yes
    Returns a list of API domains for the given project.
    Query Parameters
    Name Type Required Description
    project-id string Yes -
    Example Response JSON
    [
      {
        "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
        "domainName": "string",
        "nameServers": ["string"],
        "createdAt": "2019-08-24T14:15:22Z"
      }
    ]
    Create or update an API domain
    Path Method Protected
    /v1/api/domains PUT Yes
    Example Request JSON
    {
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "domainName": "string"
    }
    Example Response JSON
    {
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "domainName": "string",
      "nameServers": ["string"],
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Delete an API domain
    Path Method Protected
    /v1/api/domains DELETE Yes
    Query Parameters
    Name Type Required Description
    project-id string Yes -
    domain string Yes -
    Example Response JSON
    "string"
    Api Domain API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"message":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on March 28, 2025
    API Deployment
    API Security
    
  section: Rest api
  char_count: 1231
  approx_token_count: 308
- id_parent: 149
  title: Api security
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/api-security
  content: |
    REST API
    Cloud
    API Security
    Api Security API
    Get a security scheme
    Path Method Protected
    /v1/api/security/{project_id}/{security_scheme_identifier} GET Yes
    Get a security scheme by name
    Example Response JSON
    {
      "providerType": "Google",
      "schemeIdentifier": "string",
      "clientId": "string",
      "clientSecret": "string",
      "redirectUrl": "string",
      "scopes": ["string"]
    }
    Create a security scheme
    Path Method Protected
    /v1/api/security/{project_id} POST Yes
    Example Request JSON
    {
      "providerType": "Google",
      "schemeIdentifier": "string",
      "clientId": "string",
      "clientSecret": "string",
      "redirectUrl": "string",
      "scopes": ["string"]
    }
    Example Response JSON
    {
      "providerType": "Google",
      "schemeIdentifier": "string",
      "clientId": "string",
      "clientSecret": "string",
      "redirectUrl": "string",
      "scopes": ["string"]
    }
    Api Security API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"message":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on March 28, 2025
    API Domain
    Component
    
  section: Rest api
  char_count: 1090
  approx_token_count: 273
- id_parent: 150
  title: Component
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/component
  content: |
    REST API
    Cloud
    Component
    Component API
    Get the metadata for all component versions
    Path Method Protected
    /v1/components/{component_id} GET Yes
    Each component can have multiple versions. Every time a new WASM is uploaded for a given component id, that creates a new version. This endpoint returns a list of all versions for the component id provided as part of the URL. Each element of the response describes a single version of a component, but does not contain the binary (WASM) itself:
    versionedComponentId associates a specific version with the component id
    componentName is the human-readable name of the component
    componentSize is the WASM binary's size in bytes
    metadata contains information extracted from the WASM itself
    metadata.exports is a list of exported functions, including their parameter's and return value's types
    metadata.producers is a list of producer information added by tooling, each consisting of a list of fields associating one or more values to a given key. This contains information about what compilers and other WASM related tools were used to construct the Golem component.
    Example Response JSON
    [
      {
        "versionedComponentId": {
          "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
          "version": 0
        },
        "componentName": "string",
        "componentSize": 0,
        "metadata": {
          "exports": [
            {
              "type": "Function",
              "name": "string",
              "parameters": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ],
              "results": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ]
            }
          ],
          "producers": [
            {
              "fields": [
                {
                  "name": "string",
                  "values": [
                    {
                      "name": "string",
                      "version": "string"
                    }
                  ]
                }
              ]
            }
          ],
          "memories": [
            {
              "initial": 0,
              "maximum": 0
            }
          ]
        },
        "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
        "createdAt": "2019-08-24T14:15:22Z",
        "componentType": "Durable",
        "files": [
          {
            "key": "string",
            "path": "string",
            "permissions": "read-only"
          }
        ],
        "installedPlugins": [
          {
            "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
            "name": "string",
            "version": "string",
            "priority": 0,
            "parameters": {
              "property1": "string",
              "property2": "string"
            }
          }
        ]
      }
    ]
    Update a component
    Path Method Protected
    /v1/components/{component_id}/upload PUT Yes
    Query Parameters
    Name Type Required Description
    component_type #/components/schemas/ComponentType No Type of the new version of the component - if not specified, the type of the previous version
    is used.
    Request Body: WASM Binary File
    Make sure to include Content-Type: application/octet-stream Header
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ]
      },
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Update a component
    Path Method Protected
    /v1/components/{component_id}/updates POST Yes
    Request Form: multipart/form-data
    Make sure to include Content-Type: multipart/form-data Header
    Field componentType: JSON
    "Durable"
    Field component: string binary
    Field filesPermissions: JSON
    {
      "values": [
        {
          "path": "string",
          "permissions": "read-only"
        }
      ]
    }
    Field files: string binary
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ]
      },
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Get all components
    Path Method Protected
    /v1/components GET Yes
    Gets all components, optionally filtered by project and/or component name.
    Query Parameters
    Name Type Required Description
    project-id string No Project ID to filter by
    component-name string No Component name to filter by
    Example Response JSON
    [
      {
        "versionedComponentId": {
          "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
          "version": 0
        },
        "componentName": "string",
        "componentSize": 0,
        "metadata": {
          "exports": [
            {
              "type": "Function",
              "name": "string",
              "parameters": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ],
              "results": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ]
            }
          ],
          "producers": [
            {
              "fields": [
                {
                  "name": "string",
                  "values": [
                    {
                      "name": "string",
                      "version": "string"
                    }
                  ]
                }
              ]
            }
          ],
          "memories": [
            {
              "initial": 0,
              "maximum": 0
            }
          ]
        },
        "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
        "createdAt": "2019-08-24T14:15:22Z",
        "componentType": "Durable",
        "files": [
          {
            "key": "string",
            "path": "string",
            "permissions": "read-only"
          }
        ],
        "installedPlugins": [
          {
            "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
            "name": "string",
            "version": "string",
            "priority": 0,
            "parameters": {
              "property1": "string",
              "property2": "string"
            }
          }
        ]
      }
    ]
    Create a new component
    Path Method Protected
    /v1/components POST Yes
    The request body is encoded as multipart/form-data containing metadata and the WASM binary. If the component type is not specified, it will be considered as a Durable component.
    Request Form: multipart/form-data
    Make sure to include Content-Type: multipart/form-data Header
    Field query: JSON
    {
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "componentName": "string"
    }
    Field component: string binary
    Field componentType: JSON
    "Durable"
    Field filesPermissions: JSON
    {
      "values": [
        {
          "path": "string",
          "permissions": "read-only"
        }
      ]
    }
    Field files: string binary
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ]
      },
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Download a component
    Path Method Protected
    /v1/components/{component_id}/download GET Yes
    Downloads a specific version of the component's WASM.
    Query Parameters
    Name Type Required Description
    version integer No -
    Response Body: WASM Binary File
    Get the version of a given component
    Path Method Protected
    /v1/components/{component_id}/versions/{version} GET Yes
    Gets the version of a component.
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ]
      },
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Get the latest version of a given component
    Path Method Protected
    /v1/components/{component_id}/latest GET Yes
    Gets the latest version of a component.
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ]
      },
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Gets the list of plugins installed for the given component version
    Path Method Protected
    /v1/components/{component_id}/versions/{version}/plugins/installs GET Yes
    Example Response JSON
    [
      {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "name": "string",
        "version": "string",
        "priority": 0,
        "parameters": {
          "property1": "string",
          "property2": "string"
        }
      }
    ]
    Installs a new plugin for this component
    Path Method Protected
    /v1/components/{component_id}/latest/plugins/installs POST Yes
    Example Request JSON
    {
      "name": "string",
      "version": "string",
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "name": "string",
      "version": "string",
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Updates the priority or parameters of a plugin installation
    Path Method Protected
    /v1/components/{component_id}/versions/latest/plugins/installs/{installation_id} PUT Yes
    Example Request JSON
    {
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {}
    Uninstalls a plugin from this component
    Path Method Protected
    /v1/components/{component_id}/latest/plugins/installs/{installation_id} DELETE Yes
    Example Response JSON
    {}
    Component API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized {"error":"string"}
    403 Maximum number of components exceeded {"error":"string"}
    404 Component not found {"error":"string"}
    409 Component already exists {"error":"string"}
    500 Internal server error {"error":"string"}
    Last updated on March 28, 2025
    API Security
    Limits
    
  section: Rest api
  char_count: 17663
  approx_token_count: 4416
- id_parent: 151
  title: Limits
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/limits
  content: |
    REST API
    Cloud
    Limits
    Limits API
    The limits API allows users to query their current resource limits.
    Get resource limits for a given account.
    Path Method Protected
    /v1/resource-limits GET Yes
    Query Parameters
    Name Type Required Description
    account-id string Yes The Account ID to check resource limits for.
    Example Response JSON
    {
      "availableFuel": 0,
      "maxMemoryPerWorker": 0
    }
    Update resource limits for a given account.
    Path Method Protected
    /v1/resource-limits POST Yes
    Example Request JSON
    {
      "updates": {
        "property1": 0,
        "property2": 0
      }
    }
    Example Response JSON
    {}
    Limits API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized request {"error":"string"}
    403 {"error":"string"}
    500 Internal server error {"error":"string"}
    Last updated on March 28, 2025
    Component
    Login
    
  section: Rest api
  char_count: 888
  approx_token_count: 222
- id_parent: 152
  title: Login
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/login
  content: |
    REST API
    Cloud
    Login
    Login API
    The login endpoints are implementing an OAuth2 flow.
    Acquire token with OAuth2 authorization
    Path Method Protected
    /v1/oauth2 POST No
    Gets a token by authorizing with an external OAuth2 provider. Currently only github is supported.
    In the response:
    id is the identifier of the token itself
    accountId is the account's identifier, can be used on the account API
    secret is the secret key to be sent in the Authorization header as a bearer token for all the other endpoints
    Query Parameters
    Name Type Required Description
    provider string Yes Currently only github is supported.
    access-token string Yes OAuth2 access token
    Example Response JSON
    {
      "data": {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "accountId": "string",
        "createdAt": "2019-08-24T14:15:22Z",
        "expiresAt": "2019-08-24T14:15:22Z"
      },
      "secret": {
        "value": "a860a344-d7b2-406e-828e-8d442f23f344"
      }
    }
    Get information about a token
    Path Method Protected
    /v1/login/token GET Yes
    Gets information about a token that is selected by the secret key passed in the Authorization header. The JSON is the same as the data object in the oauth2 endpoint's response.
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "accountId": "string",
      "createdAt": "2019-08-24T14:15:22Z",
      "expiresAt": "2019-08-24T14:15:22Z"
    }
    Start GitHub OAuth2 interactive flow
    Path Method Protected
    /login/oauth2/device/start POST No
    Starts an interactive authorization flow. The user must open the returned url and enter the userCode in a form before the expires deadline. Then the finish GitHub OAuth2 interactive flow endpoint must be called with the encoded session to finish the flow.
    Example Response JSON
    {
      "url": "string",
      "userCode": "string",
      "expires": "2019-08-24T14:15:22Z",
      "encodedSession": "string"
    }
    Finish GitHub OAuth2 interactive flow
    Path Method Protected
    /login/oauth2/device/complete POST No
    Finishes an interactive authorization flow. The returned JSON is equivalent to the oauth2 endpoint's response. Returns a JSON string containing the encodedSession from the start endpoint's response.
    Example Request JSON
    "string"
    Example Response JSON
    {
      "data": {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "accountId": "string",
        "createdAt": "2019-08-24T14:15:22Z",
        "expiresAt": "2019-08-24T14:15:22Z"
      },
      "secret": {
        "value": "a860a344-d7b2-406e-828e-8d442f23f344"
      }
    }
    Initiate OAuth2 Web Flow
    Path Method Protected
    /v1/login/oauth2/web/authorize GET No
    Starts the OAuth2 web flow authorization process by returning the authorization URL for the given provider.
    Query Parameters
    Name Type Required Description
    provider string Yes Currently only github is supported.
    redirect string No The redirect URL to redirect to after the user has authorized the application
    Example Response JSON
    {
      "url": "string",
      "state": "string"
    }
    GitHub OAuth2 Web Flow callback
    Path Method Protected
    /v1/login/oauth2/web/callback/github GET No
    This endpoint handles the callback from GitHub after the user has authorized the application. It exchanges the code for an access token and then uses that to log the user in.
    Query Parameters
    Name Type Required Description
    code string Yes The authorization code returned by GitHub
    state string Yes The state parameter for CSRF protection
    Example Response JSON
    {}
    Poll for OAuth2 Web Flow token
    Path Method Protected
    /v1/login/oauth2/web/poll GET No
    This endpoint is used by clients to poll for the token after the user has authorized the application via the web flow.
    Query Parameters
    Name Type Required Description
    state string Yes The state parameter for identifying the session
    Example Response JSON
    {
      "data": {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "accountId": "string",
        "createdAt": "2019-08-24T14:15:22Z",
        "expiresAt": "2019-08-24T14:15:22Z"
      },
      "secret": {
        "value": "a860a344-d7b2-406e-828e-8d442f23f344"
      }
    }
    Login API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Failed to login {"error":"string"}
    500 External service call failed during login {"error":"string"}
    Last updated on March 28, 2025
    Limits
    Plugin
    
  section: Rest api
  char_count: 4234
  approx_token_count: 1059
- id_parent: 153
  title: Plugin
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/plugin
  content: |
    REST API
    Cloud
    Plugin
    Plugin API
    Lists all the registered plugins (including all versions of each).
    Path Method Protected
    /v1/plugins GET Yes
    Query Parameters
    Name Type Required Description
    scope #/components/schemas/CloudPluginScope No -
    Example Response JSON
    [
      {
        "name": "string",
        "version": "string",
        "description": "string",
        "icon": [0],
        "homepage": "string",
        "specs": {
          "type": "ComponentTransformer",
          "providedWitPackage": "string",
          "jsonSchema": "string",
          "validateUrl": "string",
          "transformUrl": "string"
        },
        "scope": {
          "type": "Global"
        },
        "owner": {
          "accountId": "string"
        }
      }
    ]
    Registers a new plugin
    Path Method Protected
    /v1/plugins POST Yes
    Example Request JSON
    {
      "name": "string",
      "version": "string",
      "description": "string",
      "icon": [0],
      "homepage": "string",
      "specs": {
        "type": "ComponentTransformer",
        "providedWitPackage": "string",
        "jsonSchema": "string",
        "validateUrl": "string",
        "transformUrl": "string"
      },
      "scope": {
        "type": "Global"
      }
    }
    Example Response JSON
    {}
    Lists all the registered versions of a specific plugin identified by its name
    Path Method Protected
    /v1/plugins/{name} GET Yes
    Example Response JSON
    [
      {
        "name": "string",
        "version": "string",
        "description": "string",
        "icon": [0],
        "homepage": "string",
        "specs": {
          "type": "ComponentTransformer",
          "providedWitPackage": "string",
          "jsonSchema": "string",
          "validateUrl": "string",
          "transformUrl": "string"
        },
        "scope": {
          "type": "Global"
        },
        "owner": {
          "accountId": "string"
        }
      }
    ]
    Gets a registered plugin by its name and version
    Path Method Protected
    /v1/plugins/{name}/{version} GET Yes
    Example Response JSON
    {
      "name": "string",
      "version": "string",
      "description": "string",
      "icon": [0],
      "homepage": "string",
      "specs": {
        "type": "ComponentTransformer",
        "providedWitPackage": "string",
        "jsonSchema": "string",
        "validateUrl": "string",
        "transformUrl": "string"
      },
      "scope": {
        "type": "Global"
      },
      "owner": {
        "accountId": "string"
      }
    }
    Deletes a registered plugin by its name and version
    Path Method Protected
    /v1/plugins/{name}/{version} DELETE Yes
    Example Response JSON
    {}
    Plugin API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized {"error":"string"}
    403 Maximum number of components exceeded {"error":"string"}
    404 Component not found {"error":"string"}
    409 Component already exists {"error":"string"}
    500 Internal server error {"error":"string"}
    Last updated on March 28, 2025
    Login
    Project
    
  section: Rest api
  char_count: 2742
  approx_token_count: 686
- id_parent: 154
  title: Project
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/project
  content: |
    REST API
    Cloud
    Project
    Project API
    Projects are groups of components and their workers, providing both a separate namespace for these entities and allows sharing between accounts.
    Every account has a default project which is assumed when no specific project ID is passed in some component and worker related APIs.
    Get the default project
    Path Method Protected
    /v1/projects/default GET Yes
    name of the project can be used for lookup the project if the ID is now known
    defaultEnvironmentId is currently always default
    projectType is either Default
    Example Response JSON
    {
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "projectData": {
        "name": "string",
        "ownerAccountId": "string",
        "description": "string",
        "defaultEnvironmentId": "string",
        "projectType": "Default"
      }
    }
    List all projects
    Path Method Protected
    /v1/projects GET Yes
    Returns all projects of the account if no project-name is specified. Otherwise, returns all projects of the account that has the given name. As unique names are not enforced on the API level, the response may contain multiple entries.
    Query Parameters
    Name Type Required Description
    project-name string No Filter by project name
    Example Response JSON
    [
      {
        "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
        "projectData": {
          "name": "string",
          "ownerAccountId": "string",
          "description": "string",
          "defaultEnvironmentId": "string",
          "projectType": "Default"
        }
      }
    ]
    Create project
    Path Method Protected
    /v1/projects POST Yes
    Creates a new project. The ownerAccountId must be the caller's account ID.
    Example Request JSON
    {
      "name": "string",
      "ownerAccountId": "string",
      "description": "string"
    }
    Example Response JSON
    {
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "projectData": {
        "name": "string",
        "ownerAccountId": "string",
        "description": "string",
        "defaultEnvironmentId": "string",
        "projectType": "Default"
      }
    }
    Get project by ID
    Path Method Protected
    /v1/projects/{project_id} GET Yes
    Gets a project by its identifier. Response is the same as for the default project.
    Example Response JSON
    {
      "projectId": "5a8591dd-4039-49df-9202-96385ba3eff8",
      "projectData": {
        "name": "string",
        "ownerAccountId": "string",
        "description": "string",
        "defaultEnvironmentId": "string",
        "projectType": "Default"
      }
    }
    Delete project
    Path Method Protected
    /v1/projects/{project_id} DELETE Yes
    Deletes a project given by its identifier.
    Example Response JSON
    {}
    Get project actions
    Path Method Protected
    /v1/projects/{project_id}/actions GET Yes
    Returns a list of actions that can be performed on the project.
    Example Response JSON
    [
      "ViewComponent"
    ]
    Gets the list of plugins installed for the given project
    Path Method Protected
    /v1/projects/{project_id}/plugins/installs GET Yes
    Example Response JSON
    [
      {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "name": "string",
        "version": "string",
        "priority": 0,
        "parameters": {
          "property1": "string",
          "property2": "string"
        }
      }
    ]
    Installs a new plugin for this project
    Path Method Protected
    /v1/projects/{project_id}/plugins/installs POST Yes
    Example Request JSON
    {
      "name": "string",
      "version": "string",
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "name": "string",
      "version": "string",
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Updates the priority or parameters of a plugin installation
    Path Method Protected
    /v1/projects/{project_id}/plugins/installs/{installation_id} PUT Yes
    Example Request JSON
    {
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {}
    Uninstalls a plugin from this project
    Path Method Protected
    /v1/projects/{project_id}/latest/plugins/installs/{installation_id} DELETE Yes
    Example Response JSON
    {}
    Project API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized {"error":"string"}
    403 Maximum number of projects exceeded {"error":"string"}
    404 Project not found {"error":"string"}
    500 Project already exists {"error":"string"}
    Last updated on March 28, 2025
    Plugin
    Project Grant
    
  section: Rest api
  char_count: 4384
  approx_token_count: 1096
- id_parent: 155
  title: Project grant
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/project-grant
  content: |
    REST API
    Cloud
    Project Grant
    Project Grant API
    Projects can have grants providing access to other accounts than the project's owner.
    The project grant API allows listing, creating and deleting such grants. What the grants allow exactly are defined by policies, covered by the Project policy API.
    Get a project's grants
    Path Method Protected
    /v1/projects/{project_id}/grants GET Yes
    Returns all projects grants associated with the given project.
    For each grant:
    `id`` is the identifier of the grant itself
    granteeAccountId the account that gets access for the project
    grantorProjectId the project ID
    projectPolicyId the associated policy - see the project policy API below
    Example Response JSON
    [
      {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "data": {
          "granteeAccountId": "string",
          "grantorProjectId": "fe216e71-e471-414b-9530-d000f4582d33",
          "projectPolicyId": "46e8c3fb-5136-4f2a-a8be-e5188bef1348"
        }
      }
    ]
    Create a project grant
    Path Method Protected
    /v1/projects/{project_id}/grants POST Yes
    Creates a new project grant from the following information:
    granteeAccountId the account that gets access for the project
    projectPolicyId the associated policy - see the project policy API below
    The response describes the new project grant including its id that can be used to query specifically this grant in the future.
    Example Request JSON
    {
      "granteeAccountId": "string",
      "projectPolicyId": "46e8c3fb-5136-4f2a-a8be-e5188bef1348",
      "projectActions": [
        "ViewComponent"
      ],
      "projectPolicyName": "string"
    }
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "data": {
        "granteeAccountId": "string",
        "grantorProjectId": "fe216e71-e471-414b-9530-d000f4582d33",
        "projectPolicyId": "46e8c3fb-5136-4f2a-a8be-e5188bef1348"
      }
    }
    Get a specific grant of a project
    Path Method Protected
    /v1/projects/{project_id}/grants/{grant_id} GET Yes
    Returns a specific grant of a specific project. The returned object is the same as the elements of the grants endpoint's response described above.
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "data": {
        "granteeAccountId": "string",
        "grantorProjectId": "fe216e71-e471-414b-9530-d000f4582d33",
        "projectPolicyId": "46e8c3fb-5136-4f2a-a8be-e5188bef1348"
      }
    }
    Delete a project grant
    Path Method Protected
    /v1/projects/{project_id}/grants/{grant_id} DELETE Yes
    Deletes an existing grant of a specific project.
    Example Response JSON
    {}
    Project Grant API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized {"error":"string"}
    403 Maximum number of projects exceeded {"error":"string"}
    404 Project not found {"error":"string"}
    500 Project already exists {"error":"string"}
    Last updated on March 28, 2025
    Project
    Project Policy
    
  section: Rest api
  char_count: 2865
  approx_token_count: 717
- id_parent: 156
  title: Project policy
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/project-policy
  content: |
    REST API
    Cloud
    Project Policy
    Project Policy API
    Project policies describe a set of actions one account can perform when it was associated with a grant for a project.
    The following actions can be used in the projectActions fields of this API:
    ViewComponent grants read access to a component
    CreateComponent allows creating new components in a project
    UpdateComponent allows uploading new versions for existing components in a project
    DeleteComponent allows deleting components from a project
    ViewWorker allows querying existing workers of a component belonging to the project
    CreateWorker allows launching new workers of a component in the project
    UpdateWorker allows manipulating existing workers of a component belonging to the project
    DeleteWorker allows deleting workers of a component belonging to the project
    ViewProjectGrants allows listing the existing grants of the project
    CreateProjectGrants allows creating new grants for the project
    DeleteProjectGrants allows deleting existing grants of the project
    Get a project policy
    Path Method Protected
    /v1/project-policies/{project_policy_id} GET Yes
    Returns a given project policy by it's ID. Project policy identifiers are used in project grants.
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "name": "string",
      "projectActions": {
        "actions": [
          "ViewComponent"
        ]
      }
    }
    Create a project policy
    Path Method Protected
    /v1/project-policies POST Yes
    Creates a new project policy and returns the object describing it, including the newly created policy's id.
    Example Request JSON
    {
      "name": "string",
      "projectActions": {
        "actions": [
          "ViewComponent"
        ]
      }
    }
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "name": "string",
      "projectActions": {
        "actions": [
          "ViewComponent"
        ]
      }
    }
    Project Policy API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized request {"error":"string"}
    404 Account not found {"error":"string"}
    500 Internal server error {"error":"string"}
    Last updated on March 28, 2025
    Project Grant
    Token
    
  section: Rest api
  char_count: 2167
  approx_token_count: 542
- id_parent: 157
  title: Token
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/token
  content: |
    REST API
    Cloud
    Token
    Token API
    The token API allows creating custom access tokens for the Golem Cloud REST API to be used by tools and services.
    Get all tokens
    Path Method Protected
    /v1/accounts/{account_id}/tokens GET Yes
    Gets all created tokens of an account. The format of each element is the same as the data object in the oauth2 endpoint's response.
    Example Response JSON
    [
      {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "accountId": "string",
        "createdAt": "2019-08-24T14:15:22Z",
        "expiresAt": "2019-08-24T14:15:22Z"
      }
    ]
    Create new token
    Path Method Protected
    /v1/accounts/{account_id}/tokens POST Yes
    Creates a new token with a given expiration date. The response not only contains the token data but also the secret which can be passed as a bearer token to the Authorization header to the Golem Cloud REST API.
    Example Request JSON
    {
      "expiresAt": "2019-08-24T14:15:22Z"
    }
    Example Response JSON
    {
      "data": {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "accountId": "string",
        "createdAt": "2019-08-24T14:15:22Z",
        "expiresAt": "2019-08-24T14:15:22Z"
      },
      "secret": {
        "value": "a860a344-d7b2-406e-828e-8d442f23f344"
      }
    }
    Get a specific token
    Path Method Protected
    /v1/accounts/{account_id}/tokens/{token_id} GET Yes
    Gets information about a token given by it's identifier. The JSON is the same as the data object in the oauth2 endpoint's response.
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "accountId": "string",
      "createdAt": "2019-08-24T14:15:22Z",
      "expiresAt": "2019-08-24T14:15:22Z"
    }
    Delete a token
    Path Method Protected
    /v1/accounts/{account_id}/tokens/{token_id} DELETE Yes
    Deletes a previously created token given by it's identifier.
    Example Response JSON
    {}
    Token API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized request {"error":"string"}
    404 Account not found {"error":"string"}
    500 Internal server error {"error":"string"}
    Last updated on March 28, 2025
    Project Policy
    Worker
    
  section: Rest api
  char_count: 2081
  approx_token_count: 521
- id_parent: 158
  title: Worker
  url: https://learn.golem.cloud/rest-api/cloud-rest-api/worker
  content: |
    REST API
    Cloud
    Worker
    Worker API
    Get metadata of multiple workers
    Path Method Protected
    /v1/components/{component_id}/workers GET Yes
    Filters
    Property Comparator Description Example
    name StringFilterComparator Name of worker name = worker-name
    version FilterComparator Version of worker version >= 0
    status FilterComparator Status of worker status = Running
    env.[key] StringFilterComparator Environment variable of worker env.var1 = value
    createdAt FilterComparator Creation time of worker createdAt > 2024-04-01T12:10:00Z
    Comparators
    StringFilterComparator: eq|equal|=|==, ne|notequal|!=, like, notlike
    FilterComparator: eq|equal|=|==, ne|notequal|!=, ge|greaterequal|>=, gt|greater|>, le|lessequal|<=, lt|less|<
    Returns metadata about an existing component workers:
    workers list of workers metadata
    cursor cursor for next request, if cursor is empty/null, there are no other values
    Query Parameters
    Name Type Required Description
    filter array No Filter for worker metadata in form of property op value. Can be used multiple times (AND condition is applied between them)
    cursor string No Count of listed values, default: 50
    count integer No Position where to start listing, if not provided, starts from the beginning. It is used to get the next page of results. To get next page, use the cursor returned in the response
    precise boolean No Precision in relation to worker status, if true, calculate the most up-to-date status for each worker, default is false
    Example Response JSON
    {
      "workers": [
        {
          "workerId": {
            "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
            "workerName": "string"
          },
          "accountId": "string",
          "args": ["string"],
          "env": {
            "property1": "string",
            "property2": "string"
          },
          "status": "Running",
          "componentVersion": 0,
          "retryCount": 0,
          "pendingInvocationCount": 0,
          "updates": [
            {
              "type": "pendingUpdate",
              "timestamp": "2019-08-24T14:15:22Z",
              "targetVersion": 0
            }
          ],
          "createdAt": "2019-08-24T14:15:22Z",
          "lastError": "string",
          "componentSize": 0,
          "totalLinearMemorySize": 0,
          "ownedResources": {
            "property1": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": ["string"]
              }
            },
            "property2": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": ["string"]
              }
            }
          },
          "activePlugins": ["497f6eca-6276-4993-bfeb-53cbbbba6f08"]
        }
      ],
      "cursor": {
        "cursor": 0,
        "layer": 0
      }
    }
    Launch a new worker.
    Path Method Protected
    /v1/components/{component_id}/workers POST Yes
    Creates a new worker. The worker initially is in `Idle`` status, waiting to be invoked.
    The parameters in the request are the following:
    name is the name of the created worker. This has to be unique, but only for a given component
    args is a list of strings which appear as command line arguments for the worker
    env is a list of key-value pairs (represented by arrays) which appear as environment variables for the worker
    Example Request JSON
    {
      "name": "string",
      "args": ["string"],
      "env": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {
      "workerId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "workerName": "string"
      },
      "componentVersion": 0
    }
    Get metadata of a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name} GET Yes
    Returns metadata about an existing worker:
    workerId is a combination of the used component and the worker's user specified name
    accountId the account the worker is created by
    args is the provided command line arguments passed to the worker
    env is the provided map of environment variables passed to the worker
    componentVersion is the version of the component used by the worker
    retryCount is the number of retries the worker did in case of a failure
    status is the worker's current status, one of the following:
    Running if the worker is currently executing
    Idle if the worker is waiting for an invocation
    Suspended if the worker was running but is now waiting to be resumed by an event (such as end of a sleep, a promise, etc)
    Interrupted if the worker was interrupted by the user
    Retrying if the worker failed, and an automatic retry was scheduled for it
    Failed if the worker failed and there are no more retries scheduled for it
    Exited if the worker explicitly exited using the exit WASI function
    Example Response JSON
    {
      "workerId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "workerName": "string"
      },
      "accountId": "string",
      "args": ["string"],
      "env": {
        "property1": "string",
        "property2": "string"
      },
      "status": "Running",
      "componentVersion": 0,
      "retryCount": 0,
      "pendingInvocationCount": 0,
      "updates": [
        {
          "type": "pendingUpdate",
          "timestamp": "2019-08-24T14:15:22Z",
          "targetVersion": 0
        }
      ],
      "createdAt": "2019-08-24T14:15:22Z",
      "lastError": "string",
      "componentSize": 0,
      "totalLinearMemorySize": 0,
      "ownedResources": {
        "property1": {
          "createdAt": "2019-08-24T14:15:22Z",
          "indexed": {
            "resourceName": "string",
            "resourceParams": ["string"]
          }
        },
        "property2": {
          "createdAt": "2019-08-24T14:15:22Z",
          "indexed": {
            "resourceName": "string",
            "resourceParams": ["string"]
          }
        }
      },
      "activePlugins": ["497f6eca-6276-4993-bfeb-53cbbbba6f08"]
    }
    Delete a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name} DELETE Yes
    Interrupts and deletes an existing worker.
    Example Response JSON
    {}
    Invoke a function and await its resolution
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/invoke-and-await POST Yes
    Supply the parameters in the request body as JSON.
    Query Parameters
    Name Type Required Description
    function string Yes -
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {
      "result": {
        "typ": {
          "type": "Variant",
          "cases": [
            {
              "name": "string",
              "typ": {}
            }
          ]
        },
        "value": null
      }
    }
    Invoke a function and await its resolution on a new worker with a random generated name
    Path Method Protected
    /v1/components/{component_id}/invoke-and-await POST Yes
    Ideal for invoking ephemeral components, but works with durable ones as well. Supply the parameters in the request body as JSON.
    Query Parameters
    Name Type Required Description
    function string Yes -
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {
      "result": {
        "typ": {
          "type": "Variant",
          "cases": [
            {
              "name": "string",
              "typ": {}
            }
          ]
        },
        "value": null
      }
    }
    Invoke a function
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/invoke POST Yes
    A simpler version of the previously defined invoke and await endpoint just triggers the execution of a function and immediately returns.
    Query Parameters
    Name Type Required Description
    function string Yes name of the exported function to be invoked
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {}
    Invoke a function on a new worker with a random generated name
    Path Method Protected
    /v1/components/{component_id}/invoke POST Yes
    Ideal for invoking ephemeral components, but works with durable ones as well. A simpler version of the previously defined invoke and await endpoint just triggers the execution of a function and immediately returns.
    Query Parameters
    Name Type Required Description
    function string Yes name of the exported function to be invoked
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {}
    Complete a promise
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/complete POST Yes
    Completes a promise with a given custom array of bytes. The promise must be previously created from within the worker, and it's identifier (a combination of a worker identifier and an oplogIdx ) must be sent out to an external caller so it can use this endpoint to mark the promise completed. The data field is sent back to the worker, and it has no predefined meaning.
    Example Request JSON
    {
      "oplogIdx": 0,
      "data": [0]
    }
    Example Response JSON
    true
    Interrupt a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/interrupt POST Yes
    Interrupts the execution of a worker. The worker's status will be Interrupted unless the recover-immediately parameter was used, in which case it remains as it was. An interrupted worker can be still used, and it is going to be automatically resumed the first time it is used. For example in case of a new invocation, the previously interrupted invocation is continued before the new one gets processed.
    Query Parameters
    Name Type Required Description
    recovery-immediately boolean No if true will simulate a worker recovery. Defaults to false.
    Example Response JSON
    {}
    Advanced search for workers
    Path Method Protected
    /v1/components/{component_id}/workers/find POST Yes
    Filter types
    Type Comparator Description Example
    Name StringFilterComparator Name of worker { "type": "Name", "comparator": "Equal", "value": "worker-name" }
    Version FilterComparator Version of worker { "type": "Version", "comparator": "GreaterEqual", "value": 0 }
    Status FilterComparator Status of worker { "type": "Status", "comparator": "Equal", "value": "Running" }
    Env StringFilterComparator Environment variable of worker { "type": "Env", "name": "var1", "comparator": "Equal", "value": "value" }
    CreatedAt FilterComparator Creation time of worker { "type": "CreatedAt", "comparator": "Greater", "value": "2024-04-01T12:10:00Z" }
    And And filter combinator { "type": "And", "filters": [ ... ] }
    Or Or filter combinator { "type": "Or", "filters": [ ... ] }
    Not Negates the specified filter { "type": "Not", "filter": { "type": "Version", "comparator": "GreaterEqual", "value": 0 } }
    Comparators
    StringFilterComparator: Equal, NotEqual, Like, NotLike
    FilterComparator: Equal, NotEqual, GreaterEqual, Greater, LessEqual, Less
    Returns metadata about an existing component workers:
    workers list of workers metadata
    cursor cursor for next request, if cursor is empty/null, there are no other values
    Example Request JSON
    {
      "filter": {
        "type": "Name",
        "comparator": "Equal",
        "value": "string"
      },
      "cursor": {
        "cursor": 0,
        "layer": 0
      },
      "count": 0,
      "precise": true
    }
    Example Response JSON
    {
      "workers": [
        {
          "workerId": {
            "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
            "workerName": "string"
          },
          "accountId": "string",
          "args": ["string"],
          "env": {
            "property1": "string",
            "property2": "string"
          },
          "status": "Running",
          "componentVersion": 0,
          "retryCount": 0,
          "pendingInvocationCount": 0,
          "updates": [
            {
              "type": "pendingUpdate",
              "timestamp": "2019-08-24T14:15:22Z",
              "targetVersion": 0
            }
          ],
          "createdAt": "2019-08-24T14:15:22Z",
          "lastError": "string",
          "componentSize": 0,
          "totalLinearMemorySize": 0,
          "ownedResources": {
            "property1": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": ["string"]
              }
            },
            "property2": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": ["string"]
              }
            }
          },
          "activePlugins": ["497f6eca-6276-4993-bfeb-53cbbbba6f08"]
        }
      ],
      "cursor": {
        "cursor": 0,
        "layer": 0
      }
    }
    Resume a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/resume POST Yes
    Example Response JSON
    {}
    Update a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/update POST Yes
    Example Request JSON
    {
      "mode": "Automatic",
      "targetVersion": 0
    }
    Example Response JSON
    {}
    Get the oplog of a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/oplog GET Yes
    Query Parameters
    Name Type Required Description
    from integer No -
    count integer Yes -
    cursor #/components/schemas/OplogCursor No -
    query string No -
    Example Response JSON
    {
      "entries": [
        {
          "oplogIndex": 0,
          "entry": {
            "type": "Create",
            "timestamp": "2019-08-24T14:15:22Z",
            "worker_id": {
              "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
              "workerName": "string"
            },
            "component_version": 0,
            "args": ["string"],
            "env": {
              "property1": "string",
              "property2": "string"
            },
            "account_id": "string",
            "parent": {
              "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
              "workerName": "string"
            },
            "component_size": 0,
            "initial_total_linear_memory_size": 0,
            "initial_active_plugins": [
              {
                "installation_id": "91166175-c6a9-4caf-88e9-3147ffc9c934",
                "plugin_name": "string",
                "plugin_version": "string",
                "parameters": {
                  "property1": "string",
                  "property2": "string"
                }
              }
            ]
          }
        }
      ],
      "next": {
        "next_oplog_index": 0,
        "current_component_version": 0
      },
      "firstIndexInChunk": 0,
      "lastIndex": 0
    }
    Worker API Errors
    Status Code Description Body
    400 Invalid request, returning with a list of issues detected in the request {"errors":["string"]}
    401 Unauthorized {"error":"string"}
    403 Maximum number of workers exceeded {"error":"string"}
    404 Component / Worker / Promise not found {"error":"string"}
    409 Worker already exists {"error":"string"}
    500 Internal server error {"golemError":{"type":"InvalidRequest","details":"string"}}
    Last updated on March 28, 2025
    Token
    Open Source
    
  section: Rest api
  char_count: 14867
  approx_token_count: 3717
- id_parent: 159
  title: Oss rest api
  url: https://learn.golem.cloud/rest-api/oss-rest-api
  content: |
    REST API
    Open Source
    Golem OSS REST API
    The following pages are the reference of the open-source Golem REST APIs:
    API Definition
    API Deployment
    Component
    Worker
    Last updated on March 28, 2025
    Worker
    API Definition
    
  section: Rest api
  char_count: 213
  approx_token_count: 54
- id_parent: 160
  title: Api definition
  url: https://learn.golem.cloud/rest-api/oss-rest-api/api-definition
  content: |
    REST API
    Open Source
    API Definition
    Api Definition API
    Upload an OpenAPI definition
    Path Method Protected
    /v1/api/definitions/import PUT No
    Uploads an OpenAPI JSON document and either creates a new one or updates an existing Golem API definition using it.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Get or list API definitions
    Path Method Protected
    /v1/api/definitions GET No
    If api_definition_id is specified, returns a single API definition. Otherwise lists all API definitions.
    Query Parameters
    Name Type Required Description
    api-definition-id string No -
    Example Response JSON
    [
      {
        "id": "string",
        "version": "string",
        "routes": [
          {
            "method": "Get",
            "path": "string",
            "security": "string",
            "binding": {
              "component": {
                "name": "string",
                "version": 0
              },
              "workerName": "string",
              "idempotencyKey": "string",
              "response": "string",
              "bindingType": "default",
              "responseMappingInput": {
                "types": {
                  "property1": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  },
                  "property2": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              },
              "workerNameInput": {
                "types": {
                  "property1": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  },
                  "property2": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              },
              "idempotencyKeyInput": {
                "types": {
                  "property1": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  },
                  "property2": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              },
              "corsPreflight": {
                "allowOrigin": "string",
                "allowMethods": "string",
                "allowHeaders": "string",
                "exposeHeaders": "string",
                "allowCredentials": true,
                "maxAge": 0
              },
              "responseMappingOutput": {
                "analysed_type": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            }
          }
        ],
        "draft": true,
        "createdAt": "2019-08-24T14:15:22Z"
      }
    ]
    Create a new API definition
    Path Method Protected
    /v1/api/definitions POST No
    Creates a new API definition described by Golem's API definition JSON document. If an API definition of the same version already exists, its an error.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Get an API definition
    Path Method Protected
    /v1/api/definitions/{id}/{version} GET No
    An API definition is selected by its API definition ID and version.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Update an existing API definition.
    Path Method Protected
    /v1/api/definitions/{id}/{version} PUT No
    Only draft API definitions can be updated.
    Example Response JSON
    {
      "id": "string",
      "version": "string",
      "routes": [
        {
          "method": "Get",
          "path": "string",
          "security": "string",
          "binding": {
            "component": {
              "name": "string",
              "version": 0
            },
            "workerName": "string",
            "idempotencyKey": "string",
            "response": "string",
            "bindingType": "default",
            "responseMappingInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "workerNameInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "idempotencyKeyInput": {
              "types": {
                "property1": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                },
                "property2": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            },
            "corsPreflight": {
              "allowOrigin": "string",
              "allowMethods": "string",
              "allowHeaders": "string",
              "exposeHeaders": "string",
              "allowCredentials": true,
              "maxAge": 0
            },
            "responseMappingOutput": {
              "analysed_type": {
                "type": "Variant",
                "cases": [
                  {
                    "name": "string",
                    "typ": {}
                  }
                ]
              }
            }
          }
        }
      ],
      "draft": true,
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Delete an API definition
    Path Method Protected
    /v1/api/definitions/{id}/{version} DELETE No
    Deletes an API definition by its API definition ID and version.
    Example Response JSON
    "string"
    Api Definition API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"error":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on April 5, 2025
    Open Source
    API Deployment
    
  section: Rest api
  char_count: 14103
  approx_token_count: 3526
- id_parent: 161
  title: Api deployment
  url: https://learn.golem.cloud/rest-api/oss-rest-api/api-deployment
  content: |
    REST API
    Open Source
    API Deployment
    Api Deployment API
    Creates or updates a deployment
    Path Method Protected
    /v1/api/deployments/deploy POST No
    Deploys a set of API definitions to a site (specific host and subdomain).
    Example Request JSON
    {
      "apiDefinitions": [
        {
          "id": "string",
          "version": "string"
        }
      ],
      "site": {
        "host": "string",
        "subdomain": "string"
      }
    }
    Example Response JSON
    {
      "apiDefinitions": [
        {
          "id": "string",
          "version": "string"
        }
      ],
      "site": {
        "host": "string",
        "subdomain": "string"
      },
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Get one or more API deployments
    Path Method Protected
    /v1/api/deployments GET No
    If api-definition-id is not set, it lists all API deployments. If api-definition-id is set, returns a single API deployment.
    Query Parameters
    Name Type Required Description
    api-definition-id string No -
    Example Response JSON
    [
      {
        "apiDefinitions": [
          {
            "id": "string",
            "version": "string"
          }
        ],
        "site": {
          "host": "string",
          "subdomain": "string"
        },
        "createdAt": "2019-08-24T14:15:22Z"
      }
    ]
    Get API deployment by site
    Path Method Protected
    /v1/api/deployments/{site} GET No
    Gets an API deployment by the host name (optionally with a subdomain) it is deployed to.
    Example Response JSON
    {
      "apiDefinitions": [
        {
          "id": "string",
          "version": "string"
        }
      ],
      "site": {
        "host": "string",
        "subdomain": "string"
      },
      "createdAt": "2019-08-24T14:15:22Z"
    }
    Delete API deployment by site
    Path Method Protected
    /v1/api/deployments/{site} DELETE No
    Deletes an API deployment by the host name (optionally with a subdomain) it is deployed to.
    Example Response JSON
    "string"
    Api Deployment API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"error":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on March 28, 2025
    API Definition
    API Security
    
  section: Rest api
  char_count: 2002
  approx_token_count: 501
- id_parent: 162
  title: Api security
  url: https://learn.golem.cloud/rest-api/oss-rest-api/api-security
  content: |
    REST API
    Open Source
    API Security
    Api Security API
    Get a security scheme
    Path Method Protected
    /v1/api/security/{security_scheme_identifier} GET No
    Get a security scheme by name
    Example Response JSON
    {
      "providerType": "Google",
      "schemeIdentifier": "string",
      "clientId": "string",
      "clientSecret": "string",
      "redirectUrl": "string",
      "scopes": [
        "string"
      ]
    }
    Create a security scheme
    Path Method Protected
    /v1/api/security POST No
    Example Request JSON
    {
      "providerType": "Google",
      "schemeIdentifier": "string",
      "clientId": "string",
      "clientSecret": "string",
      "redirectUrl": "string",
      "scopes": [
        "string"
      ]
    }
    Example Response JSON
    {
      "providerType": "Google",
      "schemeIdentifier": "string",
      "clientId": "string",
      "clientSecret": "string",
      "redirectUrl": "string",
      "scopes": [
        "string"
      ]
    }
    Api Security API Errors
    Status Code Description Body
    400 {"type":"Messages","errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"error":"string"}
    409 "string"
    500 {"error":"string"}
    Last updated on March 28, 2025
    API Deployment
    Component
    
  section: Rest api
  char_count: 1094
  approx_token_count: 274
- id_parent: 163
  title: Component
  url: https://learn.golem.cloud/rest-api/oss-rest-api/component
  content: |
    REST API
    Open Source
    Component
    Component API
    Get all components
    Path Method Protected
    /v1/components GET No
    Gets all components, optionally filtered by component name.
    Query Parameters
    Name Type Required Description
    component-name string No -
    Example Response JSON
    [
      {
        "versionedComponentId": {
          "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
          "version": 0
        },
        "componentName": "string",
        "componentSize": 0,
        "metadata": {
          "exports": [
            {
              "type": "Function",
              "name": "string",
              "parameters": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ],
              "results": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ]
            }
          ],
          "producers": [
            {
              "fields": [
                {
                  "name": "string",
                  "values": [
                    {
                      "name": "string",
                      "version": "string"
                    }
                  ]
                }
              ]
            }
          ],
          "memories": [
            {
              "initial": 0,
              "maximum": 0
            }
          ],
          "dynamicLinking": {
            "property1": {
              "type": "WasmRpc",
              "targetInterfaceName": {
                "property1": "string",
                "property2": "string"
              }
            },
            "property2": {
              "type": "WasmRpc",
              "targetInterfaceName": {
                "property1": "string",
                "property2": "string"
              }
            }
          }
        },
        "createdAt": "2019-08-24T14:15:22Z",
        "componentType": "Durable",
        "files": [
          {
            "key": "string",
            "path": "string",
            "permissions": "read-only"
          }
        ],
        "installedPlugins": [
          {
            "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
            "name": "string",
            "version": "string",
            "priority": 0,
            "parameters": {
              "property1": "string",
              "property2": "string"
            }
          }
        ]
      }
    ]
    Create a new component
    Path Method Protected
    /v1/components POST No
    The request body is encoded as multipart/form-data containing metadata and the WASM binary. If the component type is not specified, it will be considered as a Durable component.
    Request Form: multipart/form-data
    Make sure to include Content-Type: multipart/form-data Header
    Field name: string undefined
    Field componentType: JSON
    "Durable"
    Field component: string binary
    Field filesPermissions: JSON
    {
      "values": [
        {
          "path": "string",
          "permissions": "read-only"
        }
      ]
    }
    Field files: string binary
    Field dynamicLinking: JSON
    {
      "dynamicLinking": {
        "property1": {
          "type": "WasmRpc",
          "targetInterfaceName": {
            "property1": "string",
            "property2": "string"
          }
        },
        "property2": {
          "type": "WasmRpc",
          "targetInterfaceName": {
            "property1": "string",
            "property2": "string"
          }
        }
      }
    }
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ],
        "dynamicLinking": {
          "property1": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          },
          "property2": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Update a component
    Path Method Protected
    /v1/components/{component_id}/upload PUT No
    Query Parameters
    Name Type Required Description
    component_type #/components/schemas/ComponentType No Type of the new version of the component - if not specified, the type of the previous version
    is used.
    Request Body: WASM Binary File
    Make sure to include Content-Type: application/octet-stream Header
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ],
        "dynamicLinking": {
          "property1": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          },
          "property2": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Update a component
    Path Method Protected
    /v1/components/{component_id}/updates POST No
    Request Form: multipart/form-data
    Make sure to include Content-Type: multipart/form-data Header
    Field componentType: JSON
    "Durable"
    Field component: string binary
    Field filesPermissions: JSON
    {
      "values": [
        {
          "path": "string",
          "permissions": "read-only"
        }
      ]
    }
    Field files: string binary
    Field dynamicLinking: JSON
    {
      "dynamicLinking": {
        "property1": {
          "type": "WasmRpc",
          "targetInterfaceName": {
            "property1": "string",
            "property2": "string"
          }
        },
        "property2": {
          "type": "WasmRpc",
          "targetInterfaceName": {
            "property1": "string",
            "property2": "string"
          }
        }
      }
    }
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ],
        "dynamicLinking": {
          "property1": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          },
          "property2": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Download a component
    Path Method Protected
    /v1/components/{component_id}/download GET No
    Downloads a specific version of the component's WASM.
    Query Parameters
    Name Type Required Description
    version integer No -
    Response Body: WASM Binary File
    Get the metadata for all component versions
    Path Method Protected
    /v1/components/{component_id} GET No
    Each component can have multiple versions. Every time a new WASM is uploaded for a given component id, that creates a new version. This endpoint returns a list of all versions for the component id provided as part of the URL. Each element of the response describes a single version of a component, but does not contain the binary (WASM) itself:
    versionedComponentId associates a specific version with the component id
    componentName is the human-readable name of the component
    componentSize is the WASM binary's size in bytes
    metadata contains information extracted from the WASM itself
    metadata.exports is a list of exported functions, including their parameter's and return value's types
    metadata.producers is a list of producer information added by tooling, each consisting of a list of fields associating one or more values to a given key. This contains information about what compilers and other WASM related tools were used to construct the Golem component.
    Example Response JSON
    [
      {
        "versionedComponentId": {
          "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
          "version": 0
        },
        "componentName": "string",
        "componentSize": 0,
        "metadata": {
          "exports": [
            {
              "type": "Function",
              "name": "string",
              "parameters": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ],
              "results": [
                {
                  "name": "string",
                  "typ": {
                    "type": "Variant",
                    "cases": [
                      {
                        "name": "string",
                        "typ": {}
                      }
                    ]
                  }
                }
              ]
            }
          ],
          "producers": [
            {
              "fields": [
                {
                  "name": "string",
                  "values": [
                    {
                      "name": "string",
                      "version": "string"
                    }
                  ]
                }
              ]
            }
          ],
          "memories": [
            {
              "initial": 0,
              "maximum": 0
            }
          ],
          "dynamicLinking": {
            "property1": {
              "type": "WasmRpc",
              "targetInterfaceName": {
                "property1": "string",
                "property2": "string"
              }
            },
            "property2": {
              "type": "WasmRpc",
              "targetInterfaceName": {
                "property1": "string",
                "property2": "string"
              }
            }
          }
        },
        "createdAt": "2019-08-24T14:15:22Z",
        "componentType": "Durable",
        "files": [
          {
            "key": "string",
            "path": "string",
            "permissions": "read-only"
          }
        ],
        "installedPlugins": [
          {
            "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
            "name": "string",
            "version": "string",
            "priority": 0,
            "parameters": {
              "property1": "string",
              "property2": "string"
            }
          }
        ]
      }
    ]
    Get the version of a given component
    Path Method Protected
    /v1/components/{component_id}/versions/{version} GET No
    Gets the version of a component.
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ],
        "dynamicLinking": {
          "property1": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          },
          "property2": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Get the latest version of a given component
    Path Method Protected
    /v1/components/{component_id}/latest GET No
    Gets the latest version of a component.
    Example Response JSON
    {
      "versionedComponentId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "version": 0
      },
      "componentName": "string",
      "componentSize": 0,
      "metadata": {
        "exports": [
          {
            "type": "Function",
            "name": "string",
            "parameters": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ],
            "results": [
              {
                "name": "string",
                "typ": {
                  "type": "Variant",
                  "cases": [
                    {
                      "name": "string",
                      "typ": {}
                    }
                  ]
                }
              }
            ]
          }
        ],
        "producers": [
          {
            "fields": [
              {
                "name": "string",
                "values": [
                  {
                    "name": "string",
                    "version": "string"
                  }
                ]
              }
            ]
          }
        ],
        "memories": [
          {
            "initial": 0,
            "maximum": 0
          }
        ],
        "dynamicLinking": {
          "property1": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          },
          "property2": {
            "type": "WasmRpc",
            "targetInterfaceName": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "createdAt": "2019-08-24T14:15:22Z",
      "componentType": "Durable",
      "files": [
        {
          "key": "string",
          "path": "string",
          "permissions": "read-only"
        }
      ],
      "installedPlugins": [
        {
          "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
          "name": "string",
          "version": "string",
          "priority": 0,
          "parameters": {
            "property1": "string",
            "property2": "string"
          }
        }
      ]
    }
    Gets the list of plugins installed for the given component version
    Path Method Protected
    /v1/components/{component_id}/versions/{version}/plugins/installs GET No
    Example Response JSON
    [
      {
        "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
        "name": "string",
        "version": "string",
        "priority": 0,
        "parameters": {
          "property1": "string",
          "property2": "string"
        }
      }
    ]
    Installs a new plugin for this component
    Path Method Protected
    /v1/components/{component_id}/latest/plugins/installs POST No
    Example Request JSON
    {
      "name": "string",
      "version": "string",
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {
      "id": "497f6eca-6276-4993-bfeb-53cbbbba6f08",
      "name": "string",
      "version": "string",
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Updates the priority or parameters of a plugin installation
    Path Method Protected
    /v1/components/{component_id}/versions/latest/plugins/installs/{installation_id} PUT No
    Example Request JSON
    {
      "priority": 0,
      "parameters": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {}
    Uninstalls a plugin from this component
    Path Method Protected
    /v1/components/{component_id}/latest/plugins/installs/{installation_id} DELETE No
    Example Response JSON
    {}
    Component API Errors
    Status Code Description Body
    400 {"errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"error":"string"}
    409 {"error":"string"}
    500 {"error":"string"}
    Last updated on March 28, 2025
    API Security
    Plugin
    
  section: Rest api
  char_count: 20215
  approx_token_count: 5054
- id_parent: 164
  title: Plugin
  url: https://learn.golem.cloud/rest-api/oss-rest-api/plugin
  content: |
    REST API
    Open Source
    Plugin
    Plugin API
    Lists all the registered plugins (including all versions of each).
    Path Method Protected
    /v1/plugins GET No
    Query Parameters
    Name Type Required Description
    scope #/components/schemas/DefaultPluginScope No -
    Example Response JSON
    [
      {
        "name": "string",
        "version": "string",
        "description": "string",
        "icon": [
          0
        ],
        "homepage": "string",
        "specs": {
          "type": "ComponentTransformer",
          "providedWitPackage": "string",
          "jsonSchema": "string",
          "validateUrl": "string",
          "transformUrl": "string"
        },
        "scope": {
          "type": "Global"
        },
        "owner": {}
      }
    ]
    Registers a new plugin
    Path Method Protected
    /v1/plugins POST No
    Example Request JSON
    {
      "name": "string",
      "version": "string",
      "description": "string",
      "icon": [
        0
      ],
      "homepage": "string",
      "specs": {
        "type": "ComponentTransformer",
        "providedWitPackage": "string",
        "jsonSchema": "string",
        "validateUrl": "string",
        "transformUrl": "string"
      },
      "scope": {
        "type": "Global"
      }
    }
    Example Response JSON
    {}
    Lists all the registered versions of a specific plugin identified by its name
    Path Method Protected
    /v1/plugins/{name} GET No
    Example Response JSON
    [
      {
        "name": "string",
        "version": "string",
        "description": "string",
        "icon": [
          0
        ],
        "homepage": "string",
        "specs": {
          "type": "ComponentTransformer",
          "providedWitPackage": "string",
          "jsonSchema": "string",
          "validateUrl": "string",
          "transformUrl": "string"
        },
        "scope": {
          "type": "Global"
        },
        "owner": {}
      }
    ]
    Registers a new library plugin
    Path Method Protected
    /v1/library-plugins POST No
    Request Form: multipart/form-data
    Make sure to include Content-Type: multipart/form-data Header
    Field name: string undefined
    Field version: string undefined
    Field description: string undefined
    Field icon: string binary
    Field homepage: string undefined
    Field scope: JSON
    {
      "type": "Global"
    }
    Field wasm: string binary
    Example Response JSON
    {}
    Registers a new app plugin
    Path Method Protected
    /v1/app-plugins POST No
    Request Form: multipart/form-data
    Make sure to include Content-Type: multipart/form-data Header
    Field name: string undefined
    Field version: string undefined
    Field description: string undefined
    Field icon: string binary
    Field homepage: string undefined
    Field scope: JSON
    {
      "type": "Global"
    }
    Field wasm: string binary
    Example Response JSON
    {}
    Gets a registered plugin by its name and version
    Path Method Protected
    /v1/plugins/{name}/{version} GET No
    Example Response JSON
    {
      "name": "string",
      "version": "string",
      "description": "string",
      "icon": [
        0
      ],
      "homepage": "string",
      "specs": {
        "type": "ComponentTransformer",
        "providedWitPackage": "string",
        "jsonSchema": "string",
        "validateUrl": "string",
        "transformUrl": "string"
      },
      "scope": {
        "type": "Global"
      },
      "owner": {}
    }
    Deletes a registered plugin by its name and version
    Path Method Protected
    /v1/plugins/{name}/{version} DELETE No
    Example Response JSON
    {}
    Plugin API Errors
    Status Code Description Body
    400 {"errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"error":"string"}
    409 {"error":"string"}
    500 {"error":"string"}
    Last updated on March 28, 2025
    Component
    Worker
    
  section: Rest api
  char_count: 3344
  approx_token_count: 836
- id_parent: 165
  title: Worker
  url: https://learn.golem.cloud/rest-api/oss-rest-api/worker
  content: |
    REST API
    Open Source
    Worker
    Worker API
    Get metadata of multiple workers
    Path Method Protected
    /v1/components/{component_id}/workers GET No
    Filters
    Property Comparator Description Example
    name StringFilterComparator Name of worker name = worker-name
    version FilterComparator Version of worker version >= 0
    status FilterComparator Status of worker status = Running
    env.[key] StringFilterComparator Environment variable of worker env.var1 = value
    createdAt FilterComparator Creation time of worker createdAt > 2024-04-01T12:10:00Z
    Comparators
    StringFilterComparator: eq|equal|=|==, ne|notequal|!=, like, notlike
    FilterComparator: eq|equal|=|==, ne|notequal|!=, ge|greaterequal|>=, gt|greater|>, le|lessequal|<=, lt|less|<
    Returns metadata about an existing component workers:
    workers list of workers metadata
    cursor cursor for next request, if cursor is empty/null, there are no other values
    Query Parameters
    Name Type Required Description
    filter array No -
    cursor string No -
    count integer No -
    precise boolean No -
    Example Response JSON
    {
      "workers": [
        {
          "workerId": {
            "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
            "workerName": "string"
          },
          "args": [
            "string"
          ],
          "env": {
            "property1": "string",
            "property2": "string"
          },
          "status": "Running",
          "componentVersion": 0,
          "retryCount": 0,
          "pendingInvocationCount": 0,
          "updates": [
            {
              "type": "pendingUpdate",
              "timestamp": "2019-08-24T14:15:22Z",
              "targetVersion": 0
            }
          ],
          "createdAt": "2019-08-24T14:15:22Z",
          "lastError": "string",
          "componentSize": 0,
          "totalLinearMemorySize": 0,
          "ownedResources": {
            "property1": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": [
                  "string"
                ]
              }
            },
            "property2": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": [
                  "string"
                ]
              }
            }
          },
          "activePlugins": [
            "497f6eca-6276-4993-bfeb-53cbbbba6f08"
          ]
        }
      ],
      "cursor": {
        "cursor": 0,
        "layer": 0
      }
    }
    Launch a new worker.
    Path Method Protected
    /v1/components/{component_id}/workers POST No
    Creates a new worker. The worker initially is in `Idle`` status, waiting to be invoked.
    The parameters in the request are the following:
    name is the name of the created worker. This has to be unique, but only for a given component
    args is a list of strings which appear as command line arguments for the worker
    env is a list of key-value pairs (represented by arrays) which appear as environment variables for the worker
    Example Request JSON
    {
      "name": "string",
      "args": [
        "string"
      ],
      "env": {
        "property1": "string",
        "property2": "string"
      }
    }
    Example Response JSON
    {
      "workerId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "workerName": "string"
      },
      "componentVersion": 0
    }
    Get metadata of a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name} GET No
    Returns metadata about an existing worker:
    workerId is a combination of the used component and the worker's user specified name
    accountId the account the worker is created by
    args is the provided command line arguments passed to the worker
    env is the provided map of environment variables passed to the worker
    componentVersion is the version of the component used by the worker
    retryCount is the number of retries the worker did in case of a failure
    status is the worker's current status, one of the following:
    Running if the worker is currently executing
    Idle if the worker is waiting for an invocation
    Suspended if the worker was running but is now waiting to be resumed by an event (such as end of a sleep, a promise, etc)
    Interrupted if the worker was interrupted by the user
    Retrying if the worker failed, and an automatic retry was scheduled for it
    Failed if the worker failed and there are no more retries scheduled for it
    Exited if the worker explicitly exited using the exit WASI function
    Example Response JSON
    {
      "workerId": {
        "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
        "workerName": "string"
      },
      "args": [
        "string"
      ],
      "env": {
        "property1": "string",
        "property2": "string"
      },
      "status": "Running",
      "componentVersion": 0,
      "retryCount": 0,
      "pendingInvocationCount": 0,
      "updates": [
        {
          "type": "pendingUpdate",
          "timestamp": "2019-08-24T14:15:22Z",
          "targetVersion": 0
        }
      ],
      "createdAt": "2019-08-24T14:15:22Z",
      "lastError": "string",
      "componentSize": 0,
      "totalLinearMemorySize": 0,
      "ownedResources": {
        "property1": {
          "createdAt": "2019-08-24T14:15:22Z",
          "indexed": {
            "resourceName": "string",
            "resourceParams": [
              "string"
            ]
          }
        },
        "property2": {
          "createdAt": "2019-08-24T14:15:22Z",
          "indexed": {
            "resourceName": "string",
            "resourceParams": [
              "string"
            ]
          }
        }
      },
      "activePlugins": [
        "497f6eca-6276-4993-bfeb-53cbbbba6f08"
      ]
    }
    Delete a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name} DELETE No
    Interrupts and deletes an existing worker.
    Example Response JSON
    {}
    Invoke a function and await its resolution on a new worker with a random generated name
    Path Method Protected
    /v1/components/{component_id}/invoke-and-await POST No
    Ideal for invoking ephemeral components, but works with durable ones as well. Supply the parameters in the request body as JSON.
    Query Parameters
    Name Type Required Description
    function string Yes -
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {
      "result": {
        "typ": {
          "type": "Variant",
          "cases": [
            {
              "name": "string",
              "typ": {}
            }
          ]
        },
        "value": null
      }
    }
    Invoke a function and await its resolution
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/invoke-and-await POST No
    Supply the parameters in the request body as JSON.
    Query Parameters
    Name Type Required Description
    function string Yes -
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {
      "result": {
        "typ": {
          "type": "Variant",
          "cases": [
            {
              "name": "string",
              "typ": {}
            }
          ]
        },
        "value": null
      }
    }
    Invoke a function
    Path Method Protected
    /v1/components/{component_id}/invoke POST No
    Ideal for invoking ephemeral components, but works with durable ones as well. Triggers the execution of a function and immediately returns.
    Query Parameters
    Name Type Required Description
    function string Yes -
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {}
    Invoke a function
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/invoke POST No
    Triggers the execution of a function and immediately returns.
    Query Parameters
    Name Type Required Description
    function string Yes -
    Example Request JSON
    {
      "params": [
        {
          "typ": {
            "type": "Variant",
            "cases": [
              {
                "name": "string",
                "typ": {}
              }
            ]
          },
          "value": null
        }
      ]
    }
    Example Response JSON
    {}
    Complete a promise
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/complete POST No
    Completes a promise with a given custom array of bytes. The promise must be previously created from within the worker, and it's identifier (a combination of a worker identifier and an oplogIdx ) must be sent out to an external caller so it can use this endpoint to mark the promise completed. The data field is sent back to the worker, and it has no predefined meaning.
    Example Request JSON
    {
      "oplogIdx": 0,
      "data": [
        0
      ]
    }
    Example Response JSON
    true
    Interrupt a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/interrupt POST No
    Interrupts the execution of a worker. The worker's status will be Interrupted unless the recover-immediately parameter was used, in which case it remains as it was. An interrupted worker can be still used, and it is going to be automatically resumed the first time it is used. For example in case of a new invocation, the previously interrupted invocation is continued before the new one gets processed.
    Query Parameters
    Name Type Required Description
    recovery-immediately boolean No -
    Example Response JSON
    {}
    Advanced search for workers
    Path Method Protected
    /v1/components/{component_id}/workers/find POST No
    Filter types
    Type Comparator Description Example
    Name StringFilterComparator Name of worker { "type": "Name", "comparator": "Equal", "value": "worker-name" }
    Version FilterComparator Version of worker { "type": "Version", "comparator": "GreaterEqual", "value": 0 }
    Status FilterComparator Status of worker { "type": "Status", "comparator": "Equal", "value": "Running" }
    Env StringFilterComparator Environment variable of worker { "type": "Env", "name": "var1", "comparator": "Equal", "value": "value" }
    CreatedAt FilterComparator Creation time of worker { "type": "CreatedAt", "comparator": "Greater", "value": "2024-04-01T12:10:00Z" }
    And And filter combinator { "type": "And", "filters": [ ... ] }
    Or Or filter combinator { "type": "Or", "filters": [ ... ] }
    Not Negates the specified filter { "type": "Not", "filter": { "type": "Version", "comparator": "GreaterEqual", "value": 0 } }
    Comparators
    StringFilterComparator: Equal, NotEqual, Like, NotLike
    FilterComparator: Equal, NotEqual, GreaterEqual, Greater, LessEqual, Less
    Returns metadata about an existing component workers:
    workers list of workers metadata
    cursor cursor for next request, if cursor is empty/null, there are no other values
    Example Request JSON
    {
      "filter": {
        "type": "Name",
        "comparator": "Equal",
        "value": "string"
      },
      "cursor": {
        "cursor": 0,
        "layer": 0
      },
      "count": 0,
      "precise": true
    }
    Example Response JSON
    {
      "workers": [
        {
          "workerId": {
            "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
            "workerName": "string"
          },
          "args": [
            "string"
          ],
          "env": {
            "property1": "string",
            "property2": "string"
          },
          "status": "Running",
          "componentVersion": 0,
          "retryCount": 0,
          "pendingInvocationCount": 0,
          "updates": [
            {
              "type": "pendingUpdate",
              "timestamp": "2019-08-24T14:15:22Z",
              "targetVersion": 0
            }
          ],
          "createdAt": "2019-08-24T14:15:22Z",
          "lastError": "string",
          "componentSize": 0,
          "totalLinearMemorySize": 0,
          "ownedResources": {
            "property1": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": [
                  "string"
                ]
              }
            },
            "property2": {
              "createdAt": "2019-08-24T14:15:22Z",
              "indexed": {
                "resourceName": "string",
                "resourceParams": [
                  "string"
                ]
              }
            }
          },
          "activePlugins": [
            "497f6eca-6276-4993-bfeb-53cbbbba6f08"
          ]
        }
      ],
      "cursor": {
        "cursor": 0,
        "layer": 0
      }
    }
    Resume a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/resume POST No
    Example Response JSON
    {}
    Update a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/update POST No
    Example Request JSON
    {
      "mode": "Automatic",
      "targetVersion": 0
    }
    Example Response JSON
    {}
    Get or search the oplog of a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/oplog GET No
    Query Parameters
    Name Type Required Description
    from integer No -
    count integer Yes -
    cursor #/components/schemas/OplogCursor No -
    query string No -
    Example Response JSON
    {
      "entries": [
        {
          "oplogIndex": 0,
          "entry": {
            "type": "Create",
            "timestamp": "2019-08-24T14:15:22Z",
            "worker_id": {
              "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
              "workerName": "string"
            },
            "component_version": 0,
            "args": [
              "string"
            ],
            "env": {
              "property1": "string",
              "property2": "string"
            },
            "account_id": "string",
            "parent": {
              "componentId": "616ccd92-d666-4180-8349-8d125b269fac",
              "workerName": "string"
            },
            "component_size": 0,
            "initial_total_linear_memory_size": 0,
            "initial_active_plugins": [
              {
                "installation_id": "91166175-c6a9-4caf-88e9-3147ffc9c934",
                "plugin_name": "string",
                "plugin_version": "string",
                "parameters": {
                  "property1": "string",
                  "property2": "string"
                }
              }
            ]
          }
        }
      ],
      "next": {
        "next_oplog_index": 0,
        "current_component_version": 0
      },
      "firstIndexInChunk": 0,
      "lastIndex": 0
    }
    List files in a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/files/{file_name} GET No
    Example Response JSON
    {
      "nodes": [
        {
          "name": "string",
          "lastModified": 0,
          "kind": "directory",
          "permissions": "read-only",
          "size": 0
        }
      ]
    }
    Get contents of a file in a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/file-contents/{file_name} GET No
    Response Body: WASM Binary File
    Activate a plugin
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/activate-plugin POST No
    The plugin must be one of the installed plugins for the worker's current component version.
    Query Parameters
    Name Type Required Description
    plugin-installation-id string Yes -
    Example Response JSON
    {}
    Deactivate a plugin
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/deactivate-plugin POST No
    The plugin must be one of the installed plugins for the worker's current component version.
    Query Parameters
    Name Type Required Description
    plugin-installation-id string Yes -
    Example Response JSON
    {}
    Revert a worker
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/revert POST No
    Reverts a worker by undoing either the last few invocations or the last few recorded oplog entries.
    Example Request JSON
    {
      "type": "revertToOplogIndex",
      "lastOplogIndex": 0
    }
    Example Response JSON
    {}
    Cancels a pending invocation if it has not started yet
    Path Method Protected
    /v1/components/{component_id}/workers/{worker_name}/invocations/{idempotency_key} DELETE No
    The invocation to be cancelled is identified by the idempotency key passed to the invoke API.
    Example Response JSON
    {
      "canceled": true
    }
    Worker API Errors
    Status Code Description Body
    400 {"errors":["string"]}
    401 {"error":"string"}
    403 {"error":"string"}
    404 {"error":"string"}
    409 {"error":"string"}
    500 {"golemError":{"type":"InvalidRequest","details":"string"}}
    Last updated on March 28, 2025
    Plugin
    Rib
    
  section: Rest api
  char_count: 15787
  approx_token_count: 3947
- id_parent: 166
  title: Rib
  url: https://learn.golem.cloud/rib
  content: |
    Rib
    Rib
    Rib is the language used by the API Gateway that enables users to write programs capable of manipulating worker responses, which are WebAssembly (WASM) values.
    Rib uses the WAVE (WebAssembly Value Encoding)
    (opens in a new tab)
    syntax for encoding values.
    Rib Grammar
    rib-expr below defines the grammar of Rib.
    rib_expr          ::= rib_expr_untyped (":" type_name)?
    rib_expr_untyped  ::= simple_expr rib_expr_rest
    simple_expr       ::= simple_expr_untyped (":" type_name)?
    simple_expr_untyped ::=
          list_comprehension
        | list_reduce
        | pattern_match
        | let_binding
        | conditional
        | flag
        | record
        | code_block
        | tuple
        | sequence
        | boolean_literal
        | literal
        | not
        | option
        | result
        | identifier
        | call
        | signed_num
    rib_expr_rest       ::= binary_rest | method_invocation | select_field_rest | select_index_res | number_rest  |  range_rest
    select_field_rest   ::=  ("." select_field)*
    binary_rest         ::=  (binary_op simple_expr)*
    number_rest         ::=  "." fraction
    method_invocation   ::= "." call
    call                ::= function_name ("(" argument ("," argument)* ")")?
    function_name       ::= variant | enum | worker_function_call
    select_index_rest   ::= ("[" select_index "]")*
    binary_op           ::=  ">=" | "<=" | "==" | "<" | ">" | "&&" | "||" | "+" | "-" | "*" | "/"
    range_rest          ::= ".." ("="? pos_num | pos_num? )
    fraction            ::= digits (('e' | 'E') ('+' | '-')? digits)?
    let_binding         ::= "let" let_variable (":" type_name)? "=" rib_expr
    conditional         ::= "if" rib_expr "then" rib_expr "else" rib_expr
    selection_expr      ::= select_field | select_index
    select_field        ::= selection_base_expr "." identifier
    select_index        ::= pos_num
    nested_indices      ::= "[" pos_num "]" ("," "[" pos_num "]")*
    flag                ::= "{" flag_names "}"
    flag_names          ::= flag_name ("," flag_name)*
    flag_name           ::= (letter | "_" | digit | "-")+
    record              ::= "{" record_fields "}"
    record_fields       ::= field ("," field)*
    field               ::= field_key ":" rib_expr
    field_key           ::= (letter | "_" | digit | "-")+
    code_block          ::= rib_expr (";" rib_expr)*
    code_block_unit     ::= code_block ";"
    selection_base_expr ::= select_index | select_field | identifier | sequence | tuple
    tuple               ::= "("  ib_expr ("," rib_expr)* ")"
    sequence            ::= "["  rib_expr ("," rib_expr)* "]"
    enum                ::= identifier
    variant             ::= identifier ( "(" rib_expr ")" )   ?
    argument            ::= rib_expr
    list_comprehension  ::= "for" identifier_text "in" expr "{"
                               code_block_unit?
                               "yield" expr ";"
                             "}"
    list_reduce         ::= "reduce" identifier_text"," identifier_text "in" expr "from" expr "{"
                           code_block_unit?
                           "yield" expr ";"
                         "}"
    text                ::= letter (letter | digit | "_" | "-")*
    pos_num             ::= digit+
    digits              ::= [0-9]+
    signed_num          ::= ("+" | "-")? pos_num
    literal             ::= "\"" (static_term | dynamic_term)* "\""
    static_term         ::= (letter | space | digit | "_" | "-" | "." | "/" | ":" | "@")+
    dynamic_term        ::= "${" rib_expr "}"
    boolean_literal     ::= "true" | "false"
    not                 ::= "!" rib_expr
    option              ::= "some" "(" rib_expr ")" | "none"
    result              ::= "ok" "(" rib_expr ")" | "error" "(" rib_expr ")"
    identifier          ::= any_text
    function_name       ::= variant | enum | instance | text
    instance            ::= "instance"
    any_text            ::= letter (letter | digit | "_" | "-")*
    type_name           := basic_type | list_type | tuple_type | option_type | result_type
    basic_type          ::= "bool" | "s8" | "u8" | "s16" | "u16" | "s32" | "u32" | "s64" | "u64" | "f32" | "f64" | "char" | "string"
    list_type           ::= "list" "<" (basic_type | list_type | tuple_type | option_type | result_type) ">"
    tuple_type          ::= "tuple" "<" (basic_type | list_type | tuple_type | option_type | result_type) ("," (basic_type | list_type | tuple_type | option_type | result_type))* ">"
    option_type         ::= "option" "<" (basic_type | list_type | tuple_type | option_type | result_type) ">"
    result_type         ::= "result" "<" (basic_type | list_type | tuple_type | option_type | result_type) "," (basic_type | list_type | tuple_type | option_type | result_type) ">"
    The grammar is mainly to give a high level overview of the syntax of Rib.
    The following sections show some examples of each construct.
    Rib scripts can be multiline, and it should be separated by ;.
    Return type of a Rib script
    The last expression in the Rib script is the return value of the script. The last line in Rib script shouldn't end with a ;, as this is a syntax error.
    Let's see how we can write Rib corresponding to the types supported by the WebAssembly Component Model
    (opens in a new tab)
    Core Language Elements
    Identifier
    foo
    Here foo is an identifier. Note that identifiers are not wrapped with quotes.
    Rib will fail at compilation if variable foo is not available in the context.
    This implies, if you are running Rib specifying a wasm component through api-gateway in golem, then Rib has the access to look at component metadata. If Rib finds this variable foo in the component metadata,then it tries to infer its types.
    If such a variable is not present in the wasm component (i.e, you can cross check this in WIT file of the component), then technically there are two possibilities. Rib will choose to fail the compilation or consider it as a global variable input. A global input is nothing but Rib expects foo to be passed in to the evaluator of Rib script (somehow).
    Since you are using Rib from the api-gateway part of golem the only valid global variable supported is request and nothing else. This would mean, it will fail compilation.
    Example:
     
    my-worker-function(request)
      request here is a global input and Rib knows the type of request if my-worker-function is a valid function in the component (which acts as dependencies to Rib)
    Here are a few other examples of identifiers:
    foo-bar
    FOO-BAR
    More on global inputs to follow.
    Primitives
    https://component-model.bytecodealliance.org/design/wit.html#primitive-types
    (opens in a new tab)
    Numbers
    1
    You can annotate a type to Rib expression to make it specific, otherwise, it will get inferred as u64 for a positive integer, s64 for a signed integer, and f64 for a floating point number.
    1: u64
    Boolean
    true
    false
    String
    "foo"
    Lists
    # Sequence of numbers
    [1, 2, 3]
    You can annotate the type of the list as follows:
    let x: list<s32> = [1, 2, 3];
    ["foo", "bar", "baz"]
    # Sequence of record
    [{a: "foo"}, {b : "bar"}]
    Options
    Option in corresponding to WASM , which can take the shape of Some or None. This is similar to Option type in std Rust.
    An Option can be Some of a value, or None.
     some(1)
     none
    You can annotate the type of option as follows, if needed.
    let x: option<u32> = none;
    The syntax is inspired from wasm wave.
    Results
    Resultin Rib is WASM Result, which can take the shape of ok or err. This is similar to Result type in std Rust.
    A Result can be Ok of a value, or an Err of a value.
     ok(1)
     err("error")
     
    {
      "user": "ok(Alice)",
      "age": 30u32
    }
    Note that there are various possibilities
    (opens in a new tab)
    of result in Web Assembly component model.
    If there is no data associated with the error case, you can do the following:
    let my-result: result<_, string> = err("foo")
    my-result
    If there are no data associated with the success case, you can do the following:
    let my-result: result<string> = ok("foo")
      If you don't care the type of success and error.
    let my-result: result = ok("foo")
    When using rib, we recommend using the mostly used pattern which is to know both the success and error case (i.e, result<u32, string>)
    Tuples
    A tuple type is an ordered fixed length sequence of values of specified types. It is similar to a record, except that the fields are identified by their order instead of by names.
    (1, 20.1, "foo")
    This is also equivalent to the following in Rib. You can be specific about the types just like in any rib expression.
    let my-tuple: tuple<u64, f64, string> = (1, 20.1, "foo");
    my-tuple
    Unlike list, the values in a tuple can be of different types.
    Here is another example:
    ("foo", 1, {a: "bar"})
    Record
    { name: "John", age: 30 }
     
    { city: "New York", population: 8000000 }
     
    { name: "John", age: 30, { country: "France", capital: "Paris" } }
    This is parsed as a WASM Record. The syntax is inspired from WASM-WAVE.
    Note that, sometimes you will need to annotate the type of the number. It depends on the compilation context.
    Note that keys are not considered as variables. Also note that keys in a WASM record don't have quotes. Example: {"foo" : "bar"} is wrong.
    Variants
    Let say your WIT file has the following variant
    (opens in a new tab)
    variant bid-result {
       success,
       failure(string),
    }
    bid: func() -> bid-result;
    process-result: func(res: bid-result) -> string
    Then, in Rib, all you need to is simply use the variant terms directly. Example:
    let x = failure("its failed");
    x
    You can pattern match (more on this patter-match below) on variants as follows:
    let x = failure("its failed");
     
    let result = match x { success => "its success", failure(msg) => msg }
     
    result
    This will return "its failed".
    Here is the example WIT file and the corresponding rib scripts that shows how to pass variants as arguments to worker function. More explanation on how to invoke worker function using rib is explained further down below.
      variant bid-result {
        success(string),
        failure(string)
      }
      handle: func(res: bid-result) -> string;
    let worker = instance("my_worker");
    worker.handle(failure("it's failed"));
    let worker = instance("my_worker");
    worker.handle(success);
    let worker = instance("my_worker");
    let bid-result = worker.bid();
    let result = worker.handle(bid-result);
    result
      Note that rib script should have the dependency to the component that defines the variant. Otherwise, Rib will fail with compilation.
    failure("its failed")
    [invalid script] error in the following rib found at line 1, column 203
    `failure("its failed")`
    cause: invalid function call `failure`
    unknown function
    If Rib is used through API gateway and not directly, this dependency is already added automatically as you specify component name when defining API definition.
    Enums
    Let's say your WIT file has the following enum
    (opens in a new tab)
    types,
      enum status {
        backlog,
        in-progress,
        done,
      }
      enum priority {
        low,
        medium,
        high,
      }
    Then, in Rib, all you need to do is to simply specify the name of the term. Example by typing in backlog, it knows its an enum type which can be any of backlog, in-progress and done.
    let my-status = backlog;
    let my-priory = priority;
    {s: my-status, p: my-priority}
    You can pattern match (more on this pattern-match below) on enum values as follows
     
    let my-priority = low;
     
    let result = match my-priority {
      low => "its low",
      medium => "its medium",
      high => "its high"
    };
     
    result
    This will return the result "its low".
    Here is the example WIT file and the corresponding rib scripts that shows how to pass variants as arguments to worker function. More explanation on how to invoke worker function using rib is explained further down below.
      enum status {
        backlog,
        in-progress,
        done,
      }
      enum priority {
        low,
        medium,
        high,
      }
      process-user: func(status: status, priority: priority, user-id: string) -> string;
     
    let worker = instance("my_worker");
    let result = worker.process-user(backlog, low, "jon");
    result
      let worker = instance("my_worker");
    let status = in-progress;
    let priority = medium;
    let result = worker.process-user(status, priority, "jon");
    result
    Note that rib script should have the dependency to the component that defines the enum. Otherwise, Rib will fail with compilation.
    If Rib is used through API gateway and not directly, this dependency is already added automatically as you specify component name when defining API definition.
    Flags
    { Foo, Bar, Baz }
    This is of a flag type.
    Expressions and Syntax Features
    Assign to a variable
    This can be done using let binding which we have already seen in the above examples
    let x = 1;
    We can annotate the type of the variable as well.
    let x: u64 = 1;
    If you are passing this variable to a worker function, then you may not need to specify the type of the variable.
    String Interpolation (concatenation)
    This is similar to languages like scala where you start with ${ and end with }
    let x = "foo";
    let y = "bar";
    let z = "${x}-and-${y}";
    Evaluating this Rib will result in "foo-and-bar". The type of z is a string.
    Selection of Field
    A field can be selected from an Rib expression if it is a Record type. For example, foo.user is a valid selection given foo is a variable that gets evaluated to a record value.
    let foo = { name: "John", age: 30 };
    foo.name
    Selection of Index
    This is selecting an index from a sequence value.
    let x = [1, 2, 3];
    x[0]
    You can also inline as given below
    [1, 2, 3][0]
    Comparison (Boolean)
    let x: u8 = 1;
    let y: u8 = 2;
    x == y
      Similarly, we can use other comparison operators like >=, <=, ==, < etc. Both operands should be a valid Rib code that points/evaluated to a number or string.
    Arithmetic
    let x: u8 = 1;
    let y: u8 = 2;
    x + y
    +, -, / and * are supported.
    Collections and Control Structures
    List Comprehension
     let x = ["foo", "bar"];
     
     for p in x {
       yield p;
     }
    List Aggregation
     let ages: list<u16> = [1, 2, 3];
     
     reduce z, a in ages from 0 {
       yield z + a;
     }
    Ranges
    Ranges can be right exclusive or right inclusive. The right exclusive range is denoted by .. and right inclusive range is denoted by ..=.
    1..10;
    let initial: u32 = 1;
    let final: u32 = 10;
     
    let x = initial..final;
     
    for i in x {
      yield i
    }
    Similarly, you can use ..= to include the last number in the range.
    1..=10;
    let initial: u32 = 1;
    let final: u32 = 10;
     
    let x = initial..=final;
     
    for i in x {
      yield i
    }
    Please note that, you may need to help Rib compiler with type annotations for the numbers involved in the range. This depends on the context. We will improve these aspects as we go.
    You can also create infinite range, where you skip the right side of ..
    1..;
    However, note that as of now Rib interpreter (runtime) will spot any infinite loop and will throw an error. Example: The following will throw an error.
    let x = 1:u8..;
     
    for i in x {
      yield i
    }
    However, you can use infinite ranges to select a segment of the list without worrying about the end index.
    let x: list<u32> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
     
    for i in x[1..] {
      yield i
    }
    Pattern Matching
    let res: result<str, str> = ok("foo");
     
    match res {
        ok(v) => v,
        err(msg) => msg
    }
    This would probably be your go-to construct when you are dealing with complex data structures like result or option or other custom variant (WASM Variant) that comes out as the response of a worker function
      let worker_result = my_worker_function_name(1, "jon");
      match worker_result {
         ok(x) => "foo",
         err(msg) => "error"
      }
    Exhaustive pattern matching
    If the pattern match is not exhaustive, then it will throw compilation errors
    Example: The following pattern matching is invalid
      match worker_result {
        some(x) => "found",
      }
    This will result in following error:
    Error: Non-exhaustive pattern match. The following patterns are not covered: `none`.
    To ensure a complete match, add these patterns or cover them with a wildcard (`_`) or an identifier.
    Now, let's say your worker responded with a variant. Note on variant: A variant statement defines a new type where instances of the type match exactly one of the variants listed for the type. This is similar to a "sum" type in algebraic datatype (or an enum in Rust if you're familiar with it). Variants can be thought of as tagged unions as well.
    Pattern Match on Variants
    Given you are using Rib through worker bridge, which knows about component metadata, then, let's say we have a variant of type as given below responded from the worker, when invoking a function called foo:
    variant my_variant {
        bar( {a: u32,b: string }),
        foo(list<string>),
    }
    then, the following will work:
    let x = foo("abc");
     
    match x {
      bar({a: _, b: _}) => "success",
      foo(some_list) => some_list[0]
    }
      Variables in the context of pattern matching
    In all of the above, there exist a variable in the context of pattern. Example x in ok(x) or msg in err(msg) or x in some(x) or x in bar(x) or x in foo(x).
    These variables are bound to the value that is being matched.
    Example, given the worker response is ok(1), the following match expression will result in 2.
       let result = my-worker-function("foo");
     
       match result {
        ok(x) => x + 1,
        err(msg) => 0
      }
    The following match expression will result in "c", if the worker response was variant value foo(["a", "b", "c"]), and will result in "a" if the worker.response was variant value bar({a: 1, b: "a"}).
      let result = my-worker-function();
     
      match result {
        bar(x) => x.b,
        foo(x) => x[1]
      }
      Wild card patterns
    In some of the above examples, the binding variables are unused. We can use _ as a wildcard pattern to indicate that we don't care about the value.
      match worker.response {
        bar(_) => "bar",
        foo(_) => "foo"
      }
    Conditional Statement
     let id: u32 = 10;
     if id > 3 then "higher" else "lower"
    The structure of the conditional statement is if <condition> then <then-rib-expr> else <else-rib-expr>, where condition-expr is an expr that should get evaluated to boolean. The then-rib-expr or else-rib-expr can be an any valid rib code, which could be another if else itself
     let id: u32 = request.user.id;
     if id > 3 then "higher" else if id == 3 then "equal" else "lower"
    You must ensure that the branches (then branch and else branch) resolve to the same type. Otherwise, Rib will fail to compile.
    External Interactions
    Http Request Input and Field Selection
    Rib is currently mainly used in worker-gateway which will allow us to expose Http APIs on top of worker functions. If you are using Rib in the context of worker-gateway then you can use the variable request in your Rib script, which allows you to access various parameters of input Http request. In other words, request is a global input to the Rib script when used in API definitions, and worker-gateway will ensure to pass the value of request to the rib evaluator internally.
    Please refer to worker-gateway documents for more details.
    request will hold all the details of an input Http request in gateway, such as headers, path, query parameters and body.
    Request Body Parameters
    To select the body field in request,
    request.body.user
    Request Header Parameters
    To select a header from the request
    request.headers.user
    Request Path Parameters
    To select the value of a path variable in your http request /v4/{user-id}/get-cart-contents
    request.path.user-id
    Request Query Parameters
    To select the value of a query variable in your http request /v4/{user-id}/get-cart-contents?{country}
    request.query.country
    The request.path.* and request.headers.* will be inferred as string unless you specify it using type annotation.
    Example:
    let user-id: u8 = request.path.user-id;
    To select the value of a query variable in your http request /v4/{user-id}/get-cart-contents?{country}
    let country: string = request.query.country;
    A typical Rib script in API definition (worker gateway)
    Here is a full example of a Rib script that look up various elements in a Http Request.
    Given the route is /v4/{user-id}/get-cart-contents?{country} , which is a POST request, which has a body, then the following Rib script can be valid, and has a dependency to a component that has a function my-function that takes two arguments of type {foo: string, bar: string} and string
    let user-id: u8 = request.path.user-id;
    let country: string = request.query.country;
    let input = request.body;
    let worker = instance("my-worker-${user-id}");
    let result = worker.my-function(input, country);
    result
    This Rib script will be part of an API definition (please refer to worker-gateway for more details) When registering this API definition, it already keeps track of the requirements of the input http request. In this case, the input request is a POST request with a body, and the body is of type {foo: string, bar: string}, and the path variable is user-id of type u8, and the query parameter is country of type string.
    Once the API is deployed and the API is invoked, worker gateway will validate the input request against these requirements, and if they don't satisfy, it results in a BadRequest error.
    Please note the language Rib by itself don't support a keyword such as request, or path or body or headers. The above examples are valid only if are using Rib through worker-gateway. If Rib script is evaluated in the context of a http request, these values are available in the context of the Rib evaluator.
    Currently, there are two ways to use Rib in golem. One is worker-gateway and the other is golem REPL. In the case of REPL, request is not available, since we are not executing Rib in the context of an Http request.
    Here is an example of an invalid Rib script
     
    request
      request.body
    In the above case, compiler is not able to infer the type of request or request.body as it is not passed as an argument to a worker function.
    Invoke worker functions
    Rib is mainly used to write scripts to manipulate the input and call worker functions. Refer to the worker-gateway documentation for more on how you use Rib to invoke worker functions. This is useful to expose some http APIs on top of these worker functions running in golem platform, and you don't want to keep updating or change the components and expose additional APIs, as you can write a simple Rib script to do the necessary changes to the input and pass it to the worker functions. Invoking functions is similar to any other languages.
    Durable worker function invocation
    let my_worker = instance("my-worker");
    let result = my_worker.get-cart-contents();
     
    result
    Rib is evaluated in the context of a particular component (this is taken care by worker-gateway that it evaluates Rib in the context of a wasm component).
    In this script, first you create an instance (instance of a component) using instance function. instance function takes worker name as the argument. Once you created the instance, the functions in the component will be available to call.
    Ephemeral Worker function invocation
    The only difference here is that you don't need to pass an argument to the instance function.
    let my_worker_instance = instance();
    let result = my_worker.get-cart-contents();
    result
    You can avoid an unnecessary let-binding here too.
    let my_worker_instance = instance();
    my_worker.get-cart-contents();
    In this case the return value of the script is the last expression in the script, and in this case, it is of the result type of get-cart-contents.
    Worker function invocation with arguments
    Let's say there exists a function add-to-cart which takes a product as the argument, where product is a wasm record
    let my_worker_instance = instance("my-worker");
     
    let product = {product-id: 1, quantity: 2, name: "mac"};
    my_worker.add-to-cart(input);
    Similarly you can pass multiple arguments to the worker function and they should be separated by ,.
    Say you need to pass the username along with with the product details.
    let my_worker_instance = instance("my-worker");
     
    let product = {product-id: 1, quantity: 2, name: "mac"};
    let username = "foo";
     
    my_worker.add-to-cart(username, product);
    You can inline the arguments as well.
    let my_worker_instance = instance("my-worker");
     
    let product = {product-id: 1, quantity: 2, name: "mac"};
    my_worker.add-to-cart("foo", {product-id: 1, quantity: 2, name: "mac"});
    Invoke functions in a Resource
    Here is a relatively complex example where Rib is used to invoke functions in a resource cart Here the first step is to define the worker by calling instance function. Then you create a resource similar to a method invocation which is worker.cart. Here the only difference is cart is a resource rather than a function. Now you have the resource available to call methods on it such as add-item, remove-item etc.
    Please note that, everything prior to a real function call is lazy. i.e, you are not reusing the same resource at runtime to call these functions.
      let worker = instance("my-worker");
      let cart = worker.cart("bar");
      cart.add-item({product-id: "mac", name: "apple", quantity: 1, price: 1});
      cart.remove-item(a);
      cart.update-item-quantity(a, 2);
      let result = cart.get-cart-contents();
      cart.drop();
      result
    Handle conflicting function names using type parameters
    Let's say a function name add-to-cart exists in multiple interfaces (say api1, api2) in the same component. In this case, you can specify the interface as a type parameter when invoking method in the instance.
    Example:
    let my_worker_instance = instance("my-worker");
     
    let product = {product-id: 1, quantity: 2, name: "mac"};
     
    let result = my_worker.add-to-cart[api1](product);
     
    result
    If you are not specifying type parameter that narrows down the context, then compiler will return an error similar to the below one:
    error in the following rib found at line 3, column 30
    `my_worker.add-to-cart(product)`
    cause: invalid function call `qux`
    function 'add-to-cart' exists in multiple interfaces. specify an interface name as type parameter from: api1, api2
    Handle conflicting packages using type parameters
    Let's say a function name add-to-cart exists in multiple packages. In this case, you can specify the package name too as a type parameter. Let's say you care only about the package amazon:shopping-cart.
    let my_worker_instance = instance("my-worker");
     
    let product = {product-id: 1, quantity: 2, name: "mac"};
     
    let result = my_worker.add-to-cart[amazon:shopping-cart](product);
     
    result
    Handle conflicts at instance level
    You can also include this type parameter at instance level such that every method invocation will be resolved to that package or interface.
    let my_worker_instance = instance[amazon:shopping-cart]("my-worker");
     
    let product = {product-id: 1, quantity: 2, name: "mac"};
     
    let result = my_worker.add-to-cart(product);
    Conflict resolution using fully qualified type parameter
    If there exist a function add-to-cart in multiple interfaces within multiple packages, then you can specify fully qualified package name and interface as given below. As mentioned above, this can be either at instance level (which will get applied to all method calls on that instance) or at method level
    let my_worker_instance = instance[amazon:shopping-cart/api]("my-worker");
     
    let product = {product-id: 1, quantity: 2, name: "mac"};
     
    let result = my_worker.add-to-cart(product);
    Multiple invocations
    Rib allows you to invoke a function multiple times, or invoke multiple functions across multiple workers in a single script. That said, it is important to note that Rib by itself is not durable and is stateless. The next time you invoke Rib (through worker-gateway for example), these functions will get executed against the worker again and doesn't cache any result in anyway.
    Let's say we want to accumulate the contents of a shopping cart from user-id 1 to user-id 5.
      let worker = instance("my-worker");
      let cart = worker.cart[golem:it/api]("bar");
     
      let initial = 1: u64;
      let final = 5: u64;
      let range = initial..final;
     
      let result = for i in range {
         yield cart.get-cart-contents("user-id-${i}");
      };
     
      result
      Currently Rib is not durable. Also it hasn't been tested with complex use-cases such as invoking multiple functions, or invoke functions against multiple workers. This is because, Rib's primary use-case in golem platform is for users to write reasonably simple scripts in the context of worker-gateway to manipulate the http input and call worker functions.
    Type Inference
    Rib is mainly used to write script to manipulate the input and call worker functions. In this case, for the most part, most of the types will be automatically inferred. Otherwise, there will be a compilation error, asking the developer to annotate the types and help the compiler.
    let x: string = request.body;
    x
    Say the request body is a record in Json, as given below. Rib sees it as a WASM Record type.
    {
      "user": "Alice",
      "age": 30u32
    }
    Then we can use Rib language to select the field user, as it considers this request's body as a WASM Record type.
    let x: string = request.body.user;
    x
    Limitations
    We recommend the users of golem to not rely on Rib for complex business logic as of now. It's better to write it in standard languages that works with golem such as Rust, Python etc, making sure your logic or workflow is durable. We will be expanding the usability and reliability of Rib as we go.
    Issues and Trouble Shooting
    If you bump into compilation errors, annotating the types will help the compiler to infer the types properly. If you bump into internal runtime errors, please report to us and we will try to fix it as soon as possible.
    We are making improvements in this space continuously.
    Last updated on April 14, 2025
    Worker
    WASM RPC
    
  section: Rib
  char_count: 29276
  approx_token_count: 7319
- id_parent: 167
  title: Wasm rpc
  url: https://learn.golem.cloud/wasm-rpc
  content: |
    WASM RPC
    WASM-RPC
    ⚠️
    Prefer the typed approaches to worker-invocation explained in the introduction. This section describes the underlying interfaces that are used by golem itself to implement the typed approaches to RPC.
    The low-level interface to invoke other workers from within a component is the WASM-RPC
    (opens in a new tab)
    wit package. The basic workflow of using this package is to construct an instance of the wasm-rpc resource (which represents a remote worker) and call the appropriate method on it.
    Constructing an instance
    There are two constructors for creating the wasm-rpc resource:
    The default constructor takes a worker-id as a parameter
    The ephemeral constructor takes a component-id as a parameter
    WIT-Value
    As the wasm-rpc package is not statically typed, it is required to be able to pass as arguments and return arbitrary WIT values. This is done using the WIT-Value datatype which is a reified version of the regular WIT types. There is one constructor of the related WIT-Node type for each type in the WIT typesystem, i.e. a list<u64> with value [1, 2, 4] might be represented like this in a rust component using wasm-rpc:
    WitValue {
          nodes: vec![WitNode::ListValue(vec![1, 2, 3]), WitNode::PrimU64(1), WitNode::PrimU64(2), WitNode::PrimU64(4)]
    }
    The value that will end up becoming the root of the resulting WIT Value needs to be placed in index 0 of the nodes array!
    All functions in the wasm-rpc package use wit-value instead of the equivalent wit type. Invoking a function with incorrect wit-values with lead to an error.
    Invocation
    After you have constructed an instance of wasm-rpc there are a number of different functions you can choose from, depending on the invocation semantics you need.
    invoke: Non-blockingly call the desired function. Errors during invocation are returned, but the actual result of the invocation cannot be accessed.
    invoke-and-await: Blockingly call the desired function. The result of the invocation will be returned to you.
    async-invoke-and-await: Non-blockingly call the desired function. A resource will be returned to you that you can use to poll the result.
    schedule-invocation: Schedule an invocation for a point in time in the future.
    schedule-cancelable-invocation: Schedule an invocation for a point in time in the future. A resource will be returned to you that you can cancel the invocation as long as it hasn't been executed yet.
    Example
    Given the following WIT world implemented by a component:
    package golem:example;
     
    interface invocation-example-api {
      add: func(value: u64);
    }
     
    world invocation-example {
      export invocation-example-api;
    }
    A rust component could use the wasm-rpc package to schedule an invocation of 'add' 2 seconds in the future like this:
    let worker_id = WorkerId { component_id, worker_name }
    let rpc = WasmRpc::new(&worker_id);
     
    let now = OffsetDateTime::now_utc();
     
    let scheduled_time = now.saturating_add(Duration::seconds(2));
     
    let scheduled_wasi_time = WasiDatetime {
       seconds: scheduled_time.unix_timestamp() as u64,
       nanoseconds: scheduled_time.nanosecond()
    };
     
    let value: WitValue = {
       use self::bindings::golem::rpc::types::*;
       WitValue {
             nodes: vec![WitNode::PrimU64(1)]
       }
    };
    rpc.schedule_invocation(scheduled_wasi_time, "golem:example/invocation-example-api.{add}()", &vec![value]);
    Last updated on March 28, 2025
    Rib
  section: Wasm rpc
  char_count: 3355
  approx_token_count: 839
